/// Request message for
/// [AccountBudgetProposalService.GetAccountBudgetProposal][google.ads.googleads.v1.services.AccountBudgetProposalService.GetAccountBudgetProposal].
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GetAccountBudgetProposalRequest {
    /// Required. The resource name of the account-level budget proposal to fetch.
    #[prost(string, tag = "1")]
    pub resource_name: std::string::String,
}
/// Request message for
/// [AccountBudgetProposalService.MutateAccountBudgetProposal][google.ads.googleads.v1.services.AccountBudgetProposalService.MutateAccountBudgetProposal].
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct MutateAccountBudgetProposalRequest {
    /// Required. The ID of the customer.
    #[prost(string, tag = "1")]
    pub customer_id: std::string::String,
    /// Required. The operation to perform on an individual account-level budget proposal.
    #[prost(message, optional, tag = "2")]
    pub operation: ::std::option::Option<AccountBudgetProposalOperation>,
    /// If true, the request is validated but not executed. Only errors are
    /// returned, not results.
    #[prost(bool, tag = "3")]
    pub validate_only: bool,
}
/// A single operation to propose the creation of a new account-level budget or
/// edit/end/remove an existing one.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct AccountBudgetProposalOperation {
    /// FieldMask that determines which budget fields are modified.  While budgets
    /// may be modified, proposals that propose such modifications are final.
    /// Therefore, update operations are not supported for proposals.
    ///
    /// Proposals that modify budgets have the 'update' proposal type.  Specifying
    /// a mask for any other proposal type is considered an error.
    #[prost(message, optional, tag = "3")]
    pub update_mask: ::std::option::Option<::prost_types::FieldMask>,
    /// The mutate operation.
    #[prost(oneof = "account_budget_proposal_operation::Operation", tags = "2, 1")]
    pub operation: ::std::option::Option<account_budget_proposal_operation::Operation>,
}
pub mod account_budget_proposal_operation {
    /// The mutate operation.
    #[derive(Clone, PartialEq, ::prost::Oneof)]
    pub enum Operation {
        /// Create operation: A new proposal to create a new budget, edit an
        /// existing budget, end an actively running budget, or remove an approved
        /// budget scheduled to start in the future.
        /// No resource name is expected for the new proposal.
        #[prost(message, tag = "2")]
        Create(super::super::resources::AccountBudgetProposal),
        /// Remove operation: A resource name for the removed proposal is expected,
        /// in this format:
        ///
        /// `customers/{customer_id}/accountBudgetProposals/{account_budget_proposal_id}`
        /// A request may be cancelled iff it is pending.
        #[prost(string, tag = "1")]
        Remove(std::string::String),
    }
}
/// Response message for account-level budget mutate operations.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct MutateAccountBudgetProposalResponse {
    /// The result of the mutate.
    #[prost(message, optional, tag = "2")]
    pub result: ::std::option::Option<MutateAccountBudgetProposalResult>,
}
/// The result for the account budget proposal mutate.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct MutateAccountBudgetProposalResult {
    /// Returned for successful operations.
    #[prost(string, tag = "1")]
    pub resource_name: std::string::String,
}
#[doc = r" Generated client implementations."]
pub mod account_budget_proposal_service_client {
    #![allow(unused_variables, dead_code, missing_docs)]
    use tonic::codegen::*;
    #[doc = " A service for managing account-level budgets via proposals."]
    #[doc = ""]
    #[doc = " A proposal is a request to create a new budget or make changes to an"]
    #[doc = " existing one."]
    #[doc = ""]
    #[doc = " Reads for account-level budgets managed by these proposals will be"]
    #[doc = " supported in a future version. Until then, please use the"]
    #[doc = " BudgetOrderService from the AdWords API. Learn more at"]
    #[doc = " https://developers.google.com/adwords/api/docs/guides/budget-order"]
    #[doc = ""]
    #[doc = " Mutates:"]
    #[doc = " The CREATE operation creates a new proposal."]
    #[doc = " UPDATE operations aren't supported."]
    #[doc = " The REMOVE operation cancels a pending proposal."]
    pub struct AccountBudgetProposalServiceClient<T> {
        inner: tonic::client::Grpc<T>,
    }
    impl AccountBudgetProposalServiceClient<tonic::transport::Channel> {
        #[doc = r" Attempt to create a new client by connecting to a given endpoint."]
        pub async fn connect<D>(dst: D) -> Result<Self, tonic::transport::Error>
        where
            D: std::convert::TryInto<tonic::transport::Endpoint>,
            D::Error: Into<StdError>,
        {
            let conn = tonic::transport::Endpoint::new(dst)?.connect().await?;
            Ok(Self::new(conn))
        }
    }
    impl<T> AccountBudgetProposalServiceClient<T>
    where
        T: tonic::client::GrpcService<tonic::body::BoxBody>,
        T::ResponseBody: Body + HttpBody + Send + 'static,
        T::Error: Into<StdError>,
        <T::ResponseBody as HttpBody>::Error: Into<StdError> + Send,
    {
        pub fn new(inner: T) -> Self {
            let inner = tonic::client::Grpc::new(inner);
            Self { inner }
        }
        pub fn with_interceptor(inner: T, interceptor: impl Into<tonic::Interceptor>) -> Self {
            let inner = tonic::client::Grpc::with_interceptor(inner, interceptor);
            Self { inner }
        }
        #[doc = " Returns an account-level budget proposal in full detail."]
        pub async fn get_account_budget_proposal(
            &mut self,
            request: impl tonic::IntoRequest<super::GetAccountBudgetProposalRequest>,
        ) -> Result<tonic::Response<super::super::resources::AccountBudgetProposal>, tonic::Status>
        {
            self.inner.ready().await.map_err(|e| {
                tonic::Status::new(
                    tonic::Code::Unknown,
                    format!("Service was not ready: {}", e.into()),
                )
            })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http :: uri :: PathAndQuery :: from_static ( "/google.ads.googleads.v1.services.AccountBudgetProposalService/GetAccountBudgetProposal" ) ;
            self.inner.unary(request.into_request(), path, codec).await
        }
        #[doc = " Creates, updates, or removes account budget proposals.  Operation statuses"]
        #[doc = " are returned."]
        pub async fn mutate_account_budget_proposal(
            &mut self,
            request: impl tonic::IntoRequest<super::MutateAccountBudgetProposalRequest>,
        ) -> Result<tonic::Response<super::MutateAccountBudgetProposalResponse>, tonic::Status>
        {
            self.inner.ready().await.map_err(|e| {
                tonic::Status::new(
                    tonic::Code::Unknown,
                    format!("Service was not ready: {}", e.into()),
                )
            })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http :: uri :: PathAndQuery :: from_static ( "/google.ads.googleads.v1.services.AccountBudgetProposalService/MutateAccountBudgetProposal" ) ;
            self.inner.unary(request.into_request(), path, codec).await
        }
    }
    impl<T: Clone> Clone for AccountBudgetProposalServiceClient<T> {
        fn clone(&self) -> Self {
            Self {
                inner: self.inner.clone(),
            }
        }
    }
    impl<T> std::fmt::Debug for AccountBudgetProposalServiceClient<T> {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
            write!(f, "AccountBudgetProposalServiceClient {{ ... }}")
        }
    }
}
#[doc = r" Generated server implementations."]
pub mod account_budget_proposal_service_server {
    #![allow(unused_variables, dead_code, missing_docs)]
    use tonic::codegen::*;
    #[doc = "Generated trait containing gRPC methods that should be implemented for use with AccountBudgetProposalServiceServer."]
    #[async_trait]
    pub trait AccountBudgetProposalService: Send + Sync + 'static {
        #[doc = " Returns an account-level budget proposal in full detail."]
        async fn get_account_budget_proposal(
            &self,
            request: tonic::Request<super::GetAccountBudgetProposalRequest>,
        ) -> Result<tonic::Response<super::super::resources::AccountBudgetProposal>, tonic::Status>;
        #[doc = " Creates, updates, or removes account budget proposals.  Operation statuses"]
        #[doc = " are returned."]
        async fn mutate_account_budget_proposal(
            &self,
            request: tonic::Request<super::MutateAccountBudgetProposalRequest>,
        ) -> Result<tonic::Response<super::MutateAccountBudgetProposalResponse>, tonic::Status>;
    }
    #[doc = " A service for managing account-level budgets via proposals."]
    #[doc = ""]
    #[doc = " A proposal is a request to create a new budget or make changes to an"]
    #[doc = " existing one."]
    #[doc = ""]
    #[doc = " Reads for account-level budgets managed by these proposals will be"]
    #[doc = " supported in a future version. Until then, please use the"]
    #[doc = " BudgetOrderService from the AdWords API. Learn more at"]
    #[doc = " https://developers.google.com/adwords/api/docs/guides/budget-order"]
    #[doc = ""]
    #[doc = " Mutates:"]
    #[doc = " The CREATE operation creates a new proposal."]
    #[doc = " UPDATE operations aren't supported."]
    #[doc = " The REMOVE operation cancels a pending proposal."]
    #[derive(Debug)]
    #[doc(hidden)]
    pub struct AccountBudgetProposalServiceServer<T: AccountBudgetProposalService> {
        inner: _Inner<T>,
    }
    struct _Inner<T>(Arc<T>, Option<tonic::Interceptor>);
    impl<T: AccountBudgetProposalService> AccountBudgetProposalServiceServer<T> {
        pub fn new(inner: T) -> Self {
            let inner = Arc::new(inner);
            let inner = _Inner(inner, None);
            Self { inner }
        }
        pub fn with_interceptor(inner: T, interceptor: impl Into<tonic::Interceptor>) -> Self {
            let inner = Arc::new(inner);
            let inner = _Inner(inner, Some(interceptor.into()));
            Self { inner }
        }
    }
    impl<T, B> Service<http::Request<B>> for AccountBudgetProposalServiceServer<T>
    where
        T: AccountBudgetProposalService,
        B: HttpBody + Send + Sync + 'static,
        B::Error: Into<StdError> + Send + 'static,
    {
        type Response = http::Response<tonic::body::BoxBody>;
        type Error = Never;
        type Future = BoxFuture<Self::Response, Self::Error>;
        fn poll_ready(&mut self, _cx: &mut Context<'_>) -> Poll<Result<(), Self::Error>> {
            Poll::Ready(Ok(()))
        }
        fn call(&mut self, req: http::Request<B>) -> Self::Future {
            let inner = self.inner.clone();
            match req . uri ( ) . path ( ) { "/google.ads.googleads.v1.services.AccountBudgetProposalService/GetAccountBudgetProposal" => { # [ allow ( non_camel_case_types ) ] struct GetAccountBudgetProposalSvc < T : AccountBudgetProposalService > ( pub Arc < T > ) ; impl < T : AccountBudgetProposalService > tonic :: server :: UnaryService < super :: GetAccountBudgetProposalRequest > for GetAccountBudgetProposalSvc < T > { type Response = super :: super :: resources :: AccountBudgetProposal ; type Future = BoxFuture < tonic :: Response < Self :: Response > , tonic :: Status > ; fn call ( & mut self , request : tonic :: Request < super :: GetAccountBudgetProposalRequest > ) -> Self :: Future { let inner = self . 0 . clone ( ) ; let fut = async move { inner . get_account_budget_proposal ( request ) . await } ; Box :: pin ( fut ) } } let inner = self . inner . clone ( ) ; let fut = async move { let interceptor = inner . 1 . clone ( ) ; let inner = inner . 0 ; let method = GetAccountBudgetProposalSvc ( inner ) ; let codec = tonic :: codec :: ProstCodec :: default ( ) ; let mut grpc = if let Some ( interceptor ) = interceptor { tonic :: server :: Grpc :: with_interceptor ( codec , interceptor ) } else { tonic :: server :: Grpc :: new ( codec ) } ; let res = grpc . unary ( method , req ) . await ; Ok ( res ) } ; Box :: pin ( fut ) } "/google.ads.googleads.v1.services.AccountBudgetProposalService/MutateAccountBudgetProposal" => { # [ allow ( non_camel_case_types ) ] struct MutateAccountBudgetProposalSvc < T : AccountBudgetProposalService > ( pub Arc < T > ) ; impl < T : AccountBudgetProposalService > tonic :: server :: UnaryService < super :: MutateAccountBudgetProposalRequest > for MutateAccountBudgetProposalSvc < T > { type Response = super :: MutateAccountBudgetProposalResponse ; type Future = BoxFuture < tonic :: Response < Self :: Response > , tonic :: Status > ; fn call ( & mut self , request : tonic :: Request < super :: MutateAccountBudgetProposalRequest > ) -> Self :: Future { let inner = self . 0 . clone ( ) ; let fut = async move { inner . mutate_account_budget_proposal ( request ) . await } ; Box :: pin ( fut ) } } let inner = self . inner . clone ( ) ; let fut = async move { let interceptor = inner . 1 . clone ( ) ; let inner = inner . 0 ; let method = MutateAccountBudgetProposalSvc ( inner ) ; let codec = tonic :: codec :: ProstCodec :: default ( ) ; let mut grpc = if let Some ( interceptor ) = interceptor { tonic :: server :: Grpc :: with_interceptor ( codec , interceptor ) } else { tonic :: server :: Grpc :: new ( codec ) } ; let res = grpc . unary ( method , req ) . await ; Ok ( res ) } ; Box :: pin ( fut ) } _ => Box :: pin ( async move { Ok ( http :: Response :: builder ( ) . status ( 200 ) . header ( "grpc-status" , "12" ) . body ( tonic :: body :: BoxBody :: empty ( ) ) . unwrap ( ) ) } ) , }
        }
    }
    impl<T: AccountBudgetProposalService> Clone for AccountBudgetProposalServiceServer<T> {
        fn clone(&self) -> Self {
            let inner = self.inner.clone();
            Self { inner }
        }
    }
    impl<T: AccountBudgetProposalService> Clone for _Inner<T> {
        fn clone(&self) -> Self {
            Self(self.0.clone(), self.1.clone())
        }
    }
    impl<T: std::fmt::Debug> std::fmt::Debug for _Inner<T> {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
            write!(f, "{:?}", self.0)
        }
    }
    impl<T: AccountBudgetProposalService> tonic::transport::NamedService
        for AccountBudgetProposalServiceServer<T>
    {
        const NAME: &'static str = "google.ads.googleads.v1.services.AccountBudgetProposalService";
    }
}
/// Request message for
/// [AccountBudgetService.GetAccountBudget][google.ads.googleads.v1.services.AccountBudgetService.GetAccountBudget].
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GetAccountBudgetRequest {
    /// Required. The resource name of the account-level budget to fetch.
    #[prost(string, tag = "1")]
    pub resource_name: std::string::String,
}
#[doc = r" Generated client implementations."]
pub mod account_budget_service_client {
    #![allow(unused_variables, dead_code, missing_docs)]
    use tonic::codegen::*;
    #[doc = " A service for fetching an account-level budget."]
    #[doc = ""]
    #[doc = " Account-level budgets are mutated by creating proposal resources."]
    pub struct AccountBudgetServiceClient<T> {
        inner: tonic::client::Grpc<T>,
    }
    impl AccountBudgetServiceClient<tonic::transport::Channel> {
        #[doc = r" Attempt to create a new client by connecting to a given endpoint."]
        pub async fn connect<D>(dst: D) -> Result<Self, tonic::transport::Error>
        where
            D: std::convert::TryInto<tonic::transport::Endpoint>,
            D::Error: Into<StdError>,
        {
            let conn = tonic::transport::Endpoint::new(dst)?.connect().await?;
            Ok(Self::new(conn))
        }
    }
    impl<T> AccountBudgetServiceClient<T>
    where
        T: tonic::client::GrpcService<tonic::body::BoxBody>,
        T::ResponseBody: Body + HttpBody + Send + 'static,
        T::Error: Into<StdError>,
        <T::ResponseBody as HttpBody>::Error: Into<StdError> + Send,
    {
        pub fn new(inner: T) -> Self {
            let inner = tonic::client::Grpc::new(inner);
            Self { inner }
        }
        pub fn with_interceptor(inner: T, interceptor: impl Into<tonic::Interceptor>) -> Self {
            let inner = tonic::client::Grpc::with_interceptor(inner, interceptor);
            Self { inner }
        }
        #[doc = " Returns an account-level budget in full detail."]
        pub async fn get_account_budget(
            &mut self,
            request: impl tonic::IntoRequest<super::GetAccountBudgetRequest>,
        ) -> Result<tonic::Response<super::super::resources::AccountBudget>, tonic::Status>
        {
            self.inner.ready().await.map_err(|e| {
                tonic::Status::new(
                    tonic::Code::Unknown,
                    format!("Service was not ready: {}", e.into()),
                )
            })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.ads.googleads.v1.services.AccountBudgetService/GetAccountBudget",
            );
            self.inner.unary(request.into_request(), path, codec).await
        }
    }
    impl<T: Clone> Clone for AccountBudgetServiceClient<T> {
        fn clone(&self) -> Self {
            Self {
                inner: self.inner.clone(),
            }
        }
    }
    impl<T> std::fmt::Debug for AccountBudgetServiceClient<T> {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
            write!(f, "AccountBudgetServiceClient {{ ... }}")
        }
    }
}
#[doc = r" Generated server implementations."]
pub mod account_budget_service_server {
    #![allow(unused_variables, dead_code, missing_docs)]
    use tonic::codegen::*;
    #[doc = "Generated trait containing gRPC methods that should be implemented for use with AccountBudgetServiceServer."]
    #[async_trait]
    pub trait AccountBudgetService: Send + Sync + 'static {
        #[doc = " Returns an account-level budget in full detail."]
        async fn get_account_budget(
            &self,
            request: tonic::Request<super::GetAccountBudgetRequest>,
        ) -> Result<tonic::Response<super::super::resources::AccountBudget>, tonic::Status>;
    }
    #[doc = " A service for fetching an account-level budget."]
    #[doc = ""]
    #[doc = " Account-level budgets are mutated by creating proposal resources."]
    #[derive(Debug)]
    #[doc(hidden)]
    pub struct AccountBudgetServiceServer<T: AccountBudgetService> {
        inner: _Inner<T>,
    }
    struct _Inner<T>(Arc<T>, Option<tonic::Interceptor>);
    impl<T: AccountBudgetService> AccountBudgetServiceServer<T> {
        pub fn new(inner: T) -> Self {
            let inner = Arc::new(inner);
            let inner = _Inner(inner, None);
            Self { inner }
        }
        pub fn with_interceptor(inner: T, interceptor: impl Into<tonic::Interceptor>) -> Self {
            let inner = Arc::new(inner);
            let inner = _Inner(inner, Some(interceptor.into()));
            Self { inner }
        }
    }
    impl<T, B> Service<http::Request<B>> for AccountBudgetServiceServer<T>
    where
        T: AccountBudgetService,
        B: HttpBody + Send + Sync + 'static,
        B::Error: Into<StdError> + Send + 'static,
    {
        type Response = http::Response<tonic::body::BoxBody>;
        type Error = Never;
        type Future = BoxFuture<Self::Response, Self::Error>;
        fn poll_ready(&mut self, _cx: &mut Context<'_>) -> Poll<Result<(), Self::Error>> {
            Poll::Ready(Ok(()))
        }
        fn call(&mut self, req: http::Request<B>) -> Self::Future {
            let inner = self.inner.clone();
            match req.uri().path() {
                "/google.ads.googleads.v1.services.AccountBudgetService/GetAccountBudget" => {
                    #[allow(non_camel_case_types)]
                    struct GetAccountBudgetSvc<T: AccountBudgetService>(pub Arc<T>);
                    impl<T: AccountBudgetService>
                        tonic::server::UnaryService<super::GetAccountBudgetRequest>
                        for GetAccountBudgetSvc<T>
                    {
                        type Response = super::super::resources::AccountBudget;
                        type Future = BoxFuture<tonic::Response<Self::Response>, tonic::Status>;
                        fn call(
                            &mut self,
                            request: tonic::Request<super::GetAccountBudgetRequest>,
                        ) -> Self::Future {
                            let inner = self.0.clone();
                            let fut = async move { inner.get_account_budget(request).await };
                            Box::pin(fut)
                        }
                    }
                    let inner = self.inner.clone();
                    let fut = async move {
                        let interceptor = inner.1.clone();
                        let inner = inner.0;
                        let method = GetAccountBudgetSvc(inner);
                        let codec = tonic::codec::ProstCodec::default();
                        let mut grpc = if let Some(interceptor) = interceptor {
                            tonic::server::Grpc::with_interceptor(codec, interceptor)
                        } else {
                            tonic::server::Grpc::new(codec)
                        };
                        let res = grpc.unary(method, req).await;
                        Ok(res)
                    };
                    Box::pin(fut)
                }
                _ => Box::pin(async move {
                    Ok(http::Response::builder()
                        .status(200)
                        .header("grpc-status", "12")
                        .body(tonic::body::BoxBody::empty())
                        .unwrap())
                }),
            }
        }
    }
    impl<T: AccountBudgetService> Clone for AccountBudgetServiceServer<T> {
        fn clone(&self) -> Self {
            let inner = self.inner.clone();
            Self { inner }
        }
    }
    impl<T: AccountBudgetService> Clone for _Inner<T> {
        fn clone(&self) -> Self {
            Self(self.0.clone(), self.1.clone())
        }
    }
    impl<T: std::fmt::Debug> std::fmt::Debug for _Inner<T> {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
            write!(f, "{:?}", self.0)
        }
    }
    impl<T: AccountBudgetService> tonic::transport::NamedService for AccountBudgetServiceServer<T> {
        const NAME: &'static str = "google.ads.googleads.v1.services.AccountBudgetService";
    }
}
/// Request message for [AdGroupAdLabelService.GetAdGroupAdLabel][google.ads.googleads.v1.services.AdGroupAdLabelService.GetAdGroupAdLabel].
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GetAdGroupAdLabelRequest {
    /// Required. The resource name of the ad group ad label to fetch.
    #[prost(string, tag = "1")]
    pub resource_name: std::string::String,
}
/// Request message for [AdGroupAdLabelService.MutateAdGroupAdLabels][google.ads.googleads.v1.services.AdGroupAdLabelService.MutateAdGroupAdLabels].
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct MutateAdGroupAdLabelsRequest {
    /// Required. ID of the customer whose ad group ad labels are being modified.
    #[prost(string, tag = "1")]
    pub customer_id: std::string::String,
    /// Required. The list of operations to perform on ad group ad labels.
    #[prost(message, repeated, tag = "2")]
    pub operations: ::std::vec::Vec<AdGroupAdLabelOperation>,
    /// If true, successful operations will be carried out and invalid
    /// operations will return errors. If false, all operations will be carried
    /// out in one transaction if and only if they are all valid.
    /// Default is false.
    #[prost(bool, tag = "3")]
    pub partial_failure: bool,
    /// If true, the request is validated but not executed. Only errors are
    /// returned, not results.
    #[prost(bool, tag = "4")]
    pub validate_only: bool,
}
/// A single operation (create, remove) on an ad group ad label.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct AdGroupAdLabelOperation {
    /// The mutate operation.
    #[prost(oneof = "ad_group_ad_label_operation::Operation", tags = "1, 2")]
    pub operation: ::std::option::Option<ad_group_ad_label_operation::Operation>,
}
pub mod ad_group_ad_label_operation {
    /// The mutate operation.
    #[derive(Clone, PartialEq, ::prost::Oneof)]
    pub enum Operation {
        /// Create operation: No resource name is expected for the new ad group ad
        /// label.
        #[prost(message, tag = "1")]
        Create(super::super::resources::AdGroupAdLabel),
        /// Remove operation: A resource name for the ad group ad label
        /// being removed, in this format:
        ///
        /// `customers/{customer_id}/adGroupAdLabels/{ad_group_id}~{ad_id}
        /// _{label_id}`
        #[prost(string, tag = "2")]
        Remove(std::string::String),
    }
}
/// Response message for an ad group ad labels mutate.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct MutateAdGroupAdLabelsResponse {
    /// Errors that pertain to operation failures in the partial failure mode.
    /// Returned only when partial_failure = true and all errors occur inside the
    /// operations. If any errors occur outside the operations (e.g. auth errors),
    /// we return an RPC level error.
    #[prost(message, optional, tag = "3")]
    pub partial_failure_error: ::std::option::Option<super::super::super::super::rpc::Status>,
    /// All results for the mutate.
    #[prost(message, repeated, tag = "2")]
    pub results: ::std::vec::Vec<MutateAdGroupAdLabelResult>,
}
/// The result for an ad group ad label mutate.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct MutateAdGroupAdLabelResult {
    /// Returned for successful operations.
    #[prost(string, tag = "1")]
    pub resource_name: std::string::String,
}
#[doc = r" Generated client implementations."]
pub mod ad_group_ad_label_service_client {
    #![allow(unused_variables, dead_code, missing_docs)]
    use tonic::codegen::*;
    #[doc = " Service to manage labels on ad group ads."]
    pub struct AdGroupAdLabelServiceClient<T> {
        inner: tonic::client::Grpc<T>,
    }
    impl AdGroupAdLabelServiceClient<tonic::transport::Channel> {
        #[doc = r" Attempt to create a new client by connecting to a given endpoint."]
        pub async fn connect<D>(dst: D) -> Result<Self, tonic::transport::Error>
        where
            D: std::convert::TryInto<tonic::transport::Endpoint>,
            D::Error: Into<StdError>,
        {
            let conn = tonic::transport::Endpoint::new(dst)?.connect().await?;
            Ok(Self::new(conn))
        }
    }
    impl<T> AdGroupAdLabelServiceClient<T>
    where
        T: tonic::client::GrpcService<tonic::body::BoxBody>,
        T::ResponseBody: Body + HttpBody + Send + 'static,
        T::Error: Into<StdError>,
        <T::ResponseBody as HttpBody>::Error: Into<StdError> + Send,
    {
        pub fn new(inner: T) -> Self {
            let inner = tonic::client::Grpc::new(inner);
            Self { inner }
        }
        pub fn with_interceptor(inner: T, interceptor: impl Into<tonic::Interceptor>) -> Self {
            let inner = tonic::client::Grpc::with_interceptor(inner, interceptor);
            Self { inner }
        }
        #[doc = " Returns the requested ad group ad label in full detail."]
        pub async fn get_ad_group_ad_label(
            &mut self,
            request: impl tonic::IntoRequest<super::GetAdGroupAdLabelRequest>,
        ) -> Result<tonic::Response<super::super::resources::AdGroupAdLabel>, tonic::Status>
        {
            self.inner.ready().await.map_err(|e| {
                tonic::Status::new(
                    tonic::Code::Unknown,
                    format!("Service was not ready: {}", e.into()),
                )
            })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.ads.googleads.v1.services.AdGroupAdLabelService/GetAdGroupAdLabel",
            );
            self.inner.unary(request.into_request(), path, codec).await
        }
        #[doc = " Creates and removes ad group ad labels."]
        #[doc = " Operation statuses are returned."]
        pub async fn mutate_ad_group_ad_labels(
            &mut self,
            request: impl tonic::IntoRequest<super::MutateAdGroupAdLabelsRequest>,
        ) -> Result<tonic::Response<super::MutateAdGroupAdLabelsResponse>, tonic::Status> {
            self.inner.ready().await.map_err(|e| {
                tonic::Status::new(
                    tonic::Code::Unknown,
                    format!("Service was not ready: {}", e.into()),
                )
            })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.ads.googleads.v1.services.AdGroupAdLabelService/MutateAdGroupAdLabels",
            );
            self.inner.unary(request.into_request(), path, codec).await
        }
    }
    impl<T: Clone> Clone for AdGroupAdLabelServiceClient<T> {
        fn clone(&self) -> Self {
            Self {
                inner: self.inner.clone(),
            }
        }
    }
    impl<T> std::fmt::Debug for AdGroupAdLabelServiceClient<T> {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
            write!(f, "AdGroupAdLabelServiceClient {{ ... }}")
        }
    }
}
#[doc = r" Generated server implementations."]
pub mod ad_group_ad_label_service_server {
    #![allow(unused_variables, dead_code, missing_docs)]
    use tonic::codegen::*;
    #[doc = "Generated trait containing gRPC methods that should be implemented for use with AdGroupAdLabelServiceServer."]
    #[async_trait]
    pub trait AdGroupAdLabelService: Send + Sync + 'static {
        #[doc = " Returns the requested ad group ad label in full detail."]
        async fn get_ad_group_ad_label(
            &self,
            request: tonic::Request<super::GetAdGroupAdLabelRequest>,
        ) -> Result<tonic::Response<super::super::resources::AdGroupAdLabel>, tonic::Status>;
        #[doc = " Creates and removes ad group ad labels."]
        #[doc = " Operation statuses are returned."]
        async fn mutate_ad_group_ad_labels(
            &self,
            request: tonic::Request<super::MutateAdGroupAdLabelsRequest>,
        ) -> Result<tonic::Response<super::MutateAdGroupAdLabelsResponse>, tonic::Status>;
    }
    #[doc = " Service to manage labels on ad group ads."]
    #[derive(Debug)]
    #[doc(hidden)]
    pub struct AdGroupAdLabelServiceServer<T: AdGroupAdLabelService> {
        inner: _Inner<T>,
    }
    struct _Inner<T>(Arc<T>, Option<tonic::Interceptor>);
    impl<T: AdGroupAdLabelService> AdGroupAdLabelServiceServer<T> {
        pub fn new(inner: T) -> Self {
            let inner = Arc::new(inner);
            let inner = _Inner(inner, None);
            Self { inner }
        }
        pub fn with_interceptor(inner: T, interceptor: impl Into<tonic::Interceptor>) -> Self {
            let inner = Arc::new(inner);
            let inner = _Inner(inner, Some(interceptor.into()));
            Self { inner }
        }
    }
    impl<T, B> Service<http::Request<B>> for AdGroupAdLabelServiceServer<T>
    where
        T: AdGroupAdLabelService,
        B: HttpBody + Send + Sync + 'static,
        B::Error: Into<StdError> + Send + 'static,
    {
        type Response = http::Response<tonic::body::BoxBody>;
        type Error = Never;
        type Future = BoxFuture<Self::Response, Self::Error>;
        fn poll_ready(&mut self, _cx: &mut Context<'_>) -> Poll<Result<(), Self::Error>> {
            Poll::Ready(Ok(()))
        }
        fn call(&mut self, req: http::Request<B>) -> Self::Future {
            let inner = self.inner.clone();
            match req.uri().path() {
                "/google.ads.googleads.v1.services.AdGroupAdLabelService/GetAdGroupAdLabel" => {
                    #[allow(non_camel_case_types)]
                    struct GetAdGroupAdLabelSvc<T: AdGroupAdLabelService>(pub Arc<T>);
                    impl<T: AdGroupAdLabelService>
                        tonic::server::UnaryService<super::GetAdGroupAdLabelRequest>
                        for GetAdGroupAdLabelSvc<T>
                    {
                        type Response = super::super::resources::AdGroupAdLabel;
                        type Future = BoxFuture<tonic::Response<Self::Response>, tonic::Status>;
                        fn call(
                            &mut self,
                            request: tonic::Request<super::GetAdGroupAdLabelRequest>,
                        ) -> Self::Future {
                            let inner = self.0.clone();
                            let fut = async move { inner.get_ad_group_ad_label(request).await };
                            Box::pin(fut)
                        }
                    }
                    let inner = self.inner.clone();
                    let fut = async move {
                        let interceptor = inner.1.clone();
                        let inner = inner.0;
                        let method = GetAdGroupAdLabelSvc(inner);
                        let codec = tonic::codec::ProstCodec::default();
                        let mut grpc = if let Some(interceptor) = interceptor {
                            tonic::server::Grpc::with_interceptor(codec, interceptor)
                        } else {
                            tonic::server::Grpc::new(codec)
                        };
                        let res = grpc.unary(method, req).await;
                        Ok(res)
                    };
                    Box::pin(fut)
                }
                "/google.ads.googleads.v1.services.AdGroupAdLabelService/MutateAdGroupAdLabels" => {
                    #[allow(non_camel_case_types)]
                    struct MutateAdGroupAdLabelsSvc<T: AdGroupAdLabelService>(pub Arc<T>);
                    impl<T: AdGroupAdLabelService>
                        tonic::server::UnaryService<super::MutateAdGroupAdLabelsRequest>
                        for MutateAdGroupAdLabelsSvc<T>
                    {
                        type Response = super::MutateAdGroupAdLabelsResponse;
                        type Future = BoxFuture<tonic::Response<Self::Response>, tonic::Status>;
                        fn call(
                            &mut self,
                            request: tonic::Request<super::MutateAdGroupAdLabelsRequest>,
                        ) -> Self::Future {
                            let inner = self.0.clone();
                            let fut = async move { inner.mutate_ad_group_ad_labels(request).await };
                            Box::pin(fut)
                        }
                    }
                    let inner = self.inner.clone();
                    let fut = async move {
                        let interceptor = inner.1.clone();
                        let inner = inner.0;
                        let method = MutateAdGroupAdLabelsSvc(inner);
                        let codec = tonic::codec::ProstCodec::default();
                        let mut grpc = if let Some(interceptor) = interceptor {
                            tonic::server::Grpc::with_interceptor(codec, interceptor)
                        } else {
                            tonic::server::Grpc::new(codec)
                        };
                        let res = grpc.unary(method, req).await;
                        Ok(res)
                    };
                    Box::pin(fut)
                }
                _ => Box::pin(async move {
                    Ok(http::Response::builder()
                        .status(200)
                        .header("grpc-status", "12")
                        .body(tonic::body::BoxBody::empty())
                        .unwrap())
                }),
            }
        }
    }
    impl<T: AdGroupAdLabelService> Clone for AdGroupAdLabelServiceServer<T> {
        fn clone(&self) -> Self {
            let inner = self.inner.clone();
            Self { inner }
        }
    }
    impl<T: AdGroupAdLabelService> Clone for _Inner<T> {
        fn clone(&self) -> Self {
            Self(self.0.clone(), self.1.clone())
        }
    }
    impl<T: std::fmt::Debug> std::fmt::Debug for _Inner<T> {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
            write!(f, "{:?}", self.0)
        }
    }
    impl<T: AdGroupAdLabelService> tonic::transport::NamedService for AdGroupAdLabelServiceServer<T> {
        const NAME: &'static str = "google.ads.googleads.v1.services.AdGroupAdLabelService";
    }
}
/// Request message for [AdGroupAdService.GetAdGroupAd][google.ads.googleads.v1.services.AdGroupAdService.GetAdGroupAd].
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GetAdGroupAdRequest {
    /// Required. The resource name of the ad to fetch.
    #[prost(string, tag = "1")]
    pub resource_name: std::string::String,
}
/// Request message for [AdGroupAdService.MutateAdGroupAds][google.ads.googleads.v1.services.AdGroupAdService.MutateAdGroupAds].
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct MutateAdGroupAdsRequest {
    /// Required. The ID of the customer whose ads are being modified.
    #[prost(string, tag = "1")]
    pub customer_id: std::string::String,
    /// Required. The list of operations to perform on individual ads.
    #[prost(message, repeated, tag = "2")]
    pub operations: ::std::vec::Vec<AdGroupAdOperation>,
    /// If true, successful operations will be carried out and invalid
    /// operations will return errors. If false, all operations will be carried
    /// out in one transaction if and only if they are all valid.
    /// Default is false.
    #[prost(bool, tag = "3")]
    pub partial_failure: bool,
    /// If true, the request is validated but not executed. Only errors are
    /// returned, not results.
    #[prost(bool, tag = "4")]
    pub validate_only: bool,
}
/// A single operation (create, update, remove) on an ad group ad.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct AdGroupAdOperation {
    /// FieldMask that determines which resource fields are modified in an update.
    #[prost(message, optional, tag = "4")]
    pub update_mask: ::std::option::Option<::prost_types::FieldMask>,
    /// Configuration for how policies are validated.
    #[prost(message, optional, tag = "5")]
    pub policy_validation_parameter:
        ::std::option::Option<super::common::PolicyValidationParameter>,
    /// The mutate operation.
    #[prost(oneof = "ad_group_ad_operation::Operation", tags = "1, 2, 3")]
    pub operation: ::std::option::Option<ad_group_ad_operation::Operation>,
}
pub mod ad_group_ad_operation {
    /// The mutate operation.
    #[derive(Clone, PartialEq, ::prost::Oneof)]
    pub enum Operation {
        /// Create operation: No resource name is expected for the new ad.
        #[prost(message, tag = "1")]
        Create(super::super::resources::AdGroupAd),
        /// Update operation: The ad is expected to have a valid resource name.
        #[prost(message, tag = "2")]
        Update(super::super::resources::AdGroupAd),
        /// Remove operation: A resource name for the removed ad is expected,
        /// in this format:
        ///
        /// `customers/{customer_id}/adGroupAds/{ad_group_id}~{ad_id}`
        #[prost(string, tag = "3")]
        Remove(std::string::String),
    }
}
/// Response message for an ad group ad mutate.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct MutateAdGroupAdsResponse {
    /// Errors that pertain to operation failures in the partial failure mode.
    /// Returned only when partial_failure = true and all errors occur inside the
    /// operations. If any errors occur outside the operations (e.g. auth errors),
    /// we return an RPC level error.
    #[prost(message, optional, tag = "3")]
    pub partial_failure_error: ::std::option::Option<super::super::super::super::rpc::Status>,
    /// All results for the mutate.
    #[prost(message, repeated, tag = "2")]
    pub results: ::std::vec::Vec<MutateAdGroupAdResult>,
}
/// The result for the ad mutate.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct MutateAdGroupAdResult {
    /// The resource name returned for successful operations.
    #[prost(string, tag = "1")]
    pub resource_name: std::string::String,
}
#[doc = r" Generated client implementations."]
pub mod ad_group_ad_service_client {
    #![allow(unused_variables, dead_code, missing_docs)]
    use tonic::codegen::*;
    #[doc = " Service to manage ads in an ad group."]
    pub struct AdGroupAdServiceClient<T> {
        inner: tonic::client::Grpc<T>,
    }
    impl AdGroupAdServiceClient<tonic::transport::Channel> {
        #[doc = r" Attempt to create a new client by connecting to a given endpoint."]
        pub async fn connect<D>(dst: D) -> Result<Self, tonic::transport::Error>
        where
            D: std::convert::TryInto<tonic::transport::Endpoint>,
            D::Error: Into<StdError>,
        {
            let conn = tonic::transport::Endpoint::new(dst)?.connect().await?;
            Ok(Self::new(conn))
        }
    }
    impl<T> AdGroupAdServiceClient<T>
    where
        T: tonic::client::GrpcService<tonic::body::BoxBody>,
        T::ResponseBody: Body + HttpBody + Send + 'static,
        T::Error: Into<StdError>,
        <T::ResponseBody as HttpBody>::Error: Into<StdError> + Send,
    {
        pub fn new(inner: T) -> Self {
            let inner = tonic::client::Grpc::new(inner);
            Self { inner }
        }
        pub fn with_interceptor(inner: T, interceptor: impl Into<tonic::Interceptor>) -> Self {
            let inner = tonic::client::Grpc::with_interceptor(inner, interceptor);
            Self { inner }
        }
        #[doc = " Returns the requested ad in full detail."]
        pub async fn get_ad_group_ad(
            &mut self,
            request: impl tonic::IntoRequest<super::GetAdGroupAdRequest>,
        ) -> Result<tonic::Response<super::super::resources::AdGroupAd>, tonic::Status> {
            self.inner.ready().await.map_err(|e| {
                tonic::Status::new(
                    tonic::Code::Unknown,
                    format!("Service was not ready: {}", e.into()),
                )
            })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.ads.googleads.v1.services.AdGroupAdService/GetAdGroupAd",
            );
            self.inner.unary(request.into_request(), path, codec).await
        }
        #[doc = " Creates, updates, or removes ads. Operation statuses are returned."]
        pub async fn mutate_ad_group_ads(
            &mut self,
            request: impl tonic::IntoRequest<super::MutateAdGroupAdsRequest>,
        ) -> Result<tonic::Response<super::MutateAdGroupAdsResponse>, tonic::Status> {
            self.inner.ready().await.map_err(|e| {
                tonic::Status::new(
                    tonic::Code::Unknown,
                    format!("Service was not ready: {}", e.into()),
                )
            })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.ads.googleads.v1.services.AdGroupAdService/MutateAdGroupAds",
            );
            self.inner.unary(request.into_request(), path, codec).await
        }
    }
    impl<T: Clone> Clone for AdGroupAdServiceClient<T> {
        fn clone(&self) -> Self {
            Self {
                inner: self.inner.clone(),
            }
        }
    }
    impl<T> std::fmt::Debug for AdGroupAdServiceClient<T> {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
            write!(f, "AdGroupAdServiceClient {{ ... }}")
        }
    }
}
#[doc = r" Generated server implementations."]
pub mod ad_group_ad_service_server {
    #![allow(unused_variables, dead_code, missing_docs)]
    use tonic::codegen::*;
    #[doc = "Generated trait containing gRPC methods that should be implemented for use with AdGroupAdServiceServer."]
    #[async_trait]
    pub trait AdGroupAdService: Send + Sync + 'static {
        #[doc = " Returns the requested ad in full detail."]
        async fn get_ad_group_ad(
            &self,
            request: tonic::Request<super::GetAdGroupAdRequest>,
        ) -> Result<tonic::Response<super::super::resources::AdGroupAd>, tonic::Status>;
        #[doc = " Creates, updates, or removes ads. Operation statuses are returned."]
        async fn mutate_ad_group_ads(
            &self,
            request: tonic::Request<super::MutateAdGroupAdsRequest>,
        ) -> Result<tonic::Response<super::MutateAdGroupAdsResponse>, tonic::Status>;
    }
    #[doc = " Service to manage ads in an ad group."]
    #[derive(Debug)]
    #[doc(hidden)]
    pub struct AdGroupAdServiceServer<T: AdGroupAdService> {
        inner: _Inner<T>,
    }
    struct _Inner<T>(Arc<T>, Option<tonic::Interceptor>);
    impl<T: AdGroupAdService> AdGroupAdServiceServer<T> {
        pub fn new(inner: T) -> Self {
            let inner = Arc::new(inner);
            let inner = _Inner(inner, None);
            Self { inner }
        }
        pub fn with_interceptor(inner: T, interceptor: impl Into<tonic::Interceptor>) -> Self {
            let inner = Arc::new(inner);
            let inner = _Inner(inner, Some(interceptor.into()));
            Self { inner }
        }
    }
    impl<T, B> Service<http::Request<B>> for AdGroupAdServiceServer<T>
    where
        T: AdGroupAdService,
        B: HttpBody + Send + Sync + 'static,
        B::Error: Into<StdError> + Send + 'static,
    {
        type Response = http::Response<tonic::body::BoxBody>;
        type Error = Never;
        type Future = BoxFuture<Self::Response, Self::Error>;
        fn poll_ready(&mut self, _cx: &mut Context<'_>) -> Poll<Result<(), Self::Error>> {
            Poll::Ready(Ok(()))
        }
        fn call(&mut self, req: http::Request<B>) -> Self::Future {
            let inner = self.inner.clone();
            match req.uri().path() {
                "/google.ads.googleads.v1.services.AdGroupAdService/GetAdGroupAd" => {
                    #[allow(non_camel_case_types)]
                    struct GetAdGroupAdSvc<T: AdGroupAdService>(pub Arc<T>);
                    impl<T: AdGroupAdService>
                        tonic::server::UnaryService<super::GetAdGroupAdRequest>
                        for GetAdGroupAdSvc<T>
                    {
                        type Response = super::super::resources::AdGroupAd;
                        type Future = BoxFuture<tonic::Response<Self::Response>, tonic::Status>;
                        fn call(
                            &mut self,
                            request: tonic::Request<super::GetAdGroupAdRequest>,
                        ) -> Self::Future {
                            let inner = self.0.clone();
                            let fut = async move { inner.get_ad_group_ad(request).await };
                            Box::pin(fut)
                        }
                    }
                    let inner = self.inner.clone();
                    let fut = async move {
                        let interceptor = inner.1.clone();
                        let inner = inner.0;
                        let method = GetAdGroupAdSvc(inner);
                        let codec = tonic::codec::ProstCodec::default();
                        let mut grpc = if let Some(interceptor) = interceptor {
                            tonic::server::Grpc::with_interceptor(codec, interceptor)
                        } else {
                            tonic::server::Grpc::new(codec)
                        };
                        let res = grpc.unary(method, req).await;
                        Ok(res)
                    };
                    Box::pin(fut)
                }
                "/google.ads.googleads.v1.services.AdGroupAdService/MutateAdGroupAds" => {
                    #[allow(non_camel_case_types)]
                    struct MutateAdGroupAdsSvc<T: AdGroupAdService>(pub Arc<T>);
                    impl<T: AdGroupAdService>
                        tonic::server::UnaryService<super::MutateAdGroupAdsRequest>
                        for MutateAdGroupAdsSvc<T>
                    {
                        type Response = super::MutateAdGroupAdsResponse;
                        type Future = BoxFuture<tonic::Response<Self::Response>, tonic::Status>;
                        fn call(
                            &mut self,
                            request: tonic::Request<super::MutateAdGroupAdsRequest>,
                        ) -> Self::Future {
                            let inner = self.0.clone();
                            let fut = async move { inner.mutate_ad_group_ads(request).await };
                            Box::pin(fut)
                        }
                    }
                    let inner = self.inner.clone();
                    let fut = async move {
                        let interceptor = inner.1.clone();
                        let inner = inner.0;
                        let method = MutateAdGroupAdsSvc(inner);
                        let codec = tonic::codec::ProstCodec::default();
                        let mut grpc = if let Some(interceptor) = interceptor {
                            tonic::server::Grpc::with_interceptor(codec, interceptor)
                        } else {
                            tonic::server::Grpc::new(codec)
                        };
                        let res = grpc.unary(method, req).await;
                        Ok(res)
                    };
                    Box::pin(fut)
                }
                _ => Box::pin(async move {
                    Ok(http::Response::builder()
                        .status(200)
                        .header("grpc-status", "12")
                        .body(tonic::body::BoxBody::empty())
                        .unwrap())
                }),
            }
        }
    }
    impl<T: AdGroupAdService> Clone for AdGroupAdServiceServer<T> {
        fn clone(&self) -> Self {
            let inner = self.inner.clone();
            Self { inner }
        }
    }
    impl<T: AdGroupAdService> Clone for _Inner<T> {
        fn clone(&self) -> Self {
            Self(self.0.clone(), self.1.clone())
        }
    }
    impl<T: std::fmt::Debug> std::fmt::Debug for _Inner<T> {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
            write!(f, "{:?}", self.0)
        }
    }
    impl<T: AdGroupAdService> tonic::transport::NamedService for AdGroupAdServiceServer<T> {
        const NAME: &'static str = "google.ads.googleads.v1.services.AdGroupAdService";
    }
}
/// Request message for [AdGroupAudienceViewService.GetAdGoupAudienceView][].
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GetAdGroupAudienceViewRequest {
    /// Required. The resource name of the ad group audience view to fetch.
    #[prost(string, tag = "1")]
    pub resource_name: std::string::String,
}
#[doc = r" Generated client implementations."]
pub mod ad_group_audience_view_service_client {
    #![allow(unused_variables, dead_code, missing_docs)]
    use tonic::codegen::*;
    #[doc = " Service to manage ad group audience views."]
    pub struct AdGroupAudienceViewServiceClient<T> {
        inner: tonic::client::Grpc<T>,
    }
    impl AdGroupAudienceViewServiceClient<tonic::transport::Channel> {
        #[doc = r" Attempt to create a new client by connecting to a given endpoint."]
        pub async fn connect<D>(dst: D) -> Result<Self, tonic::transport::Error>
        where
            D: std::convert::TryInto<tonic::transport::Endpoint>,
            D::Error: Into<StdError>,
        {
            let conn = tonic::transport::Endpoint::new(dst)?.connect().await?;
            Ok(Self::new(conn))
        }
    }
    impl<T> AdGroupAudienceViewServiceClient<T>
    where
        T: tonic::client::GrpcService<tonic::body::BoxBody>,
        T::ResponseBody: Body + HttpBody + Send + 'static,
        T::Error: Into<StdError>,
        <T::ResponseBody as HttpBody>::Error: Into<StdError> + Send,
    {
        pub fn new(inner: T) -> Self {
            let inner = tonic::client::Grpc::new(inner);
            Self { inner }
        }
        pub fn with_interceptor(inner: T, interceptor: impl Into<tonic::Interceptor>) -> Self {
            let inner = tonic::client::Grpc::with_interceptor(inner, interceptor);
            Self { inner }
        }
        #[doc = " Returns the requested ad group audience view in full detail."]
        pub async fn get_ad_group_audience_view(
            &mut self,
            request: impl tonic::IntoRequest<super::GetAdGroupAudienceViewRequest>,
        ) -> Result<tonic::Response<super::super::resources::AdGroupAudienceView>, tonic::Status>
        {
            self.inner.ready().await.map_err(|e| {
                tonic::Status::new(
                    tonic::Code::Unknown,
                    format!("Service was not ready: {}", e.into()),
                )
            })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http :: uri :: PathAndQuery :: from_static ( "/google.ads.googleads.v1.services.AdGroupAudienceViewService/GetAdGroupAudienceView" ) ;
            self.inner.unary(request.into_request(), path, codec).await
        }
    }
    impl<T: Clone> Clone for AdGroupAudienceViewServiceClient<T> {
        fn clone(&self) -> Self {
            Self {
                inner: self.inner.clone(),
            }
        }
    }
    impl<T> std::fmt::Debug for AdGroupAudienceViewServiceClient<T> {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
            write!(f, "AdGroupAudienceViewServiceClient {{ ... }}")
        }
    }
}
#[doc = r" Generated server implementations."]
pub mod ad_group_audience_view_service_server {
    #![allow(unused_variables, dead_code, missing_docs)]
    use tonic::codegen::*;
    #[doc = "Generated trait containing gRPC methods that should be implemented for use with AdGroupAudienceViewServiceServer."]
    #[async_trait]
    pub trait AdGroupAudienceViewService: Send + Sync + 'static {
        #[doc = " Returns the requested ad group audience view in full detail."]
        async fn get_ad_group_audience_view(
            &self,
            request: tonic::Request<super::GetAdGroupAudienceViewRequest>,
        ) -> Result<tonic::Response<super::super::resources::AdGroupAudienceView>, tonic::Status>;
    }
    #[doc = " Service to manage ad group audience views."]
    #[derive(Debug)]
    #[doc(hidden)]
    pub struct AdGroupAudienceViewServiceServer<T: AdGroupAudienceViewService> {
        inner: _Inner<T>,
    }
    struct _Inner<T>(Arc<T>, Option<tonic::Interceptor>);
    impl<T: AdGroupAudienceViewService> AdGroupAudienceViewServiceServer<T> {
        pub fn new(inner: T) -> Self {
            let inner = Arc::new(inner);
            let inner = _Inner(inner, None);
            Self { inner }
        }
        pub fn with_interceptor(inner: T, interceptor: impl Into<tonic::Interceptor>) -> Self {
            let inner = Arc::new(inner);
            let inner = _Inner(inner, Some(interceptor.into()));
            Self { inner }
        }
    }
    impl<T, B> Service<http::Request<B>> for AdGroupAudienceViewServiceServer<T>
    where
        T: AdGroupAudienceViewService,
        B: HttpBody + Send + Sync + 'static,
        B::Error: Into<StdError> + Send + 'static,
    {
        type Response = http::Response<tonic::body::BoxBody>;
        type Error = Never;
        type Future = BoxFuture<Self::Response, Self::Error>;
        fn poll_ready(&mut self, _cx: &mut Context<'_>) -> Poll<Result<(), Self::Error>> {
            Poll::Ready(Ok(()))
        }
        fn call(&mut self, req: http::Request<B>) -> Self::Future {
            let inner = self.inner.clone();
            match req . uri ( ) . path ( ) { "/google.ads.googleads.v1.services.AdGroupAudienceViewService/GetAdGroupAudienceView" => { # [ allow ( non_camel_case_types ) ] struct GetAdGroupAudienceViewSvc < T : AdGroupAudienceViewService > ( pub Arc < T > ) ; impl < T : AdGroupAudienceViewService > tonic :: server :: UnaryService < super :: GetAdGroupAudienceViewRequest > for GetAdGroupAudienceViewSvc < T > { type Response = super :: super :: resources :: AdGroupAudienceView ; type Future = BoxFuture < tonic :: Response < Self :: Response > , tonic :: Status > ; fn call ( & mut self , request : tonic :: Request < super :: GetAdGroupAudienceViewRequest > ) -> Self :: Future { let inner = self . 0 . clone ( ) ; let fut = async move { inner . get_ad_group_audience_view ( request ) . await } ; Box :: pin ( fut ) } } let inner = self . inner . clone ( ) ; let fut = async move { let interceptor = inner . 1 . clone ( ) ; let inner = inner . 0 ; let method = GetAdGroupAudienceViewSvc ( inner ) ; let codec = tonic :: codec :: ProstCodec :: default ( ) ; let mut grpc = if let Some ( interceptor ) = interceptor { tonic :: server :: Grpc :: with_interceptor ( codec , interceptor ) } else { tonic :: server :: Grpc :: new ( codec ) } ; let res = grpc . unary ( method , req ) . await ; Ok ( res ) } ; Box :: pin ( fut ) } _ => Box :: pin ( async move { Ok ( http :: Response :: builder ( ) . status ( 200 ) . header ( "grpc-status" , "12" ) . body ( tonic :: body :: BoxBody :: empty ( ) ) . unwrap ( ) ) } ) , }
        }
    }
    impl<T: AdGroupAudienceViewService> Clone for AdGroupAudienceViewServiceServer<T> {
        fn clone(&self) -> Self {
            let inner = self.inner.clone();
            Self { inner }
        }
    }
    impl<T: AdGroupAudienceViewService> Clone for _Inner<T> {
        fn clone(&self) -> Self {
            Self(self.0.clone(), self.1.clone())
        }
    }
    impl<T: std::fmt::Debug> std::fmt::Debug for _Inner<T> {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
            write!(f, "{:?}", self.0)
        }
    }
    impl<T: AdGroupAudienceViewService> tonic::transport::NamedService
        for AdGroupAudienceViewServiceServer<T>
    {
        const NAME: &'static str = "google.ads.googleads.v1.services.AdGroupAudienceViewService";
    }
}
/// Request message for [AdGroupBidModifierService.GetAdGroupBidModifier][google.ads.googleads.v1.services.AdGroupBidModifierService.GetAdGroupBidModifier].
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GetAdGroupBidModifierRequest {
    /// Required. The resource name of the ad group bid modifier to fetch.
    #[prost(string, tag = "1")]
    pub resource_name: std::string::String,
}
/// Request message for [AdGroupBidModifierService.MutateAdGroupBidModifiers][google.ads.googleads.v1.services.AdGroupBidModifierService.MutateAdGroupBidModifiers].
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct MutateAdGroupBidModifiersRequest {
    /// Required. ID of the customer whose ad group bid modifiers are being modified.
    #[prost(string, tag = "1")]
    pub customer_id: std::string::String,
    /// Required. The list of operations to perform on individual ad group bid modifiers.
    #[prost(message, repeated, tag = "2")]
    pub operations: ::std::vec::Vec<AdGroupBidModifierOperation>,
    /// If true, successful operations will be carried out and invalid
    /// operations will return errors. If false, all operations will be carried
    /// out in one transaction if and only if they are all valid.
    /// Default is false.
    #[prost(bool, tag = "3")]
    pub partial_failure: bool,
    /// If true, the request is validated but not executed. Only errors are
    /// returned, not results.
    #[prost(bool, tag = "4")]
    pub validate_only: bool,
}
/// A single operation (create, remove, update) on an ad group bid modifier.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct AdGroupBidModifierOperation {
    /// FieldMask that determines which resource fields are modified in an update.
    #[prost(message, optional, tag = "4")]
    pub update_mask: ::std::option::Option<::prost_types::FieldMask>,
    /// The mutate operation.
    #[prost(oneof = "ad_group_bid_modifier_operation::Operation", tags = "1, 2, 3")]
    pub operation: ::std::option::Option<ad_group_bid_modifier_operation::Operation>,
}
pub mod ad_group_bid_modifier_operation {
    /// The mutate operation.
    #[derive(Clone, PartialEq, ::prost::Oneof)]
    pub enum Operation {
        /// Create operation: No resource name is expected for the new ad group bid
        /// modifier.
        #[prost(message, tag = "1")]
        Create(super::super::resources::AdGroupBidModifier),
        /// Update operation: The ad group bid modifier is expected to have a valid
        /// resource name.
        #[prost(message, tag = "2")]
        Update(super::super::resources::AdGroupBidModifier),
        /// Remove operation: A resource name for the removed ad group bid modifier
        /// is expected, in this format:
        ///
        /// `customers/{customer_id}/adGroupBidModifiers/{ad_group_id}~{criterion_id}`
        #[prost(string, tag = "3")]
        Remove(std::string::String),
    }
}
/// Response message for ad group bid modifiers mutate.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct MutateAdGroupBidModifiersResponse {
    /// Errors that pertain to operation failures in the partial failure mode.
    /// Returned only when partial_failure = true and all errors occur inside the
    /// operations. If any errors occur outside the operations (e.g. auth errors),
    /// we return an RPC level error.
    #[prost(message, optional, tag = "3")]
    pub partial_failure_error: ::std::option::Option<super::super::super::super::rpc::Status>,
    /// All results for the mutate.
    #[prost(message, repeated, tag = "2")]
    pub results: ::std::vec::Vec<MutateAdGroupBidModifierResult>,
}
/// The result for the criterion mutate.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct MutateAdGroupBidModifierResult {
    /// Returned for successful operations.
    #[prost(string, tag = "1")]
    pub resource_name: std::string::String,
}
#[doc = r" Generated client implementations."]
pub mod ad_group_bid_modifier_service_client {
    #![allow(unused_variables, dead_code, missing_docs)]
    use tonic::codegen::*;
    #[doc = " Service to manage ad group bid modifiers."]
    pub struct AdGroupBidModifierServiceClient<T> {
        inner: tonic::client::Grpc<T>,
    }
    impl AdGroupBidModifierServiceClient<tonic::transport::Channel> {
        #[doc = r" Attempt to create a new client by connecting to a given endpoint."]
        pub async fn connect<D>(dst: D) -> Result<Self, tonic::transport::Error>
        where
            D: std::convert::TryInto<tonic::transport::Endpoint>,
            D::Error: Into<StdError>,
        {
            let conn = tonic::transport::Endpoint::new(dst)?.connect().await?;
            Ok(Self::new(conn))
        }
    }
    impl<T> AdGroupBidModifierServiceClient<T>
    where
        T: tonic::client::GrpcService<tonic::body::BoxBody>,
        T::ResponseBody: Body + HttpBody + Send + 'static,
        T::Error: Into<StdError>,
        <T::ResponseBody as HttpBody>::Error: Into<StdError> + Send,
    {
        pub fn new(inner: T) -> Self {
            let inner = tonic::client::Grpc::new(inner);
            Self { inner }
        }
        pub fn with_interceptor(inner: T, interceptor: impl Into<tonic::Interceptor>) -> Self {
            let inner = tonic::client::Grpc::with_interceptor(inner, interceptor);
            Self { inner }
        }
        #[doc = " Returns the requested ad group bid modifier in full detail."]
        pub async fn get_ad_group_bid_modifier(
            &mut self,
            request: impl tonic::IntoRequest<super::GetAdGroupBidModifierRequest>,
        ) -> Result<tonic::Response<super::super::resources::AdGroupBidModifier>, tonic::Status>
        {
            self.inner.ready().await.map_err(|e| {
                tonic::Status::new(
                    tonic::Code::Unknown,
                    format!("Service was not ready: {}", e.into()),
                )
            })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.ads.googleads.v1.services.AdGroupBidModifierService/GetAdGroupBidModifier",
            );
            self.inner.unary(request.into_request(), path, codec).await
        }
        #[doc = " Creates, updates, or removes ad group bid modifiers."]
        #[doc = " Operation statuses are returned."]
        pub async fn mutate_ad_group_bid_modifiers(
            &mut self,
            request: impl tonic::IntoRequest<super::MutateAdGroupBidModifiersRequest>,
        ) -> Result<tonic::Response<super::MutateAdGroupBidModifiersResponse>, tonic::Status>
        {
            self.inner.ready().await.map_err(|e| {
                tonic::Status::new(
                    tonic::Code::Unknown,
                    format!("Service was not ready: {}", e.into()),
                )
            })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http :: uri :: PathAndQuery :: from_static ( "/google.ads.googleads.v1.services.AdGroupBidModifierService/MutateAdGroupBidModifiers" ) ;
            self.inner.unary(request.into_request(), path, codec).await
        }
    }
    impl<T: Clone> Clone for AdGroupBidModifierServiceClient<T> {
        fn clone(&self) -> Self {
            Self {
                inner: self.inner.clone(),
            }
        }
    }
    impl<T> std::fmt::Debug for AdGroupBidModifierServiceClient<T> {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
            write!(f, "AdGroupBidModifierServiceClient {{ ... }}")
        }
    }
}
#[doc = r" Generated server implementations."]
pub mod ad_group_bid_modifier_service_server {
    #![allow(unused_variables, dead_code, missing_docs)]
    use tonic::codegen::*;
    #[doc = "Generated trait containing gRPC methods that should be implemented for use with AdGroupBidModifierServiceServer."]
    #[async_trait]
    pub trait AdGroupBidModifierService: Send + Sync + 'static {
        #[doc = " Returns the requested ad group bid modifier in full detail."]
        async fn get_ad_group_bid_modifier(
            &self,
            request: tonic::Request<super::GetAdGroupBidModifierRequest>,
        ) -> Result<tonic::Response<super::super::resources::AdGroupBidModifier>, tonic::Status>;
        #[doc = " Creates, updates, or removes ad group bid modifiers."]
        #[doc = " Operation statuses are returned."]
        async fn mutate_ad_group_bid_modifiers(
            &self,
            request: tonic::Request<super::MutateAdGroupBidModifiersRequest>,
        ) -> Result<tonic::Response<super::MutateAdGroupBidModifiersResponse>, tonic::Status>;
    }
    #[doc = " Service to manage ad group bid modifiers."]
    #[derive(Debug)]
    #[doc(hidden)]
    pub struct AdGroupBidModifierServiceServer<T: AdGroupBidModifierService> {
        inner: _Inner<T>,
    }
    struct _Inner<T>(Arc<T>, Option<tonic::Interceptor>);
    impl<T: AdGroupBidModifierService> AdGroupBidModifierServiceServer<T> {
        pub fn new(inner: T) -> Self {
            let inner = Arc::new(inner);
            let inner = _Inner(inner, None);
            Self { inner }
        }
        pub fn with_interceptor(inner: T, interceptor: impl Into<tonic::Interceptor>) -> Self {
            let inner = Arc::new(inner);
            let inner = _Inner(inner, Some(interceptor.into()));
            Self { inner }
        }
    }
    impl<T, B> Service<http::Request<B>> for AdGroupBidModifierServiceServer<T>
    where
        T: AdGroupBidModifierService,
        B: HttpBody + Send + Sync + 'static,
        B::Error: Into<StdError> + Send + 'static,
    {
        type Response = http::Response<tonic::body::BoxBody>;
        type Error = Never;
        type Future = BoxFuture<Self::Response, Self::Error>;
        fn poll_ready(&mut self, _cx: &mut Context<'_>) -> Poll<Result<(), Self::Error>> {
            Poll::Ready(Ok(()))
        }
        fn call(&mut self, req: http::Request<B>) -> Self::Future {
            let inner = self.inner.clone();
            match req . uri ( ) . path ( ) { "/google.ads.googleads.v1.services.AdGroupBidModifierService/GetAdGroupBidModifier" => { # [ allow ( non_camel_case_types ) ] struct GetAdGroupBidModifierSvc < T : AdGroupBidModifierService > ( pub Arc < T > ) ; impl < T : AdGroupBidModifierService > tonic :: server :: UnaryService < super :: GetAdGroupBidModifierRequest > for GetAdGroupBidModifierSvc < T > { type Response = super :: super :: resources :: AdGroupBidModifier ; type Future = BoxFuture < tonic :: Response < Self :: Response > , tonic :: Status > ; fn call ( & mut self , request : tonic :: Request < super :: GetAdGroupBidModifierRequest > ) -> Self :: Future { let inner = self . 0 . clone ( ) ; let fut = async move { inner . get_ad_group_bid_modifier ( request ) . await } ; Box :: pin ( fut ) } } let inner = self . inner . clone ( ) ; let fut = async move { let interceptor = inner . 1 . clone ( ) ; let inner = inner . 0 ; let method = GetAdGroupBidModifierSvc ( inner ) ; let codec = tonic :: codec :: ProstCodec :: default ( ) ; let mut grpc = if let Some ( interceptor ) = interceptor { tonic :: server :: Grpc :: with_interceptor ( codec , interceptor ) } else { tonic :: server :: Grpc :: new ( codec ) } ; let res = grpc . unary ( method , req ) . await ; Ok ( res ) } ; Box :: pin ( fut ) } "/google.ads.googleads.v1.services.AdGroupBidModifierService/MutateAdGroupBidModifiers" => { # [ allow ( non_camel_case_types ) ] struct MutateAdGroupBidModifiersSvc < T : AdGroupBidModifierService > ( pub Arc < T > ) ; impl < T : AdGroupBidModifierService > tonic :: server :: UnaryService < super :: MutateAdGroupBidModifiersRequest > for MutateAdGroupBidModifiersSvc < T > { type Response = super :: MutateAdGroupBidModifiersResponse ; type Future = BoxFuture < tonic :: Response < Self :: Response > , tonic :: Status > ; fn call ( & mut self , request : tonic :: Request < super :: MutateAdGroupBidModifiersRequest > ) -> Self :: Future { let inner = self . 0 . clone ( ) ; let fut = async move { inner . mutate_ad_group_bid_modifiers ( request ) . await } ; Box :: pin ( fut ) } } let inner = self . inner . clone ( ) ; let fut = async move { let interceptor = inner . 1 . clone ( ) ; let inner = inner . 0 ; let method = MutateAdGroupBidModifiersSvc ( inner ) ; let codec = tonic :: codec :: ProstCodec :: default ( ) ; let mut grpc = if let Some ( interceptor ) = interceptor { tonic :: server :: Grpc :: with_interceptor ( codec , interceptor ) } else { tonic :: server :: Grpc :: new ( codec ) } ; let res = grpc . unary ( method , req ) . await ; Ok ( res ) } ; Box :: pin ( fut ) } _ => Box :: pin ( async move { Ok ( http :: Response :: builder ( ) . status ( 200 ) . header ( "grpc-status" , "12" ) . body ( tonic :: body :: BoxBody :: empty ( ) ) . unwrap ( ) ) } ) , }
        }
    }
    impl<T: AdGroupBidModifierService> Clone for AdGroupBidModifierServiceServer<T> {
        fn clone(&self) -> Self {
            let inner = self.inner.clone();
            Self { inner }
        }
    }
    impl<T: AdGroupBidModifierService> Clone for _Inner<T> {
        fn clone(&self) -> Self {
            Self(self.0.clone(), self.1.clone())
        }
    }
    impl<T: std::fmt::Debug> std::fmt::Debug for _Inner<T> {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
            write!(f, "{:?}", self.0)
        }
    }
    impl<T: AdGroupBidModifierService> tonic::transport::NamedService
        for AdGroupBidModifierServiceServer<T>
    {
        const NAME: &'static str = "google.ads.googleads.v1.services.AdGroupBidModifierService";
    }
}
/// Request message for
/// [AdGroupCriterionLabelService.GetAdGroupCriterionLabel][google.ads.googleads.v1.services.AdGroupCriterionLabelService.GetAdGroupCriterionLabel].
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GetAdGroupCriterionLabelRequest {
    /// Required. The resource name of the ad group criterion label to fetch.
    #[prost(string, tag = "1")]
    pub resource_name: std::string::String,
}
/// Request message for
/// [AdGroupCriterionLabelService.MutateAdGroupCriterionLabels][google.ads.googleads.v1.services.AdGroupCriterionLabelService.MutateAdGroupCriterionLabels].
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct MutateAdGroupCriterionLabelsRequest {
    /// Required. ID of the customer whose ad group criterion labels are being modified.
    #[prost(string, tag = "1")]
    pub customer_id: std::string::String,
    /// Required. The list of operations to perform on ad group criterion labels.
    #[prost(message, repeated, tag = "2")]
    pub operations: ::std::vec::Vec<AdGroupCriterionLabelOperation>,
    /// If true, successful operations will be carried out and invalid
    /// operations will return errors. If false, all operations will be carried
    /// out in one transaction if and only if they are all valid.
    /// Default is false.
    #[prost(bool, tag = "3")]
    pub partial_failure: bool,
    /// If true, the request is validated but not executed. Only errors are
    /// returned, not results.
    #[prost(bool, tag = "4")]
    pub validate_only: bool,
}
/// A single operation (create, remove) on an ad group criterion label.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct AdGroupCriterionLabelOperation {
    /// The mutate operation.
    #[prost(oneof = "ad_group_criterion_label_operation::Operation", tags = "1, 2")]
    pub operation: ::std::option::Option<ad_group_criterion_label_operation::Operation>,
}
pub mod ad_group_criterion_label_operation {
    /// The mutate operation.
    #[derive(Clone, PartialEq, ::prost::Oneof)]
    pub enum Operation {
        /// Create operation: No resource name is expected for the new ad group
        /// label.
        #[prost(message, tag = "1")]
        Create(super::super::resources::AdGroupCriterionLabel),
        /// Remove operation: A resource name for the ad group criterion label
        /// being removed, in this format:
        ///
        /// `customers/{customer_id}/adGroupCriterionLabels/{ad_group_id}~{criterion_id}~{label_id}`
        #[prost(string, tag = "2")]
        Remove(std::string::String),
    }
}
/// Response message for an ad group criterion labels mutate.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct MutateAdGroupCriterionLabelsResponse {
    /// Errors that pertain to operation failures in the partial failure mode.
    /// Returned only when partial_failure = true and all errors occur inside the
    /// operations. If any errors occur outside the operations (e.g. auth errors),
    /// we return an RPC level error.
    #[prost(message, optional, tag = "3")]
    pub partial_failure_error: ::std::option::Option<super::super::super::super::rpc::Status>,
    /// All results for the mutate.
    #[prost(message, repeated, tag = "2")]
    pub results: ::std::vec::Vec<MutateAdGroupCriterionLabelResult>,
}
/// The result for an ad group criterion label mutate.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct MutateAdGroupCriterionLabelResult {
    /// Returned for successful operations.
    #[prost(string, tag = "1")]
    pub resource_name: std::string::String,
}
#[doc = r" Generated client implementations."]
pub mod ad_group_criterion_label_service_client {
    #![allow(unused_variables, dead_code, missing_docs)]
    use tonic::codegen::*;
    #[doc = " Service to manage labels on ad group criteria."]
    pub struct AdGroupCriterionLabelServiceClient<T> {
        inner: tonic::client::Grpc<T>,
    }
    impl AdGroupCriterionLabelServiceClient<tonic::transport::Channel> {
        #[doc = r" Attempt to create a new client by connecting to a given endpoint."]
        pub async fn connect<D>(dst: D) -> Result<Self, tonic::transport::Error>
        where
            D: std::convert::TryInto<tonic::transport::Endpoint>,
            D::Error: Into<StdError>,
        {
            let conn = tonic::transport::Endpoint::new(dst)?.connect().await?;
            Ok(Self::new(conn))
        }
    }
    impl<T> AdGroupCriterionLabelServiceClient<T>
    where
        T: tonic::client::GrpcService<tonic::body::BoxBody>,
        T::ResponseBody: Body + HttpBody + Send + 'static,
        T::Error: Into<StdError>,
        <T::ResponseBody as HttpBody>::Error: Into<StdError> + Send,
    {
        pub fn new(inner: T) -> Self {
            let inner = tonic::client::Grpc::new(inner);
            Self { inner }
        }
        pub fn with_interceptor(inner: T, interceptor: impl Into<tonic::Interceptor>) -> Self {
            let inner = tonic::client::Grpc::with_interceptor(inner, interceptor);
            Self { inner }
        }
        #[doc = " Returns the requested ad group criterion label in full detail."]
        pub async fn get_ad_group_criterion_label(
            &mut self,
            request: impl tonic::IntoRequest<super::GetAdGroupCriterionLabelRequest>,
        ) -> Result<tonic::Response<super::super::resources::AdGroupCriterionLabel>, tonic::Status>
        {
            self.inner.ready().await.map_err(|e| {
                tonic::Status::new(
                    tonic::Code::Unknown,
                    format!("Service was not ready: {}", e.into()),
                )
            })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http :: uri :: PathAndQuery :: from_static ( "/google.ads.googleads.v1.services.AdGroupCriterionLabelService/GetAdGroupCriterionLabel" ) ;
            self.inner.unary(request.into_request(), path, codec).await
        }
        #[doc = " Creates and removes ad group criterion labels."]
        #[doc = " Operation statuses are returned."]
        pub async fn mutate_ad_group_criterion_labels(
            &mut self,
            request: impl tonic::IntoRequest<super::MutateAdGroupCriterionLabelsRequest>,
        ) -> Result<tonic::Response<super::MutateAdGroupCriterionLabelsResponse>, tonic::Status>
        {
            self.inner.ready().await.map_err(|e| {
                tonic::Status::new(
                    tonic::Code::Unknown,
                    format!("Service was not ready: {}", e.into()),
                )
            })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http :: uri :: PathAndQuery :: from_static ( "/google.ads.googleads.v1.services.AdGroupCriterionLabelService/MutateAdGroupCriterionLabels" ) ;
            self.inner.unary(request.into_request(), path, codec).await
        }
    }
    impl<T: Clone> Clone for AdGroupCriterionLabelServiceClient<T> {
        fn clone(&self) -> Self {
            Self {
                inner: self.inner.clone(),
            }
        }
    }
    impl<T> std::fmt::Debug for AdGroupCriterionLabelServiceClient<T> {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
            write!(f, "AdGroupCriterionLabelServiceClient {{ ... }}")
        }
    }
}
#[doc = r" Generated server implementations."]
pub mod ad_group_criterion_label_service_server {
    #![allow(unused_variables, dead_code, missing_docs)]
    use tonic::codegen::*;
    #[doc = "Generated trait containing gRPC methods that should be implemented for use with AdGroupCriterionLabelServiceServer."]
    #[async_trait]
    pub trait AdGroupCriterionLabelService: Send + Sync + 'static {
        #[doc = " Returns the requested ad group criterion label in full detail."]
        async fn get_ad_group_criterion_label(
            &self,
            request: tonic::Request<super::GetAdGroupCriterionLabelRequest>,
        ) -> Result<tonic::Response<super::super::resources::AdGroupCriterionLabel>, tonic::Status>;
        #[doc = " Creates and removes ad group criterion labels."]
        #[doc = " Operation statuses are returned."]
        async fn mutate_ad_group_criterion_labels(
            &self,
            request: tonic::Request<super::MutateAdGroupCriterionLabelsRequest>,
        ) -> Result<tonic::Response<super::MutateAdGroupCriterionLabelsResponse>, tonic::Status>;
    }
    #[doc = " Service to manage labels on ad group criteria."]
    #[derive(Debug)]
    #[doc(hidden)]
    pub struct AdGroupCriterionLabelServiceServer<T: AdGroupCriterionLabelService> {
        inner: _Inner<T>,
    }
    struct _Inner<T>(Arc<T>, Option<tonic::Interceptor>);
    impl<T: AdGroupCriterionLabelService> AdGroupCriterionLabelServiceServer<T> {
        pub fn new(inner: T) -> Self {
            let inner = Arc::new(inner);
            let inner = _Inner(inner, None);
            Self { inner }
        }
        pub fn with_interceptor(inner: T, interceptor: impl Into<tonic::Interceptor>) -> Self {
            let inner = Arc::new(inner);
            let inner = _Inner(inner, Some(interceptor.into()));
            Self { inner }
        }
    }
    impl<T, B> Service<http::Request<B>> for AdGroupCriterionLabelServiceServer<T>
    where
        T: AdGroupCriterionLabelService,
        B: HttpBody + Send + Sync + 'static,
        B::Error: Into<StdError> + Send + 'static,
    {
        type Response = http::Response<tonic::body::BoxBody>;
        type Error = Never;
        type Future = BoxFuture<Self::Response, Self::Error>;
        fn poll_ready(&mut self, _cx: &mut Context<'_>) -> Poll<Result<(), Self::Error>> {
            Poll::Ready(Ok(()))
        }
        fn call(&mut self, req: http::Request<B>) -> Self::Future {
            let inner = self.inner.clone();
            match req . uri ( ) . path ( ) { "/google.ads.googleads.v1.services.AdGroupCriterionLabelService/GetAdGroupCriterionLabel" => { # [ allow ( non_camel_case_types ) ] struct GetAdGroupCriterionLabelSvc < T : AdGroupCriterionLabelService > ( pub Arc < T > ) ; impl < T : AdGroupCriterionLabelService > tonic :: server :: UnaryService < super :: GetAdGroupCriterionLabelRequest > for GetAdGroupCriterionLabelSvc < T > { type Response = super :: super :: resources :: AdGroupCriterionLabel ; type Future = BoxFuture < tonic :: Response < Self :: Response > , tonic :: Status > ; fn call ( & mut self , request : tonic :: Request < super :: GetAdGroupCriterionLabelRequest > ) -> Self :: Future { let inner = self . 0 . clone ( ) ; let fut = async move { inner . get_ad_group_criterion_label ( request ) . await } ; Box :: pin ( fut ) } } let inner = self . inner . clone ( ) ; let fut = async move { let interceptor = inner . 1 . clone ( ) ; let inner = inner . 0 ; let method = GetAdGroupCriterionLabelSvc ( inner ) ; let codec = tonic :: codec :: ProstCodec :: default ( ) ; let mut grpc = if let Some ( interceptor ) = interceptor { tonic :: server :: Grpc :: with_interceptor ( codec , interceptor ) } else { tonic :: server :: Grpc :: new ( codec ) } ; let res = grpc . unary ( method , req ) . await ; Ok ( res ) } ; Box :: pin ( fut ) } "/google.ads.googleads.v1.services.AdGroupCriterionLabelService/MutateAdGroupCriterionLabels" => { # [ allow ( non_camel_case_types ) ] struct MutateAdGroupCriterionLabelsSvc < T : AdGroupCriterionLabelService > ( pub Arc < T > ) ; impl < T : AdGroupCriterionLabelService > tonic :: server :: UnaryService < super :: MutateAdGroupCriterionLabelsRequest > for MutateAdGroupCriterionLabelsSvc < T > { type Response = super :: MutateAdGroupCriterionLabelsResponse ; type Future = BoxFuture < tonic :: Response < Self :: Response > , tonic :: Status > ; fn call ( & mut self , request : tonic :: Request < super :: MutateAdGroupCriterionLabelsRequest > ) -> Self :: Future { let inner = self . 0 . clone ( ) ; let fut = async move { inner . mutate_ad_group_criterion_labels ( request ) . await } ; Box :: pin ( fut ) } } let inner = self . inner . clone ( ) ; let fut = async move { let interceptor = inner . 1 . clone ( ) ; let inner = inner . 0 ; let method = MutateAdGroupCriterionLabelsSvc ( inner ) ; let codec = tonic :: codec :: ProstCodec :: default ( ) ; let mut grpc = if let Some ( interceptor ) = interceptor { tonic :: server :: Grpc :: with_interceptor ( codec , interceptor ) } else { tonic :: server :: Grpc :: new ( codec ) } ; let res = grpc . unary ( method , req ) . await ; Ok ( res ) } ; Box :: pin ( fut ) } _ => Box :: pin ( async move { Ok ( http :: Response :: builder ( ) . status ( 200 ) . header ( "grpc-status" , "12" ) . body ( tonic :: body :: BoxBody :: empty ( ) ) . unwrap ( ) ) } ) , }
        }
    }
    impl<T: AdGroupCriterionLabelService> Clone for AdGroupCriterionLabelServiceServer<T> {
        fn clone(&self) -> Self {
            let inner = self.inner.clone();
            Self { inner }
        }
    }
    impl<T: AdGroupCriterionLabelService> Clone for _Inner<T> {
        fn clone(&self) -> Self {
            Self(self.0.clone(), self.1.clone())
        }
    }
    impl<T: std::fmt::Debug> std::fmt::Debug for _Inner<T> {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
            write!(f, "{:?}", self.0)
        }
    }
    impl<T: AdGroupCriterionLabelService> tonic::transport::NamedService
        for AdGroupCriterionLabelServiceServer<T>
    {
        const NAME: &'static str = "google.ads.googleads.v1.services.AdGroupCriterionLabelService";
    }
}
/// Request message for [AdGroupCriterionService.GetAdGroupCriterion][google.ads.googleads.v1.services.AdGroupCriterionService.GetAdGroupCriterion].
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GetAdGroupCriterionRequest {
    /// Required. The resource name of the criterion to fetch.
    #[prost(string, tag = "1")]
    pub resource_name: std::string::String,
}
/// Request message for [AdGroupCriterionService.MutateAdGroupCriteria][google.ads.googleads.v1.services.AdGroupCriterionService.MutateAdGroupCriteria].
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct MutateAdGroupCriteriaRequest {
    /// Required. ID of the customer whose criteria are being modified.
    #[prost(string, tag = "1")]
    pub customer_id: std::string::String,
    /// Required. The list of operations to perform on individual criteria.
    #[prost(message, repeated, tag = "2")]
    pub operations: ::std::vec::Vec<AdGroupCriterionOperation>,
    /// If true, successful operations will be carried out and invalid
    /// operations will return errors. If false, all operations will be carried
    /// out in one transaction if and only if they are all valid.
    /// Default is false.
    #[prost(bool, tag = "3")]
    pub partial_failure: bool,
    /// If true, the request is validated but not executed. Only errors are
    /// returned, not results.
    #[prost(bool, tag = "4")]
    pub validate_only: bool,
}
/// A single operation (create, remove, update) on an ad group criterion.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct AdGroupCriterionOperation {
    /// FieldMask that determines which resource fields are modified in an update.
    #[prost(message, optional, tag = "4")]
    pub update_mask: ::std::option::Option<::prost_types::FieldMask>,
    /// The list of policy violation keys that should not cause a
    /// PolicyViolationError to be reported. Not all policy violations are
    /// exemptable, please refer to the is_exemptible field in the returned
    /// PolicyViolationError.
    ///
    /// Resources violating these polices will be saved, but will not be eligible
    /// to serve. They may begin serving at a later time due to a change in
    /// policies, re-review of the resource, or a change in advertiser
    /// certificates.
    #[prost(message, repeated, tag = "5")]
    pub exempt_policy_violation_keys: ::std::vec::Vec<super::common::PolicyViolationKey>,
    /// The mutate operation.
    #[prost(oneof = "ad_group_criterion_operation::Operation", tags = "1, 2, 3")]
    pub operation: ::std::option::Option<ad_group_criterion_operation::Operation>,
}
pub mod ad_group_criterion_operation {
    /// The mutate operation.
    #[derive(Clone, PartialEq, ::prost::Oneof)]
    pub enum Operation {
        /// Create operation: No resource name is expected for the new criterion.
        #[prost(message, tag = "1")]
        Create(super::super::resources::AdGroupCriterion),
        /// Update operation: The criterion is expected to have a valid resource
        /// name.
        #[prost(message, tag = "2")]
        Update(super::super::resources::AdGroupCriterion),
        /// Remove operation: A resource name for the removed criterion is expected,
        /// in this format:
        ///
        /// `customers/{customer_id}/adGroupCriteria/{ad_group_id}~{criterion_id}`
        #[prost(string, tag = "3")]
        Remove(std::string::String),
    }
}
/// Response message for an ad group criterion mutate.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct MutateAdGroupCriteriaResponse {
    /// Errors that pertain to operation failures in the partial failure mode.
    /// Returned only when partial_failure = true and all errors occur inside the
    /// operations. If any errors occur outside the operations (e.g. auth errors),
    /// we return an RPC level error.
    #[prost(message, optional, tag = "3")]
    pub partial_failure_error: ::std::option::Option<super::super::super::super::rpc::Status>,
    /// All results for the mutate.
    #[prost(message, repeated, tag = "2")]
    pub results: ::std::vec::Vec<MutateAdGroupCriterionResult>,
}
/// The result for the criterion mutate.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct MutateAdGroupCriterionResult {
    /// Returned for successful operations.
    #[prost(string, tag = "1")]
    pub resource_name: std::string::String,
}
#[doc = r" Generated client implementations."]
pub mod ad_group_criterion_service_client {
    #![allow(unused_variables, dead_code, missing_docs)]
    use tonic::codegen::*;
    #[doc = " Service to manage ad group criteria."]
    pub struct AdGroupCriterionServiceClient<T> {
        inner: tonic::client::Grpc<T>,
    }
    impl AdGroupCriterionServiceClient<tonic::transport::Channel> {
        #[doc = r" Attempt to create a new client by connecting to a given endpoint."]
        pub async fn connect<D>(dst: D) -> Result<Self, tonic::transport::Error>
        where
            D: std::convert::TryInto<tonic::transport::Endpoint>,
            D::Error: Into<StdError>,
        {
            let conn = tonic::transport::Endpoint::new(dst)?.connect().await?;
            Ok(Self::new(conn))
        }
    }
    impl<T> AdGroupCriterionServiceClient<T>
    where
        T: tonic::client::GrpcService<tonic::body::BoxBody>,
        T::ResponseBody: Body + HttpBody + Send + 'static,
        T::Error: Into<StdError>,
        <T::ResponseBody as HttpBody>::Error: Into<StdError> + Send,
    {
        pub fn new(inner: T) -> Self {
            let inner = tonic::client::Grpc::new(inner);
            Self { inner }
        }
        pub fn with_interceptor(inner: T, interceptor: impl Into<tonic::Interceptor>) -> Self {
            let inner = tonic::client::Grpc::with_interceptor(inner, interceptor);
            Self { inner }
        }
        #[doc = " Returns the requested criterion in full detail."]
        pub async fn get_ad_group_criterion(
            &mut self,
            request: impl tonic::IntoRequest<super::GetAdGroupCriterionRequest>,
        ) -> Result<tonic::Response<super::super::resources::AdGroupCriterion>, tonic::Status>
        {
            self.inner.ready().await.map_err(|e| {
                tonic::Status::new(
                    tonic::Code::Unknown,
                    format!("Service was not ready: {}", e.into()),
                )
            })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.ads.googleads.v1.services.AdGroupCriterionService/GetAdGroupCriterion",
            );
            self.inner.unary(request.into_request(), path, codec).await
        }
        #[doc = " Creates, updates, or removes criteria. Operation statuses are returned."]
        pub async fn mutate_ad_group_criteria(
            &mut self,
            request: impl tonic::IntoRequest<super::MutateAdGroupCriteriaRequest>,
        ) -> Result<tonic::Response<super::MutateAdGroupCriteriaResponse>, tonic::Status> {
            self.inner.ready().await.map_err(|e| {
                tonic::Status::new(
                    tonic::Code::Unknown,
                    format!("Service was not ready: {}", e.into()),
                )
            })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.ads.googleads.v1.services.AdGroupCriterionService/MutateAdGroupCriteria",
            );
            self.inner.unary(request.into_request(), path, codec).await
        }
    }
    impl<T: Clone> Clone for AdGroupCriterionServiceClient<T> {
        fn clone(&self) -> Self {
            Self {
                inner: self.inner.clone(),
            }
        }
    }
    impl<T> std::fmt::Debug for AdGroupCriterionServiceClient<T> {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
            write!(f, "AdGroupCriterionServiceClient {{ ... }}")
        }
    }
}
#[doc = r" Generated server implementations."]
pub mod ad_group_criterion_service_server {
    #![allow(unused_variables, dead_code, missing_docs)]
    use tonic::codegen::*;
    #[doc = "Generated trait containing gRPC methods that should be implemented for use with AdGroupCriterionServiceServer."]
    #[async_trait]
    pub trait AdGroupCriterionService: Send + Sync + 'static {
        #[doc = " Returns the requested criterion in full detail."]
        async fn get_ad_group_criterion(
            &self,
            request: tonic::Request<super::GetAdGroupCriterionRequest>,
        ) -> Result<tonic::Response<super::super::resources::AdGroupCriterion>, tonic::Status>;
        #[doc = " Creates, updates, or removes criteria. Operation statuses are returned."]
        async fn mutate_ad_group_criteria(
            &self,
            request: tonic::Request<super::MutateAdGroupCriteriaRequest>,
        ) -> Result<tonic::Response<super::MutateAdGroupCriteriaResponse>, tonic::Status>;
    }
    #[doc = " Service to manage ad group criteria."]
    #[derive(Debug)]
    #[doc(hidden)]
    pub struct AdGroupCriterionServiceServer<T: AdGroupCriterionService> {
        inner: _Inner<T>,
    }
    struct _Inner<T>(Arc<T>, Option<tonic::Interceptor>);
    impl<T: AdGroupCriterionService> AdGroupCriterionServiceServer<T> {
        pub fn new(inner: T) -> Self {
            let inner = Arc::new(inner);
            let inner = _Inner(inner, None);
            Self { inner }
        }
        pub fn with_interceptor(inner: T, interceptor: impl Into<tonic::Interceptor>) -> Self {
            let inner = Arc::new(inner);
            let inner = _Inner(inner, Some(interceptor.into()));
            Self { inner }
        }
    }
    impl<T, B> Service<http::Request<B>> for AdGroupCriterionServiceServer<T>
    where
        T: AdGroupCriterionService,
        B: HttpBody + Send + Sync + 'static,
        B::Error: Into<StdError> + Send + 'static,
    {
        type Response = http::Response<tonic::body::BoxBody>;
        type Error = Never;
        type Future = BoxFuture<Self::Response, Self::Error>;
        fn poll_ready(&mut self, _cx: &mut Context<'_>) -> Poll<Result<(), Self::Error>> {
            Poll::Ready(Ok(()))
        }
        fn call(&mut self, req: http::Request<B>) -> Self::Future {
            let inner = self.inner.clone();
            match req . uri ( ) . path ( ) { "/google.ads.googleads.v1.services.AdGroupCriterionService/GetAdGroupCriterion" => { # [ allow ( non_camel_case_types ) ] struct GetAdGroupCriterionSvc < T : AdGroupCriterionService > ( pub Arc < T > ) ; impl < T : AdGroupCriterionService > tonic :: server :: UnaryService < super :: GetAdGroupCriterionRequest > for GetAdGroupCriterionSvc < T > { type Response = super :: super :: resources :: AdGroupCriterion ; type Future = BoxFuture < tonic :: Response < Self :: Response > , tonic :: Status > ; fn call ( & mut self , request : tonic :: Request < super :: GetAdGroupCriterionRequest > ) -> Self :: Future { let inner = self . 0 . clone ( ) ; let fut = async move { inner . get_ad_group_criterion ( request ) . await } ; Box :: pin ( fut ) } } let inner = self . inner . clone ( ) ; let fut = async move { let interceptor = inner . 1 . clone ( ) ; let inner = inner . 0 ; let method = GetAdGroupCriterionSvc ( inner ) ; let codec = tonic :: codec :: ProstCodec :: default ( ) ; let mut grpc = if let Some ( interceptor ) = interceptor { tonic :: server :: Grpc :: with_interceptor ( codec , interceptor ) } else { tonic :: server :: Grpc :: new ( codec ) } ; let res = grpc . unary ( method , req ) . await ; Ok ( res ) } ; Box :: pin ( fut ) } "/google.ads.googleads.v1.services.AdGroupCriterionService/MutateAdGroupCriteria" => { # [ allow ( non_camel_case_types ) ] struct MutateAdGroupCriteriaSvc < T : AdGroupCriterionService > ( pub Arc < T > ) ; impl < T : AdGroupCriterionService > tonic :: server :: UnaryService < super :: MutateAdGroupCriteriaRequest > for MutateAdGroupCriteriaSvc < T > { type Response = super :: MutateAdGroupCriteriaResponse ; type Future = BoxFuture < tonic :: Response < Self :: Response > , tonic :: Status > ; fn call ( & mut self , request : tonic :: Request < super :: MutateAdGroupCriteriaRequest > ) -> Self :: Future { let inner = self . 0 . clone ( ) ; let fut = async move { inner . mutate_ad_group_criteria ( request ) . await } ; Box :: pin ( fut ) } } let inner = self . inner . clone ( ) ; let fut = async move { let interceptor = inner . 1 . clone ( ) ; let inner = inner . 0 ; let method = MutateAdGroupCriteriaSvc ( inner ) ; let codec = tonic :: codec :: ProstCodec :: default ( ) ; let mut grpc = if let Some ( interceptor ) = interceptor { tonic :: server :: Grpc :: with_interceptor ( codec , interceptor ) } else { tonic :: server :: Grpc :: new ( codec ) } ; let res = grpc . unary ( method , req ) . await ; Ok ( res ) } ; Box :: pin ( fut ) } _ => Box :: pin ( async move { Ok ( http :: Response :: builder ( ) . status ( 200 ) . header ( "grpc-status" , "12" ) . body ( tonic :: body :: BoxBody :: empty ( ) ) . unwrap ( ) ) } ) , }
        }
    }
    impl<T: AdGroupCriterionService> Clone for AdGroupCriterionServiceServer<T> {
        fn clone(&self) -> Self {
            let inner = self.inner.clone();
            Self { inner }
        }
    }
    impl<T: AdGroupCriterionService> Clone for _Inner<T> {
        fn clone(&self) -> Self {
            Self(self.0.clone(), self.1.clone())
        }
    }
    impl<T: std::fmt::Debug> std::fmt::Debug for _Inner<T> {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
            write!(f, "{:?}", self.0)
        }
    }
    impl<T: AdGroupCriterionService> tonic::transport::NamedService
        for AdGroupCriterionServiceServer<T>
    {
        const NAME: &'static str = "google.ads.googleads.v1.services.AdGroupCriterionService";
    }
}
/// Request message for
/// [AdGroupCriterionSimulationService.GetAdGroupCriterionSimulation][google.ads.googleads.v1.services.AdGroupCriterionSimulationService.GetAdGroupCriterionSimulation].
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GetAdGroupCriterionSimulationRequest {
    /// Required. The resource name of the ad group criterion simulation to fetch.
    #[prost(string, tag = "1")]
    pub resource_name: std::string::String,
}
#[doc = r" Generated client implementations."]
pub mod ad_group_criterion_simulation_service_client {
    #![allow(unused_variables, dead_code, missing_docs)]
    use tonic::codegen::*;
    #[doc = " Service to fetch ad group criterion simulations."]
    pub struct AdGroupCriterionSimulationServiceClient<T> {
        inner: tonic::client::Grpc<T>,
    }
    impl AdGroupCriterionSimulationServiceClient<tonic::transport::Channel> {
        #[doc = r" Attempt to create a new client by connecting to a given endpoint."]
        pub async fn connect<D>(dst: D) -> Result<Self, tonic::transport::Error>
        where
            D: std::convert::TryInto<tonic::transport::Endpoint>,
            D::Error: Into<StdError>,
        {
            let conn = tonic::transport::Endpoint::new(dst)?.connect().await?;
            Ok(Self::new(conn))
        }
    }
    impl<T> AdGroupCriterionSimulationServiceClient<T>
    where
        T: tonic::client::GrpcService<tonic::body::BoxBody>,
        T::ResponseBody: Body + HttpBody + Send + 'static,
        T::Error: Into<StdError>,
        <T::ResponseBody as HttpBody>::Error: Into<StdError> + Send,
    {
        pub fn new(inner: T) -> Self {
            let inner = tonic::client::Grpc::new(inner);
            Self { inner }
        }
        pub fn with_interceptor(inner: T, interceptor: impl Into<tonic::Interceptor>) -> Self {
            let inner = tonic::client::Grpc::with_interceptor(inner, interceptor);
            Self { inner }
        }
        #[doc = " Returns the requested ad group criterion simulation in full detail."]
        pub async fn get_ad_group_criterion_simulation(
            &mut self,
            request: impl tonic::IntoRequest<super::GetAdGroupCriterionSimulationRequest>,
        ) -> Result<
            tonic::Response<super::super::resources::AdGroupCriterionSimulation>,
            tonic::Status,
        > {
            self.inner.ready().await.map_err(|e| {
                tonic::Status::new(
                    tonic::Code::Unknown,
                    format!("Service was not ready: {}", e.into()),
                )
            })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http :: uri :: PathAndQuery :: from_static ( "/google.ads.googleads.v1.services.AdGroupCriterionSimulationService/GetAdGroupCriterionSimulation" ) ;
            self.inner.unary(request.into_request(), path, codec).await
        }
    }
    impl<T: Clone> Clone for AdGroupCriterionSimulationServiceClient<T> {
        fn clone(&self) -> Self {
            Self {
                inner: self.inner.clone(),
            }
        }
    }
    impl<T> std::fmt::Debug for AdGroupCriterionSimulationServiceClient<T> {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
            write!(f, "AdGroupCriterionSimulationServiceClient {{ ... }}")
        }
    }
}
#[doc = r" Generated server implementations."]
pub mod ad_group_criterion_simulation_service_server {
    #![allow(unused_variables, dead_code, missing_docs)]
    use tonic::codegen::*;
    #[doc = "Generated trait containing gRPC methods that should be implemented for use with AdGroupCriterionSimulationServiceServer."]
    #[async_trait]
    pub trait AdGroupCriterionSimulationService: Send + Sync + 'static {
        #[doc = " Returns the requested ad group criterion simulation in full detail."]
        async fn get_ad_group_criterion_simulation(
            &self,
            request: tonic::Request<super::GetAdGroupCriterionSimulationRequest>,
        ) -> Result<
            tonic::Response<super::super::resources::AdGroupCriterionSimulation>,
            tonic::Status,
        >;
    }
    #[doc = " Service to fetch ad group criterion simulations."]
    #[derive(Debug)]
    #[doc(hidden)]
    pub struct AdGroupCriterionSimulationServiceServer<T: AdGroupCriterionSimulationService> {
        inner: _Inner<T>,
    }
    struct _Inner<T>(Arc<T>, Option<tonic::Interceptor>);
    impl<T: AdGroupCriterionSimulationService> AdGroupCriterionSimulationServiceServer<T> {
        pub fn new(inner: T) -> Self {
            let inner = Arc::new(inner);
            let inner = _Inner(inner, None);
            Self { inner }
        }
        pub fn with_interceptor(inner: T, interceptor: impl Into<tonic::Interceptor>) -> Self {
            let inner = Arc::new(inner);
            let inner = _Inner(inner, Some(interceptor.into()));
            Self { inner }
        }
    }
    impl<T, B> Service<http::Request<B>> for AdGroupCriterionSimulationServiceServer<T>
    where
        T: AdGroupCriterionSimulationService,
        B: HttpBody + Send + Sync + 'static,
        B::Error: Into<StdError> + Send + 'static,
    {
        type Response = http::Response<tonic::body::BoxBody>;
        type Error = Never;
        type Future = BoxFuture<Self::Response, Self::Error>;
        fn poll_ready(&mut self, _cx: &mut Context<'_>) -> Poll<Result<(), Self::Error>> {
            Poll::Ready(Ok(()))
        }
        fn call(&mut self, req: http::Request<B>) -> Self::Future {
            let inner = self.inner.clone();
            match req . uri ( ) . path ( ) { "/google.ads.googleads.v1.services.AdGroupCriterionSimulationService/GetAdGroupCriterionSimulation" => { # [ allow ( non_camel_case_types ) ] struct GetAdGroupCriterionSimulationSvc < T : AdGroupCriterionSimulationService > ( pub Arc < T > ) ; impl < T : AdGroupCriterionSimulationService > tonic :: server :: UnaryService < super :: GetAdGroupCriterionSimulationRequest > for GetAdGroupCriterionSimulationSvc < T > { type Response = super :: super :: resources :: AdGroupCriterionSimulation ; type Future = BoxFuture < tonic :: Response < Self :: Response > , tonic :: Status > ; fn call ( & mut self , request : tonic :: Request < super :: GetAdGroupCriterionSimulationRequest > ) -> Self :: Future { let inner = self . 0 . clone ( ) ; let fut = async move { inner . get_ad_group_criterion_simulation ( request ) . await } ; Box :: pin ( fut ) } } let inner = self . inner . clone ( ) ; let fut = async move { let interceptor = inner . 1 . clone ( ) ; let inner = inner . 0 ; let method = GetAdGroupCriterionSimulationSvc ( inner ) ; let codec = tonic :: codec :: ProstCodec :: default ( ) ; let mut grpc = if let Some ( interceptor ) = interceptor { tonic :: server :: Grpc :: with_interceptor ( codec , interceptor ) } else { tonic :: server :: Grpc :: new ( codec ) } ; let res = grpc . unary ( method , req ) . await ; Ok ( res ) } ; Box :: pin ( fut ) } _ => Box :: pin ( async move { Ok ( http :: Response :: builder ( ) . status ( 200 ) . header ( "grpc-status" , "12" ) . body ( tonic :: body :: BoxBody :: empty ( ) ) . unwrap ( ) ) } ) , }
        }
    }
    impl<T: AdGroupCriterionSimulationService> Clone for AdGroupCriterionSimulationServiceServer<T> {
        fn clone(&self) -> Self {
            let inner = self.inner.clone();
            Self { inner }
        }
    }
    impl<T: AdGroupCriterionSimulationService> Clone for _Inner<T> {
        fn clone(&self) -> Self {
            Self(self.0.clone(), self.1.clone())
        }
    }
    impl<T: std::fmt::Debug> std::fmt::Debug for _Inner<T> {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
            write!(f, "{:?}", self.0)
        }
    }
    impl<T: AdGroupCriterionSimulationService> tonic::transport::NamedService
        for AdGroupCriterionSimulationServiceServer<T>
    {
        const NAME: &'static str =
            "google.ads.googleads.v1.services.AdGroupCriterionSimulationService";
    }
}
/// Request message for
/// [AdGroupExtensionSettingService.GetAdGroupExtensionSetting][google.ads.googleads.v1.services.AdGroupExtensionSettingService.GetAdGroupExtensionSetting].
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GetAdGroupExtensionSettingRequest {
    /// Required. The resource name of the ad group extension setting to fetch.
    #[prost(string, tag = "1")]
    pub resource_name: std::string::String,
}
/// Request message for
/// [AdGroupExtensionSettingService.MutateAdGroupExtensionSettings][google.ads.googleads.v1.services.AdGroupExtensionSettingService.MutateAdGroupExtensionSettings].
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct MutateAdGroupExtensionSettingsRequest {
    /// Required. The ID of the customer whose ad group extension settings are being
    /// modified.
    #[prost(string, tag = "1")]
    pub customer_id: std::string::String,
    /// Required. The list of operations to perform on individual ad group extension
    /// settings.
    #[prost(message, repeated, tag = "2")]
    pub operations: ::std::vec::Vec<AdGroupExtensionSettingOperation>,
    /// If true, successful operations will be carried out and invalid
    /// operations will return errors. If false, all operations will be carried
    /// out in one transaction if and only if they are all valid.
    /// Default is false.
    #[prost(bool, tag = "3")]
    pub partial_failure: bool,
    /// If true, the request is validated but not executed. Only errors are
    /// returned, not results.
    #[prost(bool, tag = "4")]
    pub validate_only: bool,
}
/// A single operation (create, update, remove) on an ad group extension setting.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct AdGroupExtensionSettingOperation {
    /// FieldMask that determines which resource fields are modified in an update.
    #[prost(message, optional, tag = "4")]
    pub update_mask: ::std::option::Option<::prost_types::FieldMask>,
    /// The mutate operation.
    #[prost(
        oneof = "ad_group_extension_setting_operation::Operation",
        tags = "1, 2, 3"
    )]
    pub operation: ::std::option::Option<ad_group_extension_setting_operation::Operation>,
}
pub mod ad_group_extension_setting_operation {
    /// The mutate operation.
    #[derive(Clone, PartialEq, ::prost::Oneof)]
    pub enum Operation {
        /// Create operation: No resource name is expected for the new ad group
        /// extension setting.
        #[prost(message, tag = "1")]
        Create(super::super::resources::AdGroupExtensionSetting),
        /// Update operation: The ad group extension setting is expected to have a
        /// valid resource name.
        #[prost(message, tag = "2")]
        Update(super::super::resources::AdGroupExtensionSetting),
        /// Remove operation: A resource name for the removed ad group extension
        /// setting is expected, in this format:
        ///
        /// `customers/{customer_id}/adGroupExtensionSettings/{ad_group_id}~{extension_type}`
        #[prost(string, tag = "3")]
        Remove(std::string::String),
    }
}
/// Response message for an ad group extension setting mutate.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct MutateAdGroupExtensionSettingsResponse {
    /// Errors that pertain to operation failures in the partial failure mode.
    /// Returned only when partial_failure = true and all errors occur inside the
    /// operations. If any errors occur outside the operations (e.g. auth errors),
    /// we return an RPC level error.
    #[prost(message, optional, tag = "3")]
    pub partial_failure_error: ::std::option::Option<super::super::super::super::rpc::Status>,
    /// All results for the mutate.
    #[prost(message, repeated, tag = "2")]
    pub results: ::std::vec::Vec<MutateAdGroupExtensionSettingResult>,
}
/// The result for the ad group extension setting mutate.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct MutateAdGroupExtensionSettingResult {
    /// Returned for successful operations.
    #[prost(string, tag = "1")]
    pub resource_name: std::string::String,
}
#[doc = r" Generated client implementations."]
pub mod ad_group_extension_setting_service_client {
    #![allow(unused_variables, dead_code, missing_docs)]
    use tonic::codegen::*;
    #[doc = " Service to manage ad group extension settings."]
    pub struct AdGroupExtensionSettingServiceClient<T> {
        inner: tonic::client::Grpc<T>,
    }
    impl AdGroupExtensionSettingServiceClient<tonic::transport::Channel> {
        #[doc = r" Attempt to create a new client by connecting to a given endpoint."]
        pub async fn connect<D>(dst: D) -> Result<Self, tonic::transport::Error>
        where
            D: std::convert::TryInto<tonic::transport::Endpoint>,
            D::Error: Into<StdError>,
        {
            let conn = tonic::transport::Endpoint::new(dst)?.connect().await?;
            Ok(Self::new(conn))
        }
    }
    impl<T> AdGroupExtensionSettingServiceClient<T>
    where
        T: tonic::client::GrpcService<tonic::body::BoxBody>,
        T::ResponseBody: Body + HttpBody + Send + 'static,
        T::Error: Into<StdError>,
        <T::ResponseBody as HttpBody>::Error: Into<StdError> + Send,
    {
        pub fn new(inner: T) -> Self {
            let inner = tonic::client::Grpc::new(inner);
            Self { inner }
        }
        pub fn with_interceptor(inner: T, interceptor: impl Into<tonic::Interceptor>) -> Self {
            let inner = tonic::client::Grpc::with_interceptor(inner, interceptor);
            Self { inner }
        }
        #[doc = " Returns the requested ad group extension setting in full detail."]
        pub async fn get_ad_group_extension_setting(
            &mut self,
            request: impl tonic::IntoRequest<super::GetAdGroupExtensionSettingRequest>,
        ) -> Result<tonic::Response<super::super::resources::AdGroupExtensionSetting>, tonic::Status>
        {
            self.inner.ready().await.map_err(|e| {
                tonic::Status::new(
                    tonic::Code::Unknown,
                    format!("Service was not ready: {}", e.into()),
                )
            })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http :: uri :: PathAndQuery :: from_static ( "/google.ads.googleads.v1.services.AdGroupExtensionSettingService/GetAdGroupExtensionSetting" ) ;
            self.inner.unary(request.into_request(), path, codec).await
        }
        #[doc = " Creates, updates, or removes ad group extension settings. Operation"]
        #[doc = " statuses are returned."]
        pub async fn mutate_ad_group_extension_settings(
            &mut self,
            request: impl tonic::IntoRequest<super::MutateAdGroupExtensionSettingsRequest>,
        ) -> Result<tonic::Response<super::MutateAdGroupExtensionSettingsResponse>, tonic::Status>
        {
            self.inner.ready().await.map_err(|e| {
                tonic::Status::new(
                    tonic::Code::Unknown,
                    format!("Service was not ready: {}", e.into()),
                )
            })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http :: uri :: PathAndQuery :: from_static ( "/google.ads.googleads.v1.services.AdGroupExtensionSettingService/MutateAdGroupExtensionSettings" ) ;
            self.inner.unary(request.into_request(), path, codec).await
        }
    }
    impl<T: Clone> Clone for AdGroupExtensionSettingServiceClient<T> {
        fn clone(&self) -> Self {
            Self {
                inner: self.inner.clone(),
            }
        }
    }
    impl<T> std::fmt::Debug for AdGroupExtensionSettingServiceClient<T> {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
            write!(f, "AdGroupExtensionSettingServiceClient {{ ... }}")
        }
    }
}
#[doc = r" Generated server implementations."]
pub mod ad_group_extension_setting_service_server {
    #![allow(unused_variables, dead_code, missing_docs)]
    use tonic::codegen::*;
    #[doc = "Generated trait containing gRPC methods that should be implemented for use with AdGroupExtensionSettingServiceServer."]
    #[async_trait]
    pub trait AdGroupExtensionSettingService: Send + Sync + 'static {
        #[doc = " Returns the requested ad group extension setting in full detail."]
        async fn get_ad_group_extension_setting(
            &self,
            request: tonic::Request<super::GetAdGroupExtensionSettingRequest>,
        ) -> Result<tonic::Response<super::super::resources::AdGroupExtensionSetting>, tonic::Status>;
        #[doc = " Creates, updates, or removes ad group extension settings. Operation"]
        #[doc = " statuses are returned."]
        async fn mutate_ad_group_extension_settings(
            &self,
            request: tonic::Request<super::MutateAdGroupExtensionSettingsRequest>,
        ) -> Result<tonic::Response<super::MutateAdGroupExtensionSettingsResponse>, tonic::Status>;
    }
    #[doc = " Service to manage ad group extension settings."]
    #[derive(Debug)]
    #[doc(hidden)]
    pub struct AdGroupExtensionSettingServiceServer<T: AdGroupExtensionSettingService> {
        inner: _Inner<T>,
    }
    struct _Inner<T>(Arc<T>, Option<tonic::Interceptor>);
    impl<T: AdGroupExtensionSettingService> AdGroupExtensionSettingServiceServer<T> {
        pub fn new(inner: T) -> Self {
            let inner = Arc::new(inner);
            let inner = _Inner(inner, None);
            Self { inner }
        }
        pub fn with_interceptor(inner: T, interceptor: impl Into<tonic::Interceptor>) -> Self {
            let inner = Arc::new(inner);
            let inner = _Inner(inner, Some(interceptor.into()));
            Self { inner }
        }
    }
    impl<T, B> Service<http::Request<B>> for AdGroupExtensionSettingServiceServer<T>
    where
        T: AdGroupExtensionSettingService,
        B: HttpBody + Send + Sync + 'static,
        B::Error: Into<StdError> + Send + 'static,
    {
        type Response = http::Response<tonic::body::BoxBody>;
        type Error = Never;
        type Future = BoxFuture<Self::Response, Self::Error>;
        fn poll_ready(&mut self, _cx: &mut Context<'_>) -> Poll<Result<(), Self::Error>> {
            Poll::Ready(Ok(()))
        }
        fn call(&mut self, req: http::Request<B>) -> Self::Future {
            let inner = self.inner.clone();
            match req . uri ( ) . path ( ) { "/google.ads.googleads.v1.services.AdGroupExtensionSettingService/GetAdGroupExtensionSetting" => { # [ allow ( non_camel_case_types ) ] struct GetAdGroupExtensionSettingSvc < T : AdGroupExtensionSettingService > ( pub Arc < T > ) ; impl < T : AdGroupExtensionSettingService > tonic :: server :: UnaryService < super :: GetAdGroupExtensionSettingRequest > for GetAdGroupExtensionSettingSvc < T > { type Response = super :: super :: resources :: AdGroupExtensionSetting ; type Future = BoxFuture < tonic :: Response < Self :: Response > , tonic :: Status > ; fn call ( & mut self , request : tonic :: Request < super :: GetAdGroupExtensionSettingRequest > ) -> Self :: Future { let inner = self . 0 . clone ( ) ; let fut = async move { inner . get_ad_group_extension_setting ( request ) . await } ; Box :: pin ( fut ) } } let inner = self . inner . clone ( ) ; let fut = async move { let interceptor = inner . 1 . clone ( ) ; let inner = inner . 0 ; let method = GetAdGroupExtensionSettingSvc ( inner ) ; let codec = tonic :: codec :: ProstCodec :: default ( ) ; let mut grpc = if let Some ( interceptor ) = interceptor { tonic :: server :: Grpc :: with_interceptor ( codec , interceptor ) } else { tonic :: server :: Grpc :: new ( codec ) } ; let res = grpc . unary ( method , req ) . await ; Ok ( res ) } ; Box :: pin ( fut ) } "/google.ads.googleads.v1.services.AdGroupExtensionSettingService/MutateAdGroupExtensionSettings" => { # [ allow ( non_camel_case_types ) ] struct MutateAdGroupExtensionSettingsSvc < T : AdGroupExtensionSettingService > ( pub Arc < T > ) ; impl < T : AdGroupExtensionSettingService > tonic :: server :: UnaryService < super :: MutateAdGroupExtensionSettingsRequest > for MutateAdGroupExtensionSettingsSvc < T > { type Response = super :: MutateAdGroupExtensionSettingsResponse ; type Future = BoxFuture < tonic :: Response < Self :: Response > , tonic :: Status > ; fn call ( & mut self , request : tonic :: Request < super :: MutateAdGroupExtensionSettingsRequest > ) -> Self :: Future { let inner = self . 0 . clone ( ) ; let fut = async move { inner . mutate_ad_group_extension_settings ( request ) . await } ; Box :: pin ( fut ) } } let inner = self . inner . clone ( ) ; let fut = async move { let interceptor = inner . 1 . clone ( ) ; let inner = inner . 0 ; let method = MutateAdGroupExtensionSettingsSvc ( inner ) ; let codec = tonic :: codec :: ProstCodec :: default ( ) ; let mut grpc = if let Some ( interceptor ) = interceptor { tonic :: server :: Grpc :: with_interceptor ( codec , interceptor ) } else { tonic :: server :: Grpc :: new ( codec ) } ; let res = grpc . unary ( method , req ) . await ; Ok ( res ) } ; Box :: pin ( fut ) } _ => Box :: pin ( async move { Ok ( http :: Response :: builder ( ) . status ( 200 ) . header ( "grpc-status" , "12" ) . body ( tonic :: body :: BoxBody :: empty ( ) ) . unwrap ( ) ) } ) , }
        }
    }
    impl<T: AdGroupExtensionSettingService> Clone for AdGroupExtensionSettingServiceServer<T> {
        fn clone(&self) -> Self {
            let inner = self.inner.clone();
            Self { inner }
        }
    }
    impl<T: AdGroupExtensionSettingService> Clone for _Inner<T> {
        fn clone(&self) -> Self {
            Self(self.0.clone(), self.1.clone())
        }
    }
    impl<T: std::fmt::Debug> std::fmt::Debug for _Inner<T> {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
            write!(f, "{:?}", self.0)
        }
    }
    impl<T: AdGroupExtensionSettingService> tonic::transport::NamedService
        for AdGroupExtensionSettingServiceServer<T>
    {
        const NAME: &'static str =
            "google.ads.googleads.v1.services.AdGroupExtensionSettingService";
    }
}
/// Request message for [AdGroupFeedService.GetAdGroupFeed][google.ads.googleads.v1.services.AdGroupFeedService.GetAdGroupFeed].
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GetAdGroupFeedRequest {
    /// Required. The resource name of the ad group feed to fetch.
    #[prost(string, tag = "1")]
    pub resource_name: std::string::String,
}
/// Request message for [AdGroupFeedService.MutateAdGroupFeeds][google.ads.googleads.v1.services.AdGroupFeedService.MutateAdGroupFeeds].
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct MutateAdGroupFeedsRequest {
    /// Required. The ID of the customer whose ad group feeds are being modified.
    #[prost(string, tag = "1")]
    pub customer_id: std::string::String,
    /// Required. The list of operations to perform on individual ad group feeds.
    #[prost(message, repeated, tag = "2")]
    pub operations: ::std::vec::Vec<AdGroupFeedOperation>,
    /// If true, successful operations will be carried out and invalid
    /// operations will return errors. If false, all operations will be carried
    /// out in one transaction if and only if they are all valid.
    /// Default is false.
    #[prost(bool, tag = "3")]
    pub partial_failure: bool,
    /// If true, the request is validated but not executed. Only errors are
    /// returned, not results.
    #[prost(bool, tag = "4")]
    pub validate_only: bool,
}
/// A single operation (create, update, remove) on an ad group feed.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct AdGroupFeedOperation {
    /// FieldMask that determines which resource fields are modified in an update.
    #[prost(message, optional, tag = "4")]
    pub update_mask: ::std::option::Option<::prost_types::FieldMask>,
    /// The mutate operation.
    #[prost(oneof = "ad_group_feed_operation::Operation", tags = "1, 2, 3")]
    pub operation: ::std::option::Option<ad_group_feed_operation::Operation>,
}
pub mod ad_group_feed_operation {
    /// The mutate operation.
    #[derive(Clone, PartialEq, ::prost::Oneof)]
    pub enum Operation {
        /// Create operation: No resource name is expected for the new ad group feed.
        #[prost(message, tag = "1")]
        Create(super::super::resources::AdGroupFeed),
        /// Update operation: The ad group feed is expected to have a valid resource
        /// name.
        #[prost(message, tag = "2")]
        Update(super::super::resources::AdGroupFeed),
        /// Remove operation: A resource name for the removed ad group feed is
        /// expected, in this format:
        ///
        /// `customers/{customer_id}/adGroupFeeds/{ad_group_id}~{feed_id}`
        #[prost(string, tag = "3")]
        Remove(std::string::String),
    }
}
/// Response message for an ad group feed mutate.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct MutateAdGroupFeedsResponse {
    /// Errors that pertain to operation failures in the partial failure mode.
    /// Returned only when partial_failure = true and all errors occur inside the
    /// operations. If any errors occur outside the operations (e.g. auth errors),
    /// we return an RPC level error.
    #[prost(message, optional, tag = "3")]
    pub partial_failure_error: ::std::option::Option<super::super::super::super::rpc::Status>,
    /// All results for the mutate.
    #[prost(message, repeated, tag = "2")]
    pub results: ::std::vec::Vec<MutateAdGroupFeedResult>,
}
/// The result for the ad group feed mutate.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct MutateAdGroupFeedResult {
    /// Returned for successful operations.
    #[prost(string, tag = "1")]
    pub resource_name: std::string::String,
}
#[doc = r" Generated client implementations."]
pub mod ad_group_feed_service_client {
    #![allow(unused_variables, dead_code, missing_docs)]
    use tonic::codegen::*;
    #[doc = " Service to manage ad group feeds."]
    pub struct AdGroupFeedServiceClient<T> {
        inner: tonic::client::Grpc<T>,
    }
    impl AdGroupFeedServiceClient<tonic::transport::Channel> {
        #[doc = r" Attempt to create a new client by connecting to a given endpoint."]
        pub async fn connect<D>(dst: D) -> Result<Self, tonic::transport::Error>
        where
            D: std::convert::TryInto<tonic::transport::Endpoint>,
            D::Error: Into<StdError>,
        {
            let conn = tonic::transport::Endpoint::new(dst)?.connect().await?;
            Ok(Self::new(conn))
        }
    }
    impl<T> AdGroupFeedServiceClient<T>
    where
        T: tonic::client::GrpcService<tonic::body::BoxBody>,
        T::ResponseBody: Body + HttpBody + Send + 'static,
        T::Error: Into<StdError>,
        <T::ResponseBody as HttpBody>::Error: Into<StdError> + Send,
    {
        pub fn new(inner: T) -> Self {
            let inner = tonic::client::Grpc::new(inner);
            Self { inner }
        }
        pub fn with_interceptor(inner: T, interceptor: impl Into<tonic::Interceptor>) -> Self {
            let inner = tonic::client::Grpc::with_interceptor(inner, interceptor);
            Self { inner }
        }
        #[doc = " Returns the requested ad group feed in full detail."]
        pub async fn get_ad_group_feed(
            &mut self,
            request: impl tonic::IntoRequest<super::GetAdGroupFeedRequest>,
        ) -> Result<tonic::Response<super::super::resources::AdGroupFeed>, tonic::Status> {
            self.inner.ready().await.map_err(|e| {
                tonic::Status::new(
                    tonic::Code::Unknown,
                    format!("Service was not ready: {}", e.into()),
                )
            })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.ads.googleads.v1.services.AdGroupFeedService/GetAdGroupFeed",
            );
            self.inner.unary(request.into_request(), path, codec).await
        }
        #[doc = " Creates, updates, or removes ad group feeds. Operation statuses are"]
        #[doc = " returned."]
        pub async fn mutate_ad_group_feeds(
            &mut self,
            request: impl tonic::IntoRequest<super::MutateAdGroupFeedsRequest>,
        ) -> Result<tonic::Response<super::MutateAdGroupFeedsResponse>, tonic::Status> {
            self.inner.ready().await.map_err(|e| {
                tonic::Status::new(
                    tonic::Code::Unknown,
                    format!("Service was not ready: {}", e.into()),
                )
            })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.ads.googleads.v1.services.AdGroupFeedService/MutateAdGroupFeeds",
            );
            self.inner.unary(request.into_request(), path, codec).await
        }
    }
    impl<T: Clone> Clone for AdGroupFeedServiceClient<T> {
        fn clone(&self) -> Self {
            Self {
                inner: self.inner.clone(),
            }
        }
    }
    impl<T> std::fmt::Debug for AdGroupFeedServiceClient<T> {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
            write!(f, "AdGroupFeedServiceClient {{ ... }}")
        }
    }
}
#[doc = r" Generated server implementations."]
pub mod ad_group_feed_service_server {
    #![allow(unused_variables, dead_code, missing_docs)]
    use tonic::codegen::*;
    #[doc = "Generated trait containing gRPC methods that should be implemented for use with AdGroupFeedServiceServer."]
    #[async_trait]
    pub trait AdGroupFeedService: Send + Sync + 'static {
        #[doc = " Returns the requested ad group feed in full detail."]
        async fn get_ad_group_feed(
            &self,
            request: tonic::Request<super::GetAdGroupFeedRequest>,
        ) -> Result<tonic::Response<super::super::resources::AdGroupFeed>, tonic::Status>;
        #[doc = " Creates, updates, or removes ad group feeds. Operation statuses are"]
        #[doc = " returned."]
        async fn mutate_ad_group_feeds(
            &self,
            request: tonic::Request<super::MutateAdGroupFeedsRequest>,
        ) -> Result<tonic::Response<super::MutateAdGroupFeedsResponse>, tonic::Status>;
    }
    #[doc = " Service to manage ad group feeds."]
    #[derive(Debug)]
    #[doc(hidden)]
    pub struct AdGroupFeedServiceServer<T: AdGroupFeedService> {
        inner: _Inner<T>,
    }
    struct _Inner<T>(Arc<T>, Option<tonic::Interceptor>);
    impl<T: AdGroupFeedService> AdGroupFeedServiceServer<T> {
        pub fn new(inner: T) -> Self {
            let inner = Arc::new(inner);
            let inner = _Inner(inner, None);
            Self { inner }
        }
        pub fn with_interceptor(inner: T, interceptor: impl Into<tonic::Interceptor>) -> Self {
            let inner = Arc::new(inner);
            let inner = _Inner(inner, Some(interceptor.into()));
            Self { inner }
        }
    }
    impl<T, B> Service<http::Request<B>> for AdGroupFeedServiceServer<T>
    where
        T: AdGroupFeedService,
        B: HttpBody + Send + Sync + 'static,
        B::Error: Into<StdError> + Send + 'static,
    {
        type Response = http::Response<tonic::body::BoxBody>;
        type Error = Never;
        type Future = BoxFuture<Self::Response, Self::Error>;
        fn poll_ready(&mut self, _cx: &mut Context<'_>) -> Poll<Result<(), Self::Error>> {
            Poll::Ready(Ok(()))
        }
        fn call(&mut self, req: http::Request<B>) -> Self::Future {
            let inner = self.inner.clone();
            match req.uri().path() {
                "/google.ads.googleads.v1.services.AdGroupFeedService/GetAdGroupFeed" => {
                    #[allow(non_camel_case_types)]
                    struct GetAdGroupFeedSvc<T: AdGroupFeedService>(pub Arc<T>);
                    impl<T: AdGroupFeedService>
                        tonic::server::UnaryService<super::GetAdGroupFeedRequest>
                        for GetAdGroupFeedSvc<T>
                    {
                        type Response = super::super::resources::AdGroupFeed;
                        type Future = BoxFuture<tonic::Response<Self::Response>, tonic::Status>;
                        fn call(
                            &mut self,
                            request: tonic::Request<super::GetAdGroupFeedRequest>,
                        ) -> Self::Future {
                            let inner = self.0.clone();
                            let fut = async move { inner.get_ad_group_feed(request).await };
                            Box::pin(fut)
                        }
                    }
                    let inner = self.inner.clone();
                    let fut = async move {
                        let interceptor = inner.1.clone();
                        let inner = inner.0;
                        let method = GetAdGroupFeedSvc(inner);
                        let codec = tonic::codec::ProstCodec::default();
                        let mut grpc = if let Some(interceptor) = interceptor {
                            tonic::server::Grpc::with_interceptor(codec, interceptor)
                        } else {
                            tonic::server::Grpc::new(codec)
                        };
                        let res = grpc.unary(method, req).await;
                        Ok(res)
                    };
                    Box::pin(fut)
                }
                "/google.ads.googleads.v1.services.AdGroupFeedService/MutateAdGroupFeeds" => {
                    #[allow(non_camel_case_types)]
                    struct MutateAdGroupFeedsSvc<T: AdGroupFeedService>(pub Arc<T>);
                    impl<T: AdGroupFeedService>
                        tonic::server::UnaryService<super::MutateAdGroupFeedsRequest>
                        for MutateAdGroupFeedsSvc<T>
                    {
                        type Response = super::MutateAdGroupFeedsResponse;
                        type Future = BoxFuture<tonic::Response<Self::Response>, tonic::Status>;
                        fn call(
                            &mut self,
                            request: tonic::Request<super::MutateAdGroupFeedsRequest>,
                        ) -> Self::Future {
                            let inner = self.0.clone();
                            let fut = async move { inner.mutate_ad_group_feeds(request).await };
                            Box::pin(fut)
                        }
                    }
                    let inner = self.inner.clone();
                    let fut = async move {
                        let interceptor = inner.1.clone();
                        let inner = inner.0;
                        let method = MutateAdGroupFeedsSvc(inner);
                        let codec = tonic::codec::ProstCodec::default();
                        let mut grpc = if let Some(interceptor) = interceptor {
                            tonic::server::Grpc::with_interceptor(codec, interceptor)
                        } else {
                            tonic::server::Grpc::new(codec)
                        };
                        let res = grpc.unary(method, req).await;
                        Ok(res)
                    };
                    Box::pin(fut)
                }
                _ => Box::pin(async move {
                    Ok(http::Response::builder()
                        .status(200)
                        .header("grpc-status", "12")
                        .body(tonic::body::BoxBody::empty())
                        .unwrap())
                }),
            }
        }
    }
    impl<T: AdGroupFeedService> Clone for AdGroupFeedServiceServer<T> {
        fn clone(&self) -> Self {
            let inner = self.inner.clone();
            Self { inner }
        }
    }
    impl<T: AdGroupFeedService> Clone for _Inner<T> {
        fn clone(&self) -> Self {
            Self(self.0.clone(), self.1.clone())
        }
    }
    impl<T: std::fmt::Debug> std::fmt::Debug for _Inner<T> {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
            write!(f, "{:?}", self.0)
        }
    }
    impl<T: AdGroupFeedService> tonic::transport::NamedService for AdGroupFeedServiceServer<T> {
        const NAME: &'static str = "google.ads.googleads.v1.services.AdGroupFeedService";
    }
}
/// Request message for [AdGroupLabelService.GetAdGroupLabel][google.ads.googleads.v1.services.AdGroupLabelService.GetAdGroupLabel].
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GetAdGroupLabelRequest {
    /// Required. The resource name of the ad group label to fetch.
    #[prost(string, tag = "1")]
    pub resource_name: std::string::String,
}
/// Request message for [AdGroupLabelService.MutateAdGroupLabels][google.ads.googleads.v1.services.AdGroupLabelService.MutateAdGroupLabels].
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct MutateAdGroupLabelsRequest {
    /// Required. ID of the customer whose ad group labels are being modified.
    #[prost(string, tag = "1")]
    pub customer_id: std::string::String,
    /// Required. The list of operations to perform on ad group labels.
    #[prost(message, repeated, tag = "2")]
    pub operations: ::std::vec::Vec<AdGroupLabelOperation>,
    /// If true, successful operations will be carried out and invalid
    /// operations will return errors. If false, all operations will be carried
    /// out in one transaction if and only if they are all valid.
    /// Default is false.
    #[prost(bool, tag = "3")]
    pub partial_failure: bool,
    /// If true, the request is validated but not executed. Only errors are
    /// returned, not results.
    #[prost(bool, tag = "4")]
    pub validate_only: bool,
}
/// A single operation (create, remove) on an ad group label.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct AdGroupLabelOperation {
    /// The mutate operation.
    #[prost(oneof = "ad_group_label_operation::Operation", tags = "1, 2")]
    pub operation: ::std::option::Option<ad_group_label_operation::Operation>,
}
pub mod ad_group_label_operation {
    /// The mutate operation.
    #[derive(Clone, PartialEq, ::prost::Oneof)]
    pub enum Operation {
        /// Create operation: No resource name is expected for the new ad group
        /// label.
        #[prost(message, tag = "1")]
        Create(super::super::resources::AdGroupLabel),
        /// Remove operation: A resource name for the ad group label
        /// being removed, in this format:
        ///
        /// `customers/{customer_id}/adGroupLabels/{ad_group_id}~{label_id}`
        #[prost(string, tag = "2")]
        Remove(std::string::String),
    }
}
/// Response message for an ad group labels mutate.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct MutateAdGroupLabelsResponse {
    /// Errors that pertain to operation failures in the partial failure mode.
    /// Returned only when partial_failure = true and all errors occur inside the
    /// operations. If any errors occur outside the operations (e.g. auth errors),
    /// we return an RPC level error.
    #[prost(message, optional, tag = "3")]
    pub partial_failure_error: ::std::option::Option<super::super::super::super::rpc::Status>,
    /// All results for the mutate.
    #[prost(message, repeated, tag = "2")]
    pub results: ::std::vec::Vec<MutateAdGroupLabelResult>,
}
/// The result for an ad group label mutate.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct MutateAdGroupLabelResult {
    /// Returned for successful operations.
    #[prost(string, tag = "1")]
    pub resource_name: std::string::String,
}
#[doc = r" Generated client implementations."]
pub mod ad_group_label_service_client {
    #![allow(unused_variables, dead_code, missing_docs)]
    use tonic::codegen::*;
    #[doc = " Service to manage labels on ad groups."]
    pub struct AdGroupLabelServiceClient<T> {
        inner: tonic::client::Grpc<T>,
    }
    impl AdGroupLabelServiceClient<tonic::transport::Channel> {
        #[doc = r" Attempt to create a new client by connecting to a given endpoint."]
        pub async fn connect<D>(dst: D) -> Result<Self, tonic::transport::Error>
        where
            D: std::convert::TryInto<tonic::transport::Endpoint>,
            D::Error: Into<StdError>,
        {
            let conn = tonic::transport::Endpoint::new(dst)?.connect().await?;
            Ok(Self::new(conn))
        }
    }
    impl<T> AdGroupLabelServiceClient<T>
    where
        T: tonic::client::GrpcService<tonic::body::BoxBody>,
        T::ResponseBody: Body + HttpBody + Send + 'static,
        T::Error: Into<StdError>,
        <T::ResponseBody as HttpBody>::Error: Into<StdError> + Send,
    {
        pub fn new(inner: T) -> Self {
            let inner = tonic::client::Grpc::new(inner);
            Self { inner }
        }
        pub fn with_interceptor(inner: T, interceptor: impl Into<tonic::Interceptor>) -> Self {
            let inner = tonic::client::Grpc::with_interceptor(inner, interceptor);
            Self { inner }
        }
        #[doc = " Returns the requested ad group label in full detail."]
        pub async fn get_ad_group_label(
            &mut self,
            request: impl tonic::IntoRequest<super::GetAdGroupLabelRequest>,
        ) -> Result<tonic::Response<super::super::resources::AdGroupLabel>, tonic::Status> {
            self.inner.ready().await.map_err(|e| {
                tonic::Status::new(
                    tonic::Code::Unknown,
                    format!("Service was not ready: {}", e.into()),
                )
            })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.ads.googleads.v1.services.AdGroupLabelService/GetAdGroupLabel",
            );
            self.inner.unary(request.into_request(), path, codec).await
        }
        #[doc = " Creates and removes ad group labels."]
        #[doc = " Operation statuses are returned."]
        pub async fn mutate_ad_group_labels(
            &mut self,
            request: impl tonic::IntoRequest<super::MutateAdGroupLabelsRequest>,
        ) -> Result<tonic::Response<super::MutateAdGroupLabelsResponse>, tonic::Status> {
            self.inner.ready().await.map_err(|e| {
                tonic::Status::new(
                    tonic::Code::Unknown,
                    format!("Service was not ready: {}", e.into()),
                )
            })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.ads.googleads.v1.services.AdGroupLabelService/MutateAdGroupLabels",
            );
            self.inner.unary(request.into_request(), path, codec).await
        }
    }
    impl<T: Clone> Clone for AdGroupLabelServiceClient<T> {
        fn clone(&self) -> Self {
            Self {
                inner: self.inner.clone(),
            }
        }
    }
    impl<T> std::fmt::Debug for AdGroupLabelServiceClient<T> {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
            write!(f, "AdGroupLabelServiceClient {{ ... }}")
        }
    }
}
#[doc = r" Generated server implementations."]
pub mod ad_group_label_service_server {
    #![allow(unused_variables, dead_code, missing_docs)]
    use tonic::codegen::*;
    #[doc = "Generated trait containing gRPC methods that should be implemented for use with AdGroupLabelServiceServer."]
    #[async_trait]
    pub trait AdGroupLabelService: Send + Sync + 'static {
        #[doc = " Returns the requested ad group label in full detail."]
        async fn get_ad_group_label(
            &self,
            request: tonic::Request<super::GetAdGroupLabelRequest>,
        ) -> Result<tonic::Response<super::super::resources::AdGroupLabel>, tonic::Status>;
        #[doc = " Creates and removes ad group labels."]
        #[doc = " Operation statuses are returned."]
        async fn mutate_ad_group_labels(
            &self,
            request: tonic::Request<super::MutateAdGroupLabelsRequest>,
        ) -> Result<tonic::Response<super::MutateAdGroupLabelsResponse>, tonic::Status>;
    }
    #[doc = " Service to manage labels on ad groups."]
    #[derive(Debug)]
    #[doc(hidden)]
    pub struct AdGroupLabelServiceServer<T: AdGroupLabelService> {
        inner: _Inner<T>,
    }
    struct _Inner<T>(Arc<T>, Option<tonic::Interceptor>);
    impl<T: AdGroupLabelService> AdGroupLabelServiceServer<T> {
        pub fn new(inner: T) -> Self {
            let inner = Arc::new(inner);
            let inner = _Inner(inner, None);
            Self { inner }
        }
        pub fn with_interceptor(inner: T, interceptor: impl Into<tonic::Interceptor>) -> Self {
            let inner = Arc::new(inner);
            let inner = _Inner(inner, Some(interceptor.into()));
            Self { inner }
        }
    }
    impl<T, B> Service<http::Request<B>> for AdGroupLabelServiceServer<T>
    where
        T: AdGroupLabelService,
        B: HttpBody + Send + Sync + 'static,
        B::Error: Into<StdError> + Send + 'static,
    {
        type Response = http::Response<tonic::body::BoxBody>;
        type Error = Never;
        type Future = BoxFuture<Self::Response, Self::Error>;
        fn poll_ready(&mut self, _cx: &mut Context<'_>) -> Poll<Result<(), Self::Error>> {
            Poll::Ready(Ok(()))
        }
        fn call(&mut self, req: http::Request<B>) -> Self::Future {
            let inner = self.inner.clone();
            match req.uri().path() {
                "/google.ads.googleads.v1.services.AdGroupLabelService/GetAdGroupLabel" => {
                    #[allow(non_camel_case_types)]
                    struct GetAdGroupLabelSvc<T: AdGroupLabelService>(pub Arc<T>);
                    impl<T: AdGroupLabelService>
                        tonic::server::UnaryService<super::GetAdGroupLabelRequest>
                        for GetAdGroupLabelSvc<T>
                    {
                        type Response = super::super::resources::AdGroupLabel;
                        type Future = BoxFuture<tonic::Response<Self::Response>, tonic::Status>;
                        fn call(
                            &mut self,
                            request: tonic::Request<super::GetAdGroupLabelRequest>,
                        ) -> Self::Future {
                            let inner = self.0.clone();
                            let fut = async move { inner.get_ad_group_label(request).await };
                            Box::pin(fut)
                        }
                    }
                    let inner = self.inner.clone();
                    let fut = async move {
                        let interceptor = inner.1.clone();
                        let inner = inner.0;
                        let method = GetAdGroupLabelSvc(inner);
                        let codec = tonic::codec::ProstCodec::default();
                        let mut grpc = if let Some(interceptor) = interceptor {
                            tonic::server::Grpc::with_interceptor(codec, interceptor)
                        } else {
                            tonic::server::Grpc::new(codec)
                        };
                        let res = grpc.unary(method, req).await;
                        Ok(res)
                    };
                    Box::pin(fut)
                }
                "/google.ads.googleads.v1.services.AdGroupLabelService/MutateAdGroupLabels" => {
                    #[allow(non_camel_case_types)]
                    struct MutateAdGroupLabelsSvc<T: AdGroupLabelService>(pub Arc<T>);
                    impl<T: AdGroupLabelService>
                        tonic::server::UnaryService<super::MutateAdGroupLabelsRequest>
                        for MutateAdGroupLabelsSvc<T>
                    {
                        type Response = super::MutateAdGroupLabelsResponse;
                        type Future = BoxFuture<tonic::Response<Self::Response>, tonic::Status>;
                        fn call(
                            &mut self,
                            request: tonic::Request<super::MutateAdGroupLabelsRequest>,
                        ) -> Self::Future {
                            let inner = self.0.clone();
                            let fut = async move { inner.mutate_ad_group_labels(request).await };
                            Box::pin(fut)
                        }
                    }
                    let inner = self.inner.clone();
                    let fut = async move {
                        let interceptor = inner.1.clone();
                        let inner = inner.0;
                        let method = MutateAdGroupLabelsSvc(inner);
                        let codec = tonic::codec::ProstCodec::default();
                        let mut grpc = if let Some(interceptor) = interceptor {
                            tonic::server::Grpc::with_interceptor(codec, interceptor)
                        } else {
                            tonic::server::Grpc::new(codec)
                        };
                        let res = grpc.unary(method, req).await;
                        Ok(res)
                    };
                    Box::pin(fut)
                }
                _ => Box::pin(async move {
                    Ok(http::Response::builder()
                        .status(200)
                        .header("grpc-status", "12")
                        .body(tonic::body::BoxBody::empty())
                        .unwrap())
                }),
            }
        }
    }
    impl<T: AdGroupLabelService> Clone for AdGroupLabelServiceServer<T> {
        fn clone(&self) -> Self {
            let inner = self.inner.clone();
            Self { inner }
        }
    }
    impl<T: AdGroupLabelService> Clone for _Inner<T> {
        fn clone(&self) -> Self {
            Self(self.0.clone(), self.1.clone())
        }
    }
    impl<T: std::fmt::Debug> std::fmt::Debug for _Inner<T> {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
            write!(f, "{:?}", self.0)
        }
    }
    impl<T: AdGroupLabelService> tonic::transport::NamedService for AdGroupLabelServiceServer<T> {
        const NAME: &'static str = "google.ads.googleads.v1.services.AdGroupLabelService";
    }
}
/// Request message for [AdGroupService.GetAdGroup][google.ads.googleads.v1.services.AdGroupService.GetAdGroup].
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GetAdGroupRequest {
    /// Required. The resource name of the ad group to fetch.
    #[prost(string, tag = "1")]
    pub resource_name: std::string::String,
}
/// Request message for [AdGroupService.MutateAdGroups][google.ads.googleads.v1.services.AdGroupService.MutateAdGroups].
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct MutateAdGroupsRequest {
    /// Required. The ID of the customer whose ad groups are being modified.
    #[prost(string, tag = "1")]
    pub customer_id: std::string::String,
    /// Required. The list of operations to perform on individual ad groups.
    #[prost(message, repeated, tag = "2")]
    pub operations: ::std::vec::Vec<AdGroupOperation>,
    /// If true, successful operations will be carried out and invalid
    /// operations will return errors. If false, all operations will be carried
    /// out in one transaction if and only if they are all valid.
    /// Default is false.
    #[prost(bool, tag = "3")]
    pub partial_failure: bool,
    /// If true, the request is validated but not executed. Only errors are
    /// returned, not results.
    #[prost(bool, tag = "4")]
    pub validate_only: bool,
}
/// A single operation (create, update, remove) on an ad group.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct AdGroupOperation {
    /// FieldMask that determines which resource fields are modified in an update.
    #[prost(message, optional, tag = "4")]
    pub update_mask: ::std::option::Option<::prost_types::FieldMask>,
    /// The mutate operation.
    #[prost(oneof = "ad_group_operation::Operation", tags = "1, 2, 3")]
    pub operation: ::std::option::Option<ad_group_operation::Operation>,
}
pub mod ad_group_operation {
    /// The mutate operation.
    #[derive(Clone, PartialEq, ::prost::Oneof)]
    pub enum Operation {
        /// Create operation: No resource name is expected for the new ad group.
        #[prost(message, tag = "1")]
        Create(super::super::resources::AdGroup),
        /// Update operation: The ad group is expected to have a valid resource name.
        #[prost(message, tag = "2")]
        Update(super::super::resources::AdGroup),
        /// Remove operation: A resource name for the removed ad group is expected,
        /// in this format:
        ///
        /// `customers/{customer_id}/adGroups/{ad_group_id}`
        #[prost(string, tag = "3")]
        Remove(std::string::String),
    }
}
/// Response message for an ad group mutate.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct MutateAdGroupsResponse {
    /// Errors that pertain to operation failures in the partial failure mode.
    /// Returned only when partial_failure = true and all errors occur inside the
    /// operations. If any errors occur outside the operations (e.g. auth errors),
    /// we return an RPC level error.
    #[prost(message, optional, tag = "3")]
    pub partial_failure_error: ::std::option::Option<super::super::super::super::rpc::Status>,
    /// All results for the mutate.
    #[prost(message, repeated, tag = "2")]
    pub results: ::std::vec::Vec<MutateAdGroupResult>,
}
/// The result for the ad group mutate.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct MutateAdGroupResult {
    /// Returned for successful operations.
    #[prost(string, tag = "1")]
    pub resource_name: std::string::String,
}
#[doc = r" Generated client implementations."]
pub mod ad_group_service_client {
    #![allow(unused_variables, dead_code, missing_docs)]
    use tonic::codegen::*;
    #[doc = " Service to manage ad groups."]
    pub struct AdGroupServiceClient<T> {
        inner: tonic::client::Grpc<T>,
    }
    impl AdGroupServiceClient<tonic::transport::Channel> {
        #[doc = r" Attempt to create a new client by connecting to a given endpoint."]
        pub async fn connect<D>(dst: D) -> Result<Self, tonic::transport::Error>
        where
            D: std::convert::TryInto<tonic::transport::Endpoint>,
            D::Error: Into<StdError>,
        {
            let conn = tonic::transport::Endpoint::new(dst)?.connect().await?;
            Ok(Self::new(conn))
        }
    }
    impl<T> AdGroupServiceClient<T>
    where
        T: tonic::client::GrpcService<tonic::body::BoxBody>,
        T::ResponseBody: Body + HttpBody + Send + 'static,
        T::Error: Into<StdError>,
        <T::ResponseBody as HttpBody>::Error: Into<StdError> + Send,
    {
        pub fn new(inner: T) -> Self {
            let inner = tonic::client::Grpc::new(inner);
            Self { inner }
        }
        pub fn with_interceptor(inner: T, interceptor: impl Into<tonic::Interceptor>) -> Self {
            let inner = tonic::client::Grpc::with_interceptor(inner, interceptor);
            Self { inner }
        }
        #[doc = " Returns the requested ad group in full detail."]
        pub async fn get_ad_group(
            &mut self,
            request: impl tonic::IntoRequest<super::GetAdGroupRequest>,
        ) -> Result<tonic::Response<super::super::resources::AdGroup>, tonic::Status> {
            self.inner.ready().await.map_err(|e| {
                tonic::Status::new(
                    tonic::Code::Unknown,
                    format!("Service was not ready: {}", e.into()),
                )
            })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.ads.googleads.v1.services.AdGroupService/GetAdGroup",
            );
            self.inner.unary(request.into_request(), path, codec).await
        }
        #[doc = " Creates, updates, or removes ad groups. Operation statuses are returned."]
        pub async fn mutate_ad_groups(
            &mut self,
            request: impl tonic::IntoRequest<super::MutateAdGroupsRequest>,
        ) -> Result<tonic::Response<super::MutateAdGroupsResponse>, tonic::Status> {
            self.inner.ready().await.map_err(|e| {
                tonic::Status::new(
                    tonic::Code::Unknown,
                    format!("Service was not ready: {}", e.into()),
                )
            })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.ads.googleads.v1.services.AdGroupService/MutateAdGroups",
            );
            self.inner.unary(request.into_request(), path, codec).await
        }
    }
    impl<T: Clone> Clone for AdGroupServiceClient<T> {
        fn clone(&self) -> Self {
            Self {
                inner: self.inner.clone(),
            }
        }
    }
    impl<T> std::fmt::Debug for AdGroupServiceClient<T> {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
            write!(f, "AdGroupServiceClient {{ ... }}")
        }
    }
}
#[doc = r" Generated server implementations."]
pub mod ad_group_service_server {
    #![allow(unused_variables, dead_code, missing_docs)]
    use tonic::codegen::*;
    #[doc = "Generated trait containing gRPC methods that should be implemented for use with AdGroupServiceServer."]
    #[async_trait]
    pub trait AdGroupService: Send + Sync + 'static {
        #[doc = " Returns the requested ad group in full detail."]
        async fn get_ad_group(
            &self,
            request: tonic::Request<super::GetAdGroupRequest>,
        ) -> Result<tonic::Response<super::super::resources::AdGroup>, tonic::Status>;
        #[doc = " Creates, updates, or removes ad groups. Operation statuses are returned."]
        async fn mutate_ad_groups(
            &self,
            request: tonic::Request<super::MutateAdGroupsRequest>,
        ) -> Result<tonic::Response<super::MutateAdGroupsResponse>, tonic::Status>;
    }
    #[doc = " Service to manage ad groups."]
    #[derive(Debug)]
    #[doc(hidden)]
    pub struct AdGroupServiceServer<T: AdGroupService> {
        inner: _Inner<T>,
    }
    struct _Inner<T>(Arc<T>, Option<tonic::Interceptor>);
    impl<T: AdGroupService> AdGroupServiceServer<T> {
        pub fn new(inner: T) -> Self {
            let inner = Arc::new(inner);
            let inner = _Inner(inner, None);
            Self { inner }
        }
        pub fn with_interceptor(inner: T, interceptor: impl Into<tonic::Interceptor>) -> Self {
            let inner = Arc::new(inner);
            let inner = _Inner(inner, Some(interceptor.into()));
            Self { inner }
        }
    }
    impl<T, B> Service<http::Request<B>> for AdGroupServiceServer<T>
    where
        T: AdGroupService,
        B: HttpBody + Send + Sync + 'static,
        B::Error: Into<StdError> + Send + 'static,
    {
        type Response = http::Response<tonic::body::BoxBody>;
        type Error = Never;
        type Future = BoxFuture<Self::Response, Self::Error>;
        fn poll_ready(&mut self, _cx: &mut Context<'_>) -> Poll<Result<(), Self::Error>> {
            Poll::Ready(Ok(()))
        }
        fn call(&mut self, req: http::Request<B>) -> Self::Future {
            let inner = self.inner.clone();
            match req.uri().path() {
                "/google.ads.googleads.v1.services.AdGroupService/GetAdGroup" => {
                    #[allow(non_camel_case_types)]
                    struct GetAdGroupSvc<T: AdGroupService>(pub Arc<T>);
                    impl<T: AdGroupService> tonic::server::UnaryService<super::GetAdGroupRequest> for GetAdGroupSvc<T> {
                        type Response = super::super::resources::AdGroup;
                        type Future = BoxFuture<tonic::Response<Self::Response>, tonic::Status>;
                        fn call(
                            &mut self,
                            request: tonic::Request<super::GetAdGroupRequest>,
                        ) -> Self::Future {
                            let inner = self.0.clone();
                            let fut = async move { inner.get_ad_group(request).await };
                            Box::pin(fut)
                        }
                    }
                    let inner = self.inner.clone();
                    let fut = async move {
                        let interceptor = inner.1.clone();
                        let inner = inner.0;
                        let method = GetAdGroupSvc(inner);
                        let codec = tonic::codec::ProstCodec::default();
                        let mut grpc = if let Some(interceptor) = interceptor {
                            tonic::server::Grpc::with_interceptor(codec, interceptor)
                        } else {
                            tonic::server::Grpc::new(codec)
                        };
                        let res = grpc.unary(method, req).await;
                        Ok(res)
                    };
                    Box::pin(fut)
                }
                "/google.ads.googleads.v1.services.AdGroupService/MutateAdGroups" => {
                    #[allow(non_camel_case_types)]
                    struct MutateAdGroupsSvc<T: AdGroupService>(pub Arc<T>);
                    impl<T: AdGroupService>
                        tonic::server::UnaryService<super::MutateAdGroupsRequest>
                        for MutateAdGroupsSvc<T>
                    {
                        type Response = super::MutateAdGroupsResponse;
                        type Future = BoxFuture<tonic::Response<Self::Response>, tonic::Status>;
                        fn call(
                            &mut self,
                            request: tonic::Request<super::MutateAdGroupsRequest>,
                        ) -> Self::Future {
                            let inner = self.0.clone();
                            let fut = async move { inner.mutate_ad_groups(request).await };
                            Box::pin(fut)
                        }
                    }
                    let inner = self.inner.clone();
                    let fut = async move {
                        let interceptor = inner.1.clone();
                        let inner = inner.0;
                        let method = MutateAdGroupsSvc(inner);
                        let codec = tonic::codec::ProstCodec::default();
                        let mut grpc = if let Some(interceptor) = interceptor {
                            tonic::server::Grpc::with_interceptor(codec, interceptor)
                        } else {
                            tonic::server::Grpc::new(codec)
                        };
                        let res = grpc.unary(method, req).await;
                        Ok(res)
                    };
                    Box::pin(fut)
                }
                _ => Box::pin(async move {
                    Ok(http::Response::builder()
                        .status(200)
                        .header("grpc-status", "12")
                        .body(tonic::body::BoxBody::empty())
                        .unwrap())
                }),
            }
        }
    }
    impl<T: AdGroupService> Clone for AdGroupServiceServer<T> {
        fn clone(&self) -> Self {
            let inner = self.inner.clone();
            Self { inner }
        }
    }
    impl<T: AdGroupService> Clone for _Inner<T> {
        fn clone(&self) -> Self {
            Self(self.0.clone(), self.1.clone())
        }
    }
    impl<T: std::fmt::Debug> std::fmt::Debug for _Inner<T> {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
            write!(f, "{:?}", self.0)
        }
    }
    impl<T: AdGroupService> tonic::transport::NamedService for AdGroupServiceServer<T> {
        const NAME: &'static str = "google.ads.googleads.v1.services.AdGroupService";
    }
}
/// Request message for [AdGroupSimulationService.GetAdGroupSimulation][google.ads.googleads.v1.services.AdGroupSimulationService.GetAdGroupSimulation].
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GetAdGroupSimulationRequest {
    /// Required. The resource name of the ad group simulation to fetch.
    #[prost(string, tag = "1")]
    pub resource_name: std::string::String,
}
#[doc = r" Generated client implementations."]
pub mod ad_group_simulation_service_client {
    #![allow(unused_variables, dead_code, missing_docs)]
    use tonic::codegen::*;
    #[doc = " Service to fetch ad group simulations."]
    pub struct AdGroupSimulationServiceClient<T> {
        inner: tonic::client::Grpc<T>,
    }
    impl AdGroupSimulationServiceClient<tonic::transport::Channel> {
        #[doc = r" Attempt to create a new client by connecting to a given endpoint."]
        pub async fn connect<D>(dst: D) -> Result<Self, tonic::transport::Error>
        where
            D: std::convert::TryInto<tonic::transport::Endpoint>,
            D::Error: Into<StdError>,
        {
            let conn = tonic::transport::Endpoint::new(dst)?.connect().await?;
            Ok(Self::new(conn))
        }
    }
    impl<T> AdGroupSimulationServiceClient<T>
    where
        T: tonic::client::GrpcService<tonic::body::BoxBody>,
        T::ResponseBody: Body + HttpBody + Send + 'static,
        T::Error: Into<StdError>,
        <T::ResponseBody as HttpBody>::Error: Into<StdError> + Send,
    {
        pub fn new(inner: T) -> Self {
            let inner = tonic::client::Grpc::new(inner);
            Self { inner }
        }
        pub fn with_interceptor(inner: T, interceptor: impl Into<tonic::Interceptor>) -> Self {
            let inner = tonic::client::Grpc::with_interceptor(inner, interceptor);
            Self { inner }
        }
        #[doc = " Returns the requested ad group simulation in full detail."]
        pub async fn get_ad_group_simulation(
            &mut self,
            request: impl tonic::IntoRequest<super::GetAdGroupSimulationRequest>,
        ) -> Result<tonic::Response<super::super::resources::AdGroupSimulation>, tonic::Status>
        {
            self.inner.ready().await.map_err(|e| {
                tonic::Status::new(
                    tonic::Code::Unknown,
                    format!("Service was not ready: {}", e.into()),
                )
            })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.ads.googleads.v1.services.AdGroupSimulationService/GetAdGroupSimulation",
            );
            self.inner.unary(request.into_request(), path, codec).await
        }
    }
    impl<T: Clone> Clone for AdGroupSimulationServiceClient<T> {
        fn clone(&self) -> Self {
            Self {
                inner: self.inner.clone(),
            }
        }
    }
    impl<T> std::fmt::Debug for AdGroupSimulationServiceClient<T> {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
            write!(f, "AdGroupSimulationServiceClient {{ ... }}")
        }
    }
}
#[doc = r" Generated server implementations."]
pub mod ad_group_simulation_service_server {
    #![allow(unused_variables, dead_code, missing_docs)]
    use tonic::codegen::*;
    #[doc = "Generated trait containing gRPC methods that should be implemented for use with AdGroupSimulationServiceServer."]
    #[async_trait]
    pub trait AdGroupSimulationService: Send + Sync + 'static {
        #[doc = " Returns the requested ad group simulation in full detail."]
        async fn get_ad_group_simulation(
            &self,
            request: tonic::Request<super::GetAdGroupSimulationRequest>,
        ) -> Result<tonic::Response<super::super::resources::AdGroupSimulation>, tonic::Status>;
    }
    #[doc = " Service to fetch ad group simulations."]
    #[derive(Debug)]
    #[doc(hidden)]
    pub struct AdGroupSimulationServiceServer<T: AdGroupSimulationService> {
        inner: _Inner<T>,
    }
    struct _Inner<T>(Arc<T>, Option<tonic::Interceptor>);
    impl<T: AdGroupSimulationService> AdGroupSimulationServiceServer<T> {
        pub fn new(inner: T) -> Self {
            let inner = Arc::new(inner);
            let inner = _Inner(inner, None);
            Self { inner }
        }
        pub fn with_interceptor(inner: T, interceptor: impl Into<tonic::Interceptor>) -> Self {
            let inner = Arc::new(inner);
            let inner = _Inner(inner, Some(interceptor.into()));
            Self { inner }
        }
    }
    impl<T, B> Service<http::Request<B>> for AdGroupSimulationServiceServer<T>
    where
        T: AdGroupSimulationService,
        B: HttpBody + Send + Sync + 'static,
        B::Error: Into<StdError> + Send + 'static,
    {
        type Response = http::Response<tonic::body::BoxBody>;
        type Error = Never;
        type Future = BoxFuture<Self::Response, Self::Error>;
        fn poll_ready(&mut self, _cx: &mut Context<'_>) -> Poll<Result<(), Self::Error>> {
            Poll::Ready(Ok(()))
        }
        fn call(&mut self, req: http::Request<B>) -> Self::Future {
            let inner = self.inner.clone();
            match req . uri ( ) . path ( ) { "/google.ads.googleads.v1.services.AdGroupSimulationService/GetAdGroupSimulation" => { # [ allow ( non_camel_case_types ) ] struct GetAdGroupSimulationSvc < T : AdGroupSimulationService > ( pub Arc < T > ) ; impl < T : AdGroupSimulationService > tonic :: server :: UnaryService < super :: GetAdGroupSimulationRequest > for GetAdGroupSimulationSvc < T > { type Response = super :: super :: resources :: AdGroupSimulation ; type Future = BoxFuture < tonic :: Response < Self :: Response > , tonic :: Status > ; fn call ( & mut self , request : tonic :: Request < super :: GetAdGroupSimulationRequest > ) -> Self :: Future { let inner = self . 0 . clone ( ) ; let fut = async move { inner . get_ad_group_simulation ( request ) . await } ; Box :: pin ( fut ) } } let inner = self . inner . clone ( ) ; let fut = async move { let interceptor = inner . 1 . clone ( ) ; let inner = inner . 0 ; let method = GetAdGroupSimulationSvc ( inner ) ; let codec = tonic :: codec :: ProstCodec :: default ( ) ; let mut grpc = if let Some ( interceptor ) = interceptor { tonic :: server :: Grpc :: with_interceptor ( codec , interceptor ) } else { tonic :: server :: Grpc :: new ( codec ) } ; let res = grpc . unary ( method , req ) . await ; Ok ( res ) } ; Box :: pin ( fut ) } _ => Box :: pin ( async move { Ok ( http :: Response :: builder ( ) . status ( 200 ) . header ( "grpc-status" , "12" ) . body ( tonic :: body :: BoxBody :: empty ( ) ) . unwrap ( ) ) } ) , }
        }
    }
    impl<T: AdGroupSimulationService> Clone for AdGroupSimulationServiceServer<T> {
        fn clone(&self) -> Self {
            let inner = self.inner.clone();
            Self { inner }
        }
    }
    impl<T: AdGroupSimulationService> Clone for _Inner<T> {
        fn clone(&self) -> Self {
            Self(self.0.clone(), self.1.clone())
        }
    }
    impl<T: std::fmt::Debug> std::fmt::Debug for _Inner<T> {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
            write!(f, "{:?}", self.0)
        }
    }
    impl<T: AdGroupSimulationService> tonic::transport::NamedService
        for AdGroupSimulationServiceServer<T>
    {
        const NAME: &'static str = "google.ads.googleads.v1.services.AdGroupSimulationService";
    }
}
/// Request message for [AdParameterService.GetAdParameter][google.ads.googleads.v1.services.AdParameterService.GetAdParameter]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GetAdParameterRequest {
    /// Required. The resource name of the ad parameter to fetch.
    #[prost(string, tag = "1")]
    pub resource_name: std::string::String,
}
/// Request message for [AdParameterService.MutateAdParameters][google.ads.googleads.v1.services.AdParameterService.MutateAdParameters]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct MutateAdParametersRequest {
    /// Required. The ID of the customer whose ad parameters are being modified.
    #[prost(string, tag = "1")]
    pub customer_id: std::string::String,
    /// Required. The list of operations to perform on individual ad parameters.
    #[prost(message, repeated, tag = "2")]
    pub operations: ::std::vec::Vec<AdParameterOperation>,
    /// If true, successful operations will be carried out and invalid
    /// operations will return errors. If false, all operations will be carried
    /// out in one transaction if and only if they are all valid.
    /// Default is false.
    #[prost(bool, tag = "3")]
    pub partial_failure: bool,
    /// If true, the request is validated but not executed. Only errors are
    /// returned, not results.
    #[prost(bool, tag = "4")]
    pub validate_only: bool,
}
/// A single operation (create, update, remove) on ad parameter.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct AdParameterOperation {
    /// FieldMask that determines which resource fields are modified in an update.
    #[prost(message, optional, tag = "4")]
    pub update_mask: ::std::option::Option<::prost_types::FieldMask>,
    /// The mutate operation.
    #[prost(oneof = "ad_parameter_operation::Operation", tags = "1, 2, 3")]
    pub operation: ::std::option::Option<ad_parameter_operation::Operation>,
}
pub mod ad_parameter_operation {
    /// The mutate operation.
    #[derive(Clone, PartialEq, ::prost::Oneof)]
    pub enum Operation {
        /// Create operation: No resource name is expected for the new ad parameter.
        #[prost(message, tag = "1")]
        Create(super::super::resources::AdParameter),
        /// Update operation: The ad parameter is expected to have a valid resource
        /// name.
        #[prost(message, tag = "2")]
        Update(super::super::resources::AdParameter),
        /// Remove operation: A resource name for the ad parameter to remove is
        /// expected in this format:
        ///
        /// `customers/{customer_id}/adParameters/{ad_group_id}~{criterion_id}~{parameter_index}`
        #[prost(string, tag = "3")]
        Remove(std::string::String),
    }
}
/// Response message for an ad parameter mutate.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct MutateAdParametersResponse {
    /// Errors that pertain to operation failures in the partial failure mode.
    /// Returned only when partial_failure = true and all errors occur inside the
    /// operations. If any errors occur outside the operations (e.g. auth errors),
    /// we return an RPC level error.
    #[prost(message, optional, tag = "3")]
    pub partial_failure_error: ::std::option::Option<super::super::super::super::rpc::Status>,
    /// All results for the mutate.
    #[prost(message, repeated, tag = "2")]
    pub results: ::std::vec::Vec<MutateAdParameterResult>,
}
/// The result for the ad parameter mutate.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct MutateAdParameterResult {
    /// The resource name returned for successful operations.
    #[prost(string, tag = "1")]
    pub resource_name: std::string::String,
}
#[doc = r" Generated client implementations."]
pub mod ad_parameter_service_client {
    #![allow(unused_variables, dead_code, missing_docs)]
    use tonic::codegen::*;
    #[doc = " Service to manage ad parameters."]
    pub struct AdParameterServiceClient<T> {
        inner: tonic::client::Grpc<T>,
    }
    impl AdParameterServiceClient<tonic::transport::Channel> {
        #[doc = r" Attempt to create a new client by connecting to a given endpoint."]
        pub async fn connect<D>(dst: D) -> Result<Self, tonic::transport::Error>
        where
            D: std::convert::TryInto<tonic::transport::Endpoint>,
            D::Error: Into<StdError>,
        {
            let conn = tonic::transport::Endpoint::new(dst)?.connect().await?;
            Ok(Self::new(conn))
        }
    }
    impl<T> AdParameterServiceClient<T>
    where
        T: tonic::client::GrpcService<tonic::body::BoxBody>,
        T::ResponseBody: Body + HttpBody + Send + 'static,
        T::Error: Into<StdError>,
        <T::ResponseBody as HttpBody>::Error: Into<StdError> + Send,
    {
        pub fn new(inner: T) -> Self {
            let inner = tonic::client::Grpc::new(inner);
            Self { inner }
        }
        pub fn with_interceptor(inner: T, interceptor: impl Into<tonic::Interceptor>) -> Self {
            let inner = tonic::client::Grpc::with_interceptor(inner, interceptor);
            Self { inner }
        }
        #[doc = " Returns the requested ad parameter in full detail."]
        pub async fn get_ad_parameter(
            &mut self,
            request: impl tonic::IntoRequest<super::GetAdParameterRequest>,
        ) -> Result<tonic::Response<super::super::resources::AdParameter>, tonic::Status> {
            self.inner.ready().await.map_err(|e| {
                tonic::Status::new(
                    tonic::Code::Unknown,
                    format!("Service was not ready: {}", e.into()),
                )
            })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.ads.googleads.v1.services.AdParameterService/GetAdParameter",
            );
            self.inner.unary(request.into_request(), path, codec).await
        }
        #[doc = " Creates, updates, or removes ad parameters. Operation statuses are"]
        #[doc = " returned."]
        pub async fn mutate_ad_parameters(
            &mut self,
            request: impl tonic::IntoRequest<super::MutateAdParametersRequest>,
        ) -> Result<tonic::Response<super::MutateAdParametersResponse>, tonic::Status> {
            self.inner.ready().await.map_err(|e| {
                tonic::Status::new(
                    tonic::Code::Unknown,
                    format!("Service was not ready: {}", e.into()),
                )
            })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.ads.googleads.v1.services.AdParameterService/MutateAdParameters",
            );
            self.inner.unary(request.into_request(), path, codec).await
        }
    }
    impl<T: Clone> Clone for AdParameterServiceClient<T> {
        fn clone(&self) -> Self {
            Self {
                inner: self.inner.clone(),
            }
        }
    }
    impl<T> std::fmt::Debug for AdParameterServiceClient<T> {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
            write!(f, "AdParameterServiceClient {{ ... }}")
        }
    }
}
#[doc = r" Generated server implementations."]
pub mod ad_parameter_service_server {
    #![allow(unused_variables, dead_code, missing_docs)]
    use tonic::codegen::*;
    #[doc = "Generated trait containing gRPC methods that should be implemented for use with AdParameterServiceServer."]
    #[async_trait]
    pub trait AdParameterService: Send + Sync + 'static {
        #[doc = " Returns the requested ad parameter in full detail."]
        async fn get_ad_parameter(
            &self,
            request: tonic::Request<super::GetAdParameterRequest>,
        ) -> Result<tonic::Response<super::super::resources::AdParameter>, tonic::Status>;
        #[doc = " Creates, updates, or removes ad parameters. Operation statuses are"]
        #[doc = " returned."]
        async fn mutate_ad_parameters(
            &self,
            request: tonic::Request<super::MutateAdParametersRequest>,
        ) -> Result<tonic::Response<super::MutateAdParametersResponse>, tonic::Status>;
    }
    #[doc = " Service to manage ad parameters."]
    #[derive(Debug)]
    #[doc(hidden)]
    pub struct AdParameterServiceServer<T: AdParameterService> {
        inner: _Inner<T>,
    }
    struct _Inner<T>(Arc<T>, Option<tonic::Interceptor>);
    impl<T: AdParameterService> AdParameterServiceServer<T> {
        pub fn new(inner: T) -> Self {
            let inner = Arc::new(inner);
            let inner = _Inner(inner, None);
            Self { inner }
        }
        pub fn with_interceptor(inner: T, interceptor: impl Into<tonic::Interceptor>) -> Self {
            let inner = Arc::new(inner);
            let inner = _Inner(inner, Some(interceptor.into()));
            Self { inner }
        }
    }
    impl<T, B> Service<http::Request<B>> for AdParameterServiceServer<T>
    where
        T: AdParameterService,
        B: HttpBody + Send + Sync + 'static,
        B::Error: Into<StdError> + Send + 'static,
    {
        type Response = http::Response<tonic::body::BoxBody>;
        type Error = Never;
        type Future = BoxFuture<Self::Response, Self::Error>;
        fn poll_ready(&mut self, _cx: &mut Context<'_>) -> Poll<Result<(), Self::Error>> {
            Poll::Ready(Ok(()))
        }
        fn call(&mut self, req: http::Request<B>) -> Self::Future {
            let inner = self.inner.clone();
            match req.uri().path() {
                "/google.ads.googleads.v1.services.AdParameterService/GetAdParameter" => {
                    #[allow(non_camel_case_types)]
                    struct GetAdParameterSvc<T: AdParameterService>(pub Arc<T>);
                    impl<T: AdParameterService>
                        tonic::server::UnaryService<super::GetAdParameterRequest>
                        for GetAdParameterSvc<T>
                    {
                        type Response = super::super::resources::AdParameter;
                        type Future = BoxFuture<tonic::Response<Self::Response>, tonic::Status>;
                        fn call(
                            &mut self,
                            request: tonic::Request<super::GetAdParameterRequest>,
                        ) -> Self::Future {
                            let inner = self.0.clone();
                            let fut = async move { inner.get_ad_parameter(request).await };
                            Box::pin(fut)
                        }
                    }
                    let inner = self.inner.clone();
                    let fut = async move {
                        let interceptor = inner.1.clone();
                        let inner = inner.0;
                        let method = GetAdParameterSvc(inner);
                        let codec = tonic::codec::ProstCodec::default();
                        let mut grpc = if let Some(interceptor) = interceptor {
                            tonic::server::Grpc::with_interceptor(codec, interceptor)
                        } else {
                            tonic::server::Grpc::new(codec)
                        };
                        let res = grpc.unary(method, req).await;
                        Ok(res)
                    };
                    Box::pin(fut)
                }
                "/google.ads.googleads.v1.services.AdParameterService/MutateAdParameters" => {
                    #[allow(non_camel_case_types)]
                    struct MutateAdParametersSvc<T: AdParameterService>(pub Arc<T>);
                    impl<T: AdParameterService>
                        tonic::server::UnaryService<super::MutateAdParametersRequest>
                        for MutateAdParametersSvc<T>
                    {
                        type Response = super::MutateAdParametersResponse;
                        type Future = BoxFuture<tonic::Response<Self::Response>, tonic::Status>;
                        fn call(
                            &mut self,
                            request: tonic::Request<super::MutateAdParametersRequest>,
                        ) -> Self::Future {
                            let inner = self.0.clone();
                            let fut = async move { inner.mutate_ad_parameters(request).await };
                            Box::pin(fut)
                        }
                    }
                    let inner = self.inner.clone();
                    let fut = async move {
                        let interceptor = inner.1.clone();
                        let inner = inner.0;
                        let method = MutateAdParametersSvc(inner);
                        let codec = tonic::codec::ProstCodec::default();
                        let mut grpc = if let Some(interceptor) = interceptor {
                            tonic::server::Grpc::with_interceptor(codec, interceptor)
                        } else {
                            tonic::server::Grpc::new(codec)
                        };
                        let res = grpc.unary(method, req).await;
                        Ok(res)
                    };
                    Box::pin(fut)
                }
                _ => Box::pin(async move {
                    Ok(http::Response::builder()
                        .status(200)
                        .header("grpc-status", "12")
                        .body(tonic::body::BoxBody::empty())
                        .unwrap())
                }),
            }
        }
    }
    impl<T: AdParameterService> Clone for AdParameterServiceServer<T> {
        fn clone(&self) -> Self {
            let inner = self.inner.clone();
            Self { inner }
        }
    }
    impl<T: AdParameterService> Clone for _Inner<T> {
        fn clone(&self) -> Self {
            Self(self.0.clone(), self.1.clone())
        }
    }
    impl<T: std::fmt::Debug> std::fmt::Debug for _Inner<T> {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
            write!(f, "{:?}", self.0)
        }
    }
    impl<T: AdParameterService> tonic::transport::NamedService for AdParameterServiceServer<T> {
        const NAME: &'static str = "google.ads.googleads.v1.services.AdParameterService";
    }
}
/// Request message for [AdScheduleViewService.GetAdScheduleView][google.ads.googleads.v1.services.AdScheduleViewService.GetAdScheduleView].
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GetAdScheduleViewRequest {
    /// Required. The resource name of the ad schedule view to fetch.
    #[prost(string, tag = "1")]
    pub resource_name: std::string::String,
}
#[doc = r" Generated client implementations."]
pub mod ad_schedule_view_service_client {
    #![allow(unused_variables, dead_code, missing_docs)]
    use tonic::codegen::*;
    #[doc = " Service to fetch ad schedule views."]
    pub struct AdScheduleViewServiceClient<T> {
        inner: tonic::client::Grpc<T>,
    }
    impl AdScheduleViewServiceClient<tonic::transport::Channel> {
        #[doc = r" Attempt to create a new client by connecting to a given endpoint."]
        pub async fn connect<D>(dst: D) -> Result<Self, tonic::transport::Error>
        where
            D: std::convert::TryInto<tonic::transport::Endpoint>,
            D::Error: Into<StdError>,
        {
            let conn = tonic::transport::Endpoint::new(dst)?.connect().await?;
            Ok(Self::new(conn))
        }
    }
    impl<T> AdScheduleViewServiceClient<T>
    where
        T: tonic::client::GrpcService<tonic::body::BoxBody>,
        T::ResponseBody: Body + HttpBody + Send + 'static,
        T::Error: Into<StdError>,
        <T::ResponseBody as HttpBody>::Error: Into<StdError> + Send,
    {
        pub fn new(inner: T) -> Self {
            let inner = tonic::client::Grpc::new(inner);
            Self { inner }
        }
        pub fn with_interceptor(inner: T, interceptor: impl Into<tonic::Interceptor>) -> Self {
            let inner = tonic::client::Grpc::with_interceptor(inner, interceptor);
            Self { inner }
        }
        #[doc = " Returns the requested ad schedule view in full detail."]
        pub async fn get_ad_schedule_view(
            &mut self,
            request: impl tonic::IntoRequest<super::GetAdScheduleViewRequest>,
        ) -> Result<tonic::Response<super::super::resources::AdScheduleView>, tonic::Status>
        {
            self.inner.ready().await.map_err(|e| {
                tonic::Status::new(
                    tonic::Code::Unknown,
                    format!("Service was not ready: {}", e.into()),
                )
            })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.ads.googleads.v1.services.AdScheduleViewService/GetAdScheduleView",
            );
            self.inner.unary(request.into_request(), path, codec).await
        }
    }
    impl<T: Clone> Clone for AdScheduleViewServiceClient<T> {
        fn clone(&self) -> Self {
            Self {
                inner: self.inner.clone(),
            }
        }
    }
    impl<T> std::fmt::Debug for AdScheduleViewServiceClient<T> {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
            write!(f, "AdScheduleViewServiceClient {{ ... }}")
        }
    }
}
#[doc = r" Generated server implementations."]
pub mod ad_schedule_view_service_server {
    #![allow(unused_variables, dead_code, missing_docs)]
    use tonic::codegen::*;
    #[doc = "Generated trait containing gRPC methods that should be implemented for use with AdScheduleViewServiceServer."]
    #[async_trait]
    pub trait AdScheduleViewService: Send + Sync + 'static {
        #[doc = " Returns the requested ad schedule view in full detail."]
        async fn get_ad_schedule_view(
            &self,
            request: tonic::Request<super::GetAdScheduleViewRequest>,
        ) -> Result<tonic::Response<super::super::resources::AdScheduleView>, tonic::Status>;
    }
    #[doc = " Service to fetch ad schedule views."]
    #[derive(Debug)]
    #[doc(hidden)]
    pub struct AdScheduleViewServiceServer<T: AdScheduleViewService> {
        inner: _Inner<T>,
    }
    struct _Inner<T>(Arc<T>, Option<tonic::Interceptor>);
    impl<T: AdScheduleViewService> AdScheduleViewServiceServer<T> {
        pub fn new(inner: T) -> Self {
            let inner = Arc::new(inner);
            let inner = _Inner(inner, None);
            Self { inner }
        }
        pub fn with_interceptor(inner: T, interceptor: impl Into<tonic::Interceptor>) -> Self {
            let inner = Arc::new(inner);
            let inner = _Inner(inner, Some(interceptor.into()));
            Self { inner }
        }
    }
    impl<T, B> Service<http::Request<B>> for AdScheduleViewServiceServer<T>
    where
        T: AdScheduleViewService,
        B: HttpBody + Send + Sync + 'static,
        B::Error: Into<StdError> + Send + 'static,
    {
        type Response = http::Response<tonic::body::BoxBody>;
        type Error = Never;
        type Future = BoxFuture<Self::Response, Self::Error>;
        fn poll_ready(&mut self, _cx: &mut Context<'_>) -> Poll<Result<(), Self::Error>> {
            Poll::Ready(Ok(()))
        }
        fn call(&mut self, req: http::Request<B>) -> Self::Future {
            let inner = self.inner.clone();
            match req.uri().path() {
                "/google.ads.googleads.v1.services.AdScheduleViewService/GetAdScheduleView" => {
                    #[allow(non_camel_case_types)]
                    struct GetAdScheduleViewSvc<T: AdScheduleViewService>(pub Arc<T>);
                    impl<T: AdScheduleViewService>
                        tonic::server::UnaryService<super::GetAdScheduleViewRequest>
                        for GetAdScheduleViewSvc<T>
                    {
                        type Response = super::super::resources::AdScheduleView;
                        type Future = BoxFuture<tonic::Response<Self::Response>, tonic::Status>;
                        fn call(
                            &mut self,
                            request: tonic::Request<super::GetAdScheduleViewRequest>,
                        ) -> Self::Future {
                            let inner = self.0.clone();
                            let fut = async move { inner.get_ad_schedule_view(request).await };
                            Box::pin(fut)
                        }
                    }
                    let inner = self.inner.clone();
                    let fut = async move {
                        let interceptor = inner.1.clone();
                        let inner = inner.0;
                        let method = GetAdScheduleViewSvc(inner);
                        let codec = tonic::codec::ProstCodec::default();
                        let mut grpc = if let Some(interceptor) = interceptor {
                            tonic::server::Grpc::with_interceptor(codec, interceptor)
                        } else {
                            tonic::server::Grpc::new(codec)
                        };
                        let res = grpc.unary(method, req).await;
                        Ok(res)
                    };
                    Box::pin(fut)
                }
                _ => Box::pin(async move {
                    Ok(http::Response::builder()
                        .status(200)
                        .header("grpc-status", "12")
                        .body(tonic::body::BoxBody::empty())
                        .unwrap())
                }),
            }
        }
    }
    impl<T: AdScheduleViewService> Clone for AdScheduleViewServiceServer<T> {
        fn clone(&self) -> Self {
            let inner = self.inner.clone();
            Self { inner }
        }
    }
    impl<T: AdScheduleViewService> Clone for _Inner<T> {
        fn clone(&self) -> Self {
            Self(self.0.clone(), self.1.clone())
        }
    }
    impl<T: std::fmt::Debug> std::fmt::Debug for _Inner<T> {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
            write!(f, "{:?}", self.0)
        }
    }
    impl<T: AdScheduleViewService> tonic::transport::NamedService for AdScheduleViewServiceServer<T> {
        const NAME: &'static str = "google.ads.googleads.v1.services.AdScheduleViewService";
    }
}
/// Request message for [AgeRangeViewService.GetAgeRangeView][google.ads.googleads.v1.services.AgeRangeViewService.GetAgeRangeView].
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GetAgeRangeViewRequest {
    /// Required. The resource name of the age range view to fetch.
    #[prost(string, tag = "1")]
    pub resource_name: std::string::String,
}
#[doc = r" Generated client implementations."]
pub mod age_range_view_service_client {
    #![allow(unused_variables, dead_code, missing_docs)]
    use tonic::codegen::*;
    #[doc = " Service to manage age range views."]
    pub struct AgeRangeViewServiceClient<T> {
        inner: tonic::client::Grpc<T>,
    }
    impl AgeRangeViewServiceClient<tonic::transport::Channel> {
        #[doc = r" Attempt to create a new client by connecting to a given endpoint."]
        pub async fn connect<D>(dst: D) -> Result<Self, tonic::transport::Error>
        where
            D: std::convert::TryInto<tonic::transport::Endpoint>,
            D::Error: Into<StdError>,
        {
            let conn = tonic::transport::Endpoint::new(dst)?.connect().await?;
            Ok(Self::new(conn))
        }
    }
    impl<T> AgeRangeViewServiceClient<T>
    where
        T: tonic::client::GrpcService<tonic::body::BoxBody>,
        T::ResponseBody: Body + HttpBody + Send + 'static,
        T::Error: Into<StdError>,
        <T::ResponseBody as HttpBody>::Error: Into<StdError> + Send,
    {
        pub fn new(inner: T) -> Self {
            let inner = tonic::client::Grpc::new(inner);
            Self { inner }
        }
        pub fn with_interceptor(inner: T, interceptor: impl Into<tonic::Interceptor>) -> Self {
            let inner = tonic::client::Grpc::with_interceptor(inner, interceptor);
            Self { inner }
        }
        #[doc = " Returns the requested age range view in full detail."]
        pub async fn get_age_range_view(
            &mut self,
            request: impl tonic::IntoRequest<super::GetAgeRangeViewRequest>,
        ) -> Result<tonic::Response<super::super::resources::AgeRangeView>, tonic::Status> {
            self.inner.ready().await.map_err(|e| {
                tonic::Status::new(
                    tonic::Code::Unknown,
                    format!("Service was not ready: {}", e.into()),
                )
            })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.ads.googleads.v1.services.AgeRangeViewService/GetAgeRangeView",
            );
            self.inner.unary(request.into_request(), path, codec).await
        }
    }
    impl<T: Clone> Clone for AgeRangeViewServiceClient<T> {
        fn clone(&self) -> Self {
            Self {
                inner: self.inner.clone(),
            }
        }
    }
    impl<T> std::fmt::Debug for AgeRangeViewServiceClient<T> {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
            write!(f, "AgeRangeViewServiceClient {{ ... }}")
        }
    }
}
#[doc = r" Generated server implementations."]
pub mod age_range_view_service_server {
    #![allow(unused_variables, dead_code, missing_docs)]
    use tonic::codegen::*;
    #[doc = "Generated trait containing gRPC methods that should be implemented for use with AgeRangeViewServiceServer."]
    #[async_trait]
    pub trait AgeRangeViewService: Send + Sync + 'static {
        #[doc = " Returns the requested age range view in full detail."]
        async fn get_age_range_view(
            &self,
            request: tonic::Request<super::GetAgeRangeViewRequest>,
        ) -> Result<tonic::Response<super::super::resources::AgeRangeView>, tonic::Status>;
    }
    #[doc = " Service to manage age range views."]
    #[derive(Debug)]
    #[doc(hidden)]
    pub struct AgeRangeViewServiceServer<T: AgeRangeViewService> {
        inner: _Inner<T>,
    }
    struct _Inner<T>(Arc<T>, Option<tonic::Interceptor>);
    impl<T: AgeRangeViewService> AgeRangeViewServiceServer<T> {
        pub fn new(inner: T) -> Self {
            let inner = Arc::new(inner);
            let inner = _Inner(inner, None);
            Self { inner }
        }
        pub fn with_interceptor(inner: T, interceptor: impl Into<tonic::Interceptor>) -> Self {
            let inner = Arc::new(inner);
            let inner = _Inner(inner, Some(interceptor.into()));
            Self { inner }
        }
    }
    impl<T, B> Service<http::Request<B>> for AgeRangeViewServiceServer<T>
    where
        T: AgeRangeViewService,
        B: HttpBody + Send + Sync + 'static,
        B::Error: Into<StdError> + Send + 'static,
    {
        type Response = http::Response<tonic::body::BoxBody>;
        type Error = Never;
        type Future = BoxFuture<Self::Response, Self::Error>;
        fn poll_ready(&mut self, _cx: &mut Context<'_>) -> Poll<Result<(), Self::Error>> {
            Poll::Ready(Ok(()))
        }
        fn call(&mut self, req: http::Request<B>) -> Self::Future {
            let inner = self.inner.clone();
            match req.uri().path() {
                "/google.ads.googleads.v1.services.AgeRangeViewService/GetAgeRangeView" => {
                    #[allow(non_camel_case_types)]
                    struct GetAgeRangeViewSvc<T: AgeRangeViewService>(pub Arc<T>);
                    impl<T: AgeRangeViewService>
                        tonic::server::UnaryService<super::GetAgeRangeViewRequest>
                        for GetAgeRangeViewSvc<T>
                    {
                        type Response = super::super::resources::AgeRangeView;
                        type Future = BoxFuture<tonic::Response<Self::Response>, tonic::Status>;
                        fn call(
                            &mut self,
                            request: tonic::Request<super::GetAgeRangeViewRequest>,
                        ) -> Self::Future {
                            let inner = self.0.clone();
                            let fut = async move { inner.get_age_range_view(request).await };
                            Box::pin(fut)
                        }
                    }
                    let inner = self.inner.clone();
                    let fut = async move {
                        let interceptor = inner.1.clone();
                        let inner = inner.0;
                        let method = GetAgeRangeViewSvc(inner);
                        let codec = tonic::codec::ProstCodec::default();
                        let mut grpc = if let Some(interceptor) = interceptor {
                            tonic::server::Grpc::with_interceptor(codec, interceptor)
                        } else {
                            tonic::server::Grpc::new(codec)
                        };
                        let res = grpc.unary(method, req).await;
                        Ok(res)
                    };
                    Box::pin(fut)
                }
                _ => Box::pin(async move {
                    Ok(http::Response::builder()
                        .status(200)
                        .header("grpc-status", "12")
                        .body(tonic::body::BoxBody::empty())
                        .unwrap())
                }),
            }
        }
    }
    impl<T: AgeRangeViewService> Clone for AgeRangeViewServiceServer<T> {
        fn clone(&self) -> Self {
            let inner = self.inner.clone();
            Self { inner }
        }
    }
    impl<T: AgeRangeViewService> Clone for _Inner<T> {
        fn clone(&self) -> Self {
            Self(self.0.clone(), self.1.clone())
        }
    }
    impl<T: std::fmt::Debug> std::fmt::Debug for _Inner<T> {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
            write!(f, "{:?}", self.0)
        }
    }
    impl<T: AgeRangeViewService> tonic::transport::NamedService for AgeRangeViewServiceServer<T> {
        const NAME: &'static str = "google.ads.googleads.v1.services.AgeRangeViewService";
    }
}
/// Request message for [AssetService.GetAsset][google.ads.googleads.v1.services.AssetService.GetAsset]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GetAssetRequest {
    /// Required. The resource name of the asset to fetch.
    #[prost(string, tag = "1")]
    pub resource_name: std::string::String,
}
/// Request message for [AssetService.MutateAssets][google.ads.googleads.v1.services.AssetService.MutateAssets]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct MutateAssetsRequest {
    /// Required. The ID of the customer whose assets are being modified.
    #[prost(string, tag = "1")]
    pub customer_id: std::string::String,
    /// Required. The list of operations to perform on individual assets.
    #[prost(message, repeated, tag = "2")]
    pub operations: ::std::vec::Vec<AssetOperation>,
}
/// A single operation to create an asset. Supported asset types are
/// YoutubeVideoAsset, MediaBundleAsset, ImageAsset, and LeadFormAsset. TextAsset
/// should be created with Ad inline.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct AssetOperation {
    /// The mutate operation.
    #[prost(oneof = "asset_operation::Operation", tags = "1")]
    pub operation: ::std::option::Option<asset_operation::Operation>,
}
pub mod asset_operation {
    /// The mutate operation.
    #[derive(Clone, PartialEq, ::prost::Oneof)]
    pub enum Operation {
        /// Create operation: No resource name is expected for the new asset.
        #[prost(message, tag = "1")]
        Create(super::super::resources::Asset),
    }
}
/// Response message for an asset mutate.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct MutateAssetsResponse {
    /// All results for the mutate.
    #[prost(message, repeated, tag = "2")]
    pub results: ::std::vec::Vec<MutateAssetResult>,
}
/// The result for the asset mutate.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct MutateAssetResult {
    /// The resource name returned for successful operations.
    #[prost(string, tag = "1")]
    pub resource_name: std::string::String,
}
#[doc = r" Generated client implementations."]
pub mod asset_service_client {
    #![allow(unused_variables, dead_code, missing_docs)]
    use tonic::codegen::*;
    #[doc = " Service to manage assets. Asset types can be created with AssetService are"]
    #[doc = " YoutubeVideoAsset, MediaBundleAsset and ImageAsset. TextAsset should be"]
    #[doc = " created with Ad inline."]
    pub struct AssetServiceClient<T> {
        inner: tonic::client::Grpc<T>,
    }
    impl AssetServiceClient<tonic::transport::Channel> {
        #[doc = r" Attempt to create a new client by connecting to a given endpoint."]
        pub async fn connect<D>(dst: D) -> Result<Self, tonic::transport::Error>
        where
            D: std::convert::TryInto<tonic::transport::Endpoint>,
            D::Error: Into<StdError>,
        {
            let conn = tonic::transport::Endpoint::new(dst)?.connect().await?;
            Ok(Self::new(conn))
        }
    }
    impl<T> AssetServiceClient<T>
    where
        T: tonic::client::GrpcService<tonic::body::BoxBody>,
        T::ResponseBody: Body + HttpBody + Send + 'static,
        T::Error: Into<StdError>,
        <T::ResponseBody as HttpBody>::Error: Into<StdError> + Send,
    {
        pub fn new(inner: T) -> Self {
            let inner = tonic::client::Grpc::new(inner);
            Self { inner }
        }
        pub fn with_interceptor(inner: T, interceptor: impl Into<tonic::Interceptor>) -> Self {
            let inner = tonic::client::Grpc::with_interceptor(inner, interceptor);
            Self { inner }
        }
        #[doc = " Returns the requested asset in full detail."]
        pub async fn get_asset(
            &mut self,
            request: impl tonic::IntoRequest<super::GetAssetRequest>,
        ) -> Result<tonic::Response<super::super::resources::Asset>, tonic::Status> {
            self.inner.ready().await.map_err(|e| {
                tonic::Status::new(
                    tonic::Code::Unknown,
                    format!("Service was not ready: {}", e.into()),
                )
            })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.ads.googleads.v1.services.AssetService/GetAsset",
            );
            self.inner.unary(request.into_request(), path, codec).await
        }
        #[doc = " Creates assets. Operation statuses are returned."]
        pub async fn mutate_assets(
            &mut self,
            request: impl tonic::IntoRequest<super::MutateAssetsRequest>,
        ) -> Result<tonic::Response<super::MutateAssetsResponse>, tonic::Status> {
            self.inner.ready().await.map_err(|e| {
                tonic::Status::new(
                    tonic::Code::Unknown,
                    format!("Service was not ready: {}", e.into()),
                )
            })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.ads.googleads.v1.services.AssetService/MutateAssets",
            );
            self.inner.unary(request.into_request(), path, codec).await
        }
    }
    impl<T: Clone> Clone for AssetServiceClient<T> {
        fn clone(&self) -> Self {
            Self {
                inner: self.inner.clone(),
            }
        }
    }
    impl<T> std::fmt::Debug for AssetServiceClient<T> {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
            write!(f, "AssetServiceClient {{ ... }}")
        }
    }
}
#[doc = r" Generated server implementations."]
pub mod asset_service_server {
    #![allow(unused_variables, dead_code, missing_docs)]
    use tonic::codegen::*;
    #[doc = "Generated trait containing gRPC methods that should be implemented for use with AssetServiceServer."]
    #[async_trait]
    pub trait AssetService: Send + Sync + 'static {
        #[doc = " Returns the requested asset in full detail."]
        async fn get_asset(
            &self,
            request: tonic::Request<super::GetAssetRequest>,
        ) -> Result<tonic::Response<super::super::resources::Asset>, tonic::Status>;
        #[doc = " Creates assets. Operation statuses are returned."]
        async fn mutate_assets(
            &self,
            request: tonic::Request<super::MutateAssetsRequest>,
        ) -> Result<tonic::Response<super::MutateAssetsResponse>, tonic::Status>;
    }
    #[doc = " Service to manage assets. Asset types can be created with AssetService are"]
    #[doc = " YoutubeVideoAsset, MediaBundleAsset and ImageAsset. TextAsset should be"]
    #[doc = " created with Ad inline."]
    #[derive(Debug)]
    #[doc(hidden)]
    pub struct AssetServiceServer<T: AssetService> {
        inner: _Inner<T>,
    }
    struct _Inner<T>(Arc<T>, Option<tonic::Interceptor>);
    impl<T: AssetService> AssetServiceServer<T> {
        pub fn new(inner: T) -> Self {
            let inner = Arc::new(inner);
            let inner = _Inner(inner, None);
            Self { inner }
        }
        pub fn with_interceptor(inner: T, interceptor: impl Into<tonic::Interceptor>) -> Self {
            let inner = Arc::new(inner);
            let inner = _Inner(inner, Some(interceptor.into()));
            Self { inner }
        }
    }
    impl<T, B> Service<http::Request<B>> for AssetServiceServer<T>
    where
        T: AssetService,
        B: HttpBody + Send + Sync + 'static,
        B::Error: Into<StdError> + Send + 'static,
    {
        type Response = http::Response<tonic::body::BoxBody>;
        type Error = Never;
        type Future = BoxFuture<Self::Response, Self::Error>;
        fn poll_ready(&mut self, _cx: &mut Context<'_>) -> Poll<Result<(), Self::Error>> {
            Poll::Ready(Ok(()))
        }
        fn call(&mut self, req: http::Request<B>) -> Self::Future {
            let inner = self.inner.clone();
            match req.uri().path() {
                "/google.ads.googleads.v1.services.AssetService/GetAsset" => {
                    #[allow(non_camel_case_types)]
                    struct GetAssetSvc<T: AssetService>(pub Arc<T>);
                    impl<T: AssetService> tonic::server::UnaryService<super::GetAssetRequest> for GetAssetSvc<T> {
                        type Response = super::super::resources::Asset;
                        type Future = BoxFuture<tonic::Response<Self::Response>, tonic::Status>;
                        fn call(
                            &mut self,
                            request: tonic::Request<super::GetAssetRequest>,
                        ) -> Self::Future {
                            let inner = self.0.clone();
                            let fut = async move { inner.get_asset(request).await };
                            Box::pin(fut)
                        }
                    }
                    let inner = self.inner.clone();
                    let fut = async move {
                        let interceptor = inner.1.clone();
                        let inner = inner.0;
                        let method = GetAssetSvc(inner);
                        let codec = tonic::codec::ProstCodec::default();
                        let mut grpc = if let Some(interceptor) = interceptor {
                            tonic::server::Grpc::with_interceptor(codec, interceptor)
                        } else {
                            tonic::server::Grpc::new(codec)
                        };
                        let res = grpc.unary(method, req).await;
                        Ok(res)
                    };
                    Box::pin(fut)
                }
                "/google.ads.googleads.v1.services.AssetService/MutateAssets" => {
                    #[allow(non_camel_case_types)]
                    struct MutateAssetsSvc<T: AssetService>(pub Arc<T>);
                    impl<T: AssetService> tonic::server::UnaryService<super::MutateAssetsRequest>
                        for MutateAssetsSvc<T>
                    {
                        type Response = super::MutateAssetsResponse;
                        type Future = BoxFuture<tonic::Response<Self::Response>, tonic::Status>;
                        fn call(
                            &mut self,
                            request: tonic::Request<super::MutateAssetsRequest>,
                        ) -> Self::Future {
                            let inner = self.0.clone();
                            let fut = async move { inner.mutate_assets(request).await };
                            Box::pin(fut)
                        }
                    }
                    let inner = self.inner.clone();
                    let fut = async move {
                        let interceptor = inner.1.clone();
                        let inner = inner.0;
                        let method = MutateAssetsSvc(inner);
                        let codec = tonic::codec::ProstCodec::default();
                        let mut grpc = if let Some(interceptor) = interceptor {
                            tonic::server::Grpc::with_interceptor(codec, interceptor)
                        } else {
                            tonic::server::Grpc::new(codec)
                        };
                        let res = grpc.unary(method, req).await;
                        Ok(res)
                    };
                    Box::pin(fut)
                }
                _ => Box::pin(async move {
                    Ok(http::Response::builder()
                        .status(200)
                        .header("grpc-status", "12")
                        .body(tonic::body::BoxBody::empty())
                        .unwrap())
                }),
            }
        }
    }
    impl<T: AssetService> Clone for AssetServiceServer<T> {
        fn clone(&self) -> Self {
            let inner = self.inner.clone();
            Self { inner }
        }
    }
    impl<T: AssetService> Clone for _Inner<T> {
        fn clone(&self) -> Self {
            Self(self.0.clone(), self.1.clone())
        }
    }
    impl<T: std::fmt::Debug> std::fmt::Debug for _Inner<T> {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
            write!(f, "{:?}", self.0)
        }
    }
    impl<T: AssetService> tonic::transport::NamedService for AssetServiceServer<T> {
        const NAME: &'static str = "google.ads.googleads.v1.services.AssetService";
    }
}
/// Request message for [BiddingStrategyService.GetBiddingStrategy][google.ads.googleads.v1.services.BiddingStrategyService.GetBiddingStrategy].
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GetBiddingStrategyRequest {
    /// Required. The resource name of the bidding strategy to fetch.
    #[prost(string, tag = "1")]
    pub resource_name: std::string::String,
}
/// Request message for [BiddingStrategyService.MutateBiddingStrategies][google.ads.googleads.v1.services.BiddingStrategyService.MutateBiddingStrategies].
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct MutateBiddingStrategiesRequest {
    /// Required. The ID of the customer whose bidding strategies are being modified.
    #[prost(string, tag = "1")]
    pub customer_id: std::string::String,
    /// Required. The list of operations to perform on individual bidding strategies.
    #[prost(message, repeated, tag = "2")]
    pub operations: ::std::vec::Vec<BiddingStrategyOperation>,
    /// If true, successful operations will be carried out and invalid
    /// operations will return errors. If false, all operations will be carried
    /// out in one transaction if and only if they are all valid.
    /// Default is false.
    #[prost(bool, tag = "3")]
    pub partial_failure: bool,
    /// If true, the request is validated but not executed. Only errors are
    /// returned, not results.
    #[prost(bool, tag = "4")]
    pub validate_only: bool,
}
/// A single operation (create, update, remove) on a bidding strategy.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct BiddingStrategyOperation {
    /// FieldMask that determines which resource fields are modified in an update.
    #[prost(message, optional, tag = "4")]
    pub update_mask: ::std::option::Option<::prost_types::FieldMask>,
    /// The mutate operation.
    #[prost(oneof = "bidding_strategy_operation::Operation", tags = "1, 2, 3")]
    pub operation: ::std::option::Option<bidding_strategy_operation::Operation>,
}
pub mod bidding_strategy_operation {
    /// The mutate operation.
    #[derive(Clone, PartialEq, ::prost::Oneof)]
    pub enum Operation {
        /// Create operation: No resource name is expected for the new bidding
        /// strategy.
        #[prost(message, tag = "1")]
        Create(super::super::resources::BiddingStrategy),
        /// Update operation: The bidding strategy is expected to have a valid
        /// resource name.
        #[prost(message, tag = "2")]
        Update(super::super::resources::BiddingStrategy),
        /// Remove operation: A resource name for the removed bidding strategy is
        /// expected, in this format:
        ///
        /// `customers/{customer_id}/biddingStrategies/{bidding_strategy_id}`
        #[prost(string, tag = "3")]
        Remove(std::string::String),
    }
}
/// Response message for bidding strategy mutate.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct MutateBiddingStrategiesResponse {
    /// Errors that pertain to operation failures in the partial failure mode.
    /// Returned only when partial_failure = true and all errors occur inside the
    /// operations. If any errors occur outside the operations (e.g. auth errors),
    /// we return an RPC level error.
    #[prost(message, optional, tag = "3")]
    pub partial_failure_error: ::std::option::Option<super::super::super::super::rpc::Status>,
    /// All results for the mutate.
    #[prost(message, repeated, tag = "2")]
    pub results: ::std::vec::Vec<MutateBiddingStrategyResult>,
}
/// The result for the bidding strategy mutate.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct MutateBiddingStrategyResult {
    /// Returned for successful operations.
    #[prost(string, tag = "1")]
    pub resource_name: std::string::String,
}
#[doc = r" Generated client implementations."]
pub mod bidding_strategy_service_client {
    #![allow(unused_variables, dead_code, missing_docs)]
    use tonic::codegen::*;
    #[doc = " Service to manage bidding strategies."]
    pub struct BiddingStrategyServiceClient<T> {
        inner: tonic::client::Grpc<T>,
    }
    impl BiddingStrategyServiceClient<tonic::transport::Channel> {
        #[doc = r" Attempt to create a new client by connecting to a given endpoint."]
        pub async fn connect<D>(dst: D) -> Result<Self, tonic::transport::Error>
        where
            D: std::convert::TryInto<tonic::transport::Endpoint>,
            D::Error: Into<StdError>,
        {
            let conn = tonic::transport::Endpoint::new(dst)?.connect().await?;
            Ok(Self::new(conn))
        }
    }
    impl<T> BiddingStrategyServiceClient<T>
    where
        T: tonic::client::GrpcService<tonic::body::BoxBody>,
        T::ResponseBody: Body + HttpBody + Send + 'static,
        T::Error: Into<StdError>,
        <T::ResponseBody as HttpBody>::Error: Into<StdError> + Send,
    {
        pub fn new(inner: T) -> Self {
            let inner = tonic::client::Grpc::new(inner);
            Self { inner }
        }
        pub fn with_interceptor(inner: T, interceptor: impl Into<tonic::Interceptor>) -> Self {
            let inner = tonic::client::Grpc::with_interceptor(inner, interceptor);
            Self { inner }
        }
        #[doc = " Returns the requested bidding strategy in full detail."]
        pub async fn get_bidding_strategy(
            &mut self,
            request: impl tonic::IntoRequest<super::GetBiddingStrategyRequest>,
        ) -> Result<tonic::Response<super::super::resources::BiddingStrategy>, tonic::Status>
        {
            self.inner.ready().await.map_err(|e| {
                tonic::Status::new(
                    tonic::Code::Unknown,
                    format!("Service was not ready: {}", e.into()),
                )
            })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.ads.googleads.v1.services.BiddingStrategyService/GetBiddingStrategy",
            );
            self.inner.unary(request.into_request(), path, codec).await
        }
        #[doc = " Creates, updates, or removes bidding strategies. Operation statuses are"]
        #[doc = " returned."]
        pub async fn mutate_bidding_strategies(
            &mut self,
            request: impl tonic::IntoRequest<super::MutateBiddingStrategiesRequest>,
        ) -> Result<tonic::Response<super::MutateBiddingStrategiesResponse>, tonic::Status>
        {
            self.inner.ready().await.map_err(|e| {
                tonic::Status::new(
                    tonic::Code::Unknown,
                    format!("Service was not ready: {}", e.into()),
                )
            })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.ads.googleads.v1.services.BiddingStrategyService/MutateBiddingStrategies",
            );
            self.inner.unary(request.into_request(), path, codec).await
        }
    }
    impl<T: Clone> Clone for BiddingStrategyServiceClient<T> {
        fn clone(&self) -> Self {
            Self {
                inner: self.inner.clone(),
            }
        }
    }
    impl<T> std::fmt::Debug for BiddingStrategyServiceClient<T> {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
            write!(f, "BiddingStrategyServiceClient {{ ... }}")
        }
    }
}
#[doc = r" Generated server implementations."]
pub mod bidding_strategy_service_server {
    #![allow(unused_variables, dead_code, missing_docs)]
    use tonic::codegen::*;
    #[doc = "Generated trait containing gRPC methods that should be implemented for use with BiddingStrategyServiceServer."]
    #[async_trait]
    pub trait BiddingStrategyService: Send + Sync + 'static {
        #[doc = " Returns the requested bidding strategy in full detail."]
        async fn get_bidding_strategy(
            &self,
            request: tonic::Request<super::GetBiddingStrategyRequest>,
        ) -> Result<tonic::Response<super::super::resources::BiddingStrategy>, tonic::Status>;
        #[doc = " Creates, updates, or removes bidding strategies. Operation statuses are"]
        #[doc = " returned."]
        async fn mutate_bidding_strategies(
            &self,
            request: tonic::Request<super::MutateBiddingStrategiesRequest>,
        ) -> Result<tonic::Response<super::MutateBiddingStrategiesResponse>, tonic::Status>;
    }
    #[doc = " Service to manage bidding strategies."]
    #[derive(Debug)]
    #[doc(hidden)]
    pub struct BiddingStrategyServiceServer<T: BiddingStrategyService> {
        inner: _Inner<T>,
    }
    struct _Inner<T>(Arc<T>, Option<tonic::Interceptor>);
    impl<T: BiddingStrategyService> BiddingStrategyServiceServer<T> {
        pub fn new(inner: T) -> Self {
            let inner = Arc::new(inner);
            let inner = _Inner(inner, None);
            Self { inner }
        }
        pub fn with_interceptor(inner: T, interceptor: impl Into<tonic::Interceptor>) -> Self {
            let inner = Arc::new(inner);
            let inner = _Inner(inner, Some(interceptor.into()));
            Self { inner }
        }
    }
    impl<T, B> Service<http::Request<B>> for BiddingStrategyServiceServer<T>
    where
        T: BiddingStrategyService,
        B: HttpBody + Send + Sync + 'static,
        B::Error: Into<StdError> + Send + 'static,
    {
        type Response = http::Response<tonic::body::BoxBody>;
        type Error = Never;
        type Future = BoxFuture<Self::Response, Self::Error>;
        fn poll_ready(&mut self, _cx: &mut Context<'_>) -> Poll<Result<(), Self::Error>> {
            Poll::Ready(Ok(()))
        }
        fn call(&mut self, req: http::Request<B>) -> Self::Future {
            let inner = self.inner.clone();
            match req . uri ( ) . path ( ) { "/google.ads.googleads.v1.services.BiddingStrategyService/GetBiddingStrategy" => { # [ allow ( non_camel_case_types ) ] struct GetBiddingStrategySvc < T : BiddingStrategyService > ( pub Arc < T > ) ; impl < T : BiddingStrategyService > tonic :: server :: UnaryService < super :: GetBiddingStrategyRequest > for GetBiddingStrategySvc < T > { type Response = super :: super :: resources :: BiddingStrategy ; type Future = BoxFuture < tonic :: Response < Self :: Response > , tonic :: Status > ; fn call ( & mut self , request : tonic :: Request < super :: GetBiddingStrategyRequest > ) -> Self :: Future { let inner = self . 0 . clone ( ) ; let fut = async move { inner . get_bidding_strategy ( request ) . await } ; Box :: pin ( fut ) } } let inner = self . inner . clone ( ) ; let fut = async move { let interceptor = inner . 1 . clone ( ) ; let inner = inner . 0 ; let method = GetBiddingStrategySvc ( inner ) ; let codec = tonic :: codec :: ProstCodec :: default ( ) ; let mut grpc = if let Some ( interceptor ) = interceptor { tonic :: server :: Grpc :: with_interceptor ( codec , interceptor ) } else { tonic :: server :: Grpc :: new ( codec ) } ; let res = grpc . unary ( method , req ) . await ; Ok ( res ) } ; Box :: pin ( fut ) } "/google.ads.googleads.v1.services.BiddingStrategyService/MutateBiddingStrategies" => { # [ allow ( non_camel_case_types ) ] struct MutateBiddingStrategiesSvc < T : BiddingStrategyService > ( pub Arc < T > ) ; impl < T : BiddingStrategyService > tonic :: server :: UnaryService < super :: MutateBiddingStrategiesRequest > for MutateBiddingStrategiesSvc < T > { type Response = super :: MutateBiddingStrategiesResponse ; type Future = BoxFuture < tonic :: Response < Self :: Response > , tonic :: Status > ; fn call ( & mut self , request : tonic :: Request < super :: MutateBiddingStrategiesRequest > ) -> Self :: Future { let inner = self . 0 . clone ( ) ; let fut = async move { inner . mutate_bidding_strategies ( request ) . await } ; Box :: pin ( fut ) } } let inner = self . inner . clone ( ) ; let fut = async move { let interceptor = inner . 1 . clone ( ) ; let inner = inner . 0 ; let method = MutateBiddingStrategiesSvc ( inner ) ; let codec = tonic :: codec :: ProstCodec :: default ( ) ; let mut grpc = if let Some ( interceptor ) = interceptor { tonic :: server :: Grpc :: with_interceptor ( codec , interceptor ) } else { tonic :: server :: Grpc :: new ( codec ) } ; let res = grpc . unary ( method , req ) . await ; Ok ( res ) } ; Box :: pin ( fut ) } _ => Box :: pin ( async move { Ok ( http :: Response :: builder ( ) . status ( 200 ) . header ( "grpc-status" , "12" ) . body ( tonic :: body :: BoxBody :: empty ( ) ) . unwrap ( ) ) } ) , }
        }
    }
    impl<T: BiddingStrategyService> Clone for BiddingStrategyServiceServer<T> {
        fn clone(&self) -> Self {
            let inner = self.inner.clone();
            Self { inner }
        }
    }
    impl<T: BiddingStrategyService> Clone for _Inner<T> {
        fn clone(&self) -> Self {
            Self(self.0.clone(), self.1.clone())
        }
    }
    impl<T: std::fmt::Debug> std::fmt::Debug for _Inner<T> {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
            write!(f, "{:?}", self.0)
        }
    }
    impl<T: BiddingStrategyService> tonic::transport::NamedService for BiddingStrategyServiceServer<T> {
        const NAME: &'static str = "google.ads.googleads.v1.services.BiddingStrategyService";
    }
}
/// Request message for
/// [BillingSetupService.GetBillingSetup][google.ads.googleads.v1.services.BillingSetupService.GetBillingSetup].
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GetBillingSetupRequest {
    /// Required. The resource name of the billing setup to fetch.
    #[prost(string, tag = "1")]
    pub resource_name: std::string::String,
}
/// Request message for billing setup mutate operations.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct MutateBillingSetupRequest {
    /// Required. Id of the customer to apply the billing setup mutate operation to.
    #[prost(string, tag = "1")]
    pub customer_id: std::string::String,
    /// Required. The operation to perform.
    #[prost(message, optional, tag = "2")]
    pub operation: ::std::option::Option<BillingSetupOperation>,
}
/// A single operation on a billing setup, which describes the cancellation of an
/// existing billing setup.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct BillingSetupOperation {
    /// Only one of these operations can be set. "Update" operations are not
    /// supported.
    #[prost(oneof = "billing_setup_operation::Operation", tags = "2, 1")]
    pub operation: ::std::option::Option<billing_setup_operation::Operation>,
}
pub mod billing_setup_operation {
    /// Only one of these operations can be set. "Update" operations are not
    /// supported.
    #[derive(Clone, PartialEq, ::prost::Oneof)]
    pub enum Operation {
        /// Creates a billing setup. No resource name is expected for the new billing
        /// setup.
        #[prost(message, tag = "2")]
        Create(super::super::resources::BillingSetup),
        /// Resource name of the billing setup to remove. A setup cannot be
        /// removed unless it is in a pending state or its scheduled start time is in
        /// the future. The resource name looks like
        /// `customers/{customer_id}/billingSetups/{billing_id}`.
        #[prost(string, tag = "1")]
        Remove(std::string::String),
    }
}
/// Response message for a billing setup operation.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct MutateBillingSetupResponse {
    /// A result that identifies the resource affected by the mutate request.
    #[prost(message, optional, tag = "1")]
    pub result: ::std::option::Option<MutateBillingSetupResult>,
}
/// Result for a single billing setup mutate.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct MutateBillingSetupResult {
    /// Returned for successful operations.
    #[prost(string, tag = "1")]
    pub resource_name: std::string::String,
}
#[doc = r" Generated client implementations."]
pub mod billing_setup_service_client {
    #![allow(unused_variables, dead_code, missing_docs)]
    use tonic::codegen::*;
    #[doc = " A service for designating the business entity responsible for accrued costs."]
    #[doc = ""]
    #[doc = " A billing setup is associated with a payments account.  Billing-related"]
    #[doc = " activity for all billing setups associated with a particular payments account"]
    #[doc = " will appear on a single invoice generated monthly."]
    #[doc = ""]
    #[doc = " Mutates:"]
    #[doc = " The REMOVE operation cancels a pending billing setup."]
    #[doc = " The CREATE operation creates a new billing setup."]
    pub struct BillingSetupServiceClient<T> {
        inner: tonic::client::Grpc<T>,
    }
    impl BillingSetupServiceClient<tonic::transport::Channel> {
        #[doc = r" Attempt to create a new client by connecting to a given endpoint."]
        pub async fn connect<D>(dst: D) -> Result<Self, tonic::transport::Error>
        where
            D: std::convert::TryInto<tonic::transport::Endpoint>,
            D::Error: Into<StdError>,
        {
            let conn = tonic::transport::Endpoint::new(dst)?.connect().await?;
            Ok(Self::new(conn))
        }
    }
    impl<T> BillingSetupServiceClient<T>
    where
        T: tonic::client::GrpcService<tonic::body::BoxBody>,
        T::ResponseBody: Body + HttpBody + Send + 'static,
        T::Error: Into<StdError>,
        <T::ResponseBody as HttpBody>::Error: Into<StdError> + Send,
    {
        pub fn new(inner: T) -> Self {
            let inner = tonic::client::Grpc::new(inner);
            Self { inner }
        }
        pub fn with_interceptor(inner: T, interceptor: impl Into<tonic::Interceptor>) -> Self {
            let inner = tonic::client::Grpc::with_interceptor(inner, interceptor);
            Self { inner }
        }
        #[doc = " Returns a billing setup."]
        pub async fn get_billing_setup(
            &mut self,
            request: impl tonic::IntoRequest<super::GetBillingSetupRequest>,
        ) -> Result<tonic::Response<super::super::resources::BillingSetup>, tonic::Status> {
            self.inner.ready().await.map_err(|e| {
                tonic::Status::new(
                    tonic::Code::Unknown,
                    format!("Service was not ready: {}", e.into()),
                )
            })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.ads.googleads.v1.services.BillingSetupService/GetBillingSetup",
            );
            self.inner.unary(request.into_request(), path, codec).await
        }
        #[doc = " Creates a billing setup, or cancels an existing billing setup."]
        pub async fn mutate_billing_setup(
            &mut self,
            request: impl tonic::IntoRequest<super::MutateBillingSetupRequest>,
        ) -> Result<tonic::Response<super::MutateBillingSetupResponse>, tonic::Status> {
            self.inner.ready().await.map_err(|e| {
                tonic::Status::new(
                    tonic::Code::Unknown,
                    format!("Service was not ready: {}", e.into()),
                )
            })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.ads.googleads.v1.services.BillingSetupService/MutateBillingSetup",
            );
            self.inner.unary(request.into_request(), path, codec).await
        }
    }
    impl<T: Clone> Clone for BillingSetupServiceClient<T> {
        fn clone(&self) -> Self {
            Self {
                inner: self.inner.clone(),
            }
        }
    }
    impl<T> std::fmt::Debug for BillingSetupServiceClient<T> {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
            write!(f, "BillingSetupServiceClient {{ ... }}")
        }
    }
}
#[doc = r" Generated server implementations."]
pub mod billing_setup_service_server {
    #![allow(unused_variables, dead_code, missing_docs)]
    use tonic::codegen::*;
    #[doc = "Generated trait containing gRPC methods that should be implemented for use with BillingSetupServiceServer."]
    #[async_trait]
    pub trait BillingSetupService: Send + Sync + 'static {
        #[doc = " Returns a billing setup."]
        async fn get_billing_setup(
            &self,
            request: tonic::Request<super::GetBillingSetupRequest>,
        ) -> Result<tonic::Response<super::super::resources::BillingSetup>, tonic::Status>;
        #[doc = " Creates a billing setup, or cancels an existing billing setup."]
        async fn mutate_billing_setup(
            &self,
            request: tonic::Request<super::MutateBillingSetupRequest>,
        ) -> Result<tonic::Response<super::MutateBillingSetupResponse>, tonic::Status>;
    }
    #[doc = " A service for designating the business entity responsible for accrued costs."]
    #[doc = ""]
    #[doc = " A billing setup is associated with a payments account.  Billing-related"]
    #[doc = " activity for all billing setups associated with a particular payments account"]
    #[doc = " will appear on a single invoice generated monthly."]
    #[doc = ""]
    #[doc = " Mutates:"]
    #[doc = " The REMOVE operation cancels a pending billing setup."]
    #[doc = " The CREATE operation creates a new billing setup."]
    #[derive(Debug)]
    #[doc(hidden)]
    pub struct BillingSetupServiceServer<T: BillingSetupService> {
        inner: _Inner<T>,
    }
    struct _Inner<T>(Arc<T>, Option<tonic::Interceptor>);
    impl<T: BillingSetupService> BillingSetupServiceServer<T> {
        pub fn new(inner: T) -> Self {
            let inner = Arc::new(inner);
            let inner = _Inner(inner, None);
            Self { inner }
        }
        pub fn with_interceptor(inner: T, interceptor: impl Into<tonic::Interceptor>) -> Self {
            let inner = Arc::new(inner);
            let inner = _Inner(inner, Some(interceptor.into()));
            Self { inner }
        }
    }
    impl<T, B> Service<http::Request<B>> for BillingSetupServiceServer<T>
    where
        T: BillingSetupService,
        B: HttpBody + Send + Sync + 'static,
        B::Error: Into<StdError> + Send + 'static,
    {
        type Response = http::Response<tonic::body::BoxBody>;
        type Error = Never;
        type Future = BoxFuture<Self::Response, Self::Error>;
        fn poll_ready(&mut self, _cx: &mut Context<'_>) -> Poll<Result<(), Self::Error>> {
            Poll::Ready(Ok(()))
        }
        fn call(&mut self, req: http::Request<B>) -> Self::Future {
            let inner = self.inner.clone();
            match req.uri().path() {
                "/google.ads.googleads.v1.services.BillingSetupService/GetBillingSetup" => {
                    #[allow(non_camel_case_types)]
                    struct GetBillingSetupSvc<T: BillingSetupService>(pub Arc<T>);
                    impl<T: BillingSetupService>
                        tonic::server::UnaryService<super::GetBillingSetupRequest>
                        for GetBillingSetupSvc<T>
                    {
                        type Response = super::super::resources::BillingSetup;
                        type Future = BoxFuture<tonic::Response<Self::Response>, tonic::Status>;
                        fn call(
                            &mut self,
                            request: tonic::Request<super::GetBillingSetupRequest>,
                        ) -> Self::Future {
                            let inner = self.0.clone();
                            let fut = async move { inner.get_billing_setup(request).await };
                            Box::pin(fut)
                        }
                    }
                    let inner = self.inner.clone();
                    let fut = async move {
                        let interceptor = inner.1.clone();
                        let inner = inner.0;
                        let method = GetBillingSetupSvc(inner);
                        let codec = tonic::codec::ProstCodec::default();
                        let mut grpc = if let Some(interceptor) = interceptor {
                            tonic::server::Grpc::with_interceptor(codec, interceptor)
                        } else {
                            tonic::server::Grpc::new(codec)
                        };
                        let res = grpc.unary(method, req).await;
                        Ok(res)
                    };
                    Box::pin(fut)
                }
                "/google.ads.googleads.v1.services.BillingSetupService/MutateBillingSetup" => {
                    #[allow(non_camel_case_types)]
                    struct MutateBillingSetupSvc<T: BillingSetupService>(pub Arc<T>);
                    impl<T: BillingSetupService>
                        tonic::server::UnaryService<super::MutateBillingSetupRequest>
                        for MutateBillingSetupSvc<T>
                    {
                        type Response = super::MutateBillingSetupResponse;
                        type Future = BoxFuture<tonic::Response<Self::Response>, tonic::Status>;
                        fn call(
                            &mut self,
                            request: tonic::Request<super::MutateBillingSetupRequest>,
                        ) -> Self::Future {
                            let inner = self.0.clone();
                            let fut = async move { inner.mutate_billing_setup(request).await };
                            Box::pin(fut)
                        }
                    }
                    let inner = self.inner.clone();
                    let fut = async move {
                        let interceptor = inner.1.clone();
                        let inner = inner.0;
                        let method = MutateBillingSetupSvc(inner);
                        let codec = tonic::codec::ProstCodec::default();
                        let mut grpc = if let Some(interceptor) = interceptor {
                            tonic::server::Grpc::with_interceptor(codec, interceptor)
                        } else {
                            tonic::server::Grpc::new(codec)
                        };
                        let res = grpc.unary(method, req).await;
                        Ok(res)
                    };
                    Box::pin(fut)
                }
                _ => Box::pin(async move {
                    Ok(http::Response::builder()
                        .status(200)
                        .header("grpc-status", "12")
                        .body(tonic::body::BoxBody::empty())
                        .unwrap())
                }),
            }
        }
    }
    impl<T: BillingSetupService> Clone for BillingSetupServiceServer<T> {
        fn clone(&self) -> Self {
            let inner = self.inner.clone();
            Self { inner }
        }
    }
    impl<T: BillingSetupService> Clone for _Inner<T> {
        fn clone(&self) -> Self {
            Self(self.0.clone(), self.1.clone())
        }
    }
    impl<T: std::fmt::Debug> std::fmt::Debug for _Inner<T> {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
            write!(f, "{:?}", self.0)
        }
    }
    impl<T: BillingSetupService> tonic::transport::NamedService for BillingSetupServiceServer<T> {
        const NAME: &'static str = "google.ads.googleads.v1.services.BillingSetupService";
    }
}
/// Request message for [CampaignAudienceViewService.GetCampaignAudienceView][google.ads.googleads.v1.services.CampaignAudienceViewService.GetCampaignAudienceView].
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GetCampaignAudienceViewRequest {
    /// Required. The resource name of the campaign audience view to fetch.
    #[prost(string, tag = "1")]
    pub resource_name: std::string::String,
}
#[doc = r" Generated client implementations."]
pub mod campaign_audience_view_service_client {
    #![allow(unused_variables, dead_code, missing_docs)]
    use tonic::codegen::*;
    #[doc = " Service to manage campaign audience views."]
    pub struct CampaignAudienceViewServiceClient<T> {
        inner: tonic::client::Grpc<T>,
    }
    impl CampaignAudienceViewServiceClient<tonic::transport::Channel> {
        #[doc = r" Attempt to create a new client by connecting to a given endpoint."]
        pub async fn connect<D>(dst: D) -> Result<Self, tonic::transport::Error>
        where
            D: std::convert::TryInto<tonic::transport::Endpoint>,
            D::Error: Into<StdError>,
        {
            let conn = tonic::transport::Endpoint::new(dst)?.connect().await?;
            Ok(Self::new(conn))
        }
    }
    impl<T> CampaignAudienceViewServiceClient<T>
    where
        T: tonic::client::GrpcService<tonic::body::BoxBody>,
        T::ResponseBody: Body + HttpBody + Send + 'static,
        T::Error: Into<StdError>,
        <T::ResponseBody as HttpBody>::Error: Into<StdError> + Send,
    {
        pub fn new(inner: T) -> Self {
            let inner = tonic::client::Grpc::new(inner);
            Self { inner }
        }
        pub fn with_interceptor(inner: T, interceptor: impl Into<tonic::Interceptor>) -> Self {
            let inner = tonic::client::Grpc::with_interceptor(inner, interceptor);
            Self { inner }
        }
        #[doc = " Returns the requested campaign audience view in full detail."]
        pub async fn get_campaign_audience_view(
            &mut self,
            request: impl tonic::IntoRequest<super::GetCampaignAudienceViewRequest>,
        ) -> Result<tonic::Response<super::super::resources::CampaignAudienceView>, tonic::Status>
        {
            self.inner.ready().await.map_err(|e| {
                tonic::Status::new(
                    tonic::Code::Unknown,
                    format!("Service was not ready: {}", e.into()),
                )
            })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http :: uri :: PathAndQuery :: from_static ( "/google.ads.googleads.v1.services.CampaignAudienceViewService/GetCampaignAudienceView" ) ;
            self.inner.unary(request.into_request(), path, codec).await
        }
    }
    impl<T: Clone> Clone for CampaignAudienceViewServiceClient<T> {
        fn clone(&self) -> Self {
            Self {
                inner: self.inner.clone(),
            }
        }
    }
    impl<T> std::fmt::Debug for CampaignAudienceViewServiceClient<T> {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
            write!(f, "CampaignAudienceViewServiceClient {{ ... }}")
        }
    }
}
#[doc = r" Generated server implementations."]
pub mod campaign_audience_view_service_server {
    #![allow(unused_variables, dead_code, missing_docs)]
    use tonic::codegen::*;
    #[doc = "Generated trait containing gRPC methods that should be implemented for use with CampaignAudienceViewServiceServer."]
    #[async_trait]
    pub trait CampaignAudienceViewService: Send + Sync + 'static {
        #[doc = " Returns the requested campaign audience view in full detail."]
        async fn get_campaign_audience_view(
            &self,
            request: tonic::Request<super::GetCampaignAudienceViewRequest>,
        ) -> Result<tonic::Response<super::super::resources::CampaignAudienceView>, tonic::Status>;
    }
    #[doc = " Service to manage campaign audience views."]
    #[derive(Debug)]
    #[doc(hidden)]
    pub struct CampaignAudienceViewServiceServer<T: CampaignAudienceViewService> {
        inner: _Inner<T>,
    }
    struct _Inner<T>(Arc<T>, Option<tonic::Interceptor>);
    impl<T: CampaignAudienceViewService> CampaignAudienceViewServiceServer<T> {
        pub fn new(inner: T) -> Self {
            let inner = Arc::new(inner);
            let inner = _Inner(inner, None);
            Self { inner }
        }
        pub fn with_interceptor(inner: T, interceptor: impl Into<tonic::Interceptor>) -> Self {
            let inner = Arc::new(inner);
            let inner = _Inner(inner, Some(interceptor.into()));
            Self { inner }
        }
    }
    impl<T, B> Service<http::Request<B>> for CampaignAudienceViewServiceServer<T>
    where
        T: CampaignAudienceViewService,
        B: HttpBody + Send + Sync + 'static,
        B::Error: Into<StdError> + Send + 'static,
    {
        type Response = http::Response<tonic::body::BoxBody>;
        type Error = Never;
        type Future = BoxFuture<Self::Response, Self::Error>;
        fn poll_ready(&mut self, _cx: &mut Context<'_>) -> Poll<Result<(), Self::Error>> {
            Poll::Ready(Ok(()))
        }
        fn call(&mut self, req: http::Request<B>) -> Self::Future {
            let inner = self.inner.clone();
            match req . uri ( ) . path ( ) { "/google.ads.googleads.v1.services.CampaignAudienceViewService/GetCampaignAudienceView" => { # [ allow ( non_camel_case_types ) ] struct GetCampaignAudienceViewSvc < T : CampaignAudienceViewService > ( pub Arc < T > ) ; impl < T : CampaignAudienceViewService > tonic :: server :: UnaryService < super :: GetCampaignAudienceViewRequest > for GetCampaignAudienceViewSvc < T > { type Response = super :: super :: resources :: CampaignAudienceView ; type Future = BoxFuture < tonic :: Response < Self :: Response > , tonic :: Status > ; fn call ( & mut self , request : tonic :: Request < super :: GetCampaignAudienceViewRequest > ) -> Self :: Future { let inner = self . 0 . clone ( ) ; let fut = async move { inner . get_campaign_audience_view ( request ) . await } ; Box :: pin ( fut ) } } let inner = self . inner . clone ( ) ; let fut = async move { let interceptor = inner . 1 . clone ( ) ; let inner = inner . 0 ; let method = GetCampaignAudienceViewSvc ( inner ) ; let codec = tonic :: codec :: ProstCodec :: default ( ) ; let mut grpc = if let Some ( interceptor ) = interceptor { tonic :: server :: Grpc :: with_interceptor ( codec , interceptor ) } else { tonic :: server :: Grpc :: new ( codec ) } ; let res = grpc . unary ( method , req ) . await ; Ok ( res ) } ; Box :: pin ( fut ) } _ => Box :: pin ( async move { Ok ( http :: Response :: builder ( ) . status ( 200 ) . header ( "grpc-status" , "12" ) . body ( tonic :: body :: BoxBody :: empty ( ) ) . unwrap ( ) ) } ) , }
        }
    }
    impl<T: CampaignAudienceViewService> Clone for CampaignAudienceViewServiceServer<T> {
        fn clone(&self) -> Self {
            let inner = self.inner.clone();
            Self { inner }
        }
    }
    impl<T: CampaignAudienceViewService> Clone for _Inner<T> {
        fn clone(&self) -> Self {
            Self(self.0.clone(), self.1.clone())
        }
    }
    impl<T: std::fmt::Debug> std::fmt::Debug for _Inner<T> {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
            write!(f, "{:?}", self.0)
        }
    }
    impl<T: CampaignAudienceViewService> tonic::transport::NamedService
        for CampaignAudienceViewServiceServer<T>
    {
        const NAME: &'static str = "google.ads.googleads.v1.services.CampaignAudienceViewService";
    }
}
/// Request message for [CampaignBidModifierService.GetCampaignBidModifier][google.ads.googleads.v1.services.CampaignBidModifierService.GetCampaignBidModifier].
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GetCampaignBidModifierRequest {
    /// Required. The resource name of the campaign bid modifier to fetch.
    #[prost(string, tag = "1")]
    pub resource_name: std::string::String,
}
/// Request message for [CampaignBidModifierService.MutateCampaignBidModifier][].
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct MutateCampaignBidModifiersRequest {
    /// Required. ID of the customer whose campaign bid modifiers are being modified.
    #[prost(string, tag = "1")]
    pub customer_id: std::string::String,
    /// Required. The list of operations to perform on individual campaign bid modifiers.
    #[prost(message, repeated, tag = "2")]
    pub operations: ::std::vec::Vec<CampaignBidModifierOperation>,
    /// If true, successful operations will be carried out and invalid
    /// operations will return errors. If false, all operations will be carried
    /// out in one transaction if and only if they are all valid.
    /// Default is false.
    #[prost(bool, tag = "3")]
    pub partial_failure: bool,
    /// If true, the request is validated but not executed. Only errors are
    /// returned, not results.
    #[prost(bool, tag = "4")]
    pub validate_only: bool,
}
/// A single operation (create, remove, update) on a campaign bid modifier.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CampaignBidModifierOperation {
    /// FieldMask that determines which resource fields are modified in an update.
    #[prost(message, optional, tag = "4")]
    pub update_mask: ::std::option::Option<::prost_types::FieldMask>,
    /// The mutate operation.
    #[prost(oneof = "campaign_bid_modifier_operation::Operation", tags = "1, 2, 3")]
    pub operation: ::std::option::Option<campaign_bid_modifier_operation::Operation>,
}
pub mod campaign_bid_modifier_operation {
    /// The mutate operation.
    #[derive(Clone, PartialEq, ::prost::Oneof)]
    pub enum Operation {
        /// Create operation: No resource name is expected for the new campaign bid
        /// modifier.
        #[prost(message, tag = "1")]
        Create(super::super::resources::CampaignBidModifier),
        /// Update operation: The campaign bid modifier is expected to have a valid
        /// resource name.
        #[prost(message, tag = "2")]
        Update(super::super::resources::CampaignBidModifier),
        /// Remove operation: A resource name for the removed campaign bid modifier
        /// is expected, in this format:
        ///
        /// `customers/{customer_id}/CampaignBidModifiers/{campaign_id}~{criterion_id}`
        #[prost(string, tag = "3")]
        Remove(std::string::String),
    }
}
/// Response message for campaign bid modifiers mutate.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct MutateCampaignBidModifiersResponse {
    /// Errors that pertain to operation failures in the partial failure mode.
    /// Returned only when partial_failure = true and all errors occur inside the
    /// operations. If any errors occur outside the operations (e.g. auth errors),
    /// we return an RPC level error.
    #[prost(message, optional, tag = "3")]
    pub partial_failure_error: ::std::option::Option<super::super::super::super::rpc::Status>,
    /// All results for the mutate.
    #[prost(message, repeated, tag = "2")]
    pub results: ::std::vec::Vec<MutateCampaignBidModifierResult>,
}
/// The result for the criterion mutate.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct MutateCampaignBidModifierResult {
    /// Returned for successful operations.
    #[prost(string, tag = "1")]
    pub resource_name: std::string::String,
}
#[doc = r" Generated client implementations."]
pub mod campaign_bid_modifier_service_client {
    #![allow(unused_variables, dead_code, missing_docs)]
    use tonic::codegen::*;
    #[doc = " Service to manage campaign bid modifiers."]
    pub struct CampaignBidModifierServiceClient<T> {
        inner: tonic::client::Grpc<T>,
    }
    impl CampaignBidModifierServiceClient<tonic::transport::Channel> {
        #[doc = r" Attempt to create a new client by connecting to a given endpoint."]
        pub async fn connect<D>(dst: D) -> Result<Self, tonic::transport::Error>
        where
            D: std::convert::TryInto<tonic::transport::Endpoint>,
            D::Error: Into<StdError>,
        {
            let conn = tonic::transport::Endpoint::new(dst)?.connect().await?;
            Ok(Self::new(conn))
        }
    }
    impl<T> CampaignBidModifierServiceClient<T>
    where
        T: tonic::client::GrpcService<tonic::body::BoxBody>,
        T::ResponseBody: Body + HttpBody + Send + 'static,
        T::Error: Into<StdError>,
        <T::ResponseBody as HttpBody>::Error: Into<StdError> + Send,
    {
        pub fn new(inner: T) -> Self {
            let inner = tonic::client::Grpc::new(inner);
            Self { inner }
        }
        pub fn with_interceptor(inner: T, interceptor: impl Into<tonic::Interceptor>) -> Self {
            let inner = tonic::client::Grpc::with_interceptor(inner, interceptor);
            Self { inner }
        }
        #[doc = " Returns the requested campaign bid modifier in full detail."]
        pub async fn get_campaign_bid_modifier(
            &mut self,
            request: impl tonic::IntoRequest<super::GetCampaignBidModifierRequest>,
        ) -> Result<tonic::Response<super::super::resources::CampaignBidModifier>, tonic::Status>
        {
            self.inner.ready().await.map_err(|e| {
                tonic::Status::new(
                    tonic::Code::Unknown,
                    format!("Service was not ready: {}", e.into()),
                )
            })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http :: uri :: PathAndQuery :: from_static ( "/google.ads.googleads.v1.services.CampaignBidModifierService/GetCampaignBidModifier" ) ;
            self.inner.unary(request.into_request(), path, codec).await
        }
        #[doc = " Creates, updates, or removes campaign bid modifiers."]
        #[doc = " Operation statuses are returned."]
        pub async fn mutate_campaign_bid_modifiers(
            &mut self,
            request: impl tonic::IntoRequest<super::MutateCampaignBidModifiersRequest>,
        ) -> Result<tonic::Response<super::MutateCampaignBidModifiersResponse>, tonic::Status>
        {
            self.inner.ready().await.map_err(|e| {
                tonic::Status::new(
                    tonic::Code::Unknown,
                    format!("Service was not ready: {}", e.into()),
                )
            })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http :: uri :: PathAndQuery :: from_static ( "/google.ads.googleads.v1.services.CampaignBidModifierService/MutateCampaignBidModifiers" ) ;
            self.inner.unary(request.into_request(), path, codec).await
        }
    }
    impl<T: Clone> Clone for CampaignBidModifierServiceClient<T> {
        fn clone(&self) -> Self {
            Self {
                inner: self.inner.clone(),
            }
        }
    }
    impl<T> std::fmt::Debug for CampaignBidModifierServiceClient<T> {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
            write!(f, "CampaignBidModifierServiceClient {{ ... }}")
        }
    }
}
#[doc = r" Generated server implementations."]
pub mod campaign_bid_modifier_service_server {
    #![allow(unused_variables, dead_code, missing_docs)]
    use tonic::codegen::*;
    #[doc = "Generated trait containing gRPC methods that should be implemented for use with CampaignBidModifierServiceServer."]
    #[async_trait]
    pub trait CampaignBidModifierService: Send + Sync + 'static {
        #[doc = " Returns the requested campaign bid modifier in full detail."]
        async fn get_campaign_bid_modifier(
            &self,
            request: tonic::Request<super::GetCampaignBidModifierRequest>,
        ) -> Result<tonic::Response<super::super::resources::CampaignBidModifier>, tonic::Status>;
        #[doc = " Creates, updates, or removes campaign bid modifiers."]
        #[doc = " Operation statuses are returned."]
        async fn mutate_campaign_bid_modifiers(
            &self,
            request: tonic::Request<super::MutateCampaignBidModifiersRequest>,
        ) -> Result<tonic::Response<super::MutateCampaignBidModifiersResponse>, tonic::Status>;
    }
    #[doc = " Service to manage campaign bid modifiers."]
    #[derive(Debug)]
    #[doc(hidden)]
    pub struct CampaignBidModifierServiceServer<T: CampaignBidModifierService> {
        inner: _Inner<T>,
    }
    struct _Inner<T>(Arc<T>, Option<tonic::Interceptor>);
    impl<T: CampaignBidModifierService> CampaignBidModifierServiceServer<T> {
        pub fn new(inner: T) -> Self {
            let inner = Arc::new(inner);
            let inner = _Inner(inner, None);
            Self { inner }
        }
        pub fn with_interceptor(inner: T, interceptor: impl Into<tonic::Interceptor>) -> Self {
            let inner = Arc::new(inner);
            let inner = _Inner(inner, Some(interceptor.into()));
            Self { inner }
        }
    }
    impl<T, B> Service<http::Request<B>> for CampaignBidModifierServiceServer<T>
    where
        T: CampaignBidModifierService,
        B: HttpBody + Send + Sync + 'static,
        B::Error: Into<StdError> + Send + 'static,
    {
        type Response = http::Response<tonic::body::BoxBody>;
        type Error = Never;
        type Future = BoxFuture<Self::Response, Self::Error>;
        fn poll_ready(&mut self, _cx: &mut Context<'_>) -> Poll<Result<(), Self::Error>> {
            Poll::Ready(Ok(()))
        }
        fn call(&mut self, req: http::Request<B>) -> Self::Future {
            let inner = self.inner.clone();
            match req . uri ( ) . path ( ) { "/google.ads.googleads.v1.services.CampaignBidModifierService/GetCampaignBidModifier" => { # [ allow ( non_camel_case_types ) ] struct GetCampaignBidModifierSvc < T : CampaignBidModifierService > ( pub Arc < T > ) ; impl < T : CampaignBidModifierService > tonic :: server :: UnaryService < super :: GetCampaignBidModifierRequest > for GetCampaignBidModifierSvc < T > { type Response = super :: super :: resources :: CampaignBidModifier ; type Future = BoxFuture < tonic :: Response < Self :: Response > , tonic :: Status > ; fn call ( & mut self , request : tonic :: Request < super :: GetCampaignBidModifierRequest > ) -> Self :: Future { let inner = self . 0 . clone ( ) ; let fut = async move { inner . get_campaign_bid_modifier ( request ) . await } ; Box :: pin ( fut ) } } let inner = self . inner . clone ( ) ; let fut = async move { let interceptor = inner . 1 . clone ( ) ; let inner = inner . 0 ; let method = GetCampaignBidModifierSvc ( inner ) ; let codec = tonic :: codec :: ProstCodec :: default ( ) ; let mut grpc = if let Some ( interceptor ) = interceptor { tonic :: server :: Grpc :: with_interceptor ( codec , interceptor ) } else { tonic :: server :: Grpc :: new ( codec ) } ; let res = grpc . unary ( method , req ) . await ; Ok ( res ) } ; Box :: pin ( fut ) } "/google.ads.googleads.v1.services.CampaignBidModifierService/MutateCampaignBidModifiers" => { # [ allow ( non_camel_case_types ) ] struct MutateCampaignBidModifiersSvc < T : CampaignBidModifierService > ( pub Arc < T > ) ; impl < T : CampaignBidModifierService > tonic :: server :: UnaryService < super :: MutateCampaignBidModifiersRequest > for MutateCampaignBidModifiersSvc < T > { type Response = super :: MutateCampaignBidModifiersResponse ; type Future = BoxFuture < tonic :: Response < Self :: Response > , tonic :: Status > ; fn call ( & mut self , request : tonic :: Request < super :: MutateCampaignBidModifiersRequest > ) -> Self :: Future { let inner = self . 0 . clone ( ) ; let fut = async move { inner . mutate_campaign_bid_modifiers ( request ) . await } ; Box :: pin ( fut ) } } let inner = self . inner . clone ( ) ; let fut = async move { let interceptor = inner . 1 . clone ( ) ; let inner = inner . 0 ; let method = MutateCampaignBidModifiersSvc ( inner ) ; let codec = tonic :: codec :: ProstCodec :: default ( ) ; let mut grpc = if let Some ( interceptor ) = interceptor { tonic :: server :: Grpc :: with_interceptor ( codec , interceptor ) } else { tonic :: server :: Grpc :: new ( codec ) } ; let res = grpc . unary ( method , req ) . await ; Ok ( res ) } ; Box :: pin ( fut ) } _ => Box :: pin ( async move { Ok ( http :: Response :: builder ( ) . status ( 200 ) . header ( "grpc-status" , "12" ) . body ( tonic :: body :: BoxBody :: empty ( ) ) . unwrap ( ) ) } ) , }
        }
    }
    impl<T: CampaignBidModifierService> Clone for CampaignBidModifierServiceServer<T> {
        fn clone(&self) -> Self {
            let inner = self.inner.clone();
            Self { inner }
        }
    }
    impl<T: CampaignBidModifierService> Clone for _Inner<T> {
        fn clone(&self) -> Self {
            Self(self.0.clone(), self.1.clone())
        }
    }
    impl<T: std::fmt::Debug> std::fmt::Debug for _Inner<T> {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
            write!(f, "{:?}", self.0)
        }
    }
    impl<T: CampaignBidModifierService> tonic::transport::NamedService
        for CampaignBidModifierServiceServer<T>
    {
        const NAME: &'static str = "google.ads.googleads.v1.services.CampaignBidModifierService";
    }
}
/// Request message for [CampaignBudgetService.GetCampaignBudget][google.ads.googleads.v1.services.CampaignBudgetService.GetCampaignBudget].
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GetCampaignBudgetRequest {
    /// Required. The resource name of the campaign budget to fetch.
    #[prost(string, tag = "1")]
    pub resource_name: std::string::String,
}
/// Request message for [CampaignBudgetService.MutateCampaignBudgets][google.ads.googleads.v1.services.CampaignBudgetService.MutateCampaignBudgets].
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct MutateCampaignBudgetsRequest {
    /// Required. The ID of the customer whose campaign budgets are being modified.
    #[prost(string, tag = "1")]
    pub customer_id: std::string::String,
    /// Required. The list of operations to perform on individual campaign budgets.
    #[prost(message, repeated, tag = "2")]
    pub operations: ::std::vec::Vec<CampaignBudgetOperation>,
    /// If true, successful operations will be carried out and invalid
    /// operations will return errors. If false, all operations will be carried
    /// out in one transaction if and only if they are all valid.
    /// Default is false.
    #[prost(bool, tag = "3")]
    pub partial_failure: bool,
    /// If true, the request is validated but not executed. Only errors are
    /// returned, not results.
    #[prost(bool, tag = "4")]
    pub validate_only: bool,
}
/// A single operation (create, update, remove) on a campaign budget.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CampaignBudgetOperation {
    /// FieldMask that determines which resource fields are modified in an update.
    #[prost(message, optional, tag = "4")]
    pub update_mask: ::std::option::Option<::prost_types::FieldMask>,
    /// The mutate operation.
    #[prost(oneof = "campaign_budget_operation::Operation", tags = "1, 2, 3")]
    pub operation: ::std::option::Option<campaign_budget_operation::Operation>,
}
pub mod campaign_budget_operation {
    /// The mutate operation.
    #[derive(Clone, PartialEq, ::prost::Oneof)]
    pub enum Operation {
        /// Create operation: No resource name is expected for the new budget.
        #[prost(message, tag = "1")]
        Create(super::super::resources::CampaignBudget),
        /// Update operation: The campaign budget is expected to have a valid
        /// resource name.
        #[prost(message, tag = "2")]
        Update(super::super::resources::CampaignBudget),
        /// Remove operation: A resource name for the removed budget is expected, in
        /// this format:
        ///
        /// `customers/{customer_id}/campaignBudgets/{budget_id}`
        #[prost(string, tag = "3")]
        Remove(std::string::String),
    }
}
/// Response message for campaign budget mutate.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct MutateCampaignBudgetsResponse {
    /// Errors that pertain to operation failures in the partial failure mode.
    /// Returned only when partial_failure = true and all errors occur inside the
    /// operations. If any errors occur outside the operations (e.g. auth errors),
    /// we return an RPC level error.
    #[prost(message, optional, tag = "3")]
    pub partial_failure_error: ::std::option::Option<super::super::super::super::rpc::Status>,
    /// All results for the mutate.
    #[prost(message, repeated, tag = "2")]
    pub results: ::std::vec::Vec<MutateCampaignBudgetResult>,
}
/// The result for the campaign budget mutate.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct MutateCampaignBudgetResult {
    /// Returned for successful operations.
    #[prost(string, tag = "1")]
    pub resource_name: std::string::String,
}
#[doc = r" Generated client implementations."]
pub mod campaign_budget_service_client {
    #![allow(unused_variables, dead_code, missing_docs)]
    use tonic::codegen::*;
    #[doc = " Service to manage campaign budgets."]
    pub struct CampaignBudgetServiceClient<T> {
        inner: tonic::client::Grpc<T>,
    }
    impl CampaignBudgetServiceClient<tonic::transport::Channel> {
        #[doc = r" Attempt to create a new client by connecting to a given endpoint."]
        pub async fn connect<D>(dst: D) -> Result<Self, tonic::transport::Error>
        where
            D: std::convert::TryInto<tonic::transport::Endpoint>,
            D::Error: Into<StdError>,
        {
            let conn = tonic::transport::Endpoint::new(dst)?.connect().await?;
            Ok(Self::new(conn))
        }
    }
    impl<T> CampaignBudgetServiceClient<T>
    where
        T: tonic::client::GrpcService<tonic::body::BoxBody>,
        T::ResponseBody: Body + HttpBody + Send + 'static,
        T::Error: Into<StdError>,
        <T::ResponseBody as HttpBody>::Error: Into<StdError> + Send,
    {
        pub fn new(inner: T) -> Self {
            let inner = tonic::client::Grpc::new(inner);
            Self { inner }
        }
        pub fn with_interceptor(inner: T, interceptor: impl Into<tonic::Interceptor>) -> Self {
            let inner = tonic::client::Grpc::with_interceptor(inner, interceptor);
            Self { inner }
        }
        #[doc = " Returns the requested Campaign Budget in full detail."]
        pub async fn get_campaign_budget(
            &mut self,
            request: impl tonic::IntoRequest<super::GetCampaignBudgetRequest>,
        ) -> Result<tonic::Response<super::super::resources::CampaignBudget>, tonic::Status>
        {
            self.inner.ready().await.map_err(|e| {
                tonic::Status::new(
                    tonic::Code::Unknown,
                    format!("Service was not ready: {}", e.into()),
                )
            })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.ads.googleads.v1.services.CampaignBudgetService/GetCampaignBudget",
            );
            self.inner.unary(request.into_request(), path, codec).await
        }
        #[doc = " Creates, updates, or removes campaign budgets. Operation statuses are"]
        #[doc = " returned."]
        pub async fn mutate_campaign_budgets(
            &mut self,
            request: impl tonic::IntoRequest<super::MutateCampaignBudgetsRequest>,
        ) -> Result<tonic::Response<super::MutateCampaignBudgetsResponse>, tonic::Status> {
            self.inner.ready().await.map_err(|e| {
                tonic::Status::new(
                    tonic::Code::Unknown,
                    format!("Service was not ready: {}", e.into()),
                )
            })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.ads.googleads.v1.services.CampaignBudgetService/MutateCampaignBudgets",
            );
            self.inner.unary(request.into_request(), path, codec).await
        }
    }
    impl<T: Clone> Clone for CampaignBudgetServiceClient<T> {
        fn clone(&self) -> Self {
            Self {
                inner: self.inner.clone(),
            }
        }
    }
    impl<T> std::fmt::Debug for CampaignBudgetServiceClient<T> {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
            write!(f, "CampaignBudgetServiceClient {{ ... }}")
        }
    }
}
#[doc = r" Generated server implementations."]
pub mod campaign_budget_service_server {
    #![allow(unused_variables, dead_code, missing_docs)]
    use tonic::codegen::*;
    #[doc = "Generated trait containing gRPC methods that should be implemented for use with CampaignBudgetServiceServer."]
    #[async_trait]
    pub trait CampaignBudgetService: Send + Sync + 'static {
        #[doc = " Returns the requested Campaign Budget in full detail."]
        async fn get_campaign_budget(
            &self,
            request: tonic::Request<super::GetCampaignBudgetRequest>,
        ) -> Result<tonic::Response<super::super::resources::CampaignBudget>, tonic::Status>;
        #[doc = " Creates, updates, or removes campaign budgets. Operation statuses are"]
        #[doc = " returned."]
        async fn mutate_campaign_budgets(
            &self,
            request: tonic::Request<super::MutateCampaignBudgetsRequest>,
        ) -> Result<tonic::Response<super::MutateCampaignBudgetsResponse>, tonic::Status>;
    }
    #[doc = " Service to manage campaign budgets."]
    #[derive(Debug)]
    #[doc(hidden)]
    pub struct CampaignBudgetServiceServer<T: CampaignBudgetService> {
        inner: _Inner<T>,
    }
    struct _Inner<T>(Arc<T>, Option<tonic::Interceptor>);
    impl<T: CampaignBudgetService> CampaignBudgetServiceServer<T> {
        pub fn new(inner: T) -> Self {
            let inner = Arc::new(inner);
            let inner = _Inner(inner, None);
            Self { inner }
        }
        pub fn with_interceptor(inner: T, interceptor: impl Into<tonic::Interceptor>) -> Self {
            let inner = Arc::new(inner);
            let inner = _Inner(inner, Some(interceptor.into()));
            Self { inner }
        }
    }
    impl<T, B> Service<http::Request<B>> for CampaignBudgetServiceServer<T>
    where
        T: CampaignBudgetService,
        B: HttpBody + Send + Sync + 'static,
        B::Error: Into<StdError> + Send + 'static,
    {
        type Response = http::Response<tonic::body::BoxBody>;
        type Error = Never;
        type Future = BoxFuture<Self::Response, Self::Error>;
        fn poll_ready(&mut self, _cx: &mut Context<'_>) -> Poll<Result<(), Self::Error>> {
            Poll::Ready(Ok(()))
        }
        fn call(&mut self, req: http::Request<B>) -> Self::Future {
            let inner = self.inner.clone();
            match req.uri().path() {
                "/google.ads.googleads.v1.services.CampaignBudgetService/GetCampaignBudget" => {
                    #[allow(non_camel_case_types)]
                    struct GetCampaignBudgetSvc<T: CampaignBudgetService>(pub Arc<T>);
                    impl<T: CampaignBudgetService>
                        tonic::server::UnaryService<super::GetCampaignBudgetRequest>
                        for GetCampaignBudgetSvc<T>
                    {
                        type Response = super::super::resources::CampaignBudget;
                        type Future = BoxFuture<tonic::Response<Self::Response>, tonic::Status>;
                        fn call(
                            &mut self,
                            request: tonic::Request<super::GetCampaignBudgetRequest>,
                        ) -> Self::Future {
                            let inner = self.0.clone();
                            let fut = async move { inner.get_campaign_budget(request).await };
                            Box::pin(fut)
                        }
                    }
                    let inner = self.inner.clone();
                    let fut = async move {
                        let interceptor = inner.1.clone();
                        let inner = inner.0;
                        let method = GetCampaignBudgetSvc(inner);
                        let codec = tonic::codec::ProstCodec::default();
                        let mut grpc = if let Some(interceptor) = interceptor {
                            tonic::server::Grpc::with_interceptor(codec, interceptor)
                        } else {
                            tonic::server::Grpc::new(codec)
                        };
                        let res = grpc.unary(method, req).await;
                        Ok(res)
                    };
                    Box::pin(fut)
                }
                "/google.ads.googleads.v1.services.CampaignBudgetService/MutateCampaignBudgets" => {
                    #[allow(non_camel_case_types)]
                    struct MutateCampaignBudgetsSvc<T: CampaignBudgetService>(pub Arc<T>);
                    impl<T: CampaignBudgetService>
                        tonic::server::UnaryService<super::MutateCampaignBudgetsRequest>
                        for MutateCampaignBudgetsSvc<T>
                    {
                        type Response = super::MutateCampaignBudgetsResponse;
                        type Future = BoxFuture<tonic::Response<Self::Response>, tonic::Status>;
                        fn call(
                            &mut self,
                            request: tonic::Request<super::MutateCampaignBudgetsRequest>,
                        ) -> Self::Future {
                            let inner = self.0.clone();
                            let fut = async move { inner.mutate_campaign_budgets(request).await };
                            Box::pin(fut)
                        }
                    }
                    let inner = self.inner.clone();
                    let fut = async move {
                        let interceptor = inner.1.clone();
                        let inner = inner.0;
                        let method = MutateCampaignBudgetsSvc(inner);
                        let codec = tonic::codec::ProstCodec::default();
                        let mut grpc = if let Some(interceptor) = interceptor {
                            tonic::server::Grpc::with_interceptor(codec, interceptor)
                        } else {
                            tonic::server::Grpc::new(codec)
                        };
                        let res = grpc.unary(method, req).await;
                        Ok(res)
                    };
                    Box::pin(fut)
                }
                _ => Box::pin(async move {
                    Ok(http::Response::builder()
                        .status(200)
                        .header("grpc-status", "12")
                        .body(tonic::body::BoxBody::empty())
                        .unwrap())
                }),
            }
        }
    }
    impl<T: CampaignBudgetService> Clone for CampaignBudgetServiceServer<T> {
        fn clone(&self) -> Self {
            let inner = self.inner.clone();
            Self { inner }
        }
    }
    impl<T: CampaignBudgetService> Clone for _Inner<T> {
        fn clone(&self) -> Self {
            Self(self.0.clone(), self.1.clone())
        }
    }
    impl<T: std::fmt::Debug> std::fmt::Debug for _Inner<T> {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
            write!(f, "{:?}", self.0)
        }
    }
    impl<T: CampaignBudgetService> tonic::transport::NamedService for CampaignBudgetServiceServer<T> {
        const NAME: &'static str = "google.ads.googleads.v1.services.CampaignBudgetService";
    }
}
/// Request message for [CampaignCriterionService.GetCampaignCriterion][google.ads.googleads.v1.services.CampaignCriterionService.GetCampaignCriterion].
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GetCampaignCriterionRequest {
    /// Required. The resource name of the criterion to fetch.
    #[prost(string, tag = "1")]
    pub resource_name: std::string::String,
}
/// Request message for [CampaignCriterionService.MutateCampaignCriteria][google.ads.googleads.v1.services.CampaignCriterionService.MutateCampaignCriteria].
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct MutateCampaignCriteriaRequest {
    /// Required. The ID of the customer whose criteria are being modified.
    #[prost(string, tag = "1")]
    pub customer_id: std::string::String,
    /// Required. The list of operations to perform on individual criteria.
    #[prost(message, repeated, tag = "2")]
    pub operations: ::std::vec::Vec<CampaignCriterionOperation>,
    /// If true, successful operations will be carried out and invalid
    /// operations will return errors. If false, all operations will be carried
    /// out in one transaction if and only if they are all valid.
    /// Default is false.
    #[prost(bool, tag = "3")]
    pub partial_failure: bool,
    /// If true, the request is validated but not executed. Only errors are
    /// returned, not results.
    #[prost(bool, tag = "4")]
    pub validate_only: bool,
}
/// A single operation (create, update, remove) on a campaign criterion.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CampaignCriterionOperation {
    /// FieldMask that determines which resource fields are modified in an update.
    #[prost(message, optional, tag = "4")]
    pub update_mask: ::std::option::Option<::prost_types::FieldMask>,
    /// The mutate operation.
    #[prost(oneof = "campaign_criterion_operation::Operation", tags = "1, 2, 3")]
    pub operation: ::std::option::Option<campaign_criterion_operation::Operation>,
}
pub mod campaign_criterion_operation {
    /// The mutate operation.
    #[derive(Clone, PartialEq, ::prost::Oneof)]
    pub enum Operation {
        /// Create operation: No resource name is expected for the new criterion.
        #[prost(message, tag = "1")]
        Create(super::super::resources::CampaignCriterion),
        /// Update operation: The criterion is expected to have a valid resource
        /// name.
        #[prost(message, tag = "2")]
        Update(super::super::resources::CampaignCriterion),
        /// Remove operation: A resource name for the removed criterion is expected,
        /// in this format:
        ///
        /// `customers/{customer_id}/campaignCriteria/{campaign_id}~{criterion_id}`
        #[prost(string, tag = "3")]
        Remove(std::string::String),
    }
}
/// Response message for campaign criterion mutate.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct MutateCampaignCriteriaResponse {
    /// Errors that pertain to operation failures in the partial failure mode.
    /// Returned only when partial_failure = true and all errors occur inside the
    /// operations. If any errors occur outside the operations (e.g. auth errors),
    /// we return an RPC level error.
    #[prost(message, optional, tag = "3")]
    pub partial_failure_error: ::std::option::Option<super::super::super::super::rpc::Status>,
    /// All results for the mutate.
    #[prost(message, repeated, tag = "2")]
    pub results: ::std::vec::Vec<MutateCampaignCriterionResult>,
}
/// The result for the criterion mutate.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct MutateCampaignCriterionResult {
    /// Returned for successful operations.
    #[prost(string, tag = "1")]
    pub resource_name: std::string::String,
}
#[doc = r" Generated client implementations."]
pub mod campaign_criterion_service_client {
    #![allow(unused_variables, dead_code, missing_docs)]
    use tonic::codegen::*;
    #[doc = " Service to manage campaign criteria."]
    pub struct CampaignCriterionServiceClient<T> {
        inner: tonic::client::Grpc<T>,
    }
    impl CampaignCriterionServiceClient<tonic::transport::Channel> {
        #[doc = r" Attempt to create a new client by connecting to a given endpoint."]
        pub async fn connect<D>(dst: D) -> Result<Self, tonic::transport::Error>
        where
            D: std::convert::TryInto<tonic::transport::Endpoint>,
            D::Error: Into<StdError>,
        {
            let conn = tonic::transport::Endpoint::new(dst)?.connect().await?;
            Ok(Self::new(conn))
        }
    }
    impl<T> CampaignCriterionServiceClient<T>
    where
        T: tonic::client::GrpcService<tonic::body::BoxBody>,
        T::ResponseBody: Body + HttpBody + Send + 'static,
        T::Error: Into<StdError>,
        <T::ResponseBody as HttpBody>::Error: Into<StdError> + Send,
    {
        pub fn new(inner: T) -> Self {
            let inner = tonic::client::Grpc::new(inner);
            Self { inner }
        }
        pub fn with_interceptor(inner: T, interceptor: impl Into<tonic::Interceptor>) -> Self {
            let inner = tonic::client::Grpc::with_interceptor(inner, interceptor);
            Self { inner }
        }
        #[doc = " Returns the requested criterion in full detail."]
        pub async fn get_campaign_criterion(
            &mut self,
            request: impl tonic::IntoRequest<super::GetCampaignCriterionRequest>,
        ) -> Result<tonic::Response<super::super::resources::CampaignCriterion>, tonic::Status>
        {
            self.inner.ready().await.map_err(|e| {
                tonic::Status::new(
                    tonic::Code::Unknown,
                    format!("Service was not ready: {}", e.into()),
                )
            })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.ads.googleads.v1.services.CampaignCriterionService/GetCampaignCriterion",
            );
            self.inner.unary(request.into_request(), path, codec).await
        }
        #[doc = " Creates, updates, or removes criteria. Operation statuses are returned."]
        pub async fn mutate_campaign_criteria(
            &mut self,
            request: impl tonic::IntoRequest<super::MutateCampaignCriteriaRequest>,
        ) -> Result<tonic::Response<super::MutateCampaignCriteriaResponse>, tonic::Status> {
            self.inner.ready().await.map_err(|e| {
                tonic::Status::new(
                    tonic::Code::Unknown,
                    format!("Service was not ready: {}", e.into()),
                )
            })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.ads.googleads.v1.services.CampaignCriterionService/MutateCampaignCriteria",
            );
            self.inner.unary(request.into_request(), path, codec).await
        }
    }
    impl<T: Clone> Clone for CampaignCriterionServiceClient<T> {
        fn clone(&self) -> Self {
            Self {
                inner: self.inner.clone(),
            }
        }
    }
    impl<T> std::fmt::Debug for CampaignCriterionServiceClient<T> {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
            write!(f, "CampaignCriterionServiceClient {{ ... }}")
        }
    }
}
#[doc = r" Generated server implementations."]
pub mod campaign_criterion_service_server {
    #![allow(unused_variables, dead_code, missing_docs)]
    use tonic::codegen::*;
    #[doc = "Generated trait containing gRPC methods that should be implemented for use with CampaignCriterionServiceServer."]
    #[async_trait]
    pub trait CampaignCriterionService: Send + Sync + 'static {
        #[doc = " Returns the requested criterion in full detail."]
        async fn get_campaign_criterion(
            &self,
            request: tonic::Request<super::GetCampaignCriterionRequest>,
        ) -> Result<tonic::Response<super::super::resources::CampaignCriterion>, tonic::Status>;
        #[doc = " Creates, updates, or removes criteria. Operation statuses are returned."]
        async fn mutate_campaign_criteria(
            &self,
            request: tonic::Request<super::MutateCampaignCriteriaRequest>,
        ) -> Result<tonic::Response<super::MutateCampaignCriteriaResponse>, tonic::Status>;
    }
    #[doc = " Service to manage campaign criteria."]
    #[derive(Debug)]
    #[doc(hidden)]
    pub struct CampaignCriterionServiceServer<T: CampaignCriterionService> {
        inner: _Inner<T>,
    }
    struct _Inner<T>(Arc<T>, Option<tonic::Interceptor>);
    impl<T: CampaignCriterionService> CampaignCriterionServiceServer<T> {
        pub fn new(inner: T) -> Self {
            let inner = Arc::new(inner);
            let inner = _Inner(inner, None);
            Self { inner }
        }
        pub fn with_interceptor(inner: T, interceptor: impl Into<tonic::Interceptor>) -> Self {
            let inner = Arc::new(inner);
            let inner = _Inner(inner, Some(interceptor.into()));
            Self { inner }
        }
    }
    impl<T, B> Service<http::Request<B>> for CampaignCriterionServiceServer<T>
    where
        T: CampaignCriterionService,
        B: HttpBody + Send + Sync + 'static,
        B::Error: Into<StdError> + Send + 'static,
    {
        type Response = http::Response<tonic::body::BoxBody>;
        type Error = Never;
        type Future = BoxFuture<Self::Response, Self::Error>;
        fn poll_ready(&mut self, _cx: &mut Context<'_>) -> Poll<Result<(), Self::Error>> {
            Poll::Ready(Ok(()))
        }
        fn call(&mut self, req: http::Request<B>) -> Self::Future {
            let inner = self.inner.clone();
            match req . uri ( ) . path ( ) { "/google.ads.googleads.v1.services.CampaignCriterionService/GetCampaignCriterion" => { # [ allow ( non_camel_case_types ) ] struct GetCampaignCriterionSvc < T : CampaignCriterionService > ( pub Arc < T > ) ; impl < T : CampaignCriterionService > tonic :: server :: UnaryService < super :: GetCampaignCriterionRequest > for GetCampaignCriterionSvc < T > { type Response = super :: super :: resources :: CampaignCriterion ; type Future = BoxFuture < tonic :: Response < Self :: Response > , tonic :: Status > ; fn call ( & mut self , request : tonic :: Request < super :: GetCampaignCriterionRequest > ) -> Self :: Future { let inner = self . 0 . clone ( ) ; let fut = async move { inner . get_campaign_criterion ( request ) . await } ; Box :: pin ( fut ) } } let inner = self . inner . clone ( ) ; let fut = async move { let interceptor = inner . 1 . clone ( ) ; let inner = inner . 0 ; let method = GetCampaignCriterionSvc ( inner ) ; let codec = tonic :: codec :: ProstCodec :: default ( ) ; let mut grpc = if let Some ( interceptor ) = interceptor { tonic :: server :: Grpc :: with_interceptor ( codec , interceptor ) } else { tonic :: server :: Grpc :: new ( codec ) } ; let res = grpc . unary ( method , req ) . await ; Ok ( res ) } ; Box :: pin ( fut ) } "/google.ads.googleads.v1.services.CampaignCriterionService/MutateCampaignCriteria" => { # [ allow ( non_camel_case_types ) ] struct MutateCampaignCriteriaSvc < T : CampaignCriterionService > ( pub Arc < T > ) ; impl < T : CampaignCriterionService > tonic :: server :: UnaryService < super :: MutateCampaignCriteriaRequest > for MutateCampaignCriteriaSvc < T > { type Response = super :: MutateCampaignCriteriaResponse ; type Future = BoxFuture < tonic :: Response < Self :: Response > , tonic :: Status > ; fn call ( & mut self , request : tonic :: Request < super :: MutateCampaignCriteriaRequest > ) -> Self :: Future { let inner = self . 0 . clone ( ) ; let fut = async move { inner . mutate_campaign_criteria ( request ) . await } ; Box :: pin ( fut ) } } let inner = self . inner . clone ( ) ; let fut = async move { let interceptor = inner . 1 . clone ( ) ; let inner = inner . 0 ; let method = MutateCampaignCriteriaSvc ( inner ) ; let codec = tonic :: codec :: ProstCodec :: default ( ) ; let mut grpc = if let Some ( interceptor ) = interceptor { tonic :: server :: Grpc :: with_interceptor ( codec , interceptor ) } else { tonic :: server :: Grpc :: new ( codec ) } ; let res = grpc . unary ( method , req ) . await ; Ok ( res ) } ; Box :: pin ( fut ) } _ => Box :: pin ( async move { Ok ( http :: Response :: builder ( ) . status ( 200 ) . header ( "grpc-status" , "12" ) . body ( tonic :: body :: BoxBody :: empty ( ) ) . unwrap ( ) ) } ) , }
        }
    }
    impl<T: CampaignCriterionService> Clone for CampaignCriterionServiceServer<T> {
        fn clone(&self) -> Self {
            let inner = self.inner.clone();
            Self { inner }
        }
    }
    impl<T: CampaignCriterionService> Clone for _Inner<T> {
        fn clone(&self) -> Self {
            Self(self.0.clone(), self.1.clone())
        }
    }
    impl<T: std::fmt::Debug> std::fmt::Debug for _Inner<T> {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
            write!(f, "{:?}", self.0)
        }
    }
    impl<T: CampaignCriterionService> tonic::transport::NamedService
        for CampaignCriterionServiceServer<T>
    {
        const NAME: &'static str = "google.ads.googleads.v1.services.CampaignCriterionService";
    }
}
/// Request message for
/// [CampaignCriterionSimulationService.GetCampaignCriterionSimulation][google.ads.googleads.v1.services.CampaignCriterionSimulationService.GetCampaignCriterionSimulation].
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GetCampaignCriterionSimulationRequest {
    /// Required. The resource name of the campaign criterion simulation to fetch.
    #[prost(string, tag = "1")]
    pub resource_name: std::string::String,
}
#[doc = r" Generated client implementations."]
pub mod campaign_criterion_simulation_service_client {
    #![allow(unused_variables, dead_code, missing_docs)]
    use tonic::codegen::*;
    #[doc = " Service to fetch campaign criterion simulations."]
    pub struct CampaignCriterionSimulationServiceClient<T> {
        inner: tonic::client::Grpc<T>,
    }
    impl CampaignCriterionSimulationServiceClient<tonic::transport::Channel> {
        #[doc = r" Attempt to create a new client by connecting to a given endpoint."]
        pub async fn connect<D>(dst: D) -> Result<Self, tonic::transport::Error>
        where
            D: std::convert::TryInto<tonic::transport::Endpoint>,
            D::Error: Into<StdError>,
        {
            let conn = tonic::transport::Endpoint::new(dst)?.connect().await?;
            Ok(Self::new(conn))
        }
    }
    impl<T> CampaignCriterionSimulationServiceClient<T>
    where
        T: tonic::client::GrpcService<tonic::body::BoxBody>,
        T::ResponseBody: Body + HttpBody + Send + 'static,
        T::Error: Into<StdError>,
        <T::ResponseBody as HttpBody>::Error: Into<StdError> + Send,
    {
        pub fn new(inner: T) -> Self {
            let inner = tonic::client::Grpc::new(inner);
            Self { inner }
        }
        pub fn with_interceptor(inner: T, interceptor: impl Into<tonic::Interceptor>) -> Self {
            let inner = tonic::client::Grpc::with_interceptor(inner, interceptor);
            Self { inner }
        }
        #[doc = " Returns the requested campaign criterion simulation in full detail."]
        pub async fn get_campaign_criterion_simulation(
            &mut self,
            request: impl tonic::IntoRequest<super::GetCampaignCriterionSimulationRequest>,
        ) -> Result<
            tonic::Response<super::super::resources::CampaignCriterionSimulation>,
            tonic::Status,
        > {
            self.inner.ready().await.map_err(|e| {
                tonic::Status::new(
                    tonic::Code::Unknown,
                    format!("Service was not ready: {}", e.into()),
                )
            })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http :: uri :: PathAndQuery :: from_static ( "/google.ads.googleads.v1.services.CampaignCriterionSimulationService/GetCampaignCriterionSimulation" ) ;
            self.inner.unary(request.into_request(), path, codec).await
        }
    }
    impl<T: Clone> Clone for CampaignCriterionSimulationServiceClient<T> {
        fn clone(&self) -> Self {
            Self {
                inner: self.inner.clone(),
            }
        }
    }
    impl<T> std::fmt::Debug for CampaignCriterionSimulationServiceClient<T> {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
            write!(f, "CampaignCriterionSimulationServiceClient {{ ... }}")
        }
    }
}
#[doc = r" Generated server implementations."]
pub mod campaign_criterion_simulation_service_server {
    #![allow(unused_variables, dead_code, missing_docs)]
    use tonic::codegen::*;
    #[doc = "Generated trait containing gRPC methods that should be implemented for use with CampaignCriterionSimulationServiceServer."]
    #[async_trait]
    pub trait CampaignCriterionSimulationService: Send + Sync + 'static {
        #[doc = " Returns the requested campaign criterion simulation in full detail."]
        async fn get_campaign_criterion_simulation(
            &self,
            request: tonic::Request<super::GetCampaignCriterionSimulationRequest>,
        ) -> Result<
            tonic::Response<super::super::resources::CampaignCriterionSimulation>,
            tonic::Status,
        >;
    }
    #[doc = " Service to fetch campaign criterion simulations."]
    #[derive(Debug)]
    #[doc(hidden)]
    pub struct CampaignCriterionSimulationServiceServer<T: CampaignCriterionSimulationService> {
        inner: _Inner<T>,
    }
    struct _Inner<T>(Arc<T>, Option<tonic::Interceptor>);
    impl<T: CampaignCriterionSimulationService> CampaignCriterionSimulationServiceServer<T> {
        pub fn new(inner: T) -> Self {
            let inner = Arc::new(inner);
            let inner = _Inner(inner, None);
            Self { inner }
        }
        pub fn with_interceptor(inner: T, interceptor: impl Into<tonic::Interceptor>) -> Self {
            let inner = Arc::new(inner);
            let inner = _Inner(inner, Some(interceptor.into()));
            Self { inner }
        }
    }
    impl<T, B> Service<http::Request<B>> for CampaignCriterionSimulationServiceServer<T>
    where
        T: CampaignCriterionSimulationService,
        B: HttpBody + Send + Sync + 'static,
        B::Error: Into<StdError> + Send + 'static,
    {
        type Response = http::Response<tonic::body::BoxBody>;
        type Error = Never;
        type Future = BoxFuture<Self::Response, Self::Error>;
        fn poll_ready(&mut self, _cx: &mut Context<'_>) -> Poll<Result<(), Self::Error>> {
            Poll::Ready(Ok(()))
        }
        fn call(&mut self, req: http::Request<B>) -> Self::Future {
            let inner = self.inner.clone();
            match req . uri ( ) . path ( ) { "/google.ads.googleads.v1.services.CampaignCriterionSimulationService/GetCampaignCriterionSimulation" => { # [ allow ( non_camel_case_types ) ] struct GetCampaignCriterionSimulationSvc < T : CampaignCriterionSimulationService > ( pub Arc < T > ) ; impl < T : CampaignCriterionSimulationService > tonic :: server :: UnaryService < super :: GetCampaignCriterionSimulationRequest > for GetCampaignCriterionSimulationSvc < T > { type Response = super :: super :: resources :: CampaignCriterionSimulation ; type Future = BoxFuture < tonic :: Response < Self :: Response > , tonic :: Status > ; fn call ( & mut self , request : tonic :: Request < super :: GetCampaignCriterionSimulationRequest > ) -> Self :: Future { let inner = self . 0 . clone ( ) ; let fut = async move { inner . get_campaign_criterion_simulation ( request ) . await } ; Box :: pin ( fut ) } } let inner = self . inner . clone ( ) ; let fut = async move { let interceptor = inner . 1 . clone ( ) ; let inner = inner . 0 ; let method = GetCampaignCriterionSimulationSvc ( inner ) ; let codec = tonic :: codec :: ProstCodec :: default ( ) ; let mut grpc = if let Some ( interceptor ) = interceptor { tonic :: server :: Grpc :: with_interceptor ( codec , interceptor ) } else { tonic :: server :: Grpc :: new ( codec ) } ; let res = grpc . unary ( method , req ) . await ; Ok ( res ) } ; Box :: pin ( fut ) } _ => Box :: pin ( async move { Ok ( http :: Response :: builder ( ) . status ( 200 ) . header ( "grpc-status" , "12" ) . body ( tonic :: body :: BoxBody :: empty ( ) ) . unwrap ( ) ) } ) , }
        }
    }
    impl<T: CampaignCriterionSimulationService> Clone for CampaignCriterionSimulationServiceServer<T> {
        fn clone(&self) -> Self {
            let inner = self.inner.clone();
            Self { inner }
        }
    }
    impl<T: CampaignCriterionSimulationService> Clone for _Inner<T> {
        fn clone(&self) -> Self {
            Self(self.0.clone(), self.1.clone())
        }
    }
    impl<T: std::fmt::Debug> std::fmt::Debug for _Inner<T> {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
            write!(f, "{:?}", self.0)
        }
    }
    impl<T: CampaignCriterionSimulationService> tonic::transport::NamedService
        for CampaignCriterionSimulationServiceServer<T>
    {
        const NAME: &'static str =
            "google.ads.googleads.v1.services.CampaignCriterionSimulationService";
    }
}
/// Request message for [CampaignDraftService.GetCampaignDraft][google.ads.googleads.v1.services.CampaignDraftService.GetCampaignDraft].
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GetCampaignDraftRequest {
    /// Required. The resource name of the campaign draft to fetch.
    #[prost(string, tag = "1")]
    pub resource_name: std::string::String,
}
/// Request message for [CampaignDraftService.MutateCampaignDrafts][google.ads.googleads.v1.services.CampaignDraftService.MutateCampaignDrafts].
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct MutateCampaignDraftsRequest {
    /// Required. The ID of the customer whose campaign drafts are being modified.
    #[prost(string, tag = "1")]
    pub customer_id: std::string::String,
    /// Required. The list of operations to perform on individual campaign drafts.
    #[prost(message, repeated, tag = "2")]
    pub operations: ::std::vec::Vec<CampaignDraftOperation>,
    /// If true, successful operations will be carried out and invalid
    /// operations will return errors. If false, all operations will be carried
    /// out in one transaction if and only if they are all valid.
    /// Default is false.
    #[prost(bool, tag = "3")]
    pub partial_failure: bool,
    /// If true, the request is validated but not executed. Only errors are
    /// returned, not results.
    #[prost(bool, tag = "4")]
    pub validate_only: bool,
}
/// Request message for [CampaignDraftService.PromoteCampaignDraft][google.ads.googleads.v1.services.CampaignDraftService.PromoteCampaignDraft].
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct PromoteCampaignDraftRequest {
    /// Required. The resource name of the campaign draft to promote.
    #[prost(string, tag = "1")]
    pub campaign_draft: std::string::String,
}
/// A single operation (create, update, remove) on a campaign draft.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CampaignDraftOperation {
    /// FieldMask that determines which resource fields are modified in an update.
    #[prost(message, optional, tag = "4")]
    pub update_mask: ::std::option::Option<::prost_types::FieldMask>,
    /// The mutate operation.
    #[prost(oneof = "campaign_draft_operation::Operation", tags = "1, 2, 3")]
    pub operation: ::std::option::Option<campaign_draft_operation::Operation>,
}
pub mod campaign_draft_operation {
    /// The mutate operation.
    #[derive(Clone, PartialEq, ::prost::Oneof)]
    pub enum Operation {
        /// Create operation: No resource name is expected for the new campaign
        /// draft.
        #[prost(message, tag = "1")]
        Create(super::super::resources::CampaignDraft),
        /// Update operation: The campaign draft is expected to have a valid
        /// resource name.
        #[prost(message, tag = "2")]
        Update(super::super::resources::CampaignDraft),
        /// Remove operation: The campaign draft is expected to have a valid
        /// resource name, in this format:
        ///
        /// `customers/{customer_id}/campaignDrafts/{base_campaign_id}~{draft_id}`
        #[prost(string, tag = "3")]
        Remove(std::string::String),
    }
}
/// Response message for campaign draft mutate.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct MutateCampaignDraftsResponse {
    /// Errors that pertain to operation failures in the partial failure mode.
    /// Returned only when partial_failure = true and all errors occur inside the
    /// operations. If any errors occur outside the operations (e.g. auth errors),
    /// we return an RPC level error.
    #[prost(message, optional, tag = "3")]
    pub partial_failure_error: ::std::option::Option<super::super::super::super::rpc::Status>,
    /// All results for the mutate.
    #[prost(message, repeated, tag = "2")]
    pub results: ::std::vec::Vec<MutateCampaignDraftResult>,
}
/// The result for the campaign draft mutate.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct MutateCampaignDraftResult {
    /// Returned for successful operations.
    #[prost(string, tag = "1")]
    pub resource_name: std::string::String,
}
/// Request message for [CampaignDraftService.ListCampaignDraftAsyncErrors][google.ads.googleads.v1.services.CampaignDraftService.ListCampaignDraftAsyncErrors].
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ListCampaignDraftAsyncErrorsRequest {
    /// Required. The name of the campaign draft from which to retrieve the async errors.
    #[prost(string, tag = "1")]
    pub resource_name: std::string::String,
    /// Token of the page to retrieve. If not specified, the first
    /// page of results will be returned. Use the value obtained from
    /// `next_page_token` in the previous response in order to request
    /// the next page of results.
    #[prost(string, tag = "2")]
    pub page_token: std::string::String,
    /// Number of elements to retrieve in a single page.
    /// When a page request is too large, the server may decide to
    /// further limit the number of returned resources.
    #[prost(int32, tag = "3")]
    pub page_size: i32,
}
/// Response message for [CampaignDraftService.ListCampaignDraftAsyncErrors][google.ads.googleads.v1.services.CampaignDraftService.ListCampaignDraftAsyncErrors].
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ListCampaignDraftAsyncErrorsResponse {
    /// Details of the errors when performing the asynchronous operation.
    #[prost(message, repeated, tag = "1")]
    pub errors: ::std::vec::Vec<super::super::super::super::rpc::Status>,
    /// Pagination token used to retrieve the next page of results.
    /// Pass the content of this string as the `page_token` attribute of
    /// the next request. `next_page_token` is not returned for the last
    /// page.
    #[prost(string, tag = "2")]
    pub next_page_token: std::string::String,
}
#[doc = r" Generated client implementations."]
pub mod campaign_draft_service_client {
    #![allow(unused_variables, dead_code, missing_docs)]
    use tonic::codegen::*;
    #[doc = " Service to manage campaign drafts."]
    pub struct CampaignDraftServiceClient<T> {
        inner: tonic::client::Grpc<T>,
    }
    impl CampaignDraftServiceClient<tonic::transport::Channel> {
        #[doc = r" Attempt to create a new client by connecting to a given endpoint."]
        pub async fn connect<D>(dst: D) -> Result<Self, tonic::transport::Error>
        where
            D: std::convert::TryInto<tonic::transport::Endpoint>,
            D::Error: Into<StdError>,
        {
            let conn = tonic::transport::Endpoint::new(dst)?.connect().await?;
            Ok(Self::new(conn))
        }
    }
    impl<T> CampaignDraftServiceClient<T>
    where
        T: tonic::client::GrpcService<tonic::body::BoxBody>,
        T::ResponseBody: Body + HttpBody + Send + 'static,
        T::Error: Into<StdError>,
        <T::ResponseBody as HttpBody>::Error: Into<StdError> + Send,
    {
        pub fn new(inner: T) -> Self {
            let inner = tonic::client::Grpc::new(inner);
            Self { inner }
        }
        pub fn with_interceptor(inner: T, interceptor: impl Into<tonic::Interceptor>) -> Self {
            let inner = tonic::client::Grpc::with_interceptor(inner, interceptor);
            Self { inner }
        }
        #[doc = " Returns the requested campaign draft in full detail."]
        pub async fn get_campaign_draft(
            &mut self,
            request: impl tonic::IntoRequest<super::GetCampaignDraftRequest>,
        ) -> Result<tonic::Response<super::super::resources::CampaignDraft>, tonic::Status>
        {
            self.inner.ready().await.map_err(|e| {
                tonic::Status::new(
                    tonic::Code::Unknown,
                    format!("Service was not ready: {}", e.into()),
                )
            })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.ads.googleads.v1.services.CampaignDraftService/GetCampaignDraft",
            );
            self.inner.unary(request.into_request(), path, codec).await
        }
        #[doc = " Creates, updates, or removes campaign drafts. Operation statuses are"]
        #[doc = " returned."]
        pub async fn mutate_campaign_drafts(
            &mut self,
            request: impl tonic::IntoRequest<super::MutateCampaignDraftsRequest>,
        ) -> Result<tonic::Response<super::MutateCampaignDraftsResponse>, tonic::Status> {
            self.inner.ready().await.map_err(|e| {
                tonic::Status::new(
                    tonic::Code::Unknown,
                    format!("Service was not ready: {}", e.into()),
                )
            })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.ads.googleads.v1.services.CampaignDraftService/MutateCampaignDrafts",
            );
            self.inner.unary(request.into_request(), path, codec).await
        }
        #[doc = " Promotes the changes in a draft back to the base campaign."]
        #[doc = ""]
        #[doc = " This method returns a Long Running Operation (LRO) indicating if the"]
        #[doc = " Promote is done. Use [Operations.GetOperation] to poll the LRO until it"]
        #[doc = " is done. Only a done status is returned in the response. See the status"]
        #[doc = " in the Campaign Draft resource to determine if the promotion was"]
        #[doc = " successful. If the LRO failed, use"]
        #[doc = " [CampaignDraftService.ListCampaignDraftAsyncErrors][google.ads.googleads.v1.services.CampaignDraftService.ListCampaignDraftAsyncErrors] to view the list of"]
        #[doc = " error reasons."]
        pub async fn promote_campaign_draft(
            &mut self,
            request: impl tonic::IntoRequest<super::PromoteCampaignDraftRequest>,
        ) -> Result<
            tonic::Response<super::super::super::super::super::longrunning::Operation>,
            tonic::Status,
        > {
            self.inner.ready().await.map_err(|e| {
                tonic::Status::new(
                    tonic::Code::Unknown,
                    format!("Service was not ready: {}", e.into()),
                )
            })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.ads.googleads.v1.services.CampaignDraftService/PromoteCampaignDraft",
            );
            self.inner.unary(request.into_request(), path, codec).await
        }
        #[doc = " Returns all errors that occurred during CampaignDraft promote. Throws an"]
        #[doc = " error if called before campaign draft is promoted."]
        #[doc = " Supports standard list paging."]
        pub async fn list_campaign_draft_async_errors(
            &mut self,
            request: impl tonic::IntoRequest<super::ListCampaignDraftAsyncErrorsRequest>,
        ) -> Result<tonic::Response<super::ListCampaignDraftAsyncErrorsResponse>, tonic::Status>
        {
            self.inner.ready().await.map_err(|e| {
                tonic::Status::new(
                    tonic::Code::Unknown,
                    format!("Service was not ready: {}", e.into()),
                )
            })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http :: uri :: PathAndQuery :: from_static ( "/google.ads.googleads.v1.services.CampaignDraftService/ListCampaignDraftAsyncErrors" ) ;
            self.inner.unary(request.into_request(), path, codec).await
        }
    }
    impl<T: Clone> Clone for CampaignDraftServiceClient<T> {
        fn clone(&self) -> Self {
            Self {
                inner: self.inner.clone(),
            }
        }
    }
    impl<T> std::fmt::Debug for CampaignDraftServiceClient<T> {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
            write!(f, "CampaignDraftServiceClient {{ ... }}")
        }
    }
}
#[doc = r" Generated server implementations."]
pub mod campaign_draft_service_server {
    #![allow(unused_variables, dead_code, missing_docs)]
    use tonic::codegen::*;
    #[doc = "Generated trait containing gRPC methods that should be implemented for use with CampaignDraftServiceServer."]
    #[async_trait]
    pub trait CampaignDraftService: Send + Sync + 'static {
        #[doc = " Returns the requested campaign draft in full detail."]
        async fn get_campaign_draft(
            &self,
            request: tonic::Request<super::GetCampaignDraftRequest>,
        ) -> Result<tonic::Response<super::super::resources::CampaignDraft>, tonic::Status>;
        #[doc = " Creates, updates, or removes campaign drafts. Operation statuses are"]
        #[doc = " returned."]
        async fn mutate_campaign_drafts(
            &self,
            request: tonic::Request<super::MutateCampaignDraftsRequest>,
        ) -> Result<tonic::Response<super::MutateCampaignDraftsResponse>, tonic::Status>;
        #[doc = " Promotes the changes in a draft back to the base campaign."]
        #[doc = ""]
        #[doc = " This method returns a Long Running Operation (LRO) indicating if the"]
        #[doc = " Promote is done. Use [Operations.GetOperation] to poll the LRO until it"]
        #[doc = " is done. Only a done status is returned in the response. See the status"]
        #[doc = " in the Campaign Draft resource to determine if the promotion was"]
        #[doc = " successful. If the LRO failed, use"]
        #[doc = " [CampaignDraftService.ListCampaignDraftAsyncErrors][google.ads.googleads.v1.services.CampaignDraftService.ListCampaignDraftAsyncErrors] to view the list of"]
        #[doc = " error reasons."]
        async fn promote_campaign_draft(
            &self,
            request: tonic::Request<super::PromoteCampaignDraftRequest>,
        ) -> Result<
            tonic::Response<super::super::super::super::super::longrunning::Operation>,
            tonic::Status,
        >;
        #[doc = " Returns all errors that occurred during CampaignDraft promote. Throws an"]
        #[doc = " error if called before campaign draft is promoted."]
        #[doc = " Supports standard list paging."]
        async fn list_campaign_draft_async_errors(
            &self,
            request: tonic::Request<super::ListCampaignDraftAsyncErrorsRequest>,
        ) -> Result<tonic::Response<super::ListCampaignDraftAsyncErrorsResponse>, tonic::Status>;
    }
    #[doc = " Service to manage campaign drafts."]
    #[derive(Debug)]
    #[doc(hidden)]
    pub struct CampaignDraftServiceServer<T: CampaignDraftService> {
        inner: _Inner<T>,
    }
    struct _Inner<T>(Arc<T>, Option<tonic::Interceptor>);
    impl<T: CampaignDraftService> CampaignDraftServiceServer<T> {
        pub fn new(inner: T) -> Self {
            let inner = Arc::new(inner);
            let inner = _Inner(inner, None);
            Self { inner }
        }
        pub fn with_interceptor(inner: T, interceptor: impl Into<tonic::Interceptor>) -> Self {
            let inner = Arc::new(inner);
            let inner = _Inner(inner, Some(interceptor.into()));
            Self { inner }
        }
    }
    impl<T, B> Service<http::Request<B>> for CampaignDraftServiceServer<T>
    where
        T: CampaignDraftService,
        B: HttpBody + Send + Sync + 'static,
        B::Error: Into<StdError> + Send + 'static,
    {
        type Response = http::Response<tonic::body::BoxBody>;
        type Error = Never;
        type Future = BoxFuture<Self::Response, Self::Error>;
        fn poll_ready(&mut self, _cx: &mut Context<'_>) -> Poll<Result<(), Self::Error>> {
            Poll::Ready(Ok(()))
        }
        fn call(&mut self, req: http::Request<B>) -> Self::Future {
            let inner = self.inner.clone();
            match req . uri ( ) . path ( ) { "/google.ads.googleads.v1.services.CampaignDraftService/GetCampaignDraft" => { # [ allow ( non_camel_case_types ) ] struct GetCampaignDraftSvc < T : CampaignDraftService > ( pub Arc < T > ) ; impl < T : CampaignDraftService > tonic :: server :: UnaryService < super :: GetCampaignDraftRequest > for GetCampaignDraftSvc < T > { type Response = super :: super :: resources :: CampaignDraft ; type Future = BoxFuture < tonic :: Response < Self :: Response > , tonic :: Status > ; fn call ( & mut self , request : tonic :: Request < super :: GetCampaignDraftRequest > ) -> Self :: Future { let inner = self . 0 . clone ( ) ; let fut = async move { inner . get_campaign_draft ( request ) . await } ; Box :: pin ( fut ) } } let inner = self . inner . clone ( ) ; let fut = async move { let interceptor = inner . 1 . clone ( ) ; let inner = inner . 0 ; let method = GetCampaignDraftSvc ( inner ) ; let codec = tonic :: codec :: ProstCodec :: default ( ) ; let mut grpc = if let Some ( interceptor ) = interceptor { tonic :: server :: Grpc :: with_interceptor ( codec , interceptor ) } else { tonic :: server :: Grpc :: new ( codec ) } ; let res = grpc . unary ( method , req ) . await ; Ok ( res ) } ; Box :: pin ( fut ) } "/google.ads.googleads.v1.services.CampaignDraftService/MutateCampaignDrafts" => { # [ allow ( non_camel_case_types ) ] struct MutateCampaignDraftsSvc < T : CampaignDraftService > ( pub Arc < T > ) ; impl < T : CampaignDraftService > tonic :: server :: UnaryService < super :: MutateCampaignDraftsRequest > for MutateCampaignDraftsSvc < T > { type Response = super :: MutateCampaignDraftsResponse ; type Future = BoxFuture < tonic :: Response < Self :: Response > , tonic :: Status > ; fn call ( & mut self , request : tonic :: Request < super :: MutateCampaignDraftsRequest > ) -> Self :: Future { let inner = self . 0 . clone ( ) ; let fut = async move { inner . mutate_campaign_drafts ( request ) . await } ; Box :: pin ( fut ) } } let inner = self . inner . clone ( ) ; let fut = async move { let interceptor = inner . 1 . clone ( ) ; let inner = inner . 0 ; let method = MutateCampaignDraftsSvc ( inner ) ; let codec = tonic :: codec :: ProstCodec :: default ( ) ; let mut grpc = if let Some ( interceptor ) = interceptor { tonic :: server :: Grpc :: with_interceptor ( codec , interceptor ) } else { tonic :: server :: Grpc :: new ( codec ) } ; let res = grpc . unary ( method , req ) . await ; Ok ( res ) } ; Box :: pin ( fut ) } "/google.ads.googleads.v1.services.CampaignDraftService/PromoteCampaignDraft" => { # [ allow ( non_camel_case_types ) ] struct PromoteCampaignDraftSvc < T : CampaignDraftService > ( pub Arc < T > ) ; impl < T : CampaignDraftService > tonic :: server :: UnaryService < super :: PromoteCampaignDraftRequest > for PromoteCampaignDraftSvc < T > { type Response = super :: super :: super :: super :: super :: longrunning :: Operation ; type Future = BoxFuture < tonic :: Response < Self :: Response > , tonic :: Status > ; fn call ( & mut self , request : tonic :: Request < super :: PromoteCampaignDraftRequest > ) -> Self :: Future { let inner = self . 0 . clone ( ) ; let fut = async move { inner . promote_campaign_draft ( request ) . await } ; Box :: pin ( fut ) } } let inner = self . inner . clone ( ) ; let fut = async move { let interceptor = inner . 1 . clone ( ) ; let inner = inner . 0 ; let method = PromoteCampaignDraftSvc ( inner ) ; let codec = tonic :: codec :: ProstCodec :: default ( ) ; let mut grpc = if let Some ( interceptor ) = interceptor { tonic :: server :: Grpc :: with_interceptor ( codec , interceptor ) } else { tonic :: server :: Grpc :: new ( codec ) } ; let res = grpc . unary ( method , req ) . await ; Ok ( res ) } ; Box :: pin ( fut ) } "/google.ads.googleads.v1.services.CampaignDraftService/ListCampaignDraftAsyncErrors" => { # [ allow ( non_camel_case_types ) ] struct ListCampaignDraftAsyncErrorsSvc < T : CampaignDraftService > ( pub Arc < T > ) ; impl < T : CampaignDraftService > tonic :: server :: UnaryService < super :: ListCampaignDraftAsyncErrorsRequest > for ListCampaignDraftAsyncErrorsSvc < T > { type Response = super :: ListCampaignDraftAsyncErrorsResponse ; type Future = BoxFuture < tonic :: Response < Self :: Response > , tonic :: Status > ; fn call ( & mut self , request : tonic :: Request < super :: ListCampaignDraftAsyncErrorsRequest > ) -> Self :: Future { let inner = self . 0 . clone ( ) ; let fut = async move { inner . list_campaign_draft_async_errors ( request ) . await } ; Box :: pin ( fut ) } } let inner = self . inner . clone ( ) ; let fut = async move { let interceptor = inner . 1 . clone ( ) ; let inner = inner . 0 ; let method = ListCampaignDraftAsyncErrorsSvc ( inner ) ; let codec = tonic :: codec :: ProstCodec :: default ( ) ; let mut grpc = if let Some ( interceptor ) = interceptor { tonic :: server :: Grpc :: with_interceptor ( codec , interceptor ) } else { tonic :: server :: Grpc :: new ( codec ) } ; let res = grpc . unary ( method , req ) . await ; Ok ( res ) } ; Box :: pin ( fut ) } _ => Box :: pin ( async move { Ok ( http :: Response :: builder ( ) . status ( 200 ) . header ( "grpc-status" , "12" ) . body ( tonic :: body :: BoxBody :: empty ( ) ) . unwrap ( ) ) } ) , }
        }
    }
    impl<T: CampaignDraftService> Clone for CampaignDraftServiceServer<T> {
        fn clone(&self) -> Self {
            let inner = self.inner.clone();
            Self { inner }
        }
    }
    impl<T: CampaignDraftService> Clone for _Inner<T> {
        fn clone(&self) -> Self {
            Self(self.0.clone(), self.1.clone())
        }
    }
    impl<T: std::fmt::Debug> std::fmt::Debug for _Inner<T> {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
            write!(f, "{:?}", self.0)
        }
    }
    impl<T: CampaignDraftService> tonic::transport::NamedService for CampaignDraftServiceServer<T> {
        const NAME: &'static str = "google.ads.googleads.v1.services.CampaignDraftService";
    }
}
/// Request message for [CampaignExperimentService.GetCampaignExperiment][google.ads.googleads.v1.services.CampaignExperimentService.GetCampaignExperiment].
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GetCampaignExperimentRequest {
    /// Required. The resource name of the campaign experiment to fetch.
    #[prost(string, tag = "1")]
    pub resource_name: std::string::String,
}
/// Request message for [CampaignExperimentService.MutateCampaignExperiments][google.ads.googleads.v1.services.CampaignExperimentService.MutateCampaignExperiments].
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct MutateCampaignExperimentsRequest {
    /// Required. The ID of the customer whose campaign experiments are being modified.
    #[prost(string, tag = "1")]
    pub customer_id: std::string::String,
    /// Required. The list of operations to perform on individual campaign experiments.
    #[prost(message, repeated, tag = "2")]
    pub operations: ::std::vec::Vec<CampaignExperimentOperation>,
    /// If true, successful operations will be carried out and invalid
    /// operations will return errors. If false, all operations will be carried
    /// out in one transaction if and only if they are all valid.
    /// Default is false.
    #[prost(bool, tag = "3")]
    pub partial_failure: bool,
    /// If true, the request is validated but not executed. Only errors are
    /// returned, not results.
    #[prost(bool, tag = "4")]
    pub validate_only: bool,
}
/// A single update operation on a campaign experiment.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CampaignExperimentOperation {
    /// FieldMask that determines which resource fields are modified in an update.
    #[prost(message, optional, tag = "3")]
    pub update_mask: ::std::option::Option<::prost_types::FieldMask>,
    /// The mutate operation.
    #[prost(oneof = "campaign_experiment_operation::Operation", tags = "1, 2")]
    pub operation: ::std::option::Option<campaign_experiment_operation::Operation>,
}
pub mod campaign_experiment_operation {
    /// The mutate operation.
    #[derive(Clone, PartialEq, ::prost::Oneof)]
    pub enum Operation {
        /// Update operation: The campaign experiment is expected to have a valid
        /// resource name.
        #[prost(message, tag = "1")]
        Update(super::super::resources::CampaignExperiment),
        /// Remove operation: The campaign experiment is expected to have a valid
        /// resource name, in this format:
        ///
        /// `customers/{customer_id}/campaignExperiments/{campaign_experiment_id}`
        #[prost(string, tag = "2")]
        Remove(std::string::String),
    }
}
/// Response message for campaign experiment mutate.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct MutateCampaignExperimentsResponse {
    /// Errors that pertain to operation failures in the partial failure mode.
    /// Returned only when partial_failure = true and all errors occur inside the
    /// operations. If any errors occur outside the operations (e.g. auth errors),
    /// we return an RPC level error.
    #[prost(message, optional, tag = "3")]
    pub partial_failure_error: ::std::option::Option<super::super::super::super::rpc::Status>,
    /// All results for the mutate.
    #[prost(message, repeated, tag = "2")]
    pub results: ::std::vec::Vec<MutateCampaignExperimentResult>,
}
/// The result for the campaign experiment mutate.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct MutateCampaignExperimentResult {
    /// Returned for successful operations.
    #[prost(string, tag = "1")]
    pub resource_name: std::string::String,
}
/// Request message for [CampaignExperimentService.CreateCampaignExperiment][google.ads.googleads.v1.services.CampaignExperimentService.CreateCampaignExperiment].
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CreateCampaignExperimentRequest {
    /// Required. The ID of the customer whose campaign experiment is being created.
    #[prost(string, tag = "1")]
    pub customer_id: std::string::String,
    /// Required. The campaign experiment to be created.
    #[prost(message, optional, tag = "2")]
    pub campaign_experiment: ::std::option::Option<super::resources::CampaignExperiment>,
    /// If true, the request is validated but not executed. Only errors are
    /// returned, not results.
    #[prost(bool, tag = "3")]
    pub validate_only: bool,
}
/// Message used as metadata returned in Long Running Operations for
/// CreateCampaignExperimentRequest
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CreateCampaignExperimentMetadata {
    /// Resource name of campaign experiment created.
    #[prost(string, tag = "1")]
    pub campaign_experiment: std::string::String,
}
/// Request message for [CampaignExperimentService.GraduateCampaignExperiment][google.ads.googleads.v1.services.CampaignExperimentService.GraduateCampaignExperiment].
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GraduateCampaignExperimentRequest {
    /// Required. The resource name of the campaign experiment to graduate.
    #[prost(string, tag = "1")]
    pub campaign_experiment: std::string::String,
    /// Required. Resource name of the budget to attach to the campaign graduated from the
    /// experiment.
    #[prost(string, tag = "2")]
    pub campaign_budget: std::string::String,
}
/// Response message for campaign experiment graduate.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GraduateCampaignExperimentResponse {
    /// The resource name of the campaign from the graduated experiment.
    /// This campaign is the same one as CampaignExperiment.experiment_campaign.
    #[prost(string, tag = "1")]
    pub graduated_campaign: std::string::String,
}
/// Request message for [CampaignExperimentService.PromoteCampaignExperiment][google.ads.googleads.v1.services.CampaignExperimentService.PromoteCampaignExperiment].
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct PromoteCampaignExperimentRequest {
    /// Required. The resource name of the campaign experiment to promote.
    #[prost(string, tag = "1")]
    pub campaign_experiment: std::string::String,
}
/// Request message for [CampaignExperimentService.EndCampaignExperiment][google.ads.googleads.v1.services.CampaignExperimentService.EndCampaignExperiment].
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct EndCampaignExperimentRequest {
    /// Required. The resource name of the campaign experiment to end.
    #[prost(string, tag = "1")]
    pub campaign_experiment: std::string::String,
}
/// Request message for
/// [CampaignExperimentService.ListCampaignExperimentAsyncErrors][google.ads.googleads.v1.services.CampaignExperimentService.ListCampaignExperimentAsyncErrors].
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ListCampaignExperimentAsyncErrorsRequest {
    /// Required. The name of the campaign experiment from which to retrieve the async
    /// errors.
    #[prost(string, tag = "1")]
    pub resource_name: std::string::String,
    /// Token of the page to retrieve. If not specified, the first
    /// page of results will be returned. Use the value obtained from
    /// `next_page_token` in the previous response in order to request
    /// the next page of results.
    #[prost(string, tag = "2")]
    pub page_token: std::string::String,
    /// Number of elements to retrieve in a single page.
    /// When a page request is too large, the server may decide to
    /// further limit the number of returned resources.
    #[prost(int32, tag = "3")]
    pub page_size: i32,
}
/// Response message for
/// [CampaignExperimentService.ListCampaignExperimentAsyncErrors][google.ads.googleads.v1.services.CampaignExperimentService.ListCampaignExperimentAsyncErrors].
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ListCampaignExperimentAsyncErrorsResponse {
    /// Details of the errors when performing the asynchronous operation.
    #[prost(message, repeated, tag = "1")]
    pub errors: ::std::vec::Vec<super::super::super::super::rpc::Status>,
    /// Pagination token used to retrieve the next page of results.
    /// Pass the content of this string as the `page_token` attribute of
    /// the next request. `next_page_token` is not returned for the last
    /// page.
    #[prost(string, tag = "2")]
    pub next_page_token: std::string::String,
}
#[doc = r" Generated client implementations."]
pub mod campaign_experiment_service_client {
    #![allow(unused_variables, dead_code, missing_docs)]
    use tonic::codegen::*;
    #[doc = " CampaignExperimentService manages the life cycle of campaign experiments."]
    #[doc = " It is used to create new experiments from drafts, modify experiment"]
    #[doc = " properties, promote changes in an experiment back to its base campaign,"]
    #[doc = " graduate experiments into new stand-alone campaigns, and to remove an"]
    #[doc = " experiment."]
    #[doc = ""]
    #[doc = " An experiment consists of two variants or arms - the base campaign and the"]
    #[doc = " experiment campaign, directing a fixed share of traffic to each arm."]
    #[doc = " A campaign experiment is created from a draft of changes to the base campaign"]
    #[doc = " and will be a snapshot of changes in the draft at the time of creation."]
    pub struct CampaignExperimentServiceClient<T> {
        inner: tonic::client::Grpc<T>,
    }
    impl CampaignExperimentServiceClient<tonic::transport::Channel> {
        #[doc = r" Attempt to create a new client by connecting to a given endpoint."]
        pub async fn connect<D>(dst: D) -> Result<Self, tonic::transport::Error>
        where
            D: std::convert::TryInto<tonic::transport::Endpoint>,
            D::Error: Into<StdError>,
        {
            let conn = tonic::transport::Endpoint::new(dst)?.connect().await?;
            Ok(Self::new(conn))
        }
    }
    impl<T> CampaignExperimentServiceClient<T>
    where
        T: tonic::client::GrpcService<tonic::body::BoxBody>,
        T::ResponseBody: Body + HttpBody + Send + 'static,
        T::Error: Into<StdError>,
        <T::ResponseBody as HttpBody>::Error: Into<StdError> + Send,
    {
        pub fn new(inner: T) -> Self {
            let inner = tonic::client::Grpc::new(inner);
            Self { inner }
        }
        pub fn with_interceptor(inner: T, interceptor: impl Into<tonic::Interceptor>) -> Self {
            let inner = tonic::client::Grpc::with_interceptor(inner, interceptor);
            Self { inner }
        }
        #[doc = " Returns the requested campaign experiment in full detail."]
        pub async fn get_campaign_experiment(
            &mut self,
            request: impl tonic::IntoRequest<super::GetCampaignExperimentRequest>,
        ) -> Result<tonic::Response<super::super::resources::CampaignExperiment>, tonic::Status>
        {
            self.inner.ready().await.map_err(|e| {
                tonic::Status::new(
                    tonic::Code::Unknown,
                    format!("Service was not ready: {}", e.into()),
                )
            })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.ads.googleads.v1.services.CampaignExperimentService/GetCampaignExperiment",
            );
            self.inner.unary(request.into_request(), path, codec).await
        }
        #[doc = " Creates a campaign experiment based on a campaign draft. The draft campaign"]
        #[doc = " will be forked into a real campaign (called the experiment campaign) that"]
        #[doc = " will begin serving ads if successfully created."]
        #[doc = ""]
        #[doc = " The campaign experiment is created immediately with status INITIALIZING."]
        #[doc = " This method return a long running operation that tracks the forking of the"]
        #[doc = " draft campaign. If the forking fails, a list of errors can be retrieved"]
        #[doc = " using the ListCampaignExperimentAsyncErrors method. The operation's"]
        #[doc = " metadata will be a StringValue containing the resource name of the created"]
        #[doc = " campaign experiment."]
        pub async fn create_campaign_experiment(
            &mut self,
            request: impl tonic::IntoRequest<super::CreateCampaignExperimentRequest>,
        ) -> Result<
            tonic::Response<super::super::super::super::super::longrunning::Operation>,
            tonic::Status,
        > {
            self.inner.ready().await.map_err(|e| {
                tonic::Status::new(
                    tonic::Code::Unknown,
                    format!("Service was not ready: {}", e.into()),
                )
            })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http :: uri :: PathAndQuery :: from_static ( "/google.ads.googleads.v1.services.CampaignExperimentService/CreateCampaignExperiment" ) ;
            self.inner.unary(request.into_request(), path, codec).await
        }
        #[doc = " Updates campaign experiments. Operation statuses are returned."]
        pub async fn mutate_campaign_experiments(
            &mut self,
            request: impl tonic::IntoRequest<super::MutateCampaignExperimentsRequest>,
        ) -> Result<tonic::Response<super::MutateCampaignExperimentsResponse>, tonic::Status>
        {
            self.inner.ready().await.map_err(|e| {
                tonic::Status::new(
                    tonic::Code::Unknown,
                    format!("Service was not ready: {}", e.into()),
                )
            })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http :: uri :: PathAndQuery :: from_static ( "/google.ads.googleads.v1.services.CampaignExperimentService/MutateCampaignExperiments" ) ;
            self.inner.unary(request.into_request(), path, codec).await
        }
        #[doc = " Graduates a campaign experiment to a full campaign. The base and experiment"]
        #[doc = " campaigns will start running independently with their own budgets."]
        pub async fn graduate_campaign_experiment(
            &mut self,
            request: impl tonic::IntoRequest<super::GraduateCampaignExperimentRequest>,
        ) -> Result<tonic::Response<super::GraduateCampaignExperimentResponse>, tonic::Status>
        {
            self.inner.ready().await.map_err(|e| {
                tonic::Status::new(
                    tonic::Code::Unknown,
                    format!("Service was not ready: {}", e.into()),
                )
            })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http :: uri :: PathAndQuery :: from_static ( "/google.ads.googleads.v1.services.CampaignExperimentService/GraduateCampaignExperiment" ) ;
            self.inner.unary(request.into_request(), path, codec).await
        }
        #[doc = " Promotes the changes in a experiment campaign back to the base campaign."]
        #[doc = ""]
        #[doc = " The campaign experiment is updated immediately with status PROMOTING."]
        #[doc = " This method return a long running operation that tracks the promoting of"]
        #[doc = " the experiment campaign. If the promoting fails, a list of errors can be"]
        #[doc = " retrieved using the ListCampaignExperimentAsyncErrors method."]
        pub async fn promote_campaign_experiment(
            &mut self,
            request: impl tonic::IntoRequest<super::PromoteCampaignExperimentRequest>,
        ) -> Result<
            tonic::Response<super::super::super::super::super::longrunning::Operation>,
            tonic::Status,
        > {
            self.inner.ready().await.map_err(|e| {
                tonic::Status::new(
                    tonic::Code::Unknown,
                    format!("Service was not ready: {}", e.into()),
                )
            })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http :: uri :: PathAndQuery :: from_static ( "/google.ads.googleads.v1.services.CampaignExperimentService/PromoteCampaignExperiment" ) ;
            self.inner.unary(request.into_request(), path, codec).await
        }
        #[doc = " Immediately ends a campaign experiment, changing the experiment's scheduled"]
        #[doc = " end date and without waiting for end of day. End date is updated to be the"]
        #[doc = " time of the request."]
        pub async fn end_campaign_experiment(
            &mut self,
            request: impl tonic::IntoRequest<super::EndCampaignExperimentRequest>,
        ) -> Result<tonic::Response<()>, tonic::Status> {
            self.inner.ready().await.map_err(|e| {
                tonic::Status::new(
                    tonic::Code::Unknown,
                    format!("Service was not ready: {}", e.into()),
                )
            })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.ads.googleads.v1.services.CampaignExperimentService/EndCampaignExperiment",
            );
            self.inner.unary(request.into_request(), path, codec).await
        }
        #[doc = " Returns all errors that occurred during CampaignExperiment create or"]
        #[doc = " promote (whichever occurred last)."]
        #[doc = " Supports standard list paging."]
        pub async fn list_campaign_experiment_async_errors(
            &mut self,
            request: impl tonic::IntoRequest<super::ListCampaignExperimentAsyncErrorsRequest>,
        ) -> Result<tonic::Response<super::ListCampaignExperimentAsyncErrorsResponse>, tonic::Status>
        {
            self.inner.ready().await.map_err(|e| {
                tonic::Status::new(
                    tonic::Code::Unknown,
                    format!("Service was not ready: {}", e.into()),
                )
            })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http :: uri :: PathAndQuery :: from_static ( "/google.ads.googleads.v1.services.CampaignExperimentService/ListCampaignExperimentAsyncErrors" ) ;
            self.inner.unary(request.into_request(), path, codec).await
        }
    }
    impl<T: Clone> Clone for CampaignExperimentServiceClient<T> {
        fn clone(&self) -> Self {
            Self {
                inner: self.inner.clone(),
            }
        }
    }
    impl<T> std::fmt::Debug for CampaignExperimentServiceClient<T> {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
            write!(f, "CampaignExperimentServiceClient {{ ... }}")
        }
    }
}
#[doc = r" Generated server implementations."]
pub mod campaign_experiment_service_server {
    #![allow(unused_variables, dead_code, missing_docs)]
    use tonic::codegen::*;
    #[doc = "Generated trait containing gRPC methods that should be implemented for use with CampaignExperimentServiceServer."]
    #[async_trait]
    pub trait CampaignExperimentService: Send + Sync + 'static {
        #[doc = " Returns the requested campaign experiment in full detail."]
        async fn get_campaign_experiment(
            &self,
            request: tonic::Request<super::GetCampaignExperimentRequest>,
        ) -> Result<tonic::Response<super::super::resources::CampaignExperiment>, tonic::Status>;
        #[doc = " Creates a campaign experiment based on a campaign draft. The draft campaign"]
        #[doc = " will be forked into a real campaign (called the experiment campaign) that"]
        #[doc = " will begin serving ads if successfully created."]
        #[doc = ""]
        #[doc = " The campaign experiment is created immediately with status INITIALIZING."]
        #[doc = " This method return a long running operation that tracks the forking of the"]
        #[doc = " draft campaign. If the forking fails, a list of errors can be retrieved"]
        #[doc = " using the ListCampaignExperimentAsyncErrors method. The operation's"]
        #[doc = " metadata will be a StringValue containing the resource name of the created"]
        #[doc = " campaign experiment."]
        async fn create_campaign_experiment(
            &self,
            request: tonic::Request<super::CreateCampaignExperimentRequest>,
        ) -> Result<
            tonic::Response<super::super::super::super::super::longrunning::Operation>,
            tonic::Status,
        >;
        #[doc = " Updates campaign experiments. Operation statuses are returned."]
        async fn mutate_campaign_experiments(
            &self,
            request: tonic::Request<super::MutateCampaignExperimentsRequest>,
        ) -> Result<tonic::Response<super::MutateCampaignExperimentsResponse>, tonic::Status>;
        #[doc = " Graduates a campaign experiment to a full campaign. The base and experiment"]
        #[doc = " campaigns will start running independently with their own budgets."]
        async fn graduate_campaign_experiment(
            &self,
            request: tonic::Request<super::GraduateCampaignExperimentRequest>,
        ) -> Result<tonic::Response<super::GraduateCampaignExperimentResponse>, tonic::Status>;
        #[doc = " Promotes the changes in a experiment campaign back to the base campaign."]
        #[doc = ""]
        #[doc = " The campaign experiment is updated immediately with status PROMOTING."]
        #[doc = " This method return a long running operation that tracks the promoting of"]
        #[doc = " the experiment campaign. If the promoting fails, a list of errors can be"]
        #[doc = " retrieved using the ListCampaignExperimentAsyncErrors method."]
        async fn promote_campaign_experiment(
            &self,
            request: tonic::Request<super::PromoteCampaignExperimentRequest>,
        ) -> Result<
            tonic::Response<super::super::super::super::super::longrunning::Operation>,
            tonic::Status,
        >;
        #[doc = " Immediately ends a campaign experiment, changing the experiment's scheduled"]
        #[doc = " end date and without waiting for end of day. End date is updated to be the"]
        #[doc = " time of the request."]
        async fn end_campaign_experiment(
            &self,
            request: tonic::Request<super::EndCampaignExperimentRequest>,
        ) -> Result<tonic::Response<()>, tonic::Status>;
        #[doc = " Returns all errors that occurred during CampaignExperiment create or"]
        #[doc = " promote (whichever occurred last)."]
        #[doc = " Supports standard list paging."]
        async fn list_campaign_experiment_async_errors(
            &self,
            request: tonic::Request<super::ListCampaignExperimentAsyncErrorsRequest>,
        ) -> Result<tonic::Response<super::ListCampaignExperimentAsyncErrorsResponse>, tonic::Status>;
    }
    #[doc = " CampaignExperimentService manages the life cycle of campaign experiments."]
    #[doc = " It is used to create new experiments from drafts, modify experiment"]
    #[doc = " properties, promote changes in an experiment back to its base campaign,"]
    #[doc = " graduate experiments into new stand-alone campaigns, and to remove an"]
    #[doc = " experiment."]
    #[doc = ""]
    #[doc = " An experiment consists of two variants or arms - the base campaign and the"]
    #[doc = " experiment campaign, directing a fixed share of traffic to each arm."]
    #[doc = " A campaign experiment is created from a draft of changes to the base campaign"]
    #[doc = " and will be a snapshot of changes in the draft at the time of creation."]
    #[derive(Debug)]
    #[doc(hidden)]
    pub struct CampaignExperimentServiceServer<T: CampaignExperimentService> {
        inner: _Inner<T>,
    }
    struct _Inner<T>(Arc<T>, Option<tonic::Interceptor>);
    impl<T: CampaignExperimentService> CampaignExperimentServiceServer<T> {
        pub fn new(inner: T) -> Self {
            let inner = Arc::new(inner);
            let inner = _Inner(inner, None);
            Self { inner }
        }
        pub fn with_interceptor(inner: T, interceptor: impl Into<tonic::Interceptor>) -> Self {
            let inner = Arc::new(inner);
            let inner = _Inner(inner, Some(interceptor.into()));
            Self { inner }
        }
    }
    impl<T, B> Service<http::Request<B>> for CampaignExperimentServiceServer<T>
    where
        T: CampaignExperimentService,
        B: HttpBody + Send + Sync + 'static,
        B::Error: Into<StdError> + Send + 'static,
    {
        type Response = http::Response<tonic::body::BoxBody>;
        type Error = Never;
        type Future = BoxFuture<Self::Response, Self::Error>;
        fn poll_ready(&mut self, _cx: &mut Context<'_>) -> Poll<Result<(), Self::Error>> {
            Poll::Ready(Ok(()))
        }
        fn call(&mut self, req: http::Request<B>) -> Self::Future {
            let inner = self.inner.clone();
            match req . uri ( ) . path ( ) { "/google.ads.googleads.v1.services.CampaignExperimentService/GetCampaignExperiment" => { # [ allow ( non_camel_case_types ) ] struct GetCampaignExperimentSvc < T : CampaignExperimentService > ( pub Arc < T > ) ; impl < T : CampaignExperimentService > tonic :: server :: UnaryService < super :: GetCampaignExperimentRequest > for GetCampaignExperimentSvc < T > { type Response = super :: super :: resources :: CampaignExperiment ; type Future = BoxFuture < tonic :: Response < Self :: Response > , tonic :: Status > ; fn call ( & mut self , request : tonic :: Request < super :: GetCampaignExperimentRequest > ) -> Self :: Future { let inner = self . 0 . clone ( ) ; let fut = async move { inner . get_campaign_experiment ( request ) . await } ; Box :: pin ( fut ) } } let inner = self . inner . clone ( ) ; let fut = async move { let interceptor = inner . 1 . clone ( ) ; let inner = inner . 0 ; let method = GetCampaignExperimentSvc ( inner ) ; let codec = tonic :: codec :: ProstCodec :: default ( ) ; let mut grpc = if let Some ( interceptor ) = interceptor { tonic :: server :: Grpc :: with_interceptor ( codec , interceptor ) } else { tonic :: server :: Grpc :: new ( codec ) } ; let res = grpc . unary ( method , req ) . await ; Ok ( res ) } ; Box :: pin ( fut ) } "/google.ads.googleads.v1.services.CampaignExperimentService/CreateCampaignExperiment" => { # [ allow ( non_camel_case_types ) ] struct CreateCampaignExperimentSvc < T : CampaignExperimentService > ( pub Arc < T > ) ; impl < T : CampaignExperimentService > tonic :: server :: UnaryService < super :: CreateCampaignExperimentRequest > for CreateCampaignExperimentSvc < T > { type Response = super :: super :: super :: super :: super :: longrunning :: Operation ; type Future = BoxFuture < tonic :: Response < Self :: Response > , tonic :: Status > ; fn call ( & mut self , request : tonic :: Request < super :: CreateCampaignExperimentRequest > ) -> Self :: Future { let inner = self . 0 . clone ( ) ; let fut = async move { inner . create_campaign_experiment ( request ) . await } ; Box :: pin ( fut ) } } let inner = self . inner . clone ( ) ; let fut = async move { let interceptor = inner . 1 . clone ( ) ; let inner = inner . 0 ; let method = CreateCampaignExperimentSvc ( inner ) ; let codec = tonic :: codec :: ProstCodec :: default ( ) ; let mut grpc = if let Some ( interceptor ) = interceptor { tonic :: server :: Grpc :: with_interceptor ( codec , interceptor ) } else { tonic :: server :: Grpc :: new ( codec ) } ; let res = grpc . unary ( method , req ) . await ; Ok ( res ) } ; Box :: pin ( fut ) } "/google.ads.googleads.v1.services.CampaignExperimentService/MutateCampaignExperiments" => { # [ allow ( non_camel_case_types ) ] struct MutateCampaignExperimentsSvc < T : CampaignExperimentService > ( pub Arc < T > ) ; impl < T : CampaignExperimentService > tonic :: server :: UnaryService < super :: MutateCampaignExperimentsRequest > for MutateCampaignExperimentsSvc < T > { type Response = super :: MutateCampaignExperimentsResponse ; type Future = BoxFuture < tonic :: Response < Self :: Response > , tonic :: Status > ; fn call ( & mut self , request : tonic :: Request < super :: MutateCampaignExperimentsRequest > ) -> Self :: Future { let inner = self . 0 . clone ( ) ; let fut = async move { inner . mutate_campaign_experiments ( request ) . await } ; Box :: pin ( fut ) } } let inner = self . inner . clone ( ) ; let fut = async move { let interceptor = inner . 1 . clone ( ) ; let inner = inner . 0 ; let method = MutateCampaignExperimentsSvc ( inner ) ; let codec = tonic :: codec :: ProstCodec :: default ( ) ; let mut grpc = if let Some ( interceptor ) = interceptor { tonic :: server :: Grpc :: with_interceptor ( codec , interceptor ) } else { tonic :: server :: Grpc :: new ( codec ) } ; let res = grpc . unary ( method , req ) . await ; Ok ( res ) } ; Box :: pin ( fut ) } "/google.ads.googleads.v1.services.CampaignExperimentService/GraduateCampaignExperiment" => { # [ allow ( non_camel_case_types ) ] struct GraduateCampaignExperimentSvc < T : CampaignExperimentService > ( pub Arc < T > ) ; impl < T : CampaignExperimentService > tonic :: server :: UnaryService < super :: GraduateCampaignExperimentRequest > for GraduateCampaignExperimentSvc < T > { type Response = super :: GraduateCampaignExperimentResponse ; type Future = BoxFuture < tonic :: Response < Self :: Response > , tonic :: Status > ; fn call ( & mut self , request : tonic :: Request < super :: GraduateCampaignExperimentRequest > ) -> Self :: Future { let inner = self . 0 . clone ( ) ; let fut = async move { inner . graduate_campaign_experiment ( request ) . await } ; Box :: pin ( fut ) } } let inner = self . inner . clone ( ) ; let fut = async move { let interceptor = inner . 1 . clone ( ) ; let inner = inner . 0 ; let method = GraduateCampaignExperimentSvc ( inner ) ; let codec = tonic :: codec :: ProstCodec :: default ( ) ; let mut grpc = if let Some ( interceptor ) = interceptor { tonic :: server :: Grpc :: with_interceptor ( codec , interceptor ) } else { tonic :: server :: Grpc :: new ( codec ) } ; let res = grpc . unary ( method , req ) . await ; Ok ( res ) } ; Box :: pin ( fut ) } "/google.ads.googleads.v1.services.CampaignExperimentService/PromoteCampaignExperiment" => { # [ allow ( non_camel_case_types ) ] struct PromoteCampaignExperimentSvc < T : CampaignExperimentService > ( pub Arc < T > ) ; impl < T : CampaignExperimentService > tonic :: server :: UnaryService < super :: PromoteCampaignExperimentRequest > for PromoteCampaignExperimentSvc < T > { type Response = super :: super :: super :: super :: super :: longrunning :: Operation ; type Future = BoxFuture < tonic :: Response < Self :: Response > , tonic :: Status > ; fn call ( & mut self , request : tonic :: Request < super :: PromoteCampaignExperimentRequest > ) -> Self :: Future { let inner = self . 0 . clone ( ) ; let fut = async move { inner . promote_campaign_experiment ( request ) . await } ; Box :: pin ( fut ) } } let inner = self . inner . clone ( ) ; let fut = async move { let interceptor = inner . 1 . clone ( ) ; let inner = inner . 0 ; let method = PromoteCampaignExperimentSvc ( inner ) ; let codec = tonic :: codec :: ProstCodec :: default ( ) ; let mut grpc = if let Some ( interceptor ) = interceptor { tonic :: server :: Grpc :: with_interceptor ( codec , interceptor ) } else { tonic :: server :: Grpc :: new ( codec ) } ; let res = grpc . unary ( method , req ) . await ; Ok ( res ) } ; Box :: pin ( fut ) } "/google.ads.googleads.v1.services.CampaignExperimentService/EndCampaignExperiment" => { # [ allow ( non_camel_case_types ) ] struct EndCampaignExperimentSvc < T : CampaignExperimentService > ( pub Arc < T > ) ; impl < T : CampaignExperimentService > tonic :: server :: UnaryService < super :: EndCampaignExperimentRequest > for EndCampaignExperimentSvc < T > { type Response = ( ) ; type Future = BoxFuture < tonic :: Response < Self :: Response > , tonic :: Status > ; fn call ( & mut self , request : tonic :: Request < super :: EndCampaignExperimentRequest > ) -> Self :: Future { let inner = self . 0 . clone ( ) ; let fut = async move { inner . end_campaign_experiment ( request ) . await } ; Box :: pin ( fut ) } } let inner = self . inner . clone ( ) ; let fut = async move { let interceptor = inner . 1 . clone ( ) ; let inner = inner . 0 ; let method = EndCampaignExperimentSvc ( inner ) ; let codec = tonic :: codec :: ProstCodec :: default ( ) ; let mut grpc = if let Some ( interceptor ) = interceptor { tonic :: server :: Grpc :: with_interceptor ( codec , interceptor ) } else { tonic :: server :: Grpc :: new ( codec ) } ; let res = grpc . unary ( method , req ) . await ; Ok ( res ) } ; Box :: pin ( fut ) } "/google.ads.googleads.v1.services.CampaignExperimentService/ListCampaignExperimentAsyncErrors" => { # [ allow ( non_camel_case_types ) ] struct ListCampaignExperimentAsyncErrorsSvc < T : CampaignExperimentService > ( pub Arc < T > ) ; impl < T : CampaignExperimentService > tonic :: server :: UnaryService < super :: ListCampaignExperimentAsyncErrorsRequest > for ListCampaignExperimentAsyncErrorsSvc < T > { type Response = super :: ListCampaignExperimentAsyncErrorsResponse ; type Future = BoxFuture < tonic :: Response < Self :: Response > , tonic :: Status > ; fn call ( & mut self , request : tonic :: Request < super :: ListCampaignExperimentAsyncErrorsRequest > ) -> Self :: Future { let inner = self . 0 . clone ( ) ; let fut = async move { inner . list_campaign_experiment_async_errors ( request ) . await } ; Box :: pin ( fut ) } } let inner = self . inner . clone ( ) ; let fut = async move { let interceptor = inner . 1 . clone ( ) ; let inner = inner . 0 ; let method = ListCampaignExperimentAsyncErrorsSvc ( inner ) ; let codec = tonic :: codec :: ProstCodec :: default ( ) ; let mut grpc = if let Some ( interceptor ) = interceptor { tonic :: server :: Grpc :: with_interceptor ( codec , interceptor ) } else { tonic :: server :: Grpc :: new ( codec ) } ; let res = grpc . unary ( method , req ) . await ; Ok ( res ) } ; Box :: pin ( fut ) } _ => Box :: pin ( async move { Ok ( http :: Response :: builder ( ) . status ( 200 ) . header ( "grpc-status" , "12" ) . body ( tonic :: body :: BoxBody :: empty ( ) ) . unwrap ( ) ) } ) , }
        }
    }
    impl<T: CampaignExperimentService> Clone for CampaignExperimentServiceServer<T> {
        fn clone(&self) -> Self {
            let inner = self.inner.clone();
            Self { inner }
        }
    }
    impl<T: CampaignExperimentService> Clone for _Inner<T> {
        fn clone(&self) -> Self {
            Self(self.0.clone(), self.1.clone())
        }
    }
    impl<T: std::fmt::Debug> std::fmt::Debug for _Inner<T> {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
            write!(f, "{:?}", self.0)
        }
    }
    impl<T: CampaignExperimentService> tonic::transport::NamedService
        for CampaignExperimentServiceServer<T>
    {
        const NAME: &'static str = "google.ads.googleads.v1.services.CampaignExperimentService";
    }
}
/// Request message for
/// [CampaignExtensionSettingService.GetCampaignExtensionSetting][google.ads.googleads.v1.services.CampaignExtensionSettingService.GetCampaignExtensionSetting].
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GetCampaignExtensionSettingRequest {
    /// Required. The resource name of the campaign extension setting to fetch.
    #[prost(string, tag = "1")]
    pub resource_name: std::string::String,
}
/// Request message for
/// [CampaignExtensionSettingService.MutateCampaignExtensionSettings][google.ads.googleads.v1.services.CampaignExtensionSettingService.MutateCampaignExtensionSettings].
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct MutateCampaignExtensionSettingsRequest {
    /// Required. The ID of the customer whose campaign extension settings are being
    /// modified.
    #[prost(string, tag = "1")]
    pub customer_id: std::string::String,
    /// Required. The list of operations to perform on individual campaign extension
    /// settings.
    #[prost(message, repeated, tag = "2")]
    pub operations: ::std::vec::Vec<CampaignExtensionSettingOperation>,
    /// If true, successful operations will be carried out and invalid
    /// operations will return errors. If false, all operations will be carried
    /// out in one transaction if and only if they are all valid.
    /// Default is false.
    #[prost(bool, tag = "3")]
    pub partial_failure: bool,
    /// If true, the request is validated but not executed. Only errors are
    /// returned, not results.
    #[prost(bool, tag = "4")]
    pub validate_only: bool,
}
/// A single operation (create, update, remove) on a campaign extension setting.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CampaignExtensionSettingOperation {
    /// FieldMask that determines which resource fields are modified in an update.
    #[prost(message, optional, tag = "4")]
    pub update_mask: ::std::option::Option<::prost_types::FieldMask>,
    /// The mutate operation.
    #[prost(
        oneof = "campaign_extension_setting_operation::Operation",
        tags = "1, 2, 3"
    )]
    pub operation: ::std::option::Option<campaign_extension_setting_operation::Operation>,
}
pub mod campaign_extension_setting_operation {
    /// The mutate operation.
    #[derive(Clone, PartialEq, ::prost::Oneof)]
    pub enum Operation {
        /// Create operation: No resource name is expected for the new campaign
        /// extension setting.
        #[prost(message, tag = "1")]
        Create(super::super::resources::CampaignExtensionSetting),
        /// Update operation: The campaign extension setting is expected to have a
        /// valid resource name.
        #[prost(message, tag = "2")]
        Update(super::super::resources::CampaignExtensionSetting),
        /// Remove operation: A resource name for the removed campaign extension
        /// setting is expected, in this format:
        ///
        /// `customers/{customer_id}/campaignExtensionSettings/{campaign_id}~{extension_type}`
        #[prost(string, tag = "3")]
        Remove(std::string::String),
    }
}
/// Response message for a campaign extension setting mutate.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct MutateCampaignExtensionSettingsResponse {
    /// Errors that pertain to operation failures in the partial failure mode.
    /// Returned only when partial_failure = true and all errors occur inside the
    /// operations. If any errors occur outside the operations (e.g. auth errors),
    /// we return an RPC level error.
    #[prost(message, optional, tag = "3")]
    pub partial_failure_error: ::std::option::Option<super::super::super::super::rpc::Status>,
    /// All results for the mutate.
    #[prost(message, repeated, tag = "2")]
    pub results: ::std::vec::Vec<MutateCampaignExtensionSettingResult>,
}
/// The result for the campaign extension setting mutate.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct MutateCampaignExtensionSettingResult {
    /// Returned for successful operations.
    #[prost(string, tag = "1")]
    pub resource_name: std::string::String,
}
#[doc = r" Generated client implementations."]
pub mod campaign_extension_setting_service_client {
    #![allow(unused_variables, dead_code, missing_docs)]
    use tonic::codegen::*;
    #[doc = " Service to manage campaign extension settings."]
    pub struct CampaignExtensionSettingServiceClient<T> {
        inner: tonic::client::Grpc<T>,
    }
    impl CampaignExtensionSettingServiceClient<tonic::transport::Channel> {
        #[doc = r" Attempt to create a new client by connecting to a given endpoint."]
        pub async fn connect<D>(dst: D) -> Result<Self, tonic::transport::Error>
        where
            D: std::convert::TryInto<tonic::transport::Endpoint>,
            D::Error: Into<StdError>,
        {
            let conn = tonic::transport::Endpoint::new(dst)?.connect().await?;
            Ok(Self::new(conn))
        }
    }
    impl<T> CampaignExtensionSettingServiceClient<T>
    where
        T: tonic::client::GrpcService<tonic::body::BoxBody>,
        T::ResponseBody: Body + HttpBody + Send + 'static,
        T::Error: Into<StdError>,
        <T::ResponseBody as HttpBody>::Error: Into<StdError> + Send,
    {
        pub fn new(inner: T) -> Self {
            let inner = tonic::client::Grpc::new(inner);
            Self { inner }
        }
        pub fn with_interceptor(inner: T, interceptor: impl Into<tonic::Interceptor>) -> Self {
            let inner = tonic::client::Grpc::with_interceptor(inner, interceptor);
            Self { inner }
        }
        #[doc = " Returns the requested campaign extension setting in full detail."]
        pub async fn get_campaign_extension_setting(
            &mut self,
            request: impl tonic::IntoRequest<super::GetCampaignExtensionSettingRequest>,
        ) -> Result<tonic::Response<super::super::resources::CampaignExtensionSetting>, tonic::Status>
        {
            self.inner.ready().await.map_err(|e| {
                tonic::Status::new(
                    tonic::Code::Unknown,
                    format!("Service was not ready: {}", e.into()),
                )
            })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http :: uri :: PathAndQuery :: from_static ( "/google.ads.googleads.v1.services.CampaignExtensionSettingService/GetCampaignExtensionSetting" ) ;
            self.inner.unary(request.into_request(), path, codec).await
        }
        #[doc = " Creates, updates, or removes campaign extension settings. Operation"]
        #[doc = " statuses are returned."]
        pub async fn mutate_campaign_extension_settings(
            &mut self,
            request: impl tonic::IntoRequest<super::MutateCampaignExtensionSettingsRequest>,
        ) -> Result<tonic::Response<super::MutateCampaignExtensionSettingsResponse>, tonic::Status>
        {
            self.inner.ready().await.map_err(|e| {
                tonic::Status::new(
                    tonic::Code::Unknown,
                    format!("Service was not ready: {}", e.into()),
                )
            })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http :: uri :: PathAndQuery :: from_static ( "/google.ads.googleads.v1.services.CampaignExtensionSettingService/MutateCampaignExtensionSettings" ) ;
            self.inner.unary(request.into_request(), path, codec).await
        }
    }
    impl<T: Clone> Clone for CampaignExtensionSettingServiceClient<T> {
        fn clone(&self) -> Self {
            Self {
                inner: self.inner.clone(),
            }
        }
    }
    impl<T> std::fmt::Debug for CampaignExtensionSettingServiceClient<T> {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
            write!(f, "CampaignExtensionSettingServiceClient {{ ... }}")
        }
    }
}
#[doc = r" Generated server implementations."]
pub mod campaign_extension_setting_service_server {
    #![allow(unused_variables, dead_code, missing_docs)]
    use tonic::codegen::*;
    #[doc = "Generated trait containing gRPC methods that should be implemented for use with CampaignExtensionSettingServiceServer."]
    #[async_trait]
    pub trait CampaignExtensionSettingService: Send + Sync + 'static {
        #[doc = " Returns the requested campaign extension setting in full detail."]
        async fn get_campaign_extension_setting(
            &self,
            request: tonic::Request<super::GetCampaignExtensionSettingRequest>,
        ) -> Result<tonic::Response<super::super::resources::CampaignExtensionSetting>, tonic::Status>;
        #[doc = " Creates, updates, or removes campaign extension settings. Operation"]
        #[doc = " statuses are returned."]
        async fn mutate_campaign_extension_settings(
            &self,
            request: tonic::Request<super::MutateCampaignExtensionSettingsRequest>,
        ) -> Result<tonic::Response<super::MutateCampaignExtensionSettingsResponse>, tonic::Status>;
    }
    #[doc = " Service to manage campaign extension settings."]
    #[derive(Debug)]
    #[doc(hidden)]
    pub struct CampaignExtensionSettingServiceServer<T: CampaignExtensionSettingService> {
        inner: _Inner<T>,
    }
    struct _Inner<T>(Arc<T>, Option<tonic::Interceptor>);
    impl<T: CampaignExtensionSettingService> CampaignExtensionSettingServiceServer<T> {
        pub fn new(inner: T) -> Self {
            let inner = Arc::new(inner);
            let inner = _Inner(inner, None);
            Self { inner }
        }
        pub fn with_interceptor(inner: T, interceptor: impl Into<tonic::Interceptor>) -> Self {
            let inner = Arc::new(inner);
            let inner = _Inner(inner, Some(interceptor.into()));
            Self { inner }
        }
    }
    impl<T, B> Service<http::Request<B>> for CampaignExtensionSettingServiceServer<T>
    where
        T: CampaignExtensionSettingService,
        B: HttpBody + Send + Sync + 'static,
        B::Error: Into<StdError> + Send + 'static,
    {
        type Response = http::Response<tonic::body::BoxBody>;
        type Error = Never;
        type Future = BoxFuture<Self::Response, Self::Error>;
        fn poll_ready(&mut self, _cx: &mut Context<'_>) -> Poll<Result<(), Self::Error>> {
            Poll::Ready(Ok(()))
        }
        fn call(&mut self, req: http::Request<B>) -> Self::Future {
            let inner = self.inner.clone();
            match req . uri ( ) . path ( ) { "/google.ads.googleads.v1.services.CampaignExtensionSettingService/GetCampaignExtensionSetting" => { # [ allow ( non_camel_case_types ) ] struct GetCampaignExtensionSettingSvc < T : CampaignExtensionSettingService > ( pub Arc < T > ) ; impl < T : CampaignExtensionSettingService > tonic :: server :: UnaryService < super :: GetCampaignExtensionSettingRequest > for GetCampaignExtensionSettingSvc < T > { type Response = super :: super :: resources :: CampaignExtensionSetting ; type Future = BoxFuture < tonic :: Response < Self :: Response > , tonic :: Status > ; fn call ( & mut self , request : tonic :: Request < super :: GetCampaignExtensionSettingRequest > ) -> Self :: Future { let inner = self . 0 . clone ( ) ; let fut = async move { inner . get_campaign_extension_setting ( request ) . await } ; Box :: pin ( fut ) } } let inner = self . inner . clone ( ) ; let fut = async move { let interceptor = inner . 1 . clone ( ) ; let inner = inner . 0 ; let method = GetCampaignExtensionSettingSvc ( inner ) ; let codec = tonic :: codec :: ProstCodec :: default ( ) ; let mut grpc = if let Some ( interceptor ) = interceptor { tonic :: server :: Grpc :: with_interceptor ( codec , interceptor ) } else { tonic :: server :: Grpc :: new ( codec ) } ; let res = grpc . unary ( method , req ) . await ; Ok ( res ) } ; Box :: pin ( fut ) } "/google.ads.googleads.v1.services.CampaignExtensionSettingService/MutateCampaignExtensionSettings" => { # [ allow ( non_camel_case_types ) ] struct MutateCampaignExtensionSettingsSvc < T : CampaignExtensionSettingService > ( pub Arc < T > ) ; impl < T : CampaignExtensionSettingService > tonic :: server :: UnaryService < super :: MutateCampaignExtensionSettingsRequest > for MutateCampaignExtensionSettingsSvc < T > { type Response = super :: MutateCampaignExtensionSettingsResponse ; type Future = BoxFuture < tonic :: Response < Self :: Response > , tonic :: Status > ; fn call ( & mut self , request : tonic :: Request < super :: MutateCampaignExtensionSettingsRequest > ) -> Self :: Future { let inner = self . 0 . clone ( ) ; let fut = async move { inner . mutate_campaign_extension_settings ( request ) . await } ; Box :: pin ( fut ) } } let inner = self . inner . clone ( ) ; let fut = async move { let interceptor = inner . 1 . clone ( ) ; let inner = inner . 0 ; let method = MutateCampaignExtensionSettingsSvc ( inner ) ; let codec = tonic :: codec :: ProstCodec :: default ( ) ; let mut grpc = if let Some ( interceptor ) = interceptor { tonic :: server :: Grpc :: with_interceptor ( codec , interceptor ) } else { tonic :: server :: Grpc :: new ( codec ) } ; let res = grpc . unary ( method , req ) . await ; Ok ( res ) } ; Box :: pin ( fut ) } _ => Box :: pin ( async move { Ok ( http :: Response :: builder ( ) . status ( 200 ) . header ( "grpc-status" , "12" ) . body ( tonic :: body :: BoxBody :: empty ( ) ) . unwrap ( ) ) } ) , }
        }
    }
    impl<T: CampaignExtensionSettingService> Clone for CampaignExtensionSettingServiceServer<T> {
        fn clone(&self) -> Self {
            let inner = self.inner.clone();
            Self { inner }
        }
    }
    impl<T: CampaignExtensionSettingService> Clone for _Inner<T> {
        fn clone(&self) -> Self {
            Self(self.0.clone(), self.1.clone())
        }
    }
    impl<T: std::fmt::Debug> std::fmt::Debug for _Inner<T> {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
            write!(f, "{:?}", self.0)
        }
    }
    impl<T: CampaignExtensionSettingService> tonic::transport::NamedService
        for CampaignExtensionSettingServiceServer<T>
    {
        const NAME: &'static str =
            "google.ads.googleads.v1.services.CampaignExtensionSettingService";
    }
}
/// Request message for [CampaignFeedService.GetCampaignFeed][google.ads.googleads.v1.services.CampaignFeedService.GetCampaignFeed].
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GetCampaignFeedRequest {
    /// Required. The resource name of the campaign feed to fetch.
    #[prost(string, tag = "1")]
    pub resource_name: std::string::String,
}
/// Request message for [CampaignFeedService.MutateCampaignFeeds][google.ads.googleads.v1.services.CampaignFeedService.MutateCampaignFeeds].
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct MutateCampaignFeedsRequest {
    /// Required. The ID of the customer whose campaign feeds are being modified.
    #[prost(string, tag = "1")]
    pub customer_id: std::string::String,
    /// Required. The list of operations to perform on individual campaign feeds.
    #[prost(message, repeated, tag = "2")]
    pub operations: ::std::vec::Vec<CampaignFeedOperation>,
    /// If true, successful operations will be carried out and invalid
    /// operations will return errors. If false, all operations will be carried
    /// out in one transaction if and only if they are all valid.
    /// Default is false.
    #[prost(bool, tag = "3")]
    pub partial_failure: bool,
    /// If true, the request is validated but not executed. Only errors are
    /// returned, not results.
    #[prost(bool, tag = "4")]
    pub validate_only: bool,
}
/// A single operation (create, update, remove) on a campaign feed.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CampaignFeedOperation {
    /// FieldMask that determines which resource fields are modified in an update.
    #[prost(message, optional, tag = "4")]
    pub update_mask: ::std::option::Option<::prost_types::FieldMask>,
    /// The mutate operation.
    #[prost(oneof = "campaign_feed_operation::Operation", tags = "1, 2, 3")]
    pub operation: ::std::option::Option<campaign_feed_operation::Operation>,
}
pub mod campaign_feed_operation {
    /// The mutate operation.
    #[derive(Clone, PartialEq, ::prost::Oneof)]
    pub enum Operation {
        /// Create operation: No resource name is expected for the new campaign feed.
        #[prost(message, tag = "1")]
        Create(super::super::resources::CampaignFeed),
        /// Update operation: The campaign feed is expected to have a valid resource
        /// name.
        #[prost(message, tag = "2")]
        Update(super::super::resources::CampaignFeed),
        /// Remove operation: A resource name for the removed campaign feed is
        /// expected, in this format:
        ///
        /// `customers/{customer_id}/campaignFeeds/{campaign_id}~{feed_id}`
        #[prost(string, tag = "3")]
        Remove(std::string::String),
    }
}
/// Response message for a campaign feed mutate.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct MutateCampaignFeedsResponse {
    /// Errors that pertain to operation failures in the partial failure mode.
    /// Returned only when partial_failure = true and all errors occur inside the
    /// operations. If any errors occur outside the operations (e.g. auth errors),
    /// we return an RPC level error.
    #[prost(message, optional, tag = "3")]
    pub partial_failure_error: ::std::option::Option<super::super::super::super::rpc::Status>,
    /// All results for the mutate.
    #[prost(message, repeated, tag = "2")]
    pub results: ::std::vec::Vec<MutateCampaignFeedResult>,
}
/// The result for the campaign feed mutate.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct MutateCampaignFeedResult {
    /// Returned for successful operations.
    #[prost(string, tag = "1")]
    pub resource_name: std::string::String,
}
#[doc = r" Generated client implementations."]
pub mod campaign_feed_service_client {
    #![allow(unused_variables, dead_code, missing_docs)]
    use tonic::codegen::*;
    #[doc = " Service to manage campaign feeds."]
    pub struct CampaignFeedServiceClient<T> {
        inner: tonic::client::Grpc<T>,
    }
    impl CampaignFeedServiceClient<tonic::transport::Channel> {
        #[doc = r" Attempt to create a new client by connecting to a given endpoint."]
        pub async fn connect<D>(dst: D) -> Result<Self, tonic::transport::Error>
        where
            D: std::convert::TryInto<tonic::transport::Endpoint>,
            D::Error: Into<StdError>,
        {
            let conn = tonic::transport::Endpoint::new(dst)?.connect().await?;
            Ok(Self::new(conn))
        }
    }
    impl<T> CampaignFeedServiceClient<T>
    where
        T: tonic::client::GrpcService<tonic::body::BoxBody>,
        T::ResponseBody: Body + HttpBody + Send + 'static,
        T::Error: Into<StdError>,
        <T::ResponseBody as HttpBody>::Error: Into<StdError> + Send,
    {
        pub fn new(inner: T) -> Self {
            let inner = tonic::client::Grpc::new(inner);
            Self { inner }
        }
        pub fn with_interceptor(inner: T, interceptor: impl Into<tonic::Interceptor>) -> Self {
            let inner = tonic::client::Grpc::with_interceptor(inner, interceptor);
            Self { inner }
        }
        #[doc = " Returns the requested campaign feed in full detail."]
        pub async fn get_campaign_feed(
            &mut self,
            request: impl tonic::IntoRequest<super::GetCampaignFeedRequest>,
        ) -> Result<tonic::Response<super::super::resources::CampaignFeed>, tonic::Status> {
            self.inner.ready().await.map_err(|e| {
                tonic::Status::new(
                    tonic::Code::Unknown,
                    format!("Service was not ready: {}", e.into()),
                )
            })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.ads.googleads.v1.services.CampaignFeedService/GetCampaignFeed",
            );
            self.inner.unary(request.into_request(), path, codec).await
        }
        #[doc = " Creates, updates, or removes campaign feeds. Operation statuses are"]
        #[doc = " returned."]
        pub async fn mutate_campaign_feeds(
            &mut self,
            request: impl tonic::IntoRequest<super::MutateCampaignFeedsRequest>,
        ) -> Result<tonic::Response<super::MutateCampaignFeedsResponse>, tonic::Status> {
            self.inner.ready().await.map_err(|e| {
                tonic::Status::new(
                    tonic::Code::Unknown,
                    format!("Service was not ready: {}", e.into()),
                )
            })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.ads.googleads.v1.services.CampaignFeedService/MutateCampaignFeeds",
            );
            self.inner.unary(request.into_request(), path, codec).await
        }
    }
    impl<T: Clone> Clone for CampaignFeedServiceClient<T> {
        fn clone(&self) -> Self {
            Self {
                inner: self.inner.clone(),
            }
        }
    }
    impl<T> std::fmt::Debug for CampaignFeedServiceClient<T> {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
            write!(f, "CampaignFeedServiceClient {{ ... }}")
        }
    }
}
#[doc = r" Generated server implementations."]
pub mod campaign_feed_service_server {
    #![allow(unused_variables, dead_code, missing_docs)]
    use tonic::codegen::*;
    #[doc = "Generated trait containing gRPC methods that should be implemented for use with CampaignFeedServiceServer."]
    #[async_trait]
    pub trait CampaignFeedService: Send + Sync + 'static {
        #[doc = " Returns the requested campaign feed in full detail."]
        async fn get_campaign_feed(
            &self,
            request: tonic::Request<super::GetCampaignFeedRequest>,
        ) -> Result<tonic::Response<super::super::resources::CampaignFeed>, tonic::Status>;
        #[doc = " Creates, updates, or removes campaign feeds. Operation statuses are"]
        #[doc = " returned."]
        async fn mutate_campaign_feeds(
            &self,
            request: tonic::Request<super::MutateCampaignFeedsRequest>,
        ) -> Result<tonic::Response<super::MutateCampaignFeedsResponse>, tonic::Status>;
    }
    #[doc = " Service to manage campaign feeds."]
    #[derive(Debug)]
    #[doc(hidden)]
    pub struct CampaignFeedServiceServer<T: CampaignFeedService> {
        inner: _Inner<T>,
    }
    struct _Inner<T>(Arc<T>, Option<tonic::Interceptor>);
    impl<T: CampaignFeedService> CampaignFeedServiceServer<T> {
        pub fn new(inner: T) -> Self {
            let inner = Arc::new(inner);
            let inner = _Inner(inner, None);
            Self { inner }
        }
        pub fn with_interceptor(inner: T, interceptor: impl Into<tonic::Interceptor>) -> Self {
            let inner = Arc::new(inner);
            let inner = _Inner(inner, Some(interceptor.into()));
            Self { inner }
        }
    }
    impl<T, B> Service<http::Request<B>> for CampaignFeedServiceServer<T>
    where
        T: CampaignFeedService,
        B: HttpBody + Send + Sync + 'static,
        B::Error: Into<StdError> + Send + 'static,
    {
        type Response = http::Response<tonic::body::BoxBody>;
        type Error = Never;
        type Future = BoxFuture<Self::Response, Self::Error>;
        fn poll_ready(&mut self, _cx: &mut Context<'_>) -> Poll<Result<(), Self::Error>> {
            Poll::Ready(Ok(()))
        }
        fn call(&mut self, req: http::Request<B>) -> Self::Future {
            let inner = self.inner.clone();
            match req.uri().path() {
                "/google.ads.googleads.v1.services.CampaignFeedService/GetCampaignFeed" => {
                    #[allow(non_camel_case_types)]
                    struct GetCampaignFeedSvc<T: CampaignFeedService>(pub Arc<T>);
                    impl<T: CampaignFeedService>
                        tonic::server::UnaryService<super::GetCampaignFeedRequest>
                        for GetCampaignFeedSvc<T>
                    {
                        type Response = super::super::resources::CampaignFeed;
                        type Future = BoxFuture<tonic::Response<Self::Response>, tonic::Status>;
                        fn call(
                            &mut self,
                            request: tonic::Request<super::GetCampaignFeedRequest>,
                        ) -> Self::Future {
                            let inner = self.0.clone();
                            let fut = async move { inner.get_campaign_feed(request).await };
                            Box::pin(fut)
                        }
                    }
                    let inner = self.inner.clone();
                    let fut = async move {
                        let interceptor = inner.1.clone();
                        let inner = inner.0;
                        let method = GetCampaignFeedSvc(inner);
                        let codec = tonic::codec::ProstCodec::default();
                        let mut grpc = if let Some(interceptor) = interceptor {
                            tonic::server::Grpc::with_interceptor(codec, interceptor)
                        } else {
                            tonic::server::Grpc::new(codec)
                        };
                        let res = grpc.unary(method, req).await;
                        Ok(res)
                    };
                    Box::pin(fut)
                }
                "/google.ads.googleads.v1.services.CampaignFeedService/MutateCampaignFeeds" => {
                    #[allow(non_camel_case_types)]
                    struct MutateCampaignFeedsSvc<T: CampaignFeedService>(pub Arc<T>);
                    impl<T: CampaignFeedService>
                        tonic::server::UnaryService<super::MutateCampaignFeedsRequest>
                        for MutateCampaignFeedsSvc<T>
                    {
                        type Response = super::MutateCampaignFeedsResponse;
                        type Future = BoxFuture<tonic::Response<Self::Response>, tonic::Status>;
                        fn call(
                            &mut self,
                            request: tonic::Request<super::MutateCampaignFeedsRequest>,
                        ) -> Self::Future {
                            let inner = self.0.clone();
                            let fut = async move { inner.mutate_campaign_feeds(request).await };
                            Box::pin(fut)
                        }
                    }
                    let inner = self.inner.clone();
                    let fut = async move {
                        let interceptor = inner.1.clone();
                        let inner = inner.0;
                        let method = MutateCampaignFeedsSvc(inner);
                        let codec = tonic::codec::ProstCodec::default();
                        let mut grpc = if let Some(interceptor) = interceptor {
                            tonic::server::Grpc::with_interceptor(codec, interceptor)
                        } else {
                            tonic::server::Grpc::new(codec)
                        };
                        let res = grpc.unary(method, req).await;
                        Ok(res)
                    };
                    Box::pin(fut)
                }
                _ => Box::pin(async move {
                    Ok(http::Response::builder()
                        .status(200)
                        .header("grpc-status", "12")
                        .body(tonic::body::BoxBody::empty())
                        .unwrap())
                }),
            }
        }
    }
    impl<T: CampaignFeedService> Clone for CampaignFeedServiceServer<T> {
        fn clone(&self) -> Self {
            let inner = self.inner.clone();
            Self { inner }
        }
    }
    impl<T: CampaignFeedService> Clone for _Inner<T> {
        fn clone(&self) -> Self {
            Self(self.0.clone(), self.1.clone())
        }
    }
    impl<T: std::fmt::Debug> std::fmt::Debug for _Inner<T> {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
            write!(f, "{:?}", self.0)
        }
    }
    impl<T: CampaignFeedService> tonic::transport::NamedService for CampaignFeedServiceServer<T> {
        const NAME: &'static str = "google.ads.googleads.v1.services.CampaignFeedService";
    }
}
/// Request message for [CampaignLabelService.GetCampaignLabel][google.ads.googleads.v1.services.CampaignLabelService.GetCampaignLabel].
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GetCampaignLabelRequest {
    /// Required. The resource name of the campaign-label relationship to fetch.
    #[prost(string, tag = "1")]
    pub resource_name: std::string::String,
}
/// Request message for [CampaignLabelService.MutateCampaignLabels][google.ads.googleads.v1.services.CampaignLabelService.MutateCampaignLabels].
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct MutateCampaignLabelsRequest {
    /// Required. ID of the customer whose campaign-label relationships are being modified.
    #[prost(string, tag = "1")]
    pub customer_id: std::string::String,
    /// Required. The list of operations to perform on campaign-label relationships.
    #[prost(message, repeated, tag = "2")]
    pub operations: ::std::vec::Vec<CampaignLabelOperation>,
    /// If true, successful operations will be carried out and invalid
    /// operations will return errors. If false, all operations will be carried
    /// out in one transaction if and only if they are all valid.
    /// Default is false.
    #[prost(bool, tag = "3")]
    pub partial_failure: bool,
    /// If true, the request is validated but not executed. Only errors are
    /// returned, not results.
    #[prost(bool, tag = "4")]
    pub validate_only: bool,
}
/// A single operation (create, remove) on a campaign-label relationship.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CampaignLabelOperation {
    /// The mutate operation.
    #[prost(oneof = "campaign_label_operation::Operation", tags = "1, 2")]
    pub operation: ::std::option::Option<campaign_label_operation::Operation>,
}
pub mod campaign_label_operation {
    /// The mutate operation.
    #[derive(Clone, PartialEq, ::prost::Oneof)]
    pub enum Operation {
        /// Create operation: No resource name is expected for the new campaign-label
        /// relationship.
        #[prost(message, tag = "1")]
        Create(super::super::resources::CampaignLabel),
        /// Remove operation: A resource name for the campaign-label relationship
        /// being removed, in this format:
        ///
        /// `customers/{customer_id}/campaignLabels/{campaign_id}~{label_id}`
        #[prost(string, tag = "2")]
        Remove(std::string::String),
    }
}
/// Response message for a campaign labels mutate.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct MutateCampaignLabelsResponse {
    /// Errors that pertain to operation failures in the partial failure mode.
    /// Returned only when partial_failure = true and all errors occur inside the
    /// operations. If any errors occur outside the operations (e.g. auth errors),
    /// we return an RPC level error.
    #[prost(message, optional, tag = "3")]
    pub partial_failure_error: ::std::option::Option<super::super::super::super::rpc::Status>,
    /// All results for the mutate.
    #[prost(message, repeated, tag = "2")]
    pub results: ::std::vec::Vec<MutateCampaignLabelResult>,
}
/// The result for a campaign label mutate.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct MutateCampaignLabelResult {
    /// Returned for successful operations.
    #[prost(string, tag = "1")]
    pub resource_name: std::string::String,
}
#[doc = r" Generated client implementations."]
pub mod campaign_label_service_client {
    #![allow(unused_variables, dead_code, missing_docs)]
    use tonic::codegen::*;
    #[doc = " Service to manage labels on campaigns."]
    pub struct CampaignLabelServiceClient<T> {
        inner: tonic::client::Grpc<T>,
    }
    impl CampaignLabelServiceClient<tonic::transport::Channel> {
        #[doc = r" Attempt to create a new client by connecting to a given endpoint."]
        pub async fn connect<D>(dst: D) -> Result<Self, tonic::transport::Error>
        where
            D: std::convert::TryInto<tonic::transport::Endpoint>,
            D::Error: Into<StdError>,
        {
            let conn = tonic::transport::Endpoint::new(dst)?.connect().await?;
            Ok(Self::new(conn))
        }
    }
    impl<T> CampaignLabelServiceClient<T>
    where
        T: tonic::client::GrpcService<tonic::body::BoxBody>,
        T::ResponseBody: Body + HttpBody + Send + 'static,
        T::Error: Into<StdError>,
        <T::ResponseBody as HttpBody>::Error: Into<StdError> + Send,
    {
        pub fn new(inner: T) -> Self {
            let inner = tonic::client::Grpc::new(inner);
            Self { inner }
        }
        pub fn with_interceptor(inner: T, interceptor: impl Into<tonic::Interceptor>) -> Self {
            let inner = tonic::client::Grpc::with_interceptor(inner, interceptor);
            Self { inner }
        }
        #[doc = " Returns the requested campaign-label relationship in full detail."]
        pub async fn get_campaign_label(
            &mut self,
            request: impl tonic::IntoRequest<super::GetCampaignLabelRequest>,
        ) -> Result<tonic::Response<super::super::resources::CampaignLabel>, tonic::Status>
        {
            self.inner.ready().await.map_err(|e| {
                tonic::Status::new(
                    tonic::Code::Unknown,
                    format!("Service was not ready: {}", e.into()),
                )
            })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.ads.googleads.v1.services.CampaignLabelService/GetCampaignLabel",
            );
            self.inner.unary(request.into_request(), path, codec).await
        }
        #[doc = " Creates and removes campaign-label relationships."]
        #[doc = " Operation statuses are returned."]
        pub async fn mutate_campaign_labels(
            &mut self,
            request: impl tonic::IntoRequest<super::MutateCampaignLabelsRequest>,
        ) -> Result<tonic::Response<super::MutateCampaignLabelsResponse>, tonic::Status> {
            self.inner.ready().await.map_err(|e| {
                tonic::Status::new(
                    tonic::Code::Unknown,
                    format!("Service was not ready: {}", e.into()),
                )
            })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.ads.googleads.v1.services.CampaignLabelService/MutateCampaignLabels",
            );
            self.inner.unary(request.into_request(), path, codec).await
        }
    }
    impl<T: Clone> Clone for CampaignLabelServiceClient<T> {
        fn clone(&self) -> Self {
            Self {
                inner: self.inner.clone(),
            }
        }
    }
    impl<T> std::fmt::Debug for CampaignLabelServiceClient<T> {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
            write!(f, "CampaignLabelServiceClient {{ ... }}")
        }
    }
}
#[doc = r" Generated server implementations."]
pub mod campaign_label_service_server {
    #![allow(unused_variables, dead_code, missing_docs)]
    use tonic::codegen::*;
    #[doc = "Generated trait containing gRPC methods that should be implemented for use with CampaignLabelServiceServer."]
    #[async_trait]
    pub trait CampaignLabelService: Send + Sync + 'static {
        #[doc = " Returns the requested campaign-label relationship in full detail."]
        async fn get_campaign_label(
            &self,
            request: tonic::Request<super::GetCampaignLabelRequest>,
        ) -> Result<tonic::Response<super::super::resources::CampaignLabel>, tonic::Status>;
        #[doc = " Creates and removes campaign-label relationships."]
        #[doc = " Operation statuses are returned."]
        async fn mutate_campaign_labels(
            &self,
            request: tonic::Request<super::MutateCampaignLabelsRequest>,
        ) -> Result<tonic::Response<super::MutateCampaignLabelsResponse>, tonic::Status>;
    }
    #[doc = " Service to manage labels on campaigns."]
    #[derive(Debug)]
    #[doc(hidden)]
    pub struct CampaignLabelServiceServer<T: CampaignLabelService> {
        inner: _Inner<T>,
    }
    struct _Inner<T>(Arc<T>, Option<tonic::Interceptor>);
    impl<T: CampaignLabelService> CampaignLabelServiceServer<T> {
        pub fn new(inner: T) -> Self {
            let inner = Arc::new(inner);
            let inner = _Inner(inner, None);
            Self { inner }
        }
        pub fn with_interceptor(inner: T, interceptor: impl Into<tonic::Interceptor>) -> Self {
            let inner = Arc::new(inner);
            let inner = _Inner(inner, Some(interceptor.into()));
            Self { inner }
        }
    }
    impl<T, B> Service<http::Request<B>> for CampaignLabelServiceServer<T>
    where
        T: CampaignLabelService,
        B: HttpBody + Send + Sync + 'static,
        B::Error: Into<StdError> + Send + 'static,
    {
        type Response = http::Response<tonic::body::BoxBody>;
        type Error = Never;
        type Future = BoxFuture<Self::Response, Self::Error>;
        fn poll_ready(&mut self, _cx: &mut Context<'_>) -> Poll<Result<(), Self::Error>> {
            Poll::Ready(Ok(()))
        }
        fn call(&mut self, req: http::Request<B>) -> Self::Future {
            let inner = self.inner.clone();
            match req.uri().path() {
                "/google.ads.googleads.v1.services.CampaignLabelService/GetCampaignLabel" => {
                    #[allow(non_camel_case_types)]
                    struct GetCampaignLabelSvc<T: CampaignLabelService>(pub Arc<T>);
                    impl<T: CampaignLabelService>
                        tonic::server::UnaryService<super::GetCampaignLabelRequest>
                        for GetCampaignLabelSvc<T>
                    {
                        type Response = super::super::resources::CampaignLabel;
                        type Future = BoxFuture<tonic::Response<Self::Response>, tonic::Status>;
                        fn call(
                            &mut self,
                            request: tonic::Request<super::GetCampaignLabelRequest>,
                        ) -> Self::Future {
                            let inner = self.0.clone();
                            let fut = async move { inner.get_campaign_label(request).await };
                            Box::pin(fut)
                        }
                    }
                    let inner = self.inner.clone();
                    let fut = async move {
                        let interceptor = inner.1.clone();
                        let inner = inner.0;
                        let method = GetCampaignLabelSvc(inner);
                        let codec = tonic::codec::ProstCodec::default();
                        let mut grpc = if let Some(interceptor) = interceptor {
                            tonic::server::Grpc::with_interceptor(codec, interceptor)
                        } else {
                            tonic::server::Grpc::new(codec)
                        };
                        let res = grpc.unary(method, req).await;
                        Ok(res)
                    };
                    Box::pin(fut)
                }
                "/google.ads.googleads.v1.services.CampaignLabelService/MutateCampaignLabels" => {
                    #[allow(non_camel_case_types)]
                    struct MutateCampaignLabelsSvc<T: CampaignLabelService>(pub Arc<T>);
                    impl<T: CampaignLabelService>
                        tonic::server::UnaryService<super::MutateCampaignLabelsRequest>
                        for MutateCampaignLabelsSvc<T>
                    {
                        type Response = super::MutateCampaignLabelsResponse;
                        type Future = BoxFuture<tonic::Response<Self::Response>, tonic::Status>;
                        fn call(
                            &mut self,
                            request: tonic::Request<super::MutateCampaignLabelsRequest>,
                        ) -> Self::Future {
                            let inner = self.0.clone();
                            let fut = async move { inner.mutate_campaign_labels(request).await };
                            Box::pin(fut)
                        }
                    }
                    let inner = self.inner.clone();
                    let fut = async move {
                        let interceptor = inner.1.clone();
                        let inner = inner.0;
                        let method = MutateCampaignLabelsSvc(inner);
                        let codec = tonic::codec::ProstCodec::default();
                        let mut grpc = if let Some(interceptor) = interceptor {
                            tonic::server::Grpc::with_interceptor(codec, interceptor)
                        } else {
                            tonic::server::Grpc::new(codec)
                        };
                        let res = grpc.unary(method, req).await;
                        Ok(res)
                    };
                    Box::pin(fut)
                }
                _ => Box::pin(async move {
                    Ok(http::Response::builder()
                        .status(200)
                        .header("grpc-status", "12")
                        .body(tonic::body::BoxBody::empty())
                        .unwrap())
                }),
            }
        }
    }
    impl<T: CampaignLabelService> Clone for CampaignLabelServiceServer<T> {
        fn clone(&self) -> Self {
            let inner = self.inner.clone();
            Self { inner }
        }
    }
    impl<T: CampaignLabelService> Clone for _Inner<T> {
        fn clone(&self) -> Self {
            Self(self.0.clone(), self.1.clone())
        }
    }
    impl<T: std::fmt::Debug> std::fmt::Debug for _Inner<T> {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
            write!(f, "{:?}", self.0)
        }
    }
    impl<T: CampaignLabelService> tonic::transport::NamedService for CampaignLabelServiceServer<T> {
        const NAME: &'static str = "google.ads.googleads.v1.services.CampaignLabelService";
    }
}
/// Request message for [CampaignService.GetCampaign][google.ads.googleads.v1.services.CampaignService.GetCampaign].
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GetCampaignRequest {
    /// Required. The resource name of the campaign to fetch.
    #[prost(string, tag = "1")]
    pub resource_name: std::string::String,
}
/// Request message for [CampaignService.MutateCampaigns][google.ads.googleads.v1.services.CampaignService.MutateCampaigns].
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct MutateCampaignsRequest {
    /// Required. The ID of the customer whose campaigns are being modified.
    #[prost(string, tag = "1")]
    pub customer_id: std::string::String,
    /// Required. The list of operations to perform on individual campaigns.
    #[prost(message, repeated, tag = "2")]
    pub operations: ::std::vec::Vec<CampaignOperation>,
    /// If true, successful operations will be carried out and invalid
    /// operations will return errors. If false, all operations will be carried
    /// out in one transaction if and only if they are all valid.
    /// Default is false.
    #[prost(bool, tag = "3")]
    pub partial_failure: bool,
    /// If true, the request is validated but not executed. Only errors are
    /// returned, not results.
    #[prost(bool, tag = "4")]
    pub validate_only: bool,
}
/// A single operation (create, update, remove) on a campaign.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CampaignOperation {
    /// FieldMask that determines which resource fields are modified in an update.
    #[prost(message, optional, tag = "4")]
    pub update_mask: ::std::option::Option<::prost_types::FieldMask>,
    /// The mutate operation.
    #[prost(oneof = "campaign_operation::Operation", tags = "1, 2, 3")]
    pub operation: ::std::option::Option<campaign_operation::Operation>,
}
pub mod campaign_operation {
    /// The mutate operation.
    #[derive(Clone, PartialEq, ::prost::Oneof)]
    pub enum Operation {
        /// Create operation: No resource name is expected for the new campaign.
        #[prost(message, tag = "1")]
        Create(super::super::resources::Campaign),
        /// Update operation: The campaign is expected to have a valid
        /// resource name.
        #[prost(message, tag = "2")]
        Update(super::super::resources::Campaign),
        /// Remove operation: A resource name for the removed campaign is
        /// expected, in this format:
        ///
        /// `customers/{customer_id}/campaigns/{campaign_id}`
        #[prost(string, tag = "3")]
        Remove(std::string::String),
    }
}
/// Response message for campaign mutate.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct MutateCampaignsResponse {
    /// Errors that pertain to operation failures in the partial failure mode.
    /// Returned only when partial_failure = true and all errors occur inside the
    /// operations. If any errors occur outside the operations (e.g. auth errors),
    /// we return an RPC level error.
    #[prost(message, optional, tag = "3")]
    pub partial_failure_error: ::std::option::Option<super::super::super::super::rpc::Status>,
    /// All results for the mutate.
    #[prost(message, repeated, tag = "2")]
    pub results: ::std::vec::Vec<MutateCampaignResult>,
}
/// The result for the campaign mutate.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct MutateCampaignResult {
    /// Returned for successful operations.
    #[prost(string, tag = "1")]
    pub resource_name: std::string::String,
}
#[doc = r" Generated client implementations."]
pub mod campaign_service_client {
    #![allow(unused_variables, dead_code, missing_docs)]
    use tonic::codegen::*;
    #[doc = " Service to manage campaigns."]
    pub struct CampaignServiceClient<T> {
        inner: tonic::client::Grpc<T>,
    }
    impl CampaignServiceClient<tonic::transport::Channel> {
        #[doc = r" Attempt to create a new client by connecting to a given endpoint."]
        pub async fn connect<D>(dst: D) -> Result<Self, tonic::transport::Error>
        where
            D: std::convert::TryInto<tonic::transport::Endpoint>,
            D::Error: Into<StdError>,
        {
            let conn = tonic::transport::Endpoint::new(dst)?.connect().await?;
            Ok(Self::new(conn))
        }
    }
    impl<T> CampaignServiceClient<T>
    where
        T: tonic::client::GrpcService<tonic::body::BoxBody>,
        T::ResponseBody: Body + HttpBody + Send + 'static,
        T::Error: Into<StdError>,
        <T::ResponseBody as HttpBody>::Error: Into<StdError> + Send,
    {
        pub fn new(inner: T) -> Self {
            let inner = tonic::client::Grpc::new(inner);
            Self { inner }
        }
        pub fn with_interceptor(inner: T, interceptor: impl Into<tonic::Interceptor>) -> Self {
            let inner = tonic::client::Grpc::with_interceptor(inner, interceptor);
            Self { inner }
        }
        #[doc = " Returns the requested campaign in full detail."]
        pub async fn get_campaign(
            &mut self,
            request: impl tonic::IntoRequest<super::GetCampaignRequest>,
        ) -> Result<tonic::Response<super::super::resources::Campaign>, tonic::Status> {
            self.inner.ready().await.map_err(|e| {
                tonic::Status::new(
                    tonic::Code::Unknown,
                    format!("Service was not ready: {}", e.into()),
                )
            })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.ads.googleads.v1.services.CampaignService/GetCampaign",
            );
            self.inner.unary(request.into_request(), path, codec).await
        }
        #[doc = " Creates, updates, or removes campaigns. Operation statuses are returned."]
        pub async fn mutate_campaigns(
            &mut self,
            request: impl tonic::IntoRequest<super::MutateCampaignsRequest>,
        ) -> Result<tonic::Response<super::MutateCampaignsResponse>, tonic::Status> {
            self.inner.ready().await.map_err(|e| {
                tonic::Status::new(
                    tonic::Code::Unknown,
                    format!("Service was not ready: {}", e.into()),
                )
            })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.ads.googleads.v1.services.CampaignService/MutateCampaigns",
            );
            self.inner.unary(request.into_request(), path, codec).await
        }
    }
    impl<T: Clone> Clone for CampaignServiceClient<T> {
        fn clone(&self) -> Self {
            Self {
                inner: self.inner.clone(),
            }
        }
    }
    impl<T> std::fmt::Debug for CampaignServiceClient<T> {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
            write!(f, "CampaignServiceClient {{ ... }}")
        }
    }
}
#[doc = r" Generated server implementations."]
pub mod campaign_service_server {
    #![allow(unused_variables, dead_code, missing_docs)]
    use tonic::codegen::*;
    #[doc = "Generated trait containing gRPC methods that should be implemented for use with CampaignServiceServer."]
    #[async_trait]
    pub trait CampaignService: Send + Sync + 'static {
        #[doc = " Returns the requested campaign in full detail."]
        async fn get_campaign(
            &self,
            request: tonic::Request<super::GetCampaignRequest>,
        ) -> Result<tonic::Response<super::super::resources::Campaign>, tonic::Status>;
        #[doc = " Creates, updates, or removes campaigns. Operation statuses are returned."]
        async fn mutate_campaigns(
            &self,
            request: tonic::Request<super::MutateCampaignsRequest>,
        ) -> Result<tonic::Response<super::MutateCampaignsResponse>, tonic::Status>;
    }
    #[doc = " Service to manage campaigns."]
    #[derive(Debug)]
    #[doc(hidden)]
    pub struct CampaignServiceServer<T: CampaignService> {
        inner: _Inner<T>,
    }
    struct _Inner<T>(Arc<T>, Option<tonic::Interceptor>);
    impl<T: CampaignService> CampaignServiceServer<T> {
        pub fn new(inner: T) -> Self {
            let inner = Arc::new(inner);
            let inner = _Inner(inner, None);
            Self { inner }
        }
        pub fn with_interceptor(inner: T, interceptor: impl Into<tonic::Interceptor>) -> Self {
            let inner = Arc::new(inner);
            let inner = _Inner(inner, Some(interceptor.into()));
            Self { inner }
        }
    }
    impl<T, B> Service<http::Request<B>> for CampaignServiceServer<T>
    where
        T: CampaignService,
        B: HttpBody + Send + Sync + 'static,
        B::Error: Into<StdError> + Send + 'static,
    {
        type Response = http::Response<tonic::body::BoxBody>;
        type Error = Never;
        type Future = BoxFuture<Self::Response, Self::Error>;
        fn poll_ready(&mut self, _cx: &mut Context<'_>) -> Poll<Result<(), Self::Error>> {
            Poll::Ready(Ok(()))
        }
        fn call(&mut self, req: http::Request<B>) -> Self::Future {
            let inner = self.inner.clone();
            match req.uri().path() {
                "/google.ads.googleads.v1.services.CampaignService/GetCampaign" => {
                    #[allow(non_camel_case_types)]
                    struct GetCampaignSvc<T: CampaignService>(pub Arc<T>);
                    impl<T: CampaignService> tonic::server::UnaryService<super::GetCampaignRequest>
                        for GetCampaignSvc<T>
                    {
                        type Response = super::super::resources::Campaign;
                        type Future = BoxFuture<tonic::Response<Self::Response>, tonic::Status>;
                        fn call(
                            &mut self,
                            request: tonic::Request<super::GetCampaignRequest>,
                        ) -> Self::Future {
                            let inner = self.0.clone();
                            let fut = async move { inner.get_campaign(request).await };
                            Box::pin(fut)
                        }
                    }
                    let inner = self.inner.clone();
                    let fut = async move {
                        let interceptor = inner.1.clone();
                        let inner = inner.0;
                        let method = GetCampaignSvc(inner);
                        let codec = tonic::codec::ProstCodec::default();
                        let mut grpc = if let Some(interceptor) = interceptor {
                            tonic::server::Grpc::with_interceptor(codec, interceptor)
                        } else {
                            tonic::server::Grpc::new(codec)
                        };
                        let res = grpc.unary(method, req).await;
                        Ok(res)
                    };
                    Box::pin(fut)
                }
                "/google.ads.googleads.v1.services.CampaignService/MutateCampaigns" => {
                    #[allow(non_camel_case_types)]
                    struct MutateCampaignsSvc<T: CampaignService>(pub Arc<T>);
                    impl<T: CampaignService>
                        tonic::server::UnaryService<super::MutateCampaignsRequest>
                        for MutateCampaignsSvc<T>
                    {
                        type Response = super::MutateCampaignsResponse;
                        type Future = BoxFuture<tonic::Response<Self::Response>, tonic::Status>;
                        fn call(
                            &mut self,
                            request: tonic::Request<super::MutateCampaignsRequest>,
                        ) -> Self::Future {
                            let inner = self.0.clone();
                            let fut = async move { inner.mutate_campaigns(request).await };
                            Box::pin(fut)
                        }
                    }
                    let inner = self.inner.clone();
                    let fut = async move {
                        let interceptor = inner.1.clone();
                        let inner = inner.0;
                        let method = MutateCampaignsSvc(inner);
                        let codec = tonic::codec::ProstCodec::default();
                        let mut grpc = if let Some(interceptor) = interceptor {
                            tonic::server::Grpc::with_interceptor(codec, interceptor)
                        } else {
                            tonic::server::Grpc::new(codec)
                        };
                        let res = grpc.unary(method, req).await;
                        Ok(res)
                    };
                    Box::pin(fut)
                }
                _ => Box::pin(async move {
                    Ok(http::Response::builder()
                        .status(200)
                        .header("grpc-status", "12")
                        .body(tonic::body::BoxBody::empty())
                        .unwrap())
                }),
            }
        }
    }
    impl<T: CampaignService> Clone for CampaignServiceServer<T> {
        fn clone(&self) -> Self {
            let inner = self.inner.clone();
            Self { inner }
        }
    }
    impl<T: CampaignService> Clone for _Inner<T> {
        fn clone(&self) -> Self {
            Self(self.0.clone(), self.1.clone())
        }
    }
    impl<T: std::fmt::Debug> std::fmt::Debug for _Inner<T> {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
            write!(f, "{:?}", self.0)
        }
    }
    impl<T: CampaignService> tonic::transport::NamedService for CampaignServiceServer<T> {
        const NAME: &'static str = "google.ads.googleads.v1.services.CampaignService";
    }
}
/// Request message for [CampaignSharedSetService.GetCampaignSharedSet][google.ads.googleads.v1.services.CampaignSharedSetService.GetCampaignSharedSet].
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GetCampaignSharedSetRequest {
    /// Required. The resource name of the campaign shared set to fetch.
    #[prost(string, tag = "1")]
    pub resource_name: std::string::String,
}
/// Request message for [CampaignSharedSetService.MutateCampaignSharedSets][google.ads.googleads.v1.services.CampaignSharedSetService.MutateCampaignSharedSets].
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct MutateCampaignSharedSetsRequest {
    /// Required. The ID of the customer whose campaign shared sets are being modified.
    #[prost(string, tag = "1")]
    pub customer_id: std::string::String,
    /// Required. The list of operations to perform on individual campaign shared sets.
    #[prost(message, repeated, tag = "2")]
    pub operations: ::std::vec::Vec<CampaignSharedSetOperation>,
    /// If true, successful operations will be carried out and invalid
    /// operations will return errors. If false, all operations will be carried
    /// out in one transaction if and only if they are all valid.
    /// Default is false.
    #[prost(bool, tag = "3")]
    pub partial_failure: bool,
    /// If true, the request is validated but not executed. Only errors are
    /// returned, not results.
    #[prost(bool, tag = "4")]
    pub validate_only: bool,
}
/// A single operation (create, remove) on an campaign shared set.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CampaignSharedSetOperation {
    /// The mutate operation.
    #[prost(oneof = "campaign_shared_set_operation::Operation", tags = "1, 3")]
    pub operation: ::std::option::Option<campaign_shared_set_operation::Operation>,
}
pub mod campaign_shared_set_operation {
    /// The mutate operation.
    #[derive(Clone, PartialEq, ::prost::Oneof)]
    pub enum Operation {
        /// Create operation: No resource name is expected for the new campaign
        /// shared set.
        #[prost(message, tag = "1")]
        Create(super::super::resources::CampaignSharedSet),
        /// Remove operation: A resource name for the removed campaign shared set is
        /// expected, in this format:
        ///
        /// `customers/{customer_id}/campaignSharedSets/{campaign_id}~{shared_set_id}`
        #[prost(string, tag = "3")]
        Remove(std::string::String),
    }
}
/// Response message for a campaign shared set mutate.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct MutateCampaignSharedSetsResponse {
    /// Errors that pertain to operation failures in the partial failure mode.
    /// Returned only when partial_failure = true and all errors occur inside the
    /// operations. If any errors occur outside the operations (e.g. auth errors),
    /// we return an RPC level error.
    #[prost(message, optional, tag = "3")]
    pub partial_failure_error: ::std::option::Option<super::super::super::super::rpc::Status>,
    /// All results for the mutate.
    #[prost(message, repeated, tag = "2")]
    pub results: ::std::vec::Vec<MutateCampaignSharedSetResult>,
}
/// The result for the campaign shared set mutate.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct MutateCampaignSharedSetResult {
    /// Returned for successful operations.
    #[prost(string, tag = "1")]
    pub resource_name: std::string::String,
}
#[doc = r" Generated client implementations."]
pub mod campaign_shared_set_service_client {
    #![allow(unused_variables, dead_code, missing_docs)]
    use tonic::codegen::*;
    #[doc = " Service to manage campaign shared sets."]
    pub struct CampaignSharedSetServiceClient<T> {
        inner: tonic::client::Grpc<T>,
    }
    impl CampaignSharedSetServiceClient<tonic::transport::Channel> {
        #[doc = r" Attempt to create a new client by connecting to a given endpoint."]
        pub async fn connect<D>(dst: D) -> Result<Self, tonic::transport::Error>
        where
            D: std::convert::TryInto<tonic::transport::Endpoint>,
            D::Error: Into<StdError>,
        {
            let conn = tonic::transport::Endpoint::new(dst)?.connect().await?;
            Ok(Self::new(conn))
        }
    }
    impl<T> CampaignSharedSetServiceClient<T>
    where
        T: tonic::client::GrpcService<tonic::body::BoxBody>,
        T::ResponseBody: Body + HttpBody + Send + 'static,
        T::Error: Into<StdError>,
        <T::ResponseBody as HttpBody>::Error: Into<StdError> + Send,
    {
        pub fn new(inner: T) -> Self {
            let inner = tonic::client::Grpc::new(inner);
            Self { inner }
        }
        pub fn with_interceptor(inner: T, interceptor: impl Into<tonic::Interceptor>) -> Self {
            let inner = tonic::client::Grpc::with_interceptor(inner, interceptor);
            Self { inner }
        }
        #[doc = " Returns the requested campaign shared set in full detail."]
        pub async fn get_campaign_shared_set(
            &mut self,
            request: impl tonic::IntoRequest<super::GetCampaignSharedSetRequest>,
        ) -> Result<tonic::Response<super::super::resources::CampaignSharedSet>, tonic::Status>
        {
            self.inner.ready().await.map_err(|e| {
                tonic::Status::new(
                    tonic::Code::Unknown,
                    format!("Service was not ready: {}", e.into()),
                )
            })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.ads.googleads.v1.services.CampaignSharedSetService/GetCampaignSharedSet",
            );
            self.inner.unary(request.into_request(), path, codec).await
        }
        #[doc = " Creates or removes campaign shared sets. Operation statuses are returned."]
        pub async fn mutate_campaign_shared_sets(
            &mut self,
            request: impl tonic::IntoRequest<super::MutateCampaignSharedSetsRequest>,
        ) -> Result<tonic::Response<super::MutateCampaignSharedSetsResponse>, tonic::Status>
        {
            self.inner.ready().await.map_err(|e| {
                tonic::Status::new(
                    tonic::Code::Unknown,
                    format!("Service was not ready: {}", e.into()),
                )
            })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http :: uri :: PathAndQuery :: from_static ( "/google.ads.googleads.v1.services.CampaignSharedSetService/MutateCampaignSharedSets" ) ;
            self.inner.unary(request.into_request(), path, codec).await
        }
    }
    impl<T: Clone> Clone for CampaignSharedSetServiceClient<T> {
        fn clone(&self) -> Self {
            Self {
                inner: self.inner.clone(),
            }
        }
    }
    impl<T> std::fmt::Debug for CampaignSharedSetServiceClient<T> {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
            write!(f, "CampaignSharedSetServiceClient {{ ... }}")
        }
    }
}
#[doc = r" Generated server implementations."]
pub mod campaign_shared_set_service_server {
    #![allow(unused_variables, dead_code, missing_docs)]
    use tonic::codegen::*;
    #[doc = "Generated trait containing gRPC methods that should be implemented for use with CampaignSharedSetServiceServer."]
    #[async_trait]
    pub trait CampaignSharedSetService: Send + Sync + 'static {
        #[doc = " Returns the requested campaign shared set in full detail."]
        async fn get_campaign_shared_set(
            &self,
            request: tonic::Request<super::GetCampaignSharedSetRequest>,
        ) -> Result<tonic::Response<super::super::resources::CampaignSharedSet>, tonic::Status>;
        #[doc = " Creates or removes campaign shared sets. Operation statuses are returned."]
        async fn mutate_campaign_shared_sets(
            &self,
            request: tonic::Request<super::MutateCampaignSharedSetsRequest>,
        ) -> Result<tonic::Response<super::MutateCampaignSharedSetsResponse>, tonic::Status>;
    }
    #[doc = " Service to manage campaign shared sets."]
    #[derive(Debug)]
    #[doc(hidden)]
    pub struct CampaignSharedSetServiceServer<T: CampaignSharedSetService> {
        inner: _Inner<T>,
    }
    struct _Inner<T>(Arc<T>, Option<tonic::Interceptor>);
    impl<T: CampaignSharedSetService> CampaignSharedSetServiceServer<T> {
        pub fn new(inner: T) -> Self {
            let inner = Arc::new(inner);
            let inner = _Inner(inner, None);
            Self { inner }
        }
        pub fn with_interceptor(inner: T, interceptor: impl Into<tonic::Interceptor>) -> Self {
            let inner = Arc::new(inner);
            let inner = _Inner(inner, Some(interceptor.into()));
            Self { inner }
        }
    }
    impl<T, B> Service<http::Request<B>> for CampaignSharedSetServiceServer<T>
    where
        T: CampaignSharedSetService,
        B: HttpBody + Send + Sync + 'static,
        B::Error: Into<StdError> + Send + 'static,
    {
        type Response = http::Response<tonic::body::BoxBody>;
        type Error = Never;
        type Future = BoxFuture<Self::Response, Self::Error>;
        fn poll_ready(&mut self, _cx: &mut Context<'_>) -> Poll<Result<(), Self::Error>> {
            Poll::Ready(Ok(()))
        }
        fn call(&mut self, req: http::Request<B>) -> Self::Future {
            let inner = self.inner.clone();
            match req . uri ( ) . path ( ) { "/google.ads.googleads.v1.services.CampaignSharedSetService/GetCampaignSharedSet" => { # [ allow ( non_camel_case_types ) ] struct GetCampaignSharedSetSvc < T : CampaignSharedSetService > ( pub Arc < T > ) ; impl < T : CampaignSharedSetService > tonic :: server :: UnaryService < super :: GetCampaignSharedSetRequest > for GetCampaignSharedSetSvc < T > { type Response = super :: super :: resources :: CampaignSharedSet ; type Future = BoxFuture < tonic :: Response < Self :: Response > , tonic :: Status > ; fn call ( & mut self , request : tonic :: Request < super :: GetCampaignSharedSetRequest > ) -> Self :: Future { let inner = self . 0 . clone ( ) ; let fut = async move { inner . get_campaign_shared_set ( request ) . await } ; Box :: pin ( fut ) } } let inner = self . inner . clone ( ) ; let fut = async move { let interceptor = inner . 1 . clone ( ) ; let inner = inner . 0 ; let method = GetCampaignSharedSetSvc ( inner ) ; let codec = tonic :: codec :: ProstCodec :: default ( ) ; let mut grpc = if let Some ( interceptor ) = interceptor { tonic :: server :: Grpc :: with_interceptor ( codec , interceptor ) } else { tonic :: server :: Grpc :: new ( codec ) } ; let res = grpc . unary ( method , req ) . await ; Ok ( res ) } ; Box :: pin ( fut ) } "/google.ads.googleads.v1.services.CampaignSharedSetService/MutateCampaignSharedSets" => { # [ allow ( non_camel_case_types ) ] struct MutateCampaignSharedSetsSvc < T : CampaignSharedSetService > ( pub Arc < T > ) ; impl < T : CampaignSharedSetService > tonic :: server :: UnaryService < super :: MutateCampaignSharedSetsRequest > for MutateCampaignSharedSetsSvc < T > { type Response = super :: MutateCampaignSharedSetsResponse ; type Future = BoxFuture < tonic :: Response < Self :: Response > , tonic :: Status > ; fn call ( & mut self , request : tonic :: Request < super :: MutateCampaignSharedSetsRequest > ) -> Self :: Future { let inner = self . 0 . clone ( ) ; let fut = async move { inner . mutate_campaign_shared_sets ( request ) . await } ; Box :: pin ( fut ) } } let inner = self . inner . clone ( ) ; let fut = async move { let interceptor = inner . 1 . clone ( ) ; let inner = inner . 0 ; let method = MutateCampaignSharedSetsSvc ( inner ) ; let codec = tonic :: codec :: ProstCodec :: default ( ) ; let mut grpc = if let Some ( interceptor ) = interceptor { tonic :: server :: Grpc :: with_interceptor ( codec , interceptor ) } else { tonic :: server :: Grpc :: new ( codec ) } ; let res = grpc . unary ( method , req ) . await ; Ok ( res ) } ; Box :: pin ( fut ) } _ => Box :: pin ( async move { Ok ( http :: Response :: builder ( ) . status ( 200 ) . header ( "grpc-status" , "12" ) . body ( tonic :: body :: BoxBody :: empty ( ) ) . unwrap ( ) ) } ) , }
        }
    }
    impl<T: CampaignSharedSetService> Clone for CampaignSharedSetServiceServer<T> {
        fn clone(&self) -> Self {
            let inner = self.inner.clone();
            Self { inner }
        }
    }
    impl<T: CampaignSharedSetService> Clone for _Inner<T> {
        fn clone(&self) -> Self {
            Self(self.0.clone(), self.1.clone())
        }
    }
    impl<T: std::fmt::Debug> std::fmt::Debug for _Inner<T> {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
            write!(f, "{:?}", self.0)
        }
    }
    impl<T: CampaignSharedSetService> tonic::transport::NamedService
        for CampaignSharedSetServiceServer<T>
    {
        const NAME: &'static str = "google.ads.googleads.v1.services.CampaignSharedSetService";
    }
}
/// Request message for [CarrierConstantService.GetCarrierConstant][google.ads.googleads.v1.services.CarrierConstantService.GetCarrierConstant].
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GetCarrierConstantRequest {
    /// Required. Resource name of the carrier constant to fetch.
    #[prost(string, tag = "1")]
    pub resource_name: std::string::String,
}
#[doc = r" Generated client implementations."]
pub mod carrier_constant_service_client {
    #![allow(unused_variables, dead_code, missing_docs)]
    use tonic::codegen::*;
    #[doc = " Service to fetch carrier constants."]
    pub struct CarrierConstantServiceClient<T> {
        inner: tonic::client::Grpc<T>,
    }
    impl CarrierConstantServiceClient<tonic::transport::Channel> {
        #[doc = r" Attempt to create a new client by connecting to a given endpoint."]
        pub async fn connect<D>(dst: D) -> Result<Self, tonic::transport::Error>
        where
            D: std::convert::TryInto<tonic::transport::Endpoint>,
            D::Error: Into<StdError>,
        {
            let conn = tonic::transport::Endpoint::new(dst)?.connect().await?;
            Ok(Self::new(conn))
        }
    }
    impl<T> CarrierConstantServiceClient<T>
    where
        T: tonic::client::GrpcService<tonic::body::BoxBody>,
        T::ResponseBody: Body + HttpBody + Send + 'static,
        T::Error: Into<StdError>,
        <T::ResponseBody as HttpBody>::Error: Into<StdError> + Send,
    {
        pub fn new(inner: T) -> Self {
            let inner = tonic::client::Grpc::new(inner);
            Self { inner }
        }
        pub fn with_interceptor(inner: T, interceptor: impl Into<tonic::Interceptor>) -> Self {
            let inner = tonic::client::Grpc::with_interceptor(inner, interceptor);
            Self { inner }
        }
        #[doc = " Returns the requested carrier constant in full detail."]
        pub async fn get_carrier_constant(
            &mut self,
            request: impl tonic::IntoRequest<super::GetCarrierConstantRequest>,
        ) -> Result<tonic::Response<super::super::resources::CarrierConstant>, tonic::Status>
        {
            self.inner.ready().await.map_err(|e| {
                tonic::Status::new(
                    tonic::Code::Unknown,
                    format!("Service was not ready: {}", e.into()),
                )
            })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.ads.googleads.v1.services.CarrierConstantService/GetCarrierConstant",
            );
            self.inner.unary(request.into_request(), path, codec).await
        }
    }
    impl<T: Clone> Clone for CarrierConstantServiceClient<T> {
        fn clone(&self) -> Self {
            Self {
                inner: self.inner.clone(),
            }
        }
    }
    impl<T> std::fmt::Debug for CarrierConstantServiceClient<T> {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
            write!(f, "CarrierConstantServiceClient {{ ... }}")
        }
    }
}
#[doc = r" Generated server implementations."]
pub mod carrier_constant_service_server {
    #![allow(unused_variables, dead_code, missing_docs)]
    use tonic::codegen::*;
    #[doc = "Generated trait containing gRPC methods that should be implemented for use with CarrierConstantServiceServer."]
    #[async_trait]
    pub trait CarrierConstantService: Send + Sync + 'static {
        #[doc = " Returns the requested carrier constant in full detail."]
        async fn get_carrier_constant(
            &self,
            request: tonic::Request<super::GetCarrierConstantRequest>,
        ) -> Result<tonic::Response<super::super::resources::CarrierConstant>, tonic::Status>;
    }
    #[doc = " Service to fetch carrier constants."]
    #[derive(Debug)]
    #[doc(hidden)]
    pub struct CarrierConstantServiceServer<T: CarrierConstantService> {
        inner: _Inner<T>,
    }
    struct _Inner<T>(Arc<T>, Option<tonic::Interceptor>);
    impl<T: CarrierConstantService> CarrierConstantServiceServer<T> {
        pub fn new(inner: T) -> Self {
            let inner = Arc::new(inner);
            let inner = _Inner(inner, None);
            Self { inner }
        }
        pub fn with_interceptor(inner: T, interceptor: impl Into<tonic::Interceptor>) -> Self {
            let inner = Arc::new(inner);
            let inner = _Inner(inner, Some(interceptor.into()));
            Self { inner }
        }
    }
    impl<T, B> Service<http::Request<B>> for CarrierConstantServiceServer<T>
    where
        T: CarrierConstantService,
        B: HttpBody + Send + Sync + 'static,
        B::Error: Into<StdError> + Send + 'static,
    {
        type Response = http::Response<tonic::body::BoxBody>;
        type Error = Never;
        type Future = BoxFuture<Self::Response, Self::Error>;
        fn poll_ready(&mut self, _cx: &mut Context<'_>) -> Poll<Result<(), Self::Error>> {
            Poll::Ready(Ok(()))
        }
        fn call(&mut self, req: http::Request<B>) -> Self::Future {
            let inner = self.inner.clone();
            match req.uri().path() {
                "/google.ads.googleads.v1.services.CarrierConstantService/GetCarrierConstant" => {
                    #[allow(non_camel_case_types)]
                    struct GetCarrierConstantSvc<T: CarrierConstantService>(pub Arc<T>);
                    impl<T: CarrierConstantService>
                        tonic::server::UnaryService<super::GetCarrierConstantRequest>
                        for GetCarrierConstantSvc<T>
                    {
                        type Response = super::super::resources::CarrierConstant;
                        type Future = BoxFuture<tonic::Response<Self::Response>, tonic::Status>;
                        fn call(
                            &mut self,
                            request: tonic::Request<super::GetCarrierConstantRequest>,
                        ) -> Self::Future {
                            let inner = self.0.clone();
                            let fut = async move { inner.get_carrier_constant(request).await };
                            Box::pin(fut)
                        }
                    }
                    let inner = self.inner.clone();
                    let fut = async move {
                        let interceptor = inner.1.clone();
                        let inner = inner.0;
                        let method = GetCarrierConstantSvc(inner);
                        let codec = tonic::codec::ProstCodec::default();
                        let mut grpc = if let Some(interceptor) = interceptor {
                            tonic::server::Grpc::with_interceptor(codec, interceptor)
                        } else {
                            tonic::server::Grpc::new(codec)
                        };
                        let res = grpc.unary(method, req).await;
                        Ok(res)
                    };
                    Box::pin(fut)
                }
                _ => Box::pin(async move {
                    Ok(http::Response::builder()
                        .status(200)
                        .header("grpc-status", "12")
                        .body(tonic::body::BoxBody::empty())
                        .unwrap())
                }),
            }
        }
    }
    impl<T: CarrierConstantService> Clone for CarrierConstantServiceServer<T> {
        fn clone(&self) -> Self {
            let inner = self.inner.clone();
            Self { inner }
        }
    }
    impl<T: CarrierConstantService> Clone for _Inner<T> {
        fn clone(&self) -> Self {
            Self(self.0.clone(), self.1.clone())
        }
    }
    impl<T: std::fmt::Debug> std::fmt::Debug for _Inner<T> {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
            write!(f, "{:?}", self.0)
        }
    }
    impl<T: CarrierConstantService> tonic::transport::NamedService for CarrierConstantServiceServer<T> {
        const NAME: &'static str = "google.ads.googleads.v1.services.CarrierConstantService";
    }
}
/// Request message for '[ChangeStatusService.GetChangeStatus][google.ads.googleads.v1.services.ChangeStatusService.GetChangeStatus]'.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GetChangeStatusRequest {
    /// Required. The resource name of the change status to fetch.
    #[prost(string, tag = "1")]
    pub resource_name: std::string::String,
}
#[doc = r" Generated client implementations."]
pub mod change_status_service_client {
    #![allow(unused_variables, dead_code, missing_docs)]
    use tonic::codegen::*;
    #[doc = " Service to fetch change statuses."]
    pub struct ChangeStatusServiceClient<T> {
        inner: tonic::client::Grpc<T>,
    }
    impl ChangeStatusServiceClient<tonic::transport::Channel> {
        #[doc = r" Attempt to create a new client by connecting to a given endpoint."]
        pub async fn connect<D>(dst: D) -> Result<Self, tonic::transport::Error>
        where
            D: std::convert::TryInto<tonic::transport::Endpoint>,
            D::Error: Into<StdError>,
        {
            let conn = tonic::transport::Endpoint::new(dst)?.connect().await?;
            Ok(Self::new(conn))
        }
    }
    impl<T> ChangeStatusServiceClient<T>
    where
        T: tonic::client::GrpcService<tonic::body::BoxBody>,
        T::ResponseBody: Body + HttpBody + Send + 'static,
        T::Error: Into<StdError>,
        <T::ResponseBody as HttpBody>::Error: Into<StdError> + Send,
    {
        pub fn new(inner: T) -> Self {
            let inner = tonic::client::Grpc::new(inner);
            Self { inner }
        }
        pub fn with_interceptor(inner: T, interceptor: impl Into<tonic::Interceptor>) -> Self {
            let inner = tonic::client::Grpc::with_interceptor(inner, interceptor);
            Self { inner }
        }
        #[doc = " Returns the requested change status in full detail."]
        pub async fn get_change_status(
            &mut self,
            request: impl tonic::IntoRequest<super::GetChangeStatusRequest>,
        ) -> Result<tonic::Response<super::super::resources::ChangeStatus>, tonic::Status> {
            self.inner.ready().await.map_err(|e| {
                tonic::Status::new(
                    tonic::Code::Unknown,
                    format!("Service was not ready: {}", e.into()),
                )
            })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.ads.googleads.v1.services.ChangeStatusService/GetChangeStatus",
            );
            self.inner.unary(request.into_request(), path, codec).await
        }
    }
    impl<T: Clone> Clone for ChangeStatusServiceClient<T> {
        fn clone(&self) -> Self {
            Self {
                inner: self.inner.clone(),
            }
        }
    }
    impl<T> std::fmt::Debug for ChangeStatusServiceClient<T> {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
            write!(f, "ChangeStatusServiceClient {{ ... }}")
        }
    }
}
#[doc = r" Generated server implementations."]
pub mod change_status_service_server {
    #![allow(unused_variables, dead_code, missing_docs)]
    use tonic::codegen::*;
    #[doc = "Generated trait containing gRPC methods that should be implemented for use with ChangeStatusServiceServer."]
    #[async_trait]
    pub trait ChangeStatusService: Send + Sync + 'static {
        #[doc = " Returns the requested change status in full detail."]
        async fn get_change_status(
            &self,
            request: tonic::Request<super::GetChangeStatusRequest>,
        ) -> Result<tonic::Response<super::super::resources::ChangeStatus>, tonic::Status>;
    }
    #[doc = " Service to fetch change statuses."]
    #[derive(Debug)]
    #[doc(hidden)]
    pub struct ChangeStatusServiceServer<T: ChangeStatusService> {
        inner: _Inner<T>,
    }
    struct _Inner<T>(Arc<T>, Option<tonic::Interceptor>);
    impl<T: ChangeStatusService> ChangeStatusServiceServer<T> {
        pub fn new(inner: T) -> Self {
            let inner = Arc::new(inner);
            let inner = _Inner(inner, None);
            Self { inner }
        }
        pub fn with_interceptor(inner: T, interceptor: impl Into<tonic::Interceptor>) -> Self {
            let inner = Arc::new(inner);
            let inner = _Inner(inner, Some(interceptor.into()));
            Self { inner }
        }
    }
    impl<T, B> Service<http::Request<B>> for ChangeStatusServiceServer<T>
    where
        T: ChangeStatusService,
        B: HttpBody + Send + Sync + 'static,
        B::Error: Into<StdError> + Send + 'static,
    {
        type Response = http::Response<tonic::body::BoxBody>;
        type Error = Never;
        type Future = BoxFuture<Self::Response, Self::Error>;
        fn poll_ready(&mut self, _cx: &mut Context<'_>) -> Poll<Result<(), Self::Error>> {
            Poll::Ready(Ok(()))
        }
        fn call(&mut self, req: http::Request<B>) -> Self::Future {
            let inner = self.inner.clone();
            match req.uri().path() {
                "/google.ads.googleads.v1.services.ChangeStatusService/GetChangeStatus" => {
                    #[allow(non_camel_case_types)]
                    struct GetChangeStatusSvc<T: ChangeStatusService>(pub Arc<T>);
                    impl<T: ChangeStatusService>
                        tonic::server::UnaryService<super::GetChangeStatusRequest>
                        for GetChangeStatusSvc<T>
                    {
                        type Response = super::super::resources::ChangeStatus;
                        type Future = BoxFuture<tonic::Response<Self::Response>, tonic::Status>;
                        fn call(
                            &mut self,
                            request: tonic::Request<super::GetChangeStatusRequest>,
                        ) -> Self::Future {
                            let inner = self.0.clone();
                            let fut = async move { inner.get_change_status(request).await };
                            Box::pin(fut)
                        }
                    }
                    let inner = self.inner.clone();
                    let fut = async move {
                        let interceptor = inner.1.clone();
                        let inner = inner.0;
                        let method = GetChangeStatusSvc(inner);
                        let codec = tonic::codec::ProstCodec::default();
                        let mut grpc = if let Some(interceptor) = interceptor {
                            tonic::server::Grpc::with_interceptor(codec, interceptor)
                        } else {
                            tonic::server::Grpc::new(codec)
                        };
                        let res = grpc.unary(method, req).await;
                        Ok(res)
                    };
                    Box::pin(fut)
                }
                _ => Box::pin(async move {
                    Ok(http::Response::builder()
                        .status(200)
                        .header("grpc-status", "12")
                        .body(tonic::body::BoxBody::empty())
                        .unwrap())
                }),
            }
        }
    }
    impl<T: ChangeStatusService> Clone for ChangeStatusServiceServer<T> {
        fn clone(&self) -> Self {
            let inner = self.inner.clone();
            Self { inner }
        }
    }
    impl<T: ChangeStatusService> Clone for _Inner<T> {
        fn clone(&self) -> Self {
            Self(self.0.clone(), self.1.clone())
        }
    }
    impl<T: std::fmt::Debug> std::fmt::Debug for _Inner<T> {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
            write!(f, "{:?}", self.0)
        }
    }
    impl<T: ChangeStatusService> tonic::transport::NamedService for ChangeStatusServiceServer<T> {
        const NAME: &'static str = "google.ads.googleads.v1.services.ChangeStatusService";
    }
}
/// Request message for [ClickViewService.GetClickView][google.ads.googleads.v1.services.ClickViewService.GetClickView].
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GetClickViewRequest {
    /// Required. The resource name of the click view to fetch.
    #[prost(string, tag = "1")]
    pub resource_name: std::string::String,
}
#[doc = r" Generated client implementations."]
pub mod click_view_service_client {
    #![allow(unused_variables, dead_code, missing_docs)]
    use tonic::codegen::*;
    #[doc = " Service to fetch click views."]
    pub struct ClickViewServiceClient<T> {
        inner: tonic::client::Grpc<T>,
    }
    impl ClickViewServiceClient<tonic::transport::Channel> {
        #[doc = r" Attempt to create a new client by connecting to a given endpoint."]
        pub async fn connect<D>(dst: D) -> Result<Self, tonic::transport::Error>
        where
            D: std::convert::TryInto<tonic::transport::Endpoint>,
            D::Error: Into<StdError>,
        {
            let conn = tonic::transport::Endpoint::new(dst)?.connect().await?;
            Ok(Self::new(conn))
        }
    }
    impl<T> ClickViewServiceClient<T>
    where
        T: tonic::client::GrpcService<tonic::body::BoxBody>,
        T::ResponseBody: Body + HttpBody + Send + 'static,
        T::Error: Into<StdError>,
        <T::ResponseBody as HttpBody>::Error: Into<StdError> + Send,
    {
        pub fn new(inner: T) -> Self {
            let inner = tonic::client::Grpc::new(inner);
            Self { inner }
        }
        pub fn with_interceptor(inner: T, interceptor: impl Into<tonic::Interceptor>) -> Self {
            let inner = tonic::client::Grpc::with_interceptor(inner, interceptor);
            Self { inner }
        }
        #[doc = " Returns the requested click view in full detail."]
        pub async fn get_click_view(
            &mut self,
            request: impl tonic::IntoRequest<super::GetClickViewRequest>,
        ) -> Result<tonic::Response<super::super::resources::ClickView>, tonic::Status> {
            self.inner.ready().await.map_err(|e| {
                tonic::Status::new(
                    tonic::Code::Unknown,
                    format!("Service was not ready: {}", e.into()),
                )
            })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.ads.googleads.v1.services.ClickViewService/GetClickView",
            );
            self.inner.unary(request.into_request(), path, codec).await
        }
    }
    impl<T: Clone> Clone for ClickViewServiceClient<T> {
        fn clone(&self) -> Self {
            Self {
                inner: self.inner.clone(),
            }
        }
    }
    impl<T> std::fmt::Debug for ClickViewServiceClient<T> {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
            write!(f, "ClickViewServiceClient {{ ... }}")
        }
    }
}
#[doc = r" Generated server implementations."]
pub mod click_view_service_server {
    #![allow(unused_variables, dead_code, missing_docs)]
    use tonic::codegen::*;
    #[doc = "Generated trait containing gRPC methods that should be implemented for use with ClickViewServiceServer."]
    #[async_trait]
    pub trait ClickViewService: Send + Sync + 'static {
        #[doc = " Returns the requested click view in full detail."]
        async fn get_click_view(
            &self,
            request: tonic::Request<super::GetClickViewRequest>,
        ) -> Result<tonic::Response<super::super::resources::ClickView>, tonic::Status>;
    }
    #[doc = " Service to fetch click views."]
    #[derive(Debug)]
    #[doc(hidden)]
    pub struct ClickViewServiceServer<T: ClickViewService> {
        inner: _Inner<T>,
    }
    struct _Inner<T>(Arc<T>, Option<tonic::Interceptor>);
    impl<T: ClickViewService> ClickViewServiceServer<T> {
        pub fn new(inner: T) -> Self {
            let inner = Arc::new(inner);
            let inner = _Inner(inner, None);
            Self { inner }
        }
        pub fn with_interceptor(inner: T, interceptor: impl Into<tonic::Interceptor>) -> Self {
            let inner = Arc::new(inner);
            let inner = _Inner(inner, Some(interceptor.into()));
            Self { inner }
        }
    }
    impl<T, B> Service<http::Request<B>> for ClickViewServiceServer<T>
    where
        T: ClickViewService,
        B: HttpBody + Send + Sync + 'static,
        B::Error: Into<StdError> + Send + 'static,
    {
        type Response = http::Response<tonic::body::BoxBody>;
        type Error = Never;
        type Future = BoxFuture<Self::Response, Self::Error>;
        fn poll_ready(&mut self, _cx: &mut Context<'_>) -> Poll<Result<(), Self::Error>> {
            Poll::Ready(Ok(()))
        }
        fn call(&mut self, req: http::Request<B>) -> Self::Future {
            let inner = self.inner.clone();
            match req.uri().path() {
                "/google.ads.googleads.v1.services.ClickViewService/GetClickView" => {
                    #[allow(non_camel_case_types)]
                    struct GetClickViewSvc<T: ClickViewService>(pub Arc<T>);
                    impl<T: ClickViewService>
                        tonic::server::UnaryService<super::GetClickViewRequest>
                        for GetClickViewSvc<T>
                    {
                        type Response = super::super::resources::ClickView;
                        type Future = BoxFuture<tonic::Response<Self::Response>, tonic::Status>;
                        fn call(
                            &mut self,
                            request: tonic::Request<super::GetClickViewRequest>,
                        ) -> Self::Future {
                            let inner = self.0.clone();
                            let fut = async move { inner.get_click_view(request).await };
                            Box::pin(fut)
                        }
                    }
                    let inner = self.inner.clone();
                    let fut = async move {
                        let interceptor = inner.1.clone();
                        let inner = inner.0;
                        let method = GetClickViewSvc(inner);
                        let codec = tonic::codec::ProstCodec::default();
                        let mut grpc = if let Some(interceptor) = interceptor {
                            tonic::server::Grpc::with_interceptor(codec, interceptor)
                        } else {
                            tonic::server::Grpc::new(codec)
                        };
                        let res = grpc.unary(method, req).await;
                        Ok(res)
                    };
                    Box::pin(fut)
                }
                _ => Box::pin(async move {
                    Ok(http::Response::builder()
                        .status(200)
                        .header("grpc-status", "12")
                        .body(tonic::body::BoxBody::empty())
                        .unwrap())
                }),
            }
        }
    }
    impl<T: ClickViewService> Clone for ClickViewServiceServer<T> {
        fn clone(&self) -> Self {
            let inner = self.inner.clone();
            Self { inner }
        }
    }
    impl<T: ClickViewService> Clone for _Inner<T> {
        fn clone(&self) -> Self {
            Self(self.0.clone(), self.1.clone())
        }
    }
    impl<T: std::fmt::Debug> std::fmt::Debug for _Inner<T> {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
            write!(f, "{:?}", self.0)
        }
    }
    impl<T: ClickViewService> tonic::transport::NamedService for ClickViewServiceServer<T> {
        const NAME: &'static str = "google.ads.googleads.v1.services.ClickViewService";
    }
}
/// Request message for [ConversionActionService.GetConversionAction][google.ads.googleads.v1.services.ConversionActionService.GetConversionAction].
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GetConversionActionRequest {
    /// Required. The resource name of the conversion action to fetch.
    #[prost(string, tag = "1")]
    pub resource_name: std::string::String,
}
/// Request message for [ConversionActionService.MutateConversionActions][google.ads.googleads.v1.services.ConversionActionService.MutateConversionActions].
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct MutateConversionActionsRequest {
    /// Required. The ID of the customer whose conversion actions are being modified.
    #[prost(string, tag = "1")]
    pub customer_id: std::string::String,
    /// Required. The list of operations to perform on individual conversion actions.
    #[prost(message, repeated, tag = "2")]
    pub operations: ::std::vec::Vec<ConversionActionOperation>,
    /// If true, successful operations will be carried out and invalid
    /// operations will return errors. If false, all operations will be carried
    /// out in one transaction if and only if they are all valid.
    /// Default is false.
    #[prost(bool, tag = "3")]
    pub partial_failure: bool,
    /// If true, the request is validated but not executed. Only errors are
    /// returned, not results.
    #[prost(bool, tag = "4")]
    pub validate_only: bool,
}
/// A single operation (create, update, remove) on a conversion action.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ConversionActionOperation {
    /// FieldMask that determines which resource fields are modified in an update.
    #[prost(message, optional, tag = "4")]
    pub update_mask: ::std::option::Option<::prost_types::FieldMask>,
    /// The mutate operation.
    #[prost(oneof = "conversion_action_operation::Operation", tags = "1, 2, 3")]
    pub operation: ::std::option::Option<conversion_action_operation::Operation>,
}
pub mod conversion_action_operation {
    /// The mutate operation.
    #[derive(Clone, PartialEq, ::prost::Oneof)]
    pub enum Operation {
        /// Create operation: No resource name is expected for the new conversion
        /// action.
        #[prost(message, tag = "1")]
        Create(super::super::resources::ConversionAction),
        /// Update operation: The conversion action is expected to have a valid
        /// resource name.
        #[prost(message, tag = "2")]
        Update(super::super::resources::ConversionAction),
        /// Remove operation: A resource name for the removed conversion action is
        /// expected, in this format:
        ///
        /// `customers/{customer_id}/conversionActions/{conversion_action_id}`
        #[prost(string, tag = "3")]
        Remove(std::string::String),
    }
}
/// Response message for [ConversionActionService.MutateConversionActions][google.ads.googleads.v1.services.ConversionActionService.MutateConversionActions].
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct MutateConversionActionsResponse {
    /// Errors that pertain to operation failures in the partial failure mode.
    /// Returned only when partial_failure = true and all errors occur inside the
    /// operations. If any errors occur outside the operations (e.g. auth errors),
    /// we return an RPC level error.
    #[prost(message, optional, tag = "3")]
    pub partial_failure_error: ::std::option::Option<super::super::super::super::rpc::Status>,
    /// All results for the mutate.
    #[prost(message, repeated, tag = "2")]
    pub results: ::std::vec::Vec<MutateConversionActionResult>,
}
/// The result for the conversion action mutate.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct MutateConversionActionResult {
    /// Returned for successful operations.
    #[prost(string, tag = "1")]
    pub resource_name: std::string::String,
}
#[doc = r" Generated client implementations."]
pub mod conversion_action_service_client {
    #![allow(unused_variables, dead_code, missing_docs)]
    use tonic::codegen::*;
    #[doc = " Service to manage conversion actions."]
    pub struct ConversionActionServiceClient<T> {
        inner: tonic::client::Grpc<T>,
    }
    impl ConversionActionServiceClient<tonic::transport::Channel> {
        #[doc = r" Attempt to create a new client by connecting to a given endpoint."]
        pub async fn connect<D>(dst: D) -> Result<Self, tonic::transport::Error>
        where
            D: std::convert::TryInto<tonic::transport::Endpoint>,
            D::Error: Into<StdError>,
        {
            let conn = tonic::transport::Endpoint::new(dst)?.connect().await?;
            Ok(Self::new(conn))
        }
    }
    impl<T> ConversionActionServiceClient<T>
    where
        T: tonic::client::GrpcService<tonic::body::BoxBody>,
        T::ResponseBody: Body + HttpBody + Send + 'static,
        T::Error: Into<StdError>,
        <T::ResponseBody as HttpBody>::Error: Into<StdError> + Send,
    {
        pub fn new(inner: T) -> Self {
            let inner = tonic::client::Grpc::new(inner);
            Self { inner }
        }
        pub fn with_interceptor(inner: T, interceptor: impl Into<tonic::Interceptor>) -> Self {
            let inner = tonic::client::Grpc::with_interceptor(inner, interceptor);
            Self { inner }
        }
        #[doc = " Returns the requested conversion action."]
        pub async fn get_conversion_action(
            &mut self,
            request: impl tonic::IntoRequest<super::GetConversionActionRequest>,
        ) -> Result<tonic::Response<super::super::resources::ConversionAction>, tonic::Status>
        {
            self.inner.ready().await.map_err(|e| {
                tonic::Status::new(
                    tonic::Code::Unknown,
                    format!("Service was not ready: {}", e.into()),
                )
            })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.ads.googleads.v1.services.ConversionActionService/GetConversionAction",
            );
            self.inner.unary(request.into_request(), path, codec).await
        }
        #[doc = " Creates, updates or removes conversion actions. Operation statuses are"]
        #[doc = " returned."]
        pub async fn mutate_conversion_actions(
            &mut self,
            request: impl tonic::IntoRequest<super::MutateConversionActionsRequest>,
        ) -> Result<tonic::Response<super::MutateConversionActionsResponse>, tonic::Status>
        {
            self.inner.ready().await.map_err(|e| {
                tonic::Status::new(
                    tonic::Code::Unknown,
                    format!("Service was not ready: {}", e.into()),
                )
            })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.ads.googleads.v1.services.ConversionActionService/MutateConversionActions",
            );
            self.inner.unary(request.into_request(), path, codec).await
        }
    }
    impl<T: Clone> Clone for ConversionActionServiceClient<T> {
        fn clone(&self) -> Self {
            Self {
                inner: self.inner.clone(),
            }
        }
    }
    impl<T> std::fmt::Debug for ConversionActionServiceClient<T> {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
            write!(f, "ConversionActionServiceClient {{ ... }}")
        }
    }
}
#[doc = r" Generated server implementations."]
pub mod conversion_action_service_server {
    #![allow(unused_variables, dead_code, missing_docs)]
    use tonic::codegen::*;
    #[doc = "Generated trait containing gRPC methods that should be implemented for use with ConversionActionServiceServer."]
    #[async_trait]
    pub trait ConversionActionService: Send + Sync + 'static {
        #[doc = " Returns the requested conversion action."]
        async fn get_conversion_action(
            &self,
            request: tonic::Request<super::GetConversionActionRequest>,
        ) -> Result<tonic::Response<super::super::resources::ConversionAction>, tonic::Status>;
        #[doc = " Creates, updates or removes conversion actions. Operation statuses are"]
        #[doc = " returned."]
        async fn mutate_conversion_actions(
            &self,
            request: tonic::Request<super::MutateConversionActionsRequest>,
        ) -> Result<tonic::Response<super::MutateConversionActionsResponse>, tonic::Status>;
    }
    #[doc = " Service to manage conversion actions."]
    #[derive(Debug)]
    #[doc(hidden)]
    pub struct ConversionActionServiceServer<T: ConversionActionService> {
        inner: _Inner<T>,
    }
    struct _Inner<T>(Arc<T>, Option<tonic::Interceptor>);
    impl<T: ConversionActionService> ConversionActionServiceServer<T> {
        pub fn new(inner: T) -> Self {
            let inner = Arc::new(inner);
            let inner = _Inner(inner, None);
            Self { inner }
        }
        pub fn with_interceptor(inner: T, interceptor: impl Into<tonic::Interceptor>) -> Self {
            let inner = Arc::new(inner);
            let inner = _Inner(inner, Some(interceptor.into()));
            Self { inner }
        }
    }
    impl<T, B> Service<http::Request<B>> for ConversionActionServiceServer<T>
    where
        T: ConversionActionService,
        B: HttpBody + Send + Sync + 'static,
        B::Error: Into<StdError> + Send + 'static,
    {
        type Response = http::Response<tonic::body::BoxBody>;
        type Error = Never;
        type Future = BoxFuture<Self::Response, Self::Error>;
        fn poll_ready(&mut self, _cx: &mut Context<'_>) -> Poll<Result<(), Self::Error>> {
            Poll::Ready(Ok(()))
        }
        fn call(&mut self, req: http::Request<B>) -> Self::Future {
            let inner = self.inner.clone();
            match req . uri ( ) . path ( ) { "/google.ads.googleads.v1.services.ConversionActionService/GetConversionAction" => { # [ allow ( non_camel_case_types ) ] struct GetConversionActionSvc < T : ConversionActionService > ( pub Arc < T > ) ; impl < T : ConversionActionService > tonic :: server :: UnaryService < super :: GetConversionActionRequest > for GetConversionActionSvc < T > { type Response = super :: super :: resources :: ConversionAction ; type Future = BoxFuture < tonic :: Response < Self :: Response > , tonic :: Status > ; fn call ( & mut self , request : tonic :: Request < super :: GetConversionActionRequest > ) -> Self :: Future { let inner = self . 0 . clone ( ) ; let fut = async move { inner . get_conversion_action ( request ) . await } ; Box :: pin ( fut ) } } let inner = self . inner . clone ( ) ; let fut = async move { let interceptor = inner . 1 . clone ( ) ; let inner = inner . 0 ; let method = GetConversionActionSvc ( inner ) ; let codec = tonic :: codec :: ProstCodec :: default ( ) ; let mut grpc = if let Some ( interceptor ) = interceptor { tonic :: server :: Grpc :: with_interceptor ( codec , interceptor ) } else { tonic :: server :: Grpc :: new ( codec ) } ; let res = grpc . unary ( method , req ) . await ; Ok ( res ) } ; Box :: pin ( fut ) } "/google.ads.googleads.v1.services.ConversionActionService/MutateConversionActions" => { # [ allow ( non_camel_case_types ) ] struct MutateConversionActionsSvc < T : ConversionActionService > ( pub Arc < T > ) ; impl < T : ConversionActionService > tonic :: server :: UnaryService < super :: MutateConversionActionsRequest > for MutateConversionActionsSvc < T > { type Response = super :: MutateConversionActionsResponse ; type Future = BoxFuture < tonic :: Response < Self :: Response > , tonic :: Status > ; fn call ( & mut self , request : tonic :: Request < super :: MutateConversionActionsRequest > ) -> Self :: Future { let inner = self . 0 . clone ( ) ; let fut = async move { inner . mutate_conversion_actions ( request ) . await } ; Box :: pin ( fut ) } } let inner = self . inner . clone ( ) ; let fut = async move { let interceptor = inner . 1 . clone ( ) ; let inner = inner . 0 ; let method = MutateConversionActionsSvc ( inner ) ; let codec = tonic :: codec :: ProstCodec :: default ( ) ; let mut grpc = if let Some ( interceptor ) = interceptor { tonic :: server :: Grpc :: with_interceptor ( codec , interceptor ) } else { tonic :: server :: Grpc :: new ( codec ) } ; let res = grpc . unary ( method , req ) . await ; Ok ( res ) } ; Box :: pin ( fut ) } _ => Box :: pin ( async move { Ok ( http :: Response :: builder ( ) . status ( 200 ) . header ( "grpc-status" , "12" ) . body ( tonic :: body :: BoxBody :: empty ( ) ) . unwrap ( ) ) } ) , }
        }
    }
    impl<T: ConversionActionService> Clone for ConversionActionServiceServer<T> {
        fn clone(&self) -> Self {
            let inner = self.inner.clone();
            Self { inner }
        }
    }
    impl<T: ConversionActionService> Clone for _Inner<T> {
        fn clone(&self) -> Self {
            Self(self.0.clone(), self.1.clone())
        }
    }
    impl<T: std::fmt::Debug> std::fmt::Debug for _Inner<T> {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
            write!(f, "{:?}", self.0)
        }
    }
    impl<T: ConversionActionService> tonic::transport::NamedService
        for ConversionActionServiceServer<T>
    {
        const NAME: &'static str = "google.ads.googleads.v1.services.ConversionActionService";
    }
}
/// Request message for
/// [ConversionAdjustmentUploadService.UploadConversionAdjustments][google.ads.googleads.v1.services.ConversionAdjustmentUploadService.UploadConversionAdjustments].
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct UploadConversionAdjustmentsRequest {
    /// Required. The ID of the customer performing the upload.
    #[prost(string, tag = "1")]
    pub customer_id: std::string::String,
    /// Required. The conversion adjustments that are being uploaded.
    #[prost(message, repeated, tag = "2")]
    pub conversion_adjustments: ::std::vec::Vec<ConversionAdjustment>,
    /// If true, successful operations will be carried out and invalid
    /// operations will return errors. If false, all operations will be carried out
    /// in one transaction if and only if they are all valid. This should always be
    /// set to true.
    #[prost(bool, tag = "3")]
    pub partial_failure: bool,
    /// If true, the request is validated but not executed. Only errors are
    /// returned, not results.
    #[prost(bool, tag = "4")]
    pub validate_only: bool,
}
/// Response message for
/// [ConversionAdjustmentUploadService.UploadConversionAdjustments][google.ads.googleads.v1.services.ConversionAdjustmentUploadService.UploadConversionAdjustments].
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct UploadConversionAdjustmentsResponse {
    /// Errors that pertain to conversion adjustment failures in the partial
    /// failure mode. Returned when all errors occur inside the adjustments. If any
    /// errors occur outside the adjustments (e.g. auth errors), we return an RPC
    /// level error.
    #[prost(message, optional, tag = "1")]
    pub partial_failure_error: ::std::option::Option<super::super::super::super::rpc::Status>,
    /// Returned for successfully processed conversion adjustments. Proto will be
    /// empty for rows that received an error. Results are not returned when
    /// validate_only is true.
    #[prost(message, repeated, tag = "2")]
    pub results: ::std::vec::Vec<ConversionAdjustmentResult>,
}
/// A conversion adjustment.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ConversionAdjustment {
    /// Resource name of the conversion action associated with this conversion
    /// adjustment. Note: Although this resource name consists of a customer id and
    /// a conversion action id, validation will ignore the customer id and use the
    /// conversion action id as the sole identifier of the conversion action.
    #[prost(message, optional, tag = "3")]
    pub conversion_action: ::std::option::Option<::std::string::String>,
    /// The date time at which the adjustment occurred. Must be after the
    /// conversion_date_time. The timezone must be specified. The format is
    /// "yyyy-mm-dd hh:mm:ss+|-hh:mm", e.g. "2019-01-01 12:32:45-08:00".
    #[prost(message, optional, tag = "4")]
    pub adjustment_date_time: ::std::option::Option<::std::string::String>,
    /// The adjustment type.
    #[prost(
        enumeration = "super::enums::conversion_adjustment_type_enum::ConversionAdjustmentType",
        tag = "5"
    )]
    pub adjustment_type: i32,
    /// Information needed to restate the conversion's value.
    /// Required for restatements. Should not be supplied for retractions. An error
    /// will be returned if provided for a retraction.
    #[prost(message, optional, tag = "6")]
    pub restatement_value: ::std::option::Option<RestatementValue>,
    /// Identifies the conversion to be adjusted.
    #[prost(oneof = "conversion_adjustment::ConversionIdentifier", tags = "1, 2")]
    pub conversion_identifier: ::std::option::Option<conversion_adjustment::ConversionIdentifier>,
}
pub mod conversion_adjustment {
    /// Identifies the conversion to be adjusted.
    #[derive(Clone, PartialEq, ::prost::Oneof)]
    pub enum ConversionIdentifier {
        /// Uniquely identifies a conversion that was reported without an order ID
        /// specified.
        #[prost(message, tag = "1")]
        GclidDateTimePair(super::GclidDateTimePair),
        /// The order ID of the conversion to be adjusted. If the conversion was
        /// reported with an order ID specified, that order ID must be used as the
        /// identifier here.
        #[prost(message, tag = "2")]
        OrderId(::std::string::String),
    }
}
/// Contains information needed to restate a conversion's value.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct RestatementValue {
    /// The restated conversion value. This is the value of the conversion after
    /// restatement. For example, to change the value of a conversion from 100 to
    /// 70, an adjusted value of 70 should be reported.
    #[prost(message, optional, tag = "1")]
    pub adjusted_value: ::std::option::Option<f64>,
    /// The currency of the restated value. If not provided, then the default
    /// currency from the conversion action is used, and if that is not set then
    /// the account currency is used. This is the ISO 4217 3-character currency
    /// code e.g. USD or EUR.
    #[prost(message, optional, tag = "2")]
    pub currency_code: ::std::option::Option<::std::string::String>,
}
/// Uniquely identifies a conversion that was reported without an order ID
/// specified.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GclidDateTimePair {
    /// Google click ID (gclid) associated with the original conversion for this
    /// adjustment.
    #[prost(message, optional, tag = "1")]
    pub gclid: ::std::option::Option<::std::string::String>,
    /// The date time at which the original conversion for this adjustment
    /// occurred. The timezone must be specified. The format is "yyyy-mm-dd
    /// hh:mm:ss+|-hh:mm", e.g. "2019-01-01 12:32:45-08:00".
    #[prost(message, optional, tag = "2")]
    pub conversion_date_time: ::std::option::Option<::std::string::String>,
}
/// Information identifying a successfully processed ConversionAdjustment.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ConversionAdjustmentResult {
    /// Resource name of the conversion action associated with this conversion
    /// adjustment.
    #[prost(message, optional, tag = "3")]
    pub conversion_action: ::std::option::Option<::std::string::String>,
    /// The date time at which the adjustment occurred. The format is
    /// "yyyy-mm-dd hh:mm:ss+|-hh:mm", e.g. "2019-01-01 12:32:45-08:00".
    #[prost(message, optional, tag = "4")]
    pub adjustment_date_time: ::std::option::Option<::std::string::String>,
    /// The adjustment type.
    #[prost(
        enumeration = "super::enums::conversion_adjustment_type_enum::ConversionAdjustmentType",
        tag = "5"
    )]
    pub adjustment_type: i32,
    /// Identifies the conversion that was adjusted.
    #[prost(
        oneof = "conversion_adjustment_result::ConversionIdentifier",
        tags = "1, 2"
    )]
    pub conversion_identifier:
        ::std::option::Option<conversion_adjustment_result::ConversionIdentifier>,
}
pub mod conversion_adjustment_result {
    /// Identifies the conversion that was adjusted.
    #[derive(Clone, PartialEq, ::prost::Oneof)]
    pub enum ConversionIdentifier {
        /// Uniquely identifies a conversion that was reported without an order ID
        /// specified.
        #[prost(message, tag = "1")]
        GclidDateTimePair(super::GclidDateTimePair),
        /// The order ID of the conversion that was adjusted.
        #[prost(message, tag = "2")]
        OrderId(::std::string::String),
    }
}
#[doc = r" Generated client implementations."]
pub mod conversion_adjustment_upload_service_client {
    #![allow(unused_variables, dead_code, missing_docs)]
    use tonic::codegen::*;
    #[doc = " Service to upload conversion adjustments."]
    pub struct ConversionAdjustmentUploadServiceClient<T> {
        inner: tonic::client::Grpc<T>,
    }
    impl ConversionAdjustmentUploadServiceClient<tonic::transport::Channel> {
        #[doc = r" Attempt to create a new client by connecting to a given endpoint."]
        pub async fn connect<D>(dst: D) -> Result<Self, tonic::transport::Error>
        where
            D: std::convert::TryInto<tonic::transport::Endpoint>,
            D::Error: Into<StdError>,
        {
            let conn = tonic::transport::Endpoint::new(dst)?.connect().await?;
            Ok(Self::new(conn))
        }
    }
    impl<T> ConversionAdjustmentUploadServiceClient<T>
    where
        T: tonic::client::GrpcService<tonic::body::BoxBody>,
        T::ResponseBody: Body + HttpBody + Send + 'static,
        T::Error: Into<StdError>,
        <T::ResponseBody as HttpBody>::Error: Into<StdError> + Send,
    {
        pub fn new(inner: T) -> Self {
            let inner = tonic::client::Grpc::new(inner);
            Self { inner }
        }
        pub fn with_interceptor(inner: T, interceptor: impl Into<tonic::Interceptor>) -> Self {
            let inner = tonic::client::Grpc::with_interceptor(inner, interceptor);
            Self { inner }
        }
        #[doc = " Processes the given conversion adjustments."]
        pub async fn upload_conversion_adjustments(
            &mut self,
            request: impl tonic::IntoRequest<super::UploadConversionAdjustmentsRequest>,
        ) -> Result<tonic::Response<super::UploadConversionAdjustmentsResponse>, tonic::Status>
        {
            self.inner.ready().await.map_err(|e| {
                tonic::Status::new(
                    tonic::Code::Unknown,
                    format!("Service was not ready: {}", e.into()),
                )
            })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http :: uri :: PathAndQuery :: from_static ( "/google.ads.googleads.v1.services.ConversionAdjustmentUploadService/UploadConversionAdjustments" ) ;
            self.inner.unary(request.into_request(), path, codec).await
        }
    }
    impl<T: Clone> Clone for ConversionAdjustmentUploadServiceClient<T> {
        fn clone(&self) -> Self {
            Self {
                inner: self.inner.clone(),
            }
        }
    }
    impl<T> std::fmt::Debug for ConversionAdjustmentUploadServiceClient<T> {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
            write!(f, "ConversionAdjustmentUploadServiceClient {{ ... }}")
        }
    }
}
#[doc = r" Generated server implementations."]
pub mod conversion_adjustment_upload_service_server {
    #![allow(unused_variables, dead_code, missing_docs)]
    use tonic::codegen::*;
    #[doc = "Generated trait containing gRPC methods that should be implemented for use with ConversionAdjustmentUploadServiceServer."]
    #[async_trait]
    pub trait ConversionAdjustmentUploadService: Send + Sync + 'static {
        #[doc = " Processes the given conversion adjustments."]
        async fn upload_conversion_adjustments(
            &self,
            request: tonic::Request<super::UploadConversionAdjustmentsRequest>,
        ) -> Result<tonic::Response<super::UploadConversionAdjustmentsResponse>, tonic::Status>;
    }
    #[doc = " Service to upload conversion adjustments."]
    #[derive(Debug)]
    #[doc(hidden)]
    pub struct ConversionAdjustmentUploadServiceServer<T: ConversionAdjustmentUploadService> {
        inner: _Inner<T>,
    }
    struct _Inner<T>(Arc<T>, Option<tonic::Interceptor>);
    impl<T: ConversionAdjustmentUploadService> ConversionAdjustmentUploadServiceServer<T> {
        pub fn new(inner: T) -> Self {
            let inner = Arc::new(inner);
            let inner = _Inner(inner, None);
            Self { inner }
        }
        pub fn with_interceptor(inner: T, interceptor: impl Into<tonic::Interceptor>) -> Self {
            let inner = Arc::new(inner);
            let inner = _Inner(inner, Some(interceptor.into()));
            Self { inner }
        }
    }
    impl<T, B> Service<http::Request<B>> for ConversionAdjustmentUploadServiceServer<T>
    where
        T: ConversionAdjustmentUploadService,
        B: HttpBody + Send + Sync + 'static,
        B::Error: Into<StdError> + Send + 'static,
    {
        type Response = http::Response<tonic::body::BoxBody>;
        type Error = Never;
        type Future = BoxFuture<Self::Response, Self::Error>;
        fn poll_ready(&mut self, _cx: &mut Context<'_>) -> Poll<Result<(), Self::Error>> {
            Poll::Ready(Ok(()))
        }
        fn call(&mut self, req: http::Request<B>) -> Self::Future {
            let inner = self.inner.clone();
            match req . uri ( ) . path ( ) { "/google.ads.googleads.v1.services.ConversionAdjustmentUploadService/UploadConversionAdjustments" => { # [ allow ( non_camel_case_types ) ] struct UploadConversionAdjustmentsSvc < T : ConversionAdjustmentUploadService > ( pub Arc < T > ) ; impl < T : ConversionAdjustmentUploadService > tonic :: server :: UnaryService < super :: UploadConversionAdjustmentsRequest > for UploadConversionAdjustmentsSvc < T > { type Response = super :: UploadConversionAdjustmentsResponse ; type Future = BoxFuture < tonic :: Response < Self :: Response > , tonic :: Status > ; fn call ( & mut self , request : tonic :: Request < super :: UploadConversionAdjustmentsRequest > ) -> Self :: Future { let inner = self . 0 . clone ( ) ; let fut = async move { inner . upload_conversion_adjustments ( request ) . await } ; Box :: pin ( fut ) } } let inner = self . inner . clone ( ) ; let fut = async move { let interceptor = inner . 1 . clone ( ) ; let inner = inner . 0 ; let method = UploadConversionAdjustmentsSvc ( inner ) ; let codec = tonic :: codec :: ProstCodec :: default ( ) ; let mut grpc = if let Some ( interceptor ) = interceptor { tonic :: server :: Grpc :: with_interceptor ( codec , interceptor ) } else { tonic :: server :: Grpc :: new ( codec ) } ; let res = grpc . unary ( method , req ) . await ; Ok ( res ) } ; Box :: pin ( fut ) } _ => Box :: pin ( async move { Ok ( http :: Response :: builder ( ) . status ( 200 ) . header ( "grpc-status" , "12" ) . body ( tonic :: body :: BoxBody :: empty ( ) ) . unwrap ( ) ) } ) , }
        }
    }
    impl<T: ConversionAdjustmentUploadService> Clone for ConversionAdjustmentUploadServiceServer<T> {
        fn clone(&self) -> Self {
            let inner = self.inner.clone();
            Self { inner }
        }
    }
    impl<T: ConversionAdjustmentUploadService> Clone for _Inner<T> {
        fn clone(&self) -> Self {
            Self(self.0.clone(), self.1.clone())
        }
    }
    impl<T: std::fmt::Debug> std::fmt::Debug for _Inner<T> {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
            write!(f, "{:?}", self.0)
        }
    }
    impl<T: ConversionAdjustmentUploadService> tonic::transport::NamedService
        for ConversionAdjustmentUploadServiceServer<T>
    {
        const NAME: &'static str =
            "google.ads.googleads.v1.services.ConversionAdjustmentUploadService";
    }
}
/// Request message for [ConversionUploadService.UploadClickConversions][google.ads.googleads.v1.services.ConversionUploadService.UploadClickConversions].
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct UploadClickConversionsRequest {
    /// Required. The ID of the customer performing the upload.
    #[prost(string, tag = "1")]
    pub customer_id: std::string::String,
    /// Required. The conversions that are being uploaded.
    #[prost(message, repeated, tag = "2")]
    pub conversions: ::std::vec::Vec<ClickConversion>,
    /// If true, successful operations will be carried out and invalid
    /// operations will return errors. If false, all operations will be carried
    /// out in one transaction if and only if they are all valid.
    /// This should always be set to true.
    #[prost(bool, tag = "3")]
    pub partial_failure: bool,
    /// If true, the request is validated but not executed. Only errors are
    /// returned, not results.
    #[prost(bool, tag = "4")]
    pub validate_only: bool,
}
/// Response message for [ConversionUploadService.UploadClickConversions][google.ads.googleads.v1.services.ConversionUploadService.UploadClickConversions].
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct UploadClickConversionsResponse {
    /// Errors that pertain to conversion failures in the partial failure mode.
    /// Returned when all errors occur inside the conversions. If any errors occur
    /// outside the conversions (e.g. auth errors), we return an RPC level error.
    #[prost(message, optional, tag = "1")]
    pub partial_failure_error: ::std::option::Option<super::super::super::super::rpc::Status>,
    /// Returned for successfully processed conversions. Proto will be empty for
    /// rows that received an error. Results are not returned when validate_only is
    /// true.
    #[prost(message, repeated, tag = "2")]
    pub results: ::std::vec::Vec<ClickConversionResult>,
}
/// Request message for [ConversionUploadService.UploadCallConversions][google.ads.googleads.v1.services.ConversionUploadService.UploadCallConversions].
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct UploadCallConversionsRequest {
    /// Required. The ID of the customer performing the upload.
    #[prost(string, tag = "1")]
    pub customer_id: std::string::String,
    /// Required. The conversions that are being uploaded.
    #[prost(message, repeated, tag = "2")]
    pub conversions: ::std::vec::Vec<CallConversion>,
    /// If true, successful operations will be carried out and invalid
    /// operations will return errors. If false, all operations will be carried
    /// out in one transaction if and only if they are all valid.
    /// This should always be set to true.
    #[prost(bool, tag = "3")]
    pub partial_failure: bool,
    /// If true, the request is validated but not executed. Only errors are
    /// returned, not results.
    #[prost(bool, tag = "4")]
    pub validate_only: bool,
}
/// Response message for [ConversionUploadService.UploadCallConversions][google.ads.googleads.v1.services.ConversionUploadService.UploadCallConversions].
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct UploadCallConversionsResponse {
    /// Errors that pertain to conversion failures in the partial failure mode.
    /// Returned when all errors occur inside the conversions. If any errors occur
    /// outside the conversions (e.g. auth errors), we return an RPC level error.
    #[prost(message, optional, tag = "1")]
    pub partial_failure_error: ::std::option::Option<super::super::super::super::rpc::Status>,
    /// Returned for successfully processed conversions. Proto will be empty for
    /// rows that received an error. Results are not returned when validate_only is
    /// true.
    #[prost(message, repeated, tag = "2")]
    pub results: ::std::vec::Vec<CallConversionResult>,
}
/// A click conversion.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ClickConversion {
    /// The Google click ID (gclid) associated with this conversion.
    #[prost(message, optional, tag = "1")]
    pub gclid: ::std::option::Option<::std::string::String>,
    /// Resource name of the conversion action associated with this conversion.
    /// Note: Although this resource name consists of a customer id and a
    /// conversion action id, validation will ignore the customer id and use the
    /// conversion action id as the sole identifier of the conversion action.
    #[prost(message, optional, tag = "2")]
    pub conversion_action: ::std::option::Option<::std::string::String>,
    /// The date time at which the conversion occurred. Must be after
    /// the click time. The timezone must be specified. The format is
    /// "yyyy-mm-dd hh:mm:ss+|-hh:mm", e.g. “2019-01-01 12:32:45-08:00”.
    #[prost(message, optional, tag = "3")]
    pub conversion_date_time: ::std::option::Option<::std::string::String>,
    /// The value of the conversion for the advertiser.
    #[prost(message, optional, tag = "4")]
    pub conversion_value: ::std::option::Option<f64>,
    /// Currency associated with the conversion value. This is the ISO 4217
    /// 3-character currency code. For example: USD, EUR.
    #[prost(message, optional, tag = "5")]
    pub currency_code: ::std::option::Option<::std::string::String>,
    /// The order ID associated with the conversion. An order id can only be used
    /// for one conversion per conversion action.
    #[prost(message, optional, tag = "6")]
    pub order_id: ::std::option::Option<::std::string::String>,
    /// Additional data about externally attributed conversions. This field
    /// is required for conversions with an externally attributed conversion
    /// action, but should not be set otherwise.
    #[prost(message, optional, tag = "7")]
    pub external_attribution_data: ::std::option::Option<ExternalAttributionData>,
}
/// A call conversion.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CallConversion {
    /// The caller id from which this call was placed. Caller id is expected to be
    /// in E.164 format with preceding '+' sign. e.g. "+16502531234".
    #[prost(message, optional, tag = "1")]
    pub caller_id: ::std::option::Option<::std::string::String>,
    /// The date time at which the call occurred. The timezone must be specified.
    /// The format is "yyyy-mm-dd hh:mm:ss+|-hh:mm",
    /// e.g. "2019-01-01 12:32:45-08:00".
    #[prost(message, optional, tag = "2")]
    pub call_start_date_time: ::std::option::Option<::std::string::String>,
    /// Resource name of the conversion action associated with this conversion.
    /// Note: Although this resource name consists of a customer id and a
    /// conversion action id, validation will ignore the customer id and use the
    /// conversion action id as the sole identifier of the conversion action.
    #[prost(message, optional, tag = "3")]
    pub conversion_action: ::std::option::Option<::std::string::String>,
    /// The date time at which the conversion occurred. Must be after the call
    /// time. The timezone must be specified. The format is
    /// "yyyy-mm-dd hh:mm:ss+|-hh:mm", e.g. "2019-01-01 12:32:45-08:00".
    #[prost(message, optional, tag = "4")]
    pub conversion_date_time: ::std::option::Option<::std::string::String>,
    /// The value of the conversion for the advertiser.
    #[prost(message, optional, tag = "5")]
    pub conversion_value: ::std::option::Option<f64>,
    /// Currency associated with the conversion value. This is the ISO 4217
    /// 3-character currency code. For example: USD, EUR.
    #[prost(message, optional, tag = "6")]
    pub currency_code: ::std::option::Option<::std::string::String>,
}
/// Contains additional information about externally attributed conversions.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ExternalAttributionData {
    /// Represents the fraction of the conversion that is attributed to the
    /// Google Ads click.
    #[prost(message, optional, tag = "1")]
    pub external_attribution_credit: ::std::option::Option<f64>,
    /// Specifies the attribution model name.
    #[prost(message, optional, tag = "2")]
    pub external_attribution_model: ::std::option::Option<::std::string::String>,
}
/// Identifying information for a successfully processed ClickConversion.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ClickConversionResult {
    /// The Google Click ID (gclid) associated with this conversion.
    #[prost(message, optional, tag = "1")]
    pub gclid: ::std::option::Option<::std::string::String>,
    /// Resource name of the conversion action associated with this conversion.
    #[prost(message, optional, tag = "2")]
    pub conversion_action: ::std::option::Option<::std::string::String>,
    /// The date time at which the conversion occurred. The format is
    /// "yyyy-mm-dd hh:mm:ss+|-hh:mm", e.g. “2019-01-01 12:32:45-08:00”.
    #[prost(message, optional, tag = "3")]
    pub conversion_date_time: ::std::option::Option<::std::string::String>,
}
/// Identifying information for a successfully processed CallConversionUpload.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CallConversionResult {
    /// The caller id from which this call was placed. Caller id is expected to be
    /// in E.164 format with preceding '+' sign.
    #[prost(message, optional, tag = "1")]
    pub caller_id: ::std::option::Option<::std::string::String>,
    /// The date time at which the call occurred. The format is
    /// "yyyy-mm-dd hh:mm:ss+|-hh:mm", e.g. "2019-01-01 12:32:45-08:00".
    #[prost(message, optional, tag = "2")]
    pub call_start_date_time: ::std::option::Option<::std::string::String>,
    /// Resource name of the conversion action associated with this conversion.
    #[prost(message, optional, tag = "3")]
    pub conversion_action: ::std::option::Option<::std::string::String>,
    /// The date time at which the conversion occurred. The format is
    /// "yyyy-mm-dd hh:mm:ss+|-hh:mm", e.g. "2019-01-01 12:32:45-08:00".
    #[prost(message, optional, tag = "4")]
    pub conversion_date_time: ::std::option::Option<::std::string::String>,
}
#[doc = r" Generated client implementations."]
pub mod conversion_upload_service_client {
    #![allow(unused_variables, dead_code, missing_docs)]
    use tonic::codegen::*;
    #[doc = " Service to upload conversions."]
    pub struct ConversionUploadServiceClient<T> {
        inner: tonic::client::Grpc<T>,
    }
    impl ConversionUploadServiceClient<tonic::transport::Channel> {
        #[doc = r" Attempt to create a new client by connecting to a given endpoint."]
        pub async fn connect<D>(dst: D) -> Result<Self, tonic::transport::Error>
        where
            D: std::convert::TryInto<tonic::transport::Endpoint>,
            D::Error: Into<StdError>,
        {
            let conn = tonic::transport::Endpoint::new(dst)?.connect().await?;
            Ok(Self::new(conn))
        }
    }
    impl<T> ConversionUploadServiceClient<T>
    where
        T: tonic::client::GrpcService<tonic::body::BoxBody>,
        T::ResponseBody: Body + HttpBody + Send + 'static,
        T::Error: Into<StdError>,
        <T::ResponseBody as HttpBody>::Error: Into<StdError> + Send,
    {
        pub fn new(inner: T) -> Self {
            let inner = tonic::client::Grpc::new(inner);
            Self { inner }
        }
        pub fn with_interceptor(inner: T, interceptor: impl Into<tonic::Interceptor>) -> Self {
            let inner = tonic::client::Grpc::with_interceptor(inner, interceptor);
            Self { inner }
        }
        #[doc = " Processes the given click conversions."]
        pub async fn upload_click_conversions(
            &mut self,
            request: impl tonic::IntoRequest<super::UploadClickConversionsRequest>,
        ) -> Result<tonic::Response<super::UploadClickConversionsResponse>, tonic::Status> {
            self.inner.ready().await.map_err(|e| {
                tonic::Status::new(
                    tonic::Code::Unknown,
                    format!("Service was not ready: {}", e.into()),
                )
            })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.ads.googleads.v1.services.ConversionUploadService/UploadClickConversions",
            );
            self.inner.unary(request.into_request(), path, codec).await
        }
        #[doc = " Processes the given call conversions."]
        pub async fn upload_call_conversions(
            &mut self,
            request: impl tonic::IntoRequest<super::UploadCallConversionsRequest>,
        ) -> Result<tonic::Response<super::UploadCallConversionsResponse>, tonic::Status> {
            self.inner.ready().await.map_err(|e| {
                tonic::Status::new(
                    tonic::Code::Unknown,
                    format!("Service was not ready: {}", e.into()),
                )
            })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.ads.googleads.v1.services.ConversionUploadService/UploadCallConversions",
            );
            self.inner.unary(request.into_request(), path, codec).await
        }
    }
    impl<T: Clone> Clone for ConversionUploadServiceClient<T> {
        fn clone(&self) -> Self {
            Self {
                inner: self.inner.clone(),
            }
        }
    }
    impl<T> std::fmt::Debug for ConversionUploadServiceClient<T> {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
            write!(f, "ConversionUploadServiceClient {{ ... }}")
        }
    }
}
#[doc = r" Generated server implementations."]
pub mod conversion_upload_service_server {
    #![allow(unused_variables, dead_code, missing_docs)]
    use tonic::codegen::*;
    #[doc = "Generated trait containing gRPC methods that should be implemented for use with ConversionUploadServiceServer."]
    #[async_trait]
    pub trait ConversionUploadService: Send + Sync + 'static {
        #[doc = " Processes the given click conversions."]
        async fn upload_click_conversions(
            &self,
            request: tonic::Request<super::UploadClickConversionsRequest>,
        ) -> Result<tonic::Response<super::UploadClickConversionsResponse>, tonic::Status>;
        #[doc = " Processes the given call conversions."]
        async fn upload_call_conversions(
            &self,
            request: tonic::Request<super::UploadCallConversionsRequest>,
        ) -> Result<tonic::Response<super::UploadCallConversionsResponse>, tonic::Status>;
    }
    #[doc = " Service to upload conversions."]
    #[derive(Debug)]
    #[doc(hidden)]
    pub struct ConversionUploadServiceServer<T: ConversionUploadService> {
        inner: _Inner<T>,
    }
    struct _Inner<T>(Arc<T>, Option<tonic::Interceptor>);
    impl<T: ConversionUploadService> ConversionUploadServiceServer<T> {
        pub fn new(inner: T) -> Self {
            let inner = Arc::new(inner);
            let inner = _Inner(inner, None);
            Self { inner }
        }
        pub fn with_interceptor(inner: T, interceptor: impl Into<tonic::Interceptor>) -> Self {
            let inner = Arc::new(inner);
            let inner = _Inner(inner, Some(interceptor.into()));
            Self { inner }
        }
    }
    impl<T, B> Service<http::Request<B>> for ConversionUploadServiceServer<T>
    where
        T: ConversionUploadService,
        B: HttpBody + Send + Sync + 'static,
        B::Error: Into<StdError> + Send + 'static,
    {
        type Response = http::Response<tonic::body::BoxBody>;
        type Error = Never;
        type Future = BoxFuture<Self::Response, Self::Error>;
        fn poll_ready(&mut self, _cx: &mut Context<'_>) -> Poll<Result<(), Self::Error>> {
            Poll::Ready(Ok(()))
        }
        fn call(&mut self, req: http::Request<B>) -> Self::Future {
            let inner = self.inner.clone();
            match req . uri ( ) . path ( ) { "/google.ads.googleads.v1.services.ConversionUploadService/UploadClickConversions" => { # [ allow ( non_camel_case_types ) ] struct UploadClickConversionsSvc < T : ConversionUploadService > ( pub Arc < T > ) ; impl < T : ConversionUploadService > tonic :: server :: UnaryService < super :: UploadClickConversionsRequest > for UploadClickConversionsSvc < T > { type Response = super :: UploadClickConversionsResponse ; type Future = BoxFuture < tonic :: Response < Self :: Response > , tonic :: Status > ; fn call ( & mut self , request : tonic :: Request < super :: UploadClickConversionsRequest > ) -> Self :: Future { let inner = self . 0 . clone ( ) ; let fut = async move { inner . upload_click_conversions ( request ) . await } ; Box :: pin ( fut ) } } let inner = self . inner . clone ( ) ; let fut = async move { let interceptor = inner . 1 . clone ( ) ; let inner = inner . 0 ; let method = UploadClickConversionsSvc ( inner ) ; let codec = tonic :: codec :: ProstCodec :: default ( ) ; let mut grpc = if let Some ( interceptor ) = interceptor { tonic :: server :: Grpc :: with_interceptor ( codec , interceptor ) } else { tonic :: server :: Grpc :: new ( codec ) } ; let res = grpc . unary ( method , req ) . await ; Ok ( res ) } ; Box :: pin ( fut ) } "/google.ads.googleads.v1.services.ConversionUploadService/UploadCallConversions" => { # [ allow ( non_camel_case_types ) ] struct UploadCallConversionsSvc < T : ConversionUploadService > ( pub Arc < T > ) ; impl < T : ConversionUploadService > tonic :: server :: UnaryService < super :: UploadCallConversionsRequest > for UploadCallConversionsSvc < T > { type Response = super :: UploadCallConversionsResponse ; type Future = BoxFuture < tonic :: Response < Self :: Response > , tonic :: Status > ; fn call ( & mut self , request : tonic :: Request < super :: UploadCallConversionsRequest > ) -> Self :: Future { let inner = self . 0 . clone ( ) ; let fut = async move { inner . upload_call_conversions ( request ) . await } ; Box :: pin ( fut ) } } let inner = self . inner . clone ( ) ; let fut = async move { let interceptor = inner . 1 . clone ( ) ; let inner = inner . 0 ; let method = UploadCallConversionsSvc ( inner ) ; let codec = tonic :: codec :: ProstCodec :: default ( ) ; let mut grpc = if let Some ( interceptor ) = interceptor { tonic :: server :: Grpc :: with_interceptor ( codec , interceptor ) } else { tonic :: server :: Grpc :: new ( codec ) } ; let res = grpc . unary ( method , req ) . await ; Ok ( res ) } ; Box :: pin ( fut ) } _ => Box :: pin ( async move { Ok ( http :: Response :: builder ( ) . status ( 200 ) . header ( "grpc-status" , "12" ) . body ( tonic :: body :: BoxBody :: empty ( ) ) . unwrap ( ) ) } ) , }
        }
    }
    impl<T: ConversionUploadService> Clone for ConversionUploadServiceServer<T> {
        fn clone(&self) -> Self {
            let inner = self.inner.clone();
            Self { inner }
        }
    }
    impl<T: ConversionUploadService> Clone for _Inner<T> {
        fn clone(&self) -> Self {
            Self(self.0.clone(), self.1.clone())
        }
    }
    impl<T: std::fmt::Debug> std::fmt::Debug for _Inner<T> {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
            write!(f, "{:?}", self.0)
        }
    }
    impl<T: ConversionUploadService> tonic::transport::NamedService
        for ConversionUploadServiceServer<T>
    {
        const NAME: &'static str = "google.ads.googleads.v1.services.ConversionUploadService";
    }
}
/// Request message for [CustomInterestService.GetCustomInterest][google.ads.googleads.v1.services.CustomInterestService.GetCustomInterest].
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GetCustomInterestRequest {
    /// Required. The resource name of the custom interest to fetch.
    #[prost(string, tag = "1")]
    pub resource_name: std::string::String,
}
/// Request message for [CustomInterestService.MutateCustomInterests][google.ads.googleads.v1.services.CustomInterestService.MutateCustomInterests].
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct MutateCustomInterestsRequest {
    /// Required. The ID of the customer whose custom interests are being modified.
    #[prost(string, tag = "1")]
    pub customer_id: std::string::String,
    /// Required. The list of operations to perform on individual custom interests.
    #[prost(message, repeated, tag = "2")]
    pub operations: ::std::vec::Vec<CustomInterestOperation>,
    /// If true, the request is validated but not executed. Only errors are
    /// returned, not results.
    #[prost(bool, tag = "4")]
    pub validate_only: bool,
}
/// A single operation (create, update) on a custom interest.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CustomInterestOperation {
    /// FieldMask that determines which resource fields are modified in an update.
    #[prost(message, optional, tag = "4")]
    pub update_mask: ::std::option::Option<::prost_types::FieldMask>,
    /// The mutate operation.
    #[prost(oneof = "custom_interest_operation::Operation", tags = "1, 2")]
    pub operation: ::std::option::Option<custom_interest_operation::Operation>,
}
pub mod custom_interest_operation {
    /// The mutate operation.
    #[derive(Clone, PartialEq, ::prost::Oneof)]
    pub enum Operation {
        /// Create operation: No resource name is expected for the new custom
        /// interest.
        #[prost(message, tag = "1")]
        Create(super::super::resources::CustomInterest),
        /// Update operation: The custom interest is expected to have a valid
        /// resource name.
        #[prost(message, tag = "2")]
        Update(super::super::resources::CustomInterest),
    }
}
/// Response message for custom interest mutate.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct MutateCustomInterestsResponse {
    /// All results for the mutate.
    #[prost(message, repeated, tag = "2")]
    pub results: ::std::vec::Vec<MutateCustomInterestResult>,
}
/// The result for the custom interest mutate.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct MutateCustomInterestResult {
    /// Returned for successful operations.
    #[prost(string, tag = "1")]
    pub resource_name: std::string::String,
}
#[doc = r" Generated client implementations."]
pub mod custom_interest_service_client {
    #![allow(unused_variables, dead_code, missing_docs)]
    use tonic::codegen::*;
    #[doc = " Service to manage custom interests."]
    pub struct CustomInterestServiceClient<T> {
        inner: tonic::client::Grpc<T>,
    }
    impl CustomInterestServiceClient<tonic::transport::Channel> {
        #[doc = r" Attempt to create a new client by connecting to a given endpoint."]
        pub async fn connect<D>(dst: D) -> Result<Self, tonic::transport::Error>
        where
            D: std::convert::TryInto<tonic::transport::Endpoint>,
            D::Error: Into<StdError>,
        {
            let conn = tonic::transport::Endpoint::new(dst)?.connect().await?;
            Ok(Self::new(conn))
        }
    }
    impl<T> CustomInterestServiceClient<T>
    where
        T: tonic::client::GrpcService<tonic::body::BoxBody>,
        T::ResponseBody: Body + HttpBody + Send + 'static,
        T::Error: Into<StdError>,
        <T::ResponseBody as HttpBody>::Error: Into<StdError> + Send,
    {
        pub fn new(inner: T) -> Self {
            let inner = tonic::client::Grpc::new(inner);
            Self { inner }
        }
        pub fn with_interceptor(inner: T, interceptor: impl Into<tonic::Interceptor>) -> Self {
            let inner = tonic::client::Grpc::with_interceptor(inner, interceptor);
            Self { inner }
        }
        #[doc = " Returns the requested custom interest in full detail."]
        pub async fn get_custom_interest(
            &mut self,
            request: impl tonic::IntoRequest<super::GetCustomInterestRequest>,
        ) -> Result<tonic::Response<super::super::resources::CustomInterest>, tonic::Status>
        {
            self.inner.ready().await.map_err(|e| {
                tonic::Status::new(
                    tonic::Code::Unknown,
                    format!("Service was not ready: {}", e.into()),
                )
            })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.ads.googleads.v1.services.CustomInterestService/GetCustomInterest",
            );
            self.inner.unary(request.into_request(), path, codec).await
        }
        #[doc = " Creates or updates custom interests. Operation statuses are returned."]
        pub async fn mutate_custom_interests(
            &mut self,
            request: impl tonic::IntoRequest<super::MutateCustomInterestsRequest>,
        ) -> Result<tonic::Response<super::MutateCustomInterestsResponse>, tonic::Status> {
            self.inner.ready().await.map_err(|e| {
                tonic::Status::new(
                    tonic::Code::Unknown,
                    format!("Service was not ready: {}", e.into()),
                )
            })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.ads.googleads.v1.services.CustomInterestService/MutateCustomInterests",
            );
            self.inner.unary(request.into_request(), path, codec).await
        }
    }
    impl<T: Clone> Clone for CustomInterestServiceClient<T> {
        fn clone(&self) -> Self {
            Self {
                inner: self.inner.clone(),
            }
        }
    }
    impl<T> std::fmt::Debug for CustomInterestServiceClient<T> {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
            write!(f, "CustomInterestServiceClient {{ ... }}")
        }
    }
}
#[doc = r" Generated server implementations."]
pub mod custom_interest_service_server {
    #![allow(unused_variables, dead_code, missing_docs)]
    use tonic::codegen::*;
    #[doc = "Generated trait containing gRPC methods that should be implemented for use with CustomInterestServiceServer."]
    #[async_trait]
    pub trait CustomInterestService: Send + Sync + 'static {
        #[doc = " Returns the requested custom interest in full detail."]
        async fn get_custom_interest(
            &self,
            request: tonic::Request<super::GetCustomInterestRequest>,
        ) -> Result<tonic::Response<super::super::resources::CustomInterest>, tonic::Status>;
        #[doc = " Creates or updates custom interests. Operation statuses are returned."]
        async fn mutate_custom_interests(
            &self,
            request: tonic::Request<super::MutateCustomInterestsRequest>,
        ) -> Result<tonic::Response<super::MutateCustomInterestsResponse>, tonic::Status>;
    }
    #[doc = " Service to manage custom interests."]
    #[derive(Debug)]
    #[doc(hidden)]
    pub struct CustomInterestServiceServer<T: CustomInterestService> {
        inner: _Inner<T>,
    }
    struct _Inner<T>(Arc<T>, Option<tonic::Interceptor>);
    impl<T: CustomInterestService> CustomInterestServiceServer<T> {
        pub fn new(inner: T) -> Self {
            let inner = Arc::new(inner);
            let inner = _Inner(inner, None);
            Self { inner }
        }
        pub fn with_interceptor(inner: T, interceptor: impl Into<tonic::Interceptor>) -> Self {
            let inner = Arc::new(inner);
            let inner = _Inner(inner, Some(interceptor.into()));
            Self { inner }
        }
    }
    impl<T, B> Service<http::Request<B>> for CustomInterestServiceServer<T>
    where
        T: CustomInterestService,
        B: HttpBody + Send + Sync + 'static,
        B::Error: Into<StdError> + Send + 'static,
    {
        type Response = http::Response<tonic::body::BoxBody>;
        type Error = Never;
        type Future = BoxFuture<Self::Response, Self::Error>;
        fn poll_ready(&mut self, _cx: &mut Context<'_>) -> Poll<Result<(), Self::Error>> {
            Poll::Ready(Ok(()))
        }
        fn call(&mut self, req: http::Request<B>) -> Self::Future {
            let inner = self.inner.clone();
            match req.uri().path() {
                "/google.ads.googleads.v1.services.CustomInterestService/GetCustomInterest" => {
                    #[allow(non_camel_case_types)]
                    struct GetCustomInterestSvc<T: CustomInterestService>(pub Arc<T>);
                    impl<T: CustomInterestService>
                        tonic::server::UnaryService<super::GetCustomInterestRequest>
                        for GetCustomInterestSvc<T>
                    {
                        type Response = super::super::resources::CustomInterest;
                        type Future = BoxFuture<tonic::Response<Self::Response>, tonic::Status>;
                        fn call(
                            &mut self,
                            request: tonic::Request<super::GetCustomInterestRequest>,
                        ) -> Self::Future {
                            let inner = self.0.clone();
                            let fut = async move { inner.get_custom_interest(request).await };
                            Box::pin(fut)
                        }
                    }
                    let inner = self.inner.clone();
                    let fut = async move {
                        let interceptor = inner.1.clone();
                        let inner = inner.0;
                        let method = GetCustomInterestSvc(inner);
                        let codec = tonic::codec::ProstCodec::default();
                        let mut grpc = if let Some(interceptor) = interceptor {
                            tonic::server::Grpc::with_interceptor(codec, interceptor)
                        } else {
                            tonic::server::Grpc::new(codec)
                        };
                        let res = grpc.unary(method, req).await;
                        Ok(res)
                    };
                    Box::pin(fut)
                }
                "/google.ads.googleads.v1.services.CustomInterestService/MutateCustomInterests" => {
                    #[allow(non_camel_case_types)]
                    struct MutateCustomInterestsSvc<T: CustomInterestService>(pub Arc<T>);
                    impl<T: CustomInterestService>
                        tonic::server::UnaryService<super::MutateCustomInterestsRequest>
                        for MutateCustomInterestsSvc<T>
                    {
                        type Response = super::MutateCustomInterestsResponse;
                        type Future = BoxFuture<tonic::Response<Self::Response>, tonic::Status>;
                        fn call(
                            &mut self,
                            request: tonic::Request<super::MutateCustomInterestsRequest>,
                        ) -> Self::Future {
                            let inner = self.0.clone();
                            let fut = async move { inner.mutate_custom_interests(request).await };
                            Box::pin(fut)
                        }
                    }
                    let inner = self.inner.clone();
                    let fut = async move {
                        let interceptor = inner.1.clone();
                        let inner = inner.0;
                        let method = MutateCustomInterestsSvc(inner);
                        let codec = tonic::codec::ProstCodec::default();
                        let mut grpc = if let Some(interceptor) = interceptor {
                            tonic::server::Grpc::with_interceptor(codec, interceptor)
                        } else {
                            tonic::server::Grpc::new(codec)
                        };
                        let res = grpc.unary(method, req).await;
                        Ok(res)
                    };
                    Box::pin(fut)
                }
                _ => Box::pin(async move {
                    Ok(http::Response::builder()
                        .status(200)
                        .header("grpc-status", "12")
                        .body(tonic::body::BoxBody::empty())
                        .unwrap())
                }),
            }
        }
    }
    impl<T: CustomInterestService> Clone for CustomInterestServiceServer<T> {
        fn clone(&self) -> Self {
            let inner = self.inner.clone();
            Self { inner }
        }
    }
    impl<T: CustomInterestService> Clone for _Inner<T> {
        fn clone(&self) -> Self {
            Self(self.0.clone(), self.1.clone())
        }
    }
    impl<T: std::fmt::Debug> std::fmt::Debug for _Inner<T> {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
            write!(f, "{:?}", self.0)
        }
    }
    impl<T: CustomInterestService> tonic::transport::NamedService for CustomInterestServiceServer<T> {
        const NAME: &'static str = "google.ads.googleads.v1.services.CustomInterestService";
    }
}
/// Request message for [CustomerClientLinkService.GetCustomerClientLink][google.ads.googleads.v1.services.CustomerClientLinkService.GetCustomerClientLink].
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GetCustomerClientLinkRequest {
    /// Required. The resource name of the customer client link to fetch.
    #[prost(string, tag = "1")]
    pub resource_name: std::string::String,
}
/// Request message for [CustomerClientLinkService.MutateCustomerClientLink][google.ads.googleads.v1.services.CustomerClientLinkService.MutateCustomerClientLink].
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct MutateCustomerClientLinkRequest {
    /// Required. The ID of the customer whose customer link are being modified.
    #[prost(string, tag = "1")]
    pub customer_id: std::string::String,
    /// Required. The operation to perform on the individual CustomerClientLink.
    #[prost(message, optional, tag = "2")]
    pub operation: ::std::option::Option<CustomerClientLinkOperation>,
}
/// A single operation (create, update) on a CustomerClientLink.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CustomerClientLinkOperation {
    /// FieldMask that determines which resource fields are modified in an update.
    #[prost(message, optional, tag = "4")]
    pub update_mask: ::std::option::Option<::prost_types::FieldMask>,
    /// The mutate operation.
    #[prost(oneof = "customer_client_link_operation::Operation", tags = "1, 2")]
    pub operation: ::std::option::Option<customer_client_link_operation::Operation>,
}
pub mod customer_client_link_operation {
    /// The mutate operation.
    #[derive(Clone, PartialEq, ::prost::Oneof)]
    pub enum Operation {
        /// Create operation: No resource name is expected for the new link.
        #[prost(message, tag = "1")]
        Create(super::super::resources::CustomerClientLink),
        /// Update operation: The link is expected to have a valid resource name.
        #[prost(message, tag = "2")]
        Update(super::super::resources::CustomerClientLink),
    }
}
/// Response message for a CustomerClientLink mutate.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct MutateCustomerClientLinkResponse {
    /// A result that identifies the resource affected by the mutate request.
    #[prost(message, optional, tag = "1")]
    pub result: ::std::option::Option<MutateCustomerClientLinkResult>,
}
/// The result for a single customer client link mutate.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct MutateCustomerClientLinkResult {
    /// Returned for successful operations.
    #[prost(string, tag = "1")]
    pub resource_name: std::string::String,
}
#[doc = r" Generated client implementations."]
pub mod customer_client_link_service_client {
    #![allow(unused_variables, dead_code, missing_docs)]
    use tonic::codegen::*;
    #[doc = " Service to manage customer client links."]
    pub struct CustomerClientLinkServiceClient<T> {
        inner: tonic::client::Grpc<T>,
    }
    impl CustomerClientLinkServiceClient<tonic::transport::Channel> {
        #[doc = r" Attempt to create a new client by connecting to a given endpoint."]
        pub async fn connect<D>(dst: D) -> Result<Self, tonic::transport::Error>
        where
            D: std::convert::TryInto<tonic::transport::Endpoint>,
            D::Error: Into<StdError>,
        {
            let conn = tonic::transport::Endpoint::new(dst)?.connect().await?;
            Ok(Self::new(conn))
        }
    }
    impl<T> CustomerClientLinkServiceClient<T>
    where
        T: tonic::client::GrpcService<tonic::body::BoxBody>,
        T::ResponseBody: Body + HttpBody + Send + 'static,
        T::Error: Into<StdError>,
        <T::ResponseBody as HttpBody>::Error: Into<StdError> + Send,
    {
        pub fn new(inner: T) -> Self {
            let inner = tonic::client::Grpc::new(inner);
            Self { inner }
        }
        pub fn with_interceptor(inner: T, interceptor: impl Into<tonic::Interceptor>) -> Self {
            let inner = tonic::client::Grpc::with_interceptor(inner, interceptor);
            Self { inner }
        }
        #[doc = " Returns the requested CustomerClientLink in full detail."]
        pub async fn get_customer_client_link(
            &mut self,
            request: impl tonic::IntoRequest<super::GetCustomerClientLinkRequest>,
        ) -> Result<tonic::Response<super::super::resources::CustomerClientLink>, tonic::Status>
        {
            self.inner.ready().await.map_err(|e| {
                tonic::Status::new(
                    tonic::Code::Unknown,
                    format!("Service was not ready: {}", e.into()),
                )
            })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.ads.googleads.v1.services.CustomerClientLinkService/GetCustomerClientLink",
            );
            self.inner.unary(request.into_request(), path, codec).await
        }
        #[doc = " Creates or updates a customer client link. Operation statuses are returned."]
        pub async fn mutate_customer_client_link(
            &mut self,
            request: impl tonic::IntoRequest<super::MutateCustomerClientLinkRequest>,
        ) -> Result<tonic::Response<super::MutateCustomerClientLinkResponse>, tonic::Status>
        {
            self.inner.ready().await.map_err(|e| {
                tonic::Status::new(
                    tonic::Code::Unknown,
                    format!("Service was not ready: {}", e.into()),
                )
            })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http :: uri :: PathAndQuery :: from_static ( "/google.ads.googleads.v1.services.CustomerClientLinkService/MutateCustomerClientLink" ) ;
            self.inner.unary(request.into_request(), path, codec).await
        }
    }
    impl<T: Clone> Clone for CustomerClientLinkServiceClient<T> {
        fn clone(&self) -> Self {
            Self {
                inner: self.inner.clone(),
            }
        }
    }
    impl<T> std::fmt::Debug for CustomerClientLinkServiceClient<T> {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
            write!(f, "CustomerClientLinkServiceClient {{ ... }}")
        }
    }
}
#[doc = r" Generated server implementations."]
pub mod customer_client_link_service_server {
    #![allow(unused_variables, dead_code, missing_docs)]
    use tonic::codegen::*;
    #[doc = "Generated trait containing gRPC methods that should be implemented for use with CustomerClientLinkServiceServer."]
    #[async_trait]
    pub trait CustomerClientLinkService: Send + Sync + 'static {
        #[doc = " Returns the requested CustomerClientLink in full detail."]
        async fn get_customer_client_link(
            &self,
            request: tonic::Request<super::GetCustomerClientLinkRequest>,
        ) -> Result<tonic::Response<super::super::resources::CustomerClientLink>, tonic::Status>;
        #[doc = " Creates or updates a customer client link. Operation statuses are returned."]
        async fn mutate_customer_client_link(
            &self,
            request: tonic::Request<super::MutateCustomerClientLinkRequest>,
        ) -> Result<tonic::Response<super::MutateCustomerClientLinkResponse>, tonic::Status>;
    }
    #[doc = " Service to manage customer client links."]
    #[derive(Debug)]
    #[doc(hidden)]
    pub struct CustomerClientLinkServiceServer<T: CustomerClientLinkService> {
        inner: _Inner<T>,
    }
    struct _Inner<T>(Arc<T>, Option<tonic::Interceptor>);
    impl<T: CustomerClientLinkService> CustomerClientLinkServiceServer<T> {
        pub fn new(inner: T) -> Self {
            let inner = Arc::new(inner);
            let inner = _Inner(inner, None);
            Self { inner }
        }
        pub fn with_interceptor(inner: T, interceptor: impl Into<tonic::Interceptor>) -> Self {
            let inner = Arc::new(inner);
            let inner = _Inner(inner, Some(interceptor.into()));
            Self { inner }
        }
    }
    impl<T, B> Service<http::Request<B>> for CustomerClientLinkServiceServer<T>
    where
        T: CustomerClientLinkService,
        B: HttpBody + Send + Sync + 'static,
        B::Error: Into<StdError> + Send + 'static,
    {
        type Response = http::Response<tonic::body::BoxBody>;
        type Error = Never;
        type Future = BoxFuture<Self::Response, Self::Error>;
        fn poll_ready(&mut self, _cx: &mut Context<'_>) -> Poll<Result<(), Self::Error>> {
            Poll::Ready(Ok(()))
        }
        fn call(&mut self, req: http::Request<B>) -> Self::Future {
            let inner = self.inner.clone();
            match req . uri ( ) . path ( ) { "/google.ads.googleads.v1.services.CustomerClientLinkService/GetCustomerClientLink" => { # [ allow ( non_camel_case_types ) ] struct GetCustomerClientLinkSvc < T : CustomerClientLinkService > ( pub Arc < T > ) ; impl < T : CustomerClientLinkService > tonic :: server :: UnaryService < super :: GetCustomerClientLinkRequest > for GetCustomerClientLinkSvc < T > { type Response = super :: super :: resources :: CustomerClientLink ; type Future = BoxFuture < tonic :: Response < Self :: Response > , tonic :: Status > ; fn call ( & mut self , request : tonic :: Request < super :: GetCustomerClientLinkRequest > ) -> Self :: Future { let inner = self . 0 . clone ( ) ; let fut = async move { inner . get_customer_client_link ( request ) . await } ; Box :: pin ( fut ) } } let inner = self . inner . clone ( ) ; let fut = async move { let interceptor = inner . 1 . clone ( ) ; let inner = inner . 0 ; let method = GetCustomerClientLinkSvc ( inner ) ; let codec = tonic :: codec :: ProstCodec :: default ( ) ; let mut grpc = if let Some ( interceptor ) = interceptor { tonic :: server :: Grpc :: with_interceptor ( codec , interceptor ) } else { tonic :: server :: Grpc :: new ( codec ) } ; let res = grpc . unary ( method , req ) . await ; Ok ( res ) } ; Box :: pin ( fut ) } "/google.ads.googleads.v1.services.CustomerClientLinkService/MutateCustomerClientLink" => { # [ allow ( non_camel_case_types ) ] struct MutateCustomerClientLinkSvc < T : CustomerClientLinkService > ( pub Arc < T > ) ; impl < T : CustomerClientLinkService > tonic :: server :: UnaryService < super :: MutateCustomerClientLinkRequest > for MutateCustomerClientLinkSvc < T > { type Response = super :: MutateCustomerClientLinkResponse ; type Future = BoxFuture < tonic :: Response < Self :: Response > , tonic :: Status > ; fn call ( & mut self , request : tonic :: Request < super :: MutateCustomerClientLinkRequest > ) -> Self :: Future { let inner = self . 0 . clone ( ) ; let fut = async move { inner . mutate_customer_client_link ( request ) . await } ; Box :: pin ( fut ) } } let inner = self . inner . clone ( ) ; let fut = async move { let interceptor = inner . 1 . clone ( ) ; let inner = inner . 0 ; let method = MutateCustomerClientLinkSvc ( inner ) ; let codec = tonic :: codec :: ProstCodec :: default ( ) ; let mut grpc = if let Some ( interceptor ) = interceptor { tonic :: server :: Grpc :: with_interceptor ( codec , interceptor ) } else { tonic :: server :: Grpc :: new ( codec ) } ; let res = grpc . unary ( method , req ) . await ; Ok ( res ) } ; Box :: pin ( fut ) } _ => Box :: pin ( async move { Ok ( http :: Response :: builder ( ) . status ( 200 ) . header ( "grpc-status" , "12" ) . body ( tonic :: body :: BoxBody :: empty ( ) ) . unwrap ( ) ) } ) , }
        }
    }
    impl<T: CustomerClientLinkService> Clone for CustomerClientLinkServiceServer<T> {
        fn clone(&self) -> Self {
            let inner = self.inner.clone();
            Self { inner }
        }
    }
    impl<T: CustomerClientLinkService> Clone for _Inner<T> {
        fn clone(&self) -> Self {
            Self(self.0.clone(), self.1.clone())
        }
    }
    impl<T: std::fmt::Debug> std::fmt::Debug for _Inner<T> {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
            write!(f, "{:?}", self.0)
        }
    }
    impl<T: CustomerClientLinkService> tonic::transport::NamedService
        for CustomerClientLinkServiceServer<T>
    {
        const NAME: &'static str = "google.ads.googleads.v1.services.CustomerClientLinkService";
    }
}
/// Request message for [CustomerClientService.GetCustomerClient][google.ads.googleads.v1.services.CustomerClientService.GetCustomerClient].
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GetCustomerClientRequest {
    /// Required. The resource name of the client to fetch.
    #[prost(string, tag = "1")]
    pub resource_name: std::string::String,
}
#[doc = r" Generated client implementations."]
pub mod customer_client_service_client {
    #![allow(unused_variables, dead_code, missing_docs)]
    use tonic::codegen::*;
    #[doc = " Service to get clients in a customer's hierarchy."]
    pub struct CustomerClientServiceClient<T> {
        inner: tonic::client::Grpc<T>,
    }
    impl CustomerClientServiceClient<tonic::transport::Channel> {
        #[doc = r" Attempt to create a new client by connecting to a given endpoint."]
        pub async fn connect<D>(dst: D) -> Result<Self, tonic::transport::Error>
        where
            D: std::convert::TryInto<tonic::transport::Endpoint>,
            D::Error: Into<StdError>,
        {
            let conn = tonic::transport::Endpoint::new(dst)?.connect().await?;
            Ok(Self::new(conn))
        }
    }
    impl<T> CustomerClientServiceClient<T>
    where
        T: tonic::client::GrpcService<tonic::body::BoxBody>,
        T::ResponseBody: Body + HttpBody + Send + 'static,
        T::Error: Into<StdError>,
        <T::ResponseBody as HttpBody>::Error: Into<StdError> + Send,
    {
        pub fn new(inner: T) -> Self {
            let inner = tonic::client::Grpc::new(inner);
            Self { inner }
        }
        pub fn with_interceptor(inner: T, interceptor: impl Into<tonic::Interceptor>) -> Self {
            let inner = tonic::client::Grpc::with_interceptor(inner, interceptor);
            Self { inner }
        }
        #[doc = " Returns the requested client in full detail."]
        pub async fn get_customer_client(
            &mut self,
            request: impl tonic::IntoRequest<super::GetCustomerClientRequest>,
        ) -> Result<tonic::Response<super::super::resources::CustomerClient>, tonic::Status>
        {
            self.inner.ready().await.map_err(|e| {
                tonic::Status::new(
                    tonic::Code::Unknown,
                    format!("Service was not ready: {}", e.into()),
                )
            })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.ads.googleads.v1.services.CustomerClientService/GetCustomerClient",
            );
            self.inner.unary(request.into_request(), path, codec).await
        }
    }
    impl<T: Clone> Clone for CustomerClientServiceClient<T> {
        fn clone(&self) -> Self {
            Self {
                inner: self.inner.clone(),
            }
        }
    }
    impl<T> std::fmt::Debug for CustomerClientServiceClient<T> {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
            write!(f, "CustomerClientServiceClient {{ ... }}")
        }
    }
}
#[doc = r" Generated server implementations."]
pub mod customer_client_service_server {
    #![allow(unused_variables, dead_code, missing_docs)]
    use tonic::codegen::*;
    #[doc = "Generated trait containing gRPC methods that should be implemented for use with CustomerClientServiceServer."]
    #[async_trait]
    pub trait CustomerClientService: Send + Sync + 'static {
        #[doc = " Returns the requested client in full detail."]
        async fn get_customer_client(
            &self,
            request: tonic::Request<super::GetCustomerClientRequest>,
        ) -> Result<tonic::Response<super::super::resources::CustomerClient>, tonic::Status>;
    }
    #[doc = " Service to get clients in a customer's hierarchy."]
    #[derive(Debug)]
    #[doc(hidden)]
    pub struct CustomerClientServiceServer<T: CustomerClientService> {
        inner: _Inner<T>,
    }
    struct _Inner<T>(Arc<T>, Option<tonic::Interceptor>);
    impl<T: CustomerClientService> CustomerClientServiceServer<T> {
        pub fn new(inner: T) -> Self {
            let inner = Arc::new(inner);
            let inner = _Inner(inner, None);
            Self { inner }
        }
        pub fn with_interceptor(inner: T, interceptor: impl Into<tonic::Interceptor>) -> Self {
            let inner = Arc::new(inner);
            let inner = _Inner(inner, Some(interceptor.into()));
            Self { inner }
        }
    }
    impl<T, B> Service<http::Request<B>> for CustomerClientServiceServer<T>
    where
        T: CustomerClientService,
        B: HttpBody + Send + Sync + 'static,
        B::Error: Into<StdError> + Send + 'static,
    {
        type Response = http::Response<tonic::body::BoxBody>;
        type Error = Never;
        type Future = BoxFuture<Self::Response, Self::Error>;
        fn poll_ready(&mut self, _cx: &mut Context<'_>) -> Poll<Result<(), Self::Error>> {
            Poll::Ready(Ok(()))
        }
        fn call(&mut self, req: http::Request<B>) -> Self::Future {
            let inner = self.inner.clone();
            match req.uri().path() {
                "/google.ads.googleads.v1.services.CustomerClientService/GetCustomerClient" => {
                    #[allow(non_camel_case_types)]
                    struct GetCustomerClientSvc<T: CustomerClientService>(pub Arc<T>);
                    impl<T: CustomerClientService>
                        tonic::server::UnaryService<super::GetCustomerClientRequest>
                        for GetCustomerClientSvc<T>
                    {
                        type Response = super::super::resources::CustomerClient;
                        type Future = BoxFuture<tonic::Response<Self::Response>, tonic::Status>;
                        fn call(
                            &mut self,
                            request: tonic::Request<super::GetCustomerClientRequest>,
                        ) -> Self::Future {
                            let inner = self.0.clone();
                            let fut = async move { inner.get_customer_client(request).await };
                            Box::pin(fut)
                        }
                    }
                    let inner = self.inner.clone();
                    let fut = async move {
                        let interceptor = inner.1.clone();
                        let inner = inner.0;
                        let method = GetCustomerClientSvc(inner);
                        let codec = tonic::codec::ProstCodec::default();
                        let mut grpc = if let Some(interceptor) = interceptor {
                            tonic::server::Grpc::with_interceptor(codec, interceptor)
                        } else {
                            tonic::server::Grpc::new(codec)
                        };
                        let res = grpc.unary(method, req).await;
                        Ok(res)
                    };
                    Box::pin(fut)
                }
                _ => Box::pin(async move {
                    Ok(http::Response::builder()
                        .status(200)
                        .header("grpc-status", "12")
                        .body(tonic::body::BoxBody::empty())
                        .unwrap())
                }),
            }
        }
    }
    impl<T: CustomerClientService> Clone for CustomerClientServiceServer<T> {
        fn clone(&self) -> Self {
            let inner = self.inner.clone();
            Self { inner }
        }
    }
    impl<T: CustomerClientService> Clone for _Inner<T> {
        fn clone(&self) -> Self {
            Self(self.0.clone(), self.1.clone())
        }
    }
    impl<T: std::fmt::Debug> std::fmt::Debug for _Inner<T> {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
            write!(f, "{:?}", self.0)
        }
    }
    impl<T: CustomerClientService> tonic::transport::NamedService for CustomerClientServiceServer<T> {
        const NAME: &'static str = "google.ads.googleads.v1.services.CustomerClientService";
    }
}
/// Request message for
/// [CustomerExtensionSettingService.GetCustomerExtensionSetting][google.ads.googleads.v1.services.CustomerExtensionSettingService.GetCustomerExtensionSetting].
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GetCustomerExtensionSettingRequest {
    /// Required. The resource name of the customer extension setting to fetch.
    #[prost(string, tag = "1")]
    pub resource_name: std::string::String,
}
/// Request message for
/// [CustomerExtensionSettingService.MutateCustomerExtensionSettings][google.ads.googleads.v1.services.CustomerExtensionSettingService.MutateCustomerExtensionSettings].
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct MutateCustomerExtensionSettingsRequest {
    /// Required. The ID of the customer whose customer extension settings are being
    /// modified.
    #[prost(string, tag = "1")]
    pub customer_id: std::string::String,
    /// Required. The list of operations to perform on individual customer extension
    /// settings.
    #[prost(message, repeated, tag = "2")]
    pub operations: ::std::vec::Vec<CustomerExtensionSettingOperation>,
    /// If true, successful operations will be carried out and invalid
    /// operations will return errors. If false, all operations will be carried
    /// out in one transaction if and only if they are all valid.
    /// Default is false.
    #[prost(bool, tag = "3")]
    pub partial_failure: bool,
    /// If true, the request is validated but not executed. Only errors are
    /// returned, not results.
    #[prost(bool, tag = "4")]
    pub validate_only: bool,
}
/// A single operation (create, update, remove) on a customer extension setting.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CustomerExtensionSettingOperation {
    /// FieldMask that determines which resource fields are modified in an update.
    #[prost(message, optional, tag = "4")]
    pub update_mask: ::std::option::Option<::prost_types::FieldMask>,
    /// The mutate operation.
    #[prost(
        oneof = "customer_extension_setting_operation::Operation",
        tags = "1, 2, 3"
    )]
    pub operation: ::std::option::Option<customer_extension_setting_operation::Operation>,
}
pub mod customer_extension_setting_operation {
    /// The mutate operation.
    #[derive(Clone, PartialEq, ::prost::Oneof)]
    pub enum Operation {
        /// Create operation: No resource name is expected for the new customer
        /// extension setting.
        #[prost(message, tag = "1")]
        Create(super::super::resources::CustomerExtensionSetting),
        /// Update operation: The customer extension setting is expected to have a
        /// valid resource name.
        #[prost(message, tag = "2")]
        Update(super::super::resources::CustomerExtensionSetting),
        /// Remove operation: A resource name for the removed customer extension
        /// setting is expected, in this format:
        ///
        /// `customers/{customer_id}/customerExtensionSettings/{extension_type}`
        #[prost(string, tag = "3")]
        Remove(std::string::String),
    }
}
/// Response message for a customer extension setting mutate.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct MutateCustomerExtensionSettingsResponse {
    /// Errors that pertain to operation failures in the partial failure mode.
    /// Returned only when partial_failure = true and all errors occur inside the
    /// operations. If any errors occur outside the operations (e.g. auth errors),
    /// we return an RPC level error.
    #[prost(message, optional, tag = "3")]
    pub partial_failure_error: ::std::option::Option<super::super::super::super::rpc::Status>,
    /// All results for the mutate.
    #[prost(message, repeated, tag = "2")]
    pub results: ::std::vec::Vec<MutateCustomerExtensionSettingResult>,
}
/// The result for the customer extension setting mutate.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct MutateCustomerExtensionSettingResult {
    /// Returned for successful operations.
    #[prost(string, tag = "1")]
    pub resource_name: std::string::String,
}
#[doc = r" Generated client implementations."]
pub mod customer_extension_setting_service_client {
    #![allow(unused_variables, dead_code, missing_docs)]
    use tonic::codegen::*;
    #[doc = " Service to manage customer extension settings."]
    pub struct CustomerExtensionSettingServiceClient<T> {
        inner: tonic::client::Grpc<T>,
    }
    impl CustomerExtensionSettingServiceClient<tonic::transport::Channel> {
        #[doc = r" Attempt to create a new client by connecting to a given endpoint."]
        pub async fn connect<D>(dst: D) -> Result<Self, tonic::transport::Error>
        where
            D: std::convert::TryInto<tonic::transport::Endpoint>,
            D::Error: Into<StdError>,
        {
            let conn = tonic::transport::Endpoint::new(dst)?.connect().await?;
            Ok(Self::new(conn))
        }
    }
    impl<T> CustomerExtensionSettingServiceClient<T>
    where
        T: tonic::client::GrpcService<tonic::body::BoxBody>,
        T::ResponseBody: Body + HttpBody + Send + 'static,
        T::Error: Into<StdError>,
        <T::ResponseBody as HttpBody>::Error: Into<StdError> + Send,
    {
        pub fn new(inner: T) -> Self {
            let inner = tonic::client::Grpc::new(inner);
            Self { inner }
        }
        pub fn with_interceptor(inner: T, interceptor: impl Into<tonic::Interceptor>) -> Self {
            let inner = tonic::client::Grpc::with_interceptor(inner, interceptor);
            Self { inner }
        }
        #[doc = " Returns the requested customer extension setting in full detail."]
        pub async fn get_customer_extension_setting(
            &mut self,
            request: impl tonic::IntoRequest<super::GetCustomerExtensionSettingRequest>,
        ) -> Result<tonic::Response<super::super::resources::CustomerExtensionSetting>, tonic::Status>
        {
            self.inner.ready().await.map_err(|e| {
                tonic::Status::new(
                    tonic::Code::Unknown,
                    format!("Service was not ready: {}", e.into()),
                )
            })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http :: uri :: PathAndQuery :: from_static ( "/google.ads.googleads.v1.services.CustomerExtensionSettingService/GetCustomerExtensionSetting" ) ;
            self.inner.unary(request.into_request(), path, codec).await
        }
        #[doc = " Creates, updates, or removes customer extension settings. Operation"]
        #[doc = " statuses are returned."]
        pub async fn mutate_customer_extension_settings(
            &mut self,
            request: impl tonic::IntoRequest<super::MutateCustomerExtensionSettingsRequest>,
        ) -> Result<tonic::Response<super::MutateCustomerExtensionSettingsResponse>, tonic::Status>
        {
            self.inner.ready().await.map_err(|e| {
                tonic::Status::new(
                    tonic::Code::Unknown,
                    format!("Service was not ready: {}", e.into()),
                )
            })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http :: uri :: PathAndQuery :: from_static ( "/google.ads.googleads.v1.services.CustomerExtensionSettingService/MutateCustomerExtensionSettings" ) ;
            self.inner.unary(request.into_request(), path, codec).await
        }
    }
    impl<T: Clone> Clone for CustomerExtensionSettingServiceClient<T> {
        fn clone(&self) -> Self {
            Self {
                inner: self.inner.clone(),
            }
        }
    }
    impl<T> std::fmt::Debug for CustomerExtensionSettingServiceClient<T> {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
            write!(f, "CustomerExtensionSettingServiceClient {{ ... }}")
        }
    }
}
#[doc = r" Generated server implementations."]
pub mod customer_extension_setting_service_server {
    #![allow(unused_variables, dead_code, missing_docs)]
    use tonic::codegen::*;
    #[doc = "Generated trait containing gRPC methods that should be implemented for use with CustomerExtensionSettingServiceServer."]
    #[async_trait]
    pub trait CustomerExtensionSettingService: Send + Sync + 'static {
        #[doc = " Returns the requested customer extension setting in full detail."]
        async fn get_customer_extension_setting(
            &self,
            request: tonic::Request<super::GetCustomerExtensionSettingRequest>,
        ) -> Result<tonic::Response<super::super::resources::CustomerExtensionSetting>, tonic::Status>;
        #[doc = " Creates, updates, or removes customer extension settings. Operation"]
        #[doc = " statuses are returned."]
        async fn mutate_customer_extension_settings(
            &self,
            request: tonic::Request<super::MutateCustomerExtensionSettingsRequest>,
        ) -> Result<tonic::Response<super::MutateCustomerExtensionSettingsResponse>, tonic::Status>;
    }
    #[doc = " Service to manage customer extension settings."]
    #[derive(Debug)]
    #[doc(hidden)]
    pub struct CustomerExtensionSettingServiceServer<T: CustomerExtensionSettingService> {
        inner: _Inner<T>,
    }
    struct _Inner<T>(Arc<T>, Option<tonic::Interceptor>);
    impl<T: CustomerExtensionSettingService> CustomerExtensionSettingServiceServer<T> {
        pub fn new(inner: T) -> Self {
            let inner = Arc::new(inner);
            let inner = _Inner(inner, None);
            Self { inner }
        }
        pub fn with_interceptor(inner: T, interceptor: impl Into<tonic::Interceptor>) -> Self {
            let inner = Arc::new(inner);
            let inner = _Inner(inner, Some(interceptor.into()));
            Self { inner }
        }
    }
    impl<T, B> Service<http::Request<B>> for CustomerExtensionSettingServiceServer<T>
    where
        T: CustomerExtensionSettingService,
        B: HttpBody + Send + Sync + 'static,
        B::Error: Into<StdError> + Send + 'static,
    {
        type Response = http::Response<tonic::body::BoxBody>;
        type Error = Never;
        type Future = BoxFuture<Self::Response, Self::Error>;
        fn poll_ready(&mut self, _cx: &mut Context<'_>) -> Poll<Result<(), Self::Error>> {
            Poll::Ready(Ok(()))
        }
        fn call(&mut self, req: http::Request<B>) -> Self::Future {
            let inner = self.inner.clone();
            match req . uri ( ) . path ( ) { "/google.ads.googleads.v1.services.CustomerExtensionSettingService/GetCustomerExtensionSetting" => { # [ allow ( non_camel_case_types ) ] struct GetCustomerExtensionSettingSvc < T : CustomerExtensionSettingService > ( pub Arc < T > ) ; impl < T : CustomerExtensionSettingService > tonic :: server :: UnaryService < super :: GetCustomerExtensionSettingRequest > for GetCustomerExtensionSettingSvc < T > { type Response = super :: super :: resources :: CustomerExtensionSetting ; type Future = BoxFuture < tonic :: Response < Self :: Response > , tonic :: Status > ; fn call ( & mut self , request : tonic :: Request < super :: GetCustomerExtensionSettingRequest > ) -> Self :: Future { let inner = self . 0 . clone ( ) ; let fut = async move { inner . get_customer_extension_setting ( request ) . await } ; Box :: pin ( fut ) } } let inner = self . inner . clone ( ) ; let fut = async move { let interceptor = inner . 1 . clone ( ) ; let inner = inner . 0 ; let method = GetCustomerExtensionSettingSvc ( inner ) ; let codec = tonic :: codec :: ProstCodec :: default ( ) ; let mut grpc = if let Some ( interceptor ) = interceptor { tonic :: server :: Grpc :: with_interceptor ( codec , interceptor ) } else { tonic :: server :: Grpc :: new ( codec ) } ; let res = grpc . unary ( method , req ) . await ; Ok ( res ) } ; Box :: pin ( fut ) } "/google.ads.googleads.v1.services.CustomerExtensionSettingService/MutateCustomerExtensionSettings" => { # [ allow ( non_camel_case_types ) ] struct MutateCustomerExtensionSettingsSvc < T : CustomerExtensionSettingService > ( pub Arc < T > ) ; impl < T : CustomerExtensionSettingService > tonic :: server :: UnaryService < super :: MutateCustomerExtensionSettingsRequest > for MutateCustomerExtensionSettingsSvc < T > { type Response = super :: MutateCustomerExtensionSettingsResponse ; type Future = BoxFuture < tonic :: Response < Self :: Response > , tonic :: Status > ; fn call ( & mut self , request : tonic :: Request < super :: MutateCustomerExtensionSettingsRequest > ) -> Self :: Future { let inner = self . 0 . clone ( ) ; let fut = async move { inner . mutate_customer_extension_settings ( request ) . await } ; Box :: pin ( fut ) } } let inner = self . inner . clone ( ) ; let fut = async move { let interceptor = inner . 1 . clone ( ) ; let inner = inner . 0 ; let method = MutateCustomerExtensionSettingsSvc ( inner ) ; let codec = tonic :: codec :: ProstCodec :: default ( ) ; let mut grpc = if let Some ( interceptor ) = interceptor { tonic :: server :: Grpc :: with_interceptor ( codec , interceptor ) } else { tonic :: server :: Grpc :: new ( codec ) } ; let res = grpc . unary ( method , req ) . await ; Ok ( res ) } ; Box :: pin ( fut ) } _ => Box :: pin ( async move { Ok ( http :: Response :: builder ( ) . status ( 200 ) . header ( "grpc-status" , "12" ) . body ( tonic :: body :: BoxBody :: empty ( ) ) . unwrap ( ) ) } ) , }
        }
    }
    impl<T: CustomerExtensionSettingService> Clone for CustomerExtensionSettingServiceServer<T> {
        fn clone(&self) -> Self {
            let inner = self.inner.clone();
            Self { inner }
        }
    }
    impl<T: CustomerExtensionSettingService> Clone for _Inner<T> {
        fn clone(&self) -> Self {
            Self(self.0.clone(), self.1.clone())
        }
    }
    impl<T: std::fmt::Debug> std::fmt::Debug for _Inner<T> {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
            write!(f, "{:?}", self.0)
        }
    }
    impl<T: CustomerExtensionSettingService> tonic::transport::NamedService
        for CustomerExtensionSettingServiceServer<T>
    {
        const NAME: &'static str =
            "google.ads.googleads.v1.services.CustomerExtensionSettingService";
    }
}
/// Request message for [CustomerFeedService.GetCustomerFeed][google.ads.googleads.v1.services.CustomerFeedService.GetCustomerFeed].
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GetCustomerFeedRequest {
    /// Required. The resource name of the customer feed to fetch.
    #[prost(string, tag = "1")]
    pub resource_name: std::string::String,
}
/// Request message for [CustomerFeedService.MutateCustomerFeeds][google.ads.googleads.v1.services.CustomerFeedService.MutateCustomerFeeds].
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct MutateCustomerFeedsRequest {
    /// Required. The ID of the customer whose customer feeds are being modified.
    #[prost(string, tag = "1")]
    pub customer_id: std::string::String,
    /// Required. The list of operations to perform on individual customer feeds.
    #[prost(message, repeated, tag = "2")]
    pub operations: ::std::vec::Vec<CustomerFeedOperation>,
    /// If true, successful operations will be carried out and invalid
    /// operations will return errors. If false, all operations will be carried
    /// out in one transaction if and only if they are all valid.
    /// Default is false.
    #[prost(bool, tag = "3")]
    pub partial_failure: bool,
    /// If true, the request is validated but not executed. Only errors are
    /// returned, not results.
    #[prost(bool, tag = "4")]
    pub validate_only: bool,
}
/// A single operation (create, update, remove) on a customer feed.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CustomerFeedOperation {
    /// FieldMask that determines which resource fields are modified in an update.
    #[prost(message, optional, tag = "4")]
    pub update_mask: ::std::option::Option<::prost_types::FieldMask>,
    /// The mutate operation.
    #[prost(oneof = "customer_feed_operation::Operation", tags = "1, 2, 3")]
    pub operation: ::std::option::Option<customer_feed_operation::Operation>,
}
pub mod customer_feed_operation {
    /// The mutate operation.
    #[derive(Clone, PartialEq, ::prost::Oneof)]
    pub enum Operation {
        /// Create operation: No resource name is expected for the new customer feed.
        #[prost(message, tag = "1")]
        Create(super::super::resources::CustomerFeed),
        /// Update operation: The customer feed is expected to have a valid resource
        /// name.
        #[prost(message, tag = "2")]
        Update(super::super::resources::CustomerFeed),
        /// Remove operation: A resource name for the removed customer feed is
        /// expected, in this format:
        ///
        /// `customers/{customer_id}/customerFeeds/{feed_id}`
        #[prost(string, tag = "3")]
        Remove(std::string::String),
    }
}
/// Response message for a customer feed mutate.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct MutateCustomerFeedsResponse {
    /// Errors that pertain to operation failures in the partial failure mode.
    /// Returned only when partial_failure = true and all errors occur inside the
    /// operations. If any errors occur outside the operations (e.g. auth errors),
    /// we return an RPC level error.
    #[prost(message, optional, tag = "3")]
    pub partial_failure_error: ::std::option::Option<super::super::super::super::rpc::Status>,
    /// All results for the mutate.
    #[prost(message, repeated, tag = "2")]
    pub results: ::std::vec::Vec<MutateCustomerFeedResult>,
}
/// The result for the customer feed mutate.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct MutateCustomerFeedResult {
    /// Returned for successful operations.
    #[prost(string, tag = "1")]
    pub resource_name: std::string::String,
}
#[doc = r" Generated client implementations."]
pub mod customer_feed_service_client {
    #![allow(unused_variables, dead_code, missing_docs)]
    use tonic::codegen::*;
    #[doc = " Service to manage customer feeds."]
    pub struct CustomerFeedServiceClient<T> {
        inner: tonic::client::Grpc<T>,
    }
    impl CustomerFeedServiceClient<tonic::transport::Channel> {
        #[doc = r" Attempt to create a new client by connecting to a given endpoint."]
        pub async fn connect<D>(dst: D) -> Result<Self, tonic::transport::Error>
        where
            D: std::convert::TryInto<tonic::transport::Endpoint>,
            D::Error: Into<StdError>,
        {
            let conn = tonic::transport::Endpoint::new(dst)?.connect().await?;
            Ok(Self::new(conn))
        }
    }
    impl<T> CustomerFeedServiceClient<T>
    where
        T: tonic::client::GrpcService<tonic::body::BoxBody>,
        T::ResponseBody: Body + HttpBody + Send + 'static,
        T::Error: Into<StdError>,
        <T::ResponseBody as HttpBody>::Error: Into<StdError> + Send,
    {
        pub fn new(inner: T) -> Self {
            let inner = tonic::client::Grpc::new(inner);
            Self { inner }
        }
        pub fn with_interceptor(inner: T, interceptor: impl Into<tonic::Interceptor>) -> Self {
            let inner = tonic::client::Grpc::with_interceptor(inner, interceptor);
            Self { inner }
        }
        #[doc = " Returns the requested customer feed in full detail."]
        pub async fn get_customer_feed(
            &mut self,
            request: impl tonic::IntoRequest<super::GetCustomerFeedRequest>,
        ) -> Result<tonic::Response<super::super::resources::CustomerFeed>, tonic::Status> {
            self.inner.ready().await.map_err(|e| {
                tonic::Status::new(
                    tonic::Code::Unknown,
                    format!("Service was not ready: {}", e.into()),
                )
            })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.ads.googleads.v1.services.CustomerFeedService/GetCustomerFeed",
            );
            self.inner.unary(request.into_request(), path, codec).await
        }
        #[doc = " Creates, updates, or removes customer feeds. Operation statuses are"]
        #[doc = " returned."]
        pub async fn mutate_customer_feeds(
            &mut self,
            request: impl tonic::IntoRequest<super::MutateCustomerFeedsRequest>,
        ) -> Result<tonic::Response<super::MutateCustomerFeedsResponse>, tonic::Status> {
            self.inner.ready().await.map_err(|e| {
                tonic::Status::new(
                    tonic::Code::Unknown,
                    format!("Service was not ready: {}", e.into()),
                )
            })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.ads.googleads.v1.services.CustomerFeedService/MutateCustomerFeeds",
            );
            self.inner.unary(request.into_request(), path, codec).await
        }
    }
    impl<T: Clone> Clone for CustomerFeedServiceClient<T> {
        fn clone(&self) -> Self {
            Self {
                inner: self.inner.clone(),
            }
        }
    }
    impl<T> std::fmt::Debug for CustomerFeedServiceClient<T> {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
            write!(f, "CustomerFeedServiceClient {{ ... }}")
        }
    }
}
#[doc = r" Generated server implementations."]
pub mod customer_feed_service_server {
    #![allow(unused_variables, dead_code, missing_docs)]
    use tonic::codegen::*;
    #[doc = "Generated trait containing gRPC methods that should be implemented for use with CustomerFeedServiceServer."]
    #[async_trait]
    pub trait CustomerFeedService: Send + Sync + 'static {
        #[doc = " Returns the requested customer feed in full detail."]
        async fn get_customer_feed(
            &self,
            request: tonic::Request<super::GetCustomerFeedRequest>,
        ) -> Result<tonic::Response<super::super::resources::CustomerFeed>, tonic::Status>;
        #[doc = " Creates, updates, or removes customer feeds. Operation statuses are"]
        #[doc = " returned."]
        async fn mutate_customer_feeds(
            &self,
            request: tonic::Request<super::MutateCustomerFeedsRequest>,
        ) -> Result<tonic::Response<super::MutateCustomerFeedsResponse>, tonic::Status>;
    }
    #[doc = " Service to manage customer feeds."]
    #[derive(Debug)]
    #[doc(hidden)]
    pub struct CustomerFeedServiceServer<T: CustomerFeedService> {
        inner: _Inner<T>,
    }
    struct _Inner<T>(Arc<T>, Option<tonic::Interceptor>);
    impl<T: CustomerFeedService> CustomerFeedServiceServer<T> {
        pub fn new(inner: T) -> Self {
            let inner = Arc::new(inner);
            let inner = _Inner(inner, None);
            Self { inner }
        }
        pub fn with_interceptor(inner: T, interceptor: impl Into<tonic::Interceptor>) -> Self {
            let inner = Arc::new(inner);
            let inner = _Inner(inner, Some(interceptor.into()));
            Self { inner }
        }
    }
    impl<T, B> Service<http::Request<B>> for CustomerFeedServiceServer<T>
    where
        T: CustomerFeedService,
        B: HttpBody + Send + Sync + 'static,
        B::Error: Into<StdError> + Send + 'static,
    {
        type Response = http::Response<tonic::body::BoxBody>;
        type Error = Never;
        type Future = BoxFuture<Self::Response, Self::Error>;
        fn poll_ready(&mut self, _cx: &mut Context<'_>) -> Poll<Result<(), Self::Error>> {
            Poll::Ready(Ok(()))
        }
        fn call(&mut self, req: http::Request<B>) -> Self::Future {
            let inner = self.inner.clone();
            match req.uri().path() {
                "/google.ads.googleads.v1.services.CustomerFeedService/GetCustomerFeed" => {
                    #[allow(non_camel_case_types)]
                    struct GetCustomerFeedSvc<T: CustomerFeedService>(pub Arc<T>);
                    impl<T: CustomerFeedService>
                        tonic::server::UnaryService<super::GetCustomerFeedRequest>
                        for GetCustomerFeedSvc<T>
                    {
                        type Response = super::super::resources::CustomerFeed;
                        type Future = BoxFuture<tonic::Response<Self::Response>, tonic::Status>;
                        fn call(
                            &mut self,
                            request: tonic::Request<super::GetCustomerFeedRequest>,
                        ) -> Self::Future {
                            let inner = self.0.clone();
                            let fut = async move { inner.get_customer_feed(request).await };
                            Box::pin(fut)
                        }
                    }
                    let inner = self.inner.clone();
                    let fut = async move {
                        let interceptor = inner.1.clone();
                        let inner = inner.0;
                        let method = GetCustomerFeedSvc(inner);
                        let codec = tonic::codec::ProstCodec::default();
                        let mut grpc = if let Some(interceptor) = interceptor {
                            tonic::server::Grpc::with_interceptor(codec, interceptor)
                        } else {
                            tonic::server::Grpc::new(codec)
                        };
                        let res = grpc.unary(method, req).await;
                        Ok(res)
                    };
                    Box::pin(fut)
                }
                "/google.ads.googleads.v1.services.CustomerFeedService/MutateCustomerFeeds" => {
                    #[allow(non_camel_case_types)]
                    struct MutateCustomerFeedsSvc<T: CustomerFeedService>(pub Arc<T>);
                    impl<T: CustomerFeedService>
                        tonic::server::UnaryService<super::MutateCustomerFeedsRequest>
                        for MutateCustomerFeedsSvc<T>
                    {
                        type Response = super::MutateCustomerFeedsResponse;
                        type Future = BoxFuture<tonic::Response<Self::Response>, tonic::Status>;
                        fn call(
                            &mut self,
                            request: tonic::Request<super::MutateCustomerFeedsRequest>,
                        ) -> Self::Future {
                            let inner = self.0.clone();
                            let fut = async move { inner.mutate_customer_feeds(request).await };
                            Box::pin(fut)
                        }
                    }
                    let inner = self.inner.clone();
                    let fut = async move {
                        let interceptor = inner.1.clone();
                        let inner = inner.0;
                        let method = MutateCustomerFeedsSvc(inner);
                        let codec = tonic::codec::ProstCodec::default();
                        let mut grpc = if let Some(interceptor) = interceptor {
                            tonic::server::Grpc::with_interceptor(codec, interceptor)
                        } else {
                            tonic::server::Grpc::new(codec)
                        };
                        let res = grpc.unary(method, req).await;
                        Ok(res)
                    };
                    Box::pin(fut)
                }
                _ => Box::pin(async move {
                    Ok(http::Response::builder()
                        .status(200)
                        .header("grpc-status", "12")
                        .body(tonic::body::BoxBody::empty())
                        .unwrap())
                }),
            }
        }
    }
    impl<T: CustomerFeedService> Clone for CustomerFeedServiceServer<T> {
        fn clone(&self) -> Self {
            let inner = self.inner.clone();
            Self { inner }
        }
    }
    impl<T: CustomerFeedService> Clone for _Inner<T> {
        fn clone(&self) -> Self {
            Self(self.0.clone(), self.1.clone())
        }
    }
    impl<T: std::fmt::Debug> std::fmt::Debug for _Inner<T> {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
            write!(f, "{:?}", self.0)
        }
    }
    impl<T: CustomerFeedService> tonic::transport::NamedService for CustomerFeedServiceServer<T> {
        const NAME: &'static str = "google.ads.googleads.v1.services.CustomerFeedService";
    }
}
/// Request message for [CustomerLabelService.GetCustomerLabel][google.ads.googleads.v1.services.CustomerLabelService.GetCustomerLabel].
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GetCustomerLabelRequest {
    /// Required. The resource name of the customer-label relationship to fetch.
    #[prost(string, tag = "1")]
    pub resource_name: std::string::String,
}
/// Request message for [CustomerLabelService.MutateCustomerLabels][google.ads.googleads.v1.services.CustomerLabelService.MutateCustomerLabels].
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct MutateCustomerLabelsRequest {
    /// Required. ID of the customer whose customer-label relationships are being modified.
    #[prost(string, tag = "1")]
    pub customer_id: std::string::String,
    /// Required. The list of operations to perform on customer-label relationships.
    #[prost(message, repeated, tag = "2")]
    pub operations: ::std::vec::Vec<CustomerLabelOperation>,
    /// If true, successful operations will be carried out and invalid
    /// operations will return errors. If false, all operations will be carried
    /// out in one transaction if and only if they are all valid.
    /// Default is false.
    #[prost(bool, tag = "3")]
    pub partial_failure: bool,
    /// If true, the request is validated but not executed. Only errors are
    /// returned, not results.
    #[prost(bool, tag = "4")]
    pub validate_only: bool,
}
/// A single operation (create, remove) on a customer-label relationship.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CustomerLabelOperation {
    /// The mutate operation.
    #[prost(oneof = "customer_label_operation::Operation", tags = "1, 2")]
    pub operation: ::std::option::Option<customer_label_operation::Operation>,
}
pub mod customer_label_operation {
    /// The mutate operation.
    #[derive(Clone, PartialEq, ::prost::Oneof)]
    pub enum Operation {
        /// Create operation: No resource name is expected for the new customer-label
        /// relationship.
        #[prost(message, tag = "1")]
        Create(super::super::resources::CustomerLabel),
        /// Remove operation: A resource name for the customer-label relationship
        /// being removed, in this format:
        ///
        /// `customers/{customer_id}/customerLabels/{label_id}`
        #[prost(string, tag = "2")]
        Remove(std::string::String),
    }
}
/// Response message for a customer labels mutate.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct MutateCustomerLabelsResponse {
    /// Errors that pertain to operation failures in the partial failure mode.
    /// Returned only when partial_failure = true and all errors occur inside the
    /// operations. If any errors occur outside the operations (e.g. auth errors),
    /// we return an RPC level error.
    #[prost(message, optional, tag = "3")]
    pub partial_failure_error: ::std::option::Option<super::super::super::super::rpc::Status>,
    /// All results for the mutate.
    #[prost(message, repeated, tag = "2")]
    pub results: ::std::vec::Vec<MutateCustomerLabelResult>,
}
/// The result for a customer label mutate.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct MutateCustomerLabelResult {
    /// Returned for successful operations.
    #[prost(string, tag = "1")]
    pub resource_name: std::string::String,
}
#[doc = r" Generated client implementations."]
pub mod customer_label_service_client {
    #![allow(unused_variables, dead_code, missing_docs)]
    use tonic::codegen::*;
    #[doc = " Service to manage labels on customers."]
    pub struct CustomerLabelServiceClient<T> {
        inner: tonic::client::Grpc<T>,
    }
    impl CustomerLabelServiceClient<tonic::transport::Channel> {
        #[doc = r" Attempt to create a new client by connecting to a given endpoint."]
        pub async fn connect<D>(dst: D) -> Result<Self, tonic::transport::Error>
        where
            D: std::convert::TryInto<tonic::transport::Endpoint>,
            D::Error: Into<StdError>,
        {
            let conn = tonic::transport::Endpoint::new(dst)?.connect().await?;
            Ok(Self::new(conn))
        }
    }
    impl<T> CustomerLabelServiceClient<T>
    where
        T: tonic::client::GrpcService<tonic::body::BoxBody>,
        T::ResponseBody: Body + HttpBody + Send + 'static,
        T::Error: Into<StdError>,
        <T::ResponseBody as HttpBody>::Error: Into<StdError> + Send,
    {
        pub fn new(inner: T) -> Self {
            let inner = tonic::client::Grpc::new(inner);
            Self { inner }
        }
        pub fn with_interceptor(inner: T, interceptor: impl Into<tonic::Interceptor>) -> Self {
            let inner = tonic::client::Grpc::with_interceptor(inner, interceptor);
            Self { inner }
        }
        #[doc = " Returns the requested customer-label relationship in full detail."]
        pub async fn get_customer_label(
            &mut self,
            request: impl tonic::IntoRequest<super::GetCustomerLabelRequest>,
        ) -> Result<tonic::Response<super::super::resources::CustomerLabel>, tonic::Status>
        {
            self.inner.ready().await.map_err(|e| {
                tonic::Status::new(
                    tonic::Code::Unknown,
                    format!("Service was not ready: {}", e.into()),
                )
            })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.ads.googleads.v1.services.CustomerLabelService/GetCustomerLabel",
            );
            self.inner.unary(request.into_request(), path, codec).await
        }
        #[doc = " Creates and removes customer-label relationships."]
        #[doc = " Operation statuses are returned."]
        pub async fn mutate_customer_labels(
            &mut self,
            request: impl tonic::IntoRequest<super::MutateCustomerLabelsRequest>,
        ) -> Result<tonic::Response<super::MutateCustomerLabelsResponse>, tonic::Status> {
            self.inner.ready().await.map_err(|e| {
                tonic::Status::new(
                    tonic::Code::Unknown,
                    format!("Service was not ready: {}", e.into()),
                )
            })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.ads.googleads.v1.services.CustomerLabelService/MutateCustomerLabels",
            );
            self.inner.unary(request.into_request(), path, codec).await
        }
    }
    impl<T: Clone> Clone for CustomerLabelServiceClient<T> {
        fn clone(&self) -> Self {
            Self {
                inner: self.inner.clone(),
            }
        }
    }
    impl<T> std::fmt::Debug for CustomerLabelServiceClient<T> {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
            write!(f, "CustomerLabelServiceClient {{ ... }}")
        }
    }
}
#[doc = r" Generated server implementations."]
pub mod customer_label_service_server {
    #![allow(unused_variables, dead_code, missing_docs)]
    use tonic::codegen::*;
    #[doc = "Generated trait containing gRPC methods that should be implemented for use with CustomerLabelServiceServer."]
    #[async_trait]
    pub trait CustomerLabelService: Send + Sync + 'static {
        #[doc = " Returns the requested customer-label relationship in full detail."]
        async fn get_customer_label(
            &self,
            request: tonic::Request<super::GetCustomerLabelRequest>,
        ) -> Result<tonic::Response<super::super::resources::CustomerLabel>, tonic::Status>;
        #[doc = " Creates and removes customer-label relationships."]
        #[doc = " Operation statuses are returned."]
        async fn mutate_customer_labels(
            &self,
            request: tonic::Request<super::MutateCustomerLabelsRequest>,
        ) -> Result<tonic::Response<super::MutateCustomerLabelsResponse>, tonic::Status>;
    }
    #[doc = " Service to manage labels on customers."]
    #[derive(Debug)]
    #[doc(hidden)]
    pub struct CustomerLabelServiceServer<T: CustomerLabelService> {
        inner: _Inner<T>,
    }
    struct _Inner<T>(Arc<T>, Option<tonic::Interceptor>);
    impl<T: CustomerLabelService> CustomerLabelServiceServer<T> {
        pub fn new(inner: T) -> Self {
            let inner = Arc::new(inner);
            let inner = _Inner(inner, None);
            Self { inner }
        }
        pub fn with_interceptor(inner: T, interceptor: impl Into<tonic::Interceptor>) -> Self {
            let inner = Arc::new(inner);
            let inner = _Inner(inner, Some(interceptor.into()));
            Self { inner }
        }
    }
    impl<T, B> Service<http::Request<B>> for CustomerLabelServiceServer<T>
    where
        T: CustomerLabelService,
        B: HttpBody + Send + Sync + 'static,
        B::Error: Into<StdError> + Send + 'static,
    {
        type Response = http::Response<tonic::body::BoxBody>;
        type Error = Never;
        type Future = BoxFuture<Self::Response, Self::Error>;
        fn poll_ready(&mut self, _cx: &mut Context<'_>) -> Poll<Result<(), Self::Error>> {
            Poll::Ready(Ok(()))
        }
        fn call(&mut self, req: http::Request<B>) -> Self::Future {
            let inner = self.inner.clone();
            match req.uri().path() {
                "/google.ads.googleads.v1.services.CustomerLabelService/GetCustomerLabel" => {
                    #[allow(non_camel_case_types)]
                    struct GetCustomerLabelSvc<T: CustomerLabelService>(pub Arc<T>);
                    impl<T: CustomerLabelService>
                        tonic::server::UnaryService<super::GetCustomerLabelRequest>
                        for GetCustomerLabelSvc<T>
                    {
                        type Response = super::super::resources::CustomerLabel;
                        type Future = BoxFuture<tonic::Response<Self::Response>, tonic::Status>;
                        fn call(
                            &mut self,
                            request: tonic::Request<super::GetCustomerLabelRequest>,
                        ) -> Self::Future {
                            let inner = self.0.clone();
                            let fut = async move { inner.get_customer_label(request).await };
                            Box::pin(fut)
                        }
                    }
                    let inner = self.inner.clone();
                    let fut = async move {
                        let interceptor = inner.1.clone();
                        let inner = inner.0;
                        let method = GetCustomerLabelSvc(inner);
                        let codec = tonic::codec::ProstCodec::default();
                        let mut grpc = if let Some(interceptor) = interceptor {
                            tonic::server::Grpc::with_interceptor(codec, interceptor)
                        } else {
                            tonic::server::Grpc::new(codec)
                        };
                        let res = grpc.unary(method, req).await;
                        Ok(res)
                    };
                    Box::pin(fut)
                }
                "/google.ads.googleads.v1.services.CustomerLabelService/MutateCustomerLabels" => {
                    #[allow(non_camel_case_types)]
                    struct MutateCustomerLabelsSvc<T: CustomerLabelService>(pub Arc<T>);
                    impl<T: CustomerLabelService>
                        tonic::server::UnaryService<super::MutateCustomerLabelsRequest>
                        for MutateCustomerLabelsSvc<T>
                    {
                        type Response = super::MutateCustomerLabelsResponse;
                        type Future = BoxFuture<tonic::Response<Self::Response>, tonic::Status>;
                        fn call(
                            &mut self,
                            request: tonic::Request<super::MutateCustomerLabelsRequest>,
                        ) -> Self::Future {
                            let inner = self.0.clone();
                            let fut = async move { inner.mutate_customer_labels(request).await };
                            Box::pin(fut)
                        }
                    }
                    let inner = self.inner.clone();
                    let fut = async move {
                        let interceptor = inner.1.clone();
                        let inner = inner.0;
                        let method = MutateCustomerLabelsSvc(inner);
                        let codec = tonic::codec::ProstCodec::default();
                        let mut grpc = if let Some(interceptor) = interceptor {
                            tonic::server::Grpc::with_interceptor(codec, interceptor)
                        } else {
                            tonic::server::Grpc::new(codec)
                        };
                        let res = grpc.unary(method, req).await;
                        Ok(res)
                    };
                    Box::pin(fut)
                }
                _ => Box::pin(async move {
                    Ok(http::Response::builder()
                        .status(200)
                        .header("grpc-status", "12")
                        .body(tonic::body::BoxBody::empty())
                        .unwrap())
                }),
            }
        }
    }
    impl<T: CustomerLabelService> Clone for CustomerLabelServiceServer<T> {
        fn clone(&self) -> Self {
            let inner = self.inner.clone();
            Self { inner }
        }
    }
    impl<T: CustomerLabelService> Clone for _Inner<T> {
        fn clone(&self) -> Self {
            Self(self.0.clone(), self.1.clone())
        }
    }
    impl<T: std::fmt::Debug> std::fmt::Debug for _Inner<T> {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
            write!(f, "{:?}", self.0)
        }
    }
    impl<T: CustomerLabelService> tonic::transport::NamedService for CustomerLabelServiceServer<T> {
        const NAME: &'static str = "google.ads.googleads.v1.services.CustomerLabelService";
    }
}
/// Request message for [CustomerManagerLinkService.GetCustomerManagerLink][google.ads.googleads.v1.services.CustomerManagerLinkService.GetCustomerManagerLink].
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GetCustomerManagerLinkRequest {
    /// Required. The resource name of the CustomerManagerLink to fetch.
    #[prost(string, tag = "1")]
    pub resource_name: std::string::String,
}
/// Request message for [CustomerManagerLinkService.MutateCustomerManagerLink][google.ads.googleads.v1.services.CustomerManagerLinkService.MutateCustomerManagerLink].
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct MutateCustomerManagerLinkRequest {
    /// Required. The ID of the customer whose customer manager links are being modified.
    #[prost(string, tag = "1")]
    pub customer_id: std::string::String,
    /// Required. The list of operations to perform on individual customer manager links.
    #[prost(message, repeated, tag = "2")]
    pub operations: ::std::vec::Vec<CustomerManagerLinkOperation>,
}
/// Updates the status of a CustomerManagerLink.
/// The following actions are possible:
/// 1. Update operation with status ACTIVE accepts a pending invitation.
/// 2. Update operation with status REFUSED declines a pending invitation.
/// 3. Update operation with status INACTIVE terminates link to manager.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CustomerManagerLinkOperation {
    /// FieldMask that determines which resource fields are modified in an update.
    #[prost(message, optional, tag = "4")]
    pub update_mask: ::std::option::Option<::prost_types::FieldMask>,
    /// The mutate operation.
    #[prost(oneof = "customer_manager_link_operation::Operation", tags = "2")]
    pub operation: ::std::option::Option<customer_manager_link_operation::Operation>,
}
pub mod customer_manager_link_operation {
    /// The mutate operation.
    #[derive(Clone, PartialEq, ::prost::Oneof)]
    pub enum Operation {
        /// Update operation: The link is expected to have a valid resource name.
        #[prost(message, tag = "2")]
        Update(super::super::resources::CustomerManagerLink),
    }
}
/// Response message for a CustomerManagerLink mutate.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct MutateCustomerManagerLinkResponse {
    /// A result that identifies the resource affected by the mutate request.
    #[prost(message, repeated, tag = "1")]
    pub results: ::std::vec::Vec<MutateCustomerManagerLinkResult>,
}
/// The result for the customer manager link mutate.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct MutateCustomerManagerLinkResult {
    /// Returned for successful operations.
    #[prost(string, tag = "1")]
    pub resource_name: std::string::String,
}
#[doc = r" Generated client implementations."]
pub mod customer_manager_link_service_client {
    #![allow(unused_variables, dead_code, missing_docs)]
    use tonic::codegen::*;
    #[doc = " Service to manage customer-manager links."]
    pub struct CustomerManagerLinkServiceClient<T> {
        inner: tonic::client::Grpc<T>,
    }
    impl CustomerManagerLinkServiceClient<tonic::transport::Channel> {
        #[doc = r" Attempt to create a new client by connecting to a given endpoint."]
        pub async fn connect<D>(dst: D) -> Result<Self, tonic::transport::Error>
        where
            D: std::convert::TryInto<tonic::transport::Endpoint>,
            D::Error: Into<StdError>,
        {
            let conn = tonic::transport::Endpoint::new(dst)?.connect().await?;
            Ok(Self::new(conn))
        }
    }
    impl<T> CustomerManagerLinkServiceClient<T>
    where
        T: tonic::client::GrpcService<tonic::body::BoxBody>,
        T::ResponseBody: Body + HttpBody + Send + 'static,
        T::Error: Into<StdError>,
        <T::ResponseBody as HttpBody>::Error: Into<StdError> + Send,
    {
        pub fn new(inner: T) -> Self {
            let inner = tonic::client::Grpc::new(inner);
            Self { inner }
        }
        pub fn with_interceptor(inner: T, interceptor: impl Into<tonic::Interceptor>) -> Self {
            let inner = tonic::client::Grpc::with_interceptor(inner, interceptor);
            Self { inner }
        }
        #[doc = " Returns the requested CustomerManagerLink in full detail."]
        pub async fn get_customer_manager_link(
            &mut self,
            request: impl tonic::IntoRequest<super::GetCustomerManagerLinkRequest>,
        ) -> Result<tonic::Response<super::super::resources::CustomerManagerLink>, tonic::Status>
        {
            self.inner.ready().await.map_err(|e| {
                tonic::Status::new(
                    tonic::Code::Unknown,
                    format!("Service was not ready: {}", e.into()),
                )
            })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http :: uri :: PathAndQuery :: from_static ( "/google.ads.googleads.v1.services.CustomerManagerLinkService/GetCustomerManagerLink" ) ;
            self.inner.unary(request.into_request(), path, codec).await
        }
        #[doc = " Creates or updates customer manager links. Operation statuses are returned."]
        pub async fn mutate_customer_manager_link(
            &mut self,
            request: impl tonic::IntoRequest<super::MutateCustomerManagerLinkRequest>,
        ) -> Result<tonic::Response<super::MutateCustomerManagerLinkResponse>, tonic::Status>
        {
            self.inner.ready().await.map_err(|e| {
                tonic::Status::new(
                    tonic::Code::Unknown,
                    format!("Service was not ready: {}", e.into()),
                )
            })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http :: uri :: PathAndQuery :: from_static ( "/google.ads.googleads.v1.services.CustomerManagerLinkService/MutateCustomerManagerLink" ) ;
            self.inner.unary(request.into_request(), path, codec).await
        }
    }
    impl<T: Clone> Clone for CustomerManagerLinkServiceClient<T> {
        fn clone(&self) -> Self {
            Self {
                inner: self.inner.clone(),
            }
        }
    }
    impl<T> std::fmt::Debug for CustomerManagerLinkServiceClient<T> {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
            write!(f, "CustomerManagerLinkServiceClient {{ ... }}")
        }
    }
}
#[doc = r" Generated server implementations."]
pub mod customer_manager_link_service_server {
    #![allow(unused_variables, dead_code, missing_docs)]
    use tonic::codegen::*;
    #[doc = "Generated trait containing gRPC methods that should be implemented for use with CustomerManagerLinkServiceServer."]
    #[async_trait]
    pub trait CustomerManagerLinkService: Send + Sync + 'static {
        #[doc = " Returns the requested CustomerManagerLink in full detail."]
        async fn get_customer_manager_link(
            &self,
            request: tonic::Request<super::GetCustomerManagerLinkRequest>,
        ) -> Result<tonic::Response<super::super::resources::CustomerManagerLink>, tonic::Status>;
        #[doc = " Creates or updates customer manager links. Operation statuses are returned."]
        async fn mutate_customer_manager_link(
            &self,
            request: tonic::Request<super::MutateCustomerManagerLinkRequest>,
        ) -> Result<tonic::Response<super::MutateCustomerManagerLinkResponse>, tonic::Status>;
    }
    #[doc = " Service to manage customer-manager links."]
    #[derive(Debug)]
    #[doc(hidden)]
    pub struct CustomerManagerLinkServiceServer<T: CustomerManagerLinkService> {
        inner: _Inner<T>,
    }
    struct _Inner<T>(Arc<T>, Option<tonic::Interceptor>);
    impl<T: CustomerManagerLinkService> CustomerManagerLinkServiceServer<T> {
        pub fn new(inner: T) -> Self {
            let inner = Arc::new(inner);
            let inner = _Inner(inner, None);
            Self { inner }
        }
        pub fn with_interceptor(inner: T, interceptor: impl Into<tonic::Interceptor>) -> Self {
            let inner = Arc::new(inner);
            let inner = _Inner(inner, Some(interceptor.into()));
            Self { inner }
        }
    }
    impl<T, B> Service<http::Request<B>> for CustomerManagerLinkServiceServer<T>
    where
        T: CustomerManagerLinkService,
        B: HttpBody + Send + Sync + 'static,
        B::Error: Into<StdError> + Send + 'static,
    {
        type Response = http::Response<tonic::body::BoxBody>;
        type Error = Never;
        type Future = BoxFuture<Self::Response, Self::Error>;
        fn poll_ready(&mut self, _cx: &mut Context<'_>) -> Poll<Result<(), Self::Error>> {
            Poll::Ready(Ok(()))
        }
        fn call(&mut self, req: http::Request<B>) -> Self::Future {
            let inner = self.inner.clone();
            match req . uri ( ) . path ( ) { "/google.ads.googleads.v1.services.CustomerManagerLinkService/GetCustomerManagerLink" => { # [ allow ( non_camel_case_types ) ] struct GetCustomerManagerLinkSvc < T : CustomerManagerLinkService > ( pub Arc < T > ) ; impl < T : CustomerManagerLinkService > tonic :: server :: UnaryService < super :: GetCustomerManagerLinkRequest > for GetCustomerManagerLinkSvc < T > { type Response = super :: super :: resources :: CustomerManagerLink ; type Future = BoxFuture < tonic :: Response < Self :: Response > , tonic :: Status > ; fn call ( & mut self , request : tonic :: Request < super :: GetCustomerManagerLinkRequest > ) -> Self :: Future { let inner = self . 0 . clone ( ) ; let fut = async move { inner . get_customer_manager_link ( request ) . await } ; Box :: pin ( fut ) } } let inner = self . inner . clone ( ) ; let fut = async move { let interceptor = inner . 1 . clone ( ) ; let inner = inner . 0 ; let method = GetCustomerManagerLinkSvc ( inner ) ; let codec = tonic :: codec :: ProstCodec :: default ( ) ; let mut grpc = if let Some ( interceptor ) = interceptor { tonic :: server :: Grpc :: with_interceptor ( codec , interceptor ) } else { tonic :: server :: Grpc :: new ( codec ) } ; let res = grpc . unary ( method , req ) . await ; Ok ( res ) } ; Box :: pin ( fut ) } "/google.ads.googleads.v1.services.CustomerManagerLinkService/MutateCustomerManagerLink" => { # [ allow ( non_camel_case_types ) ] struct MutateCustomerManagerLinkSvc < T : CustomerManagerLinkService > ( pub Arc < T > ) ; impl < T : CustomerManagerLinkService > tonic :: server :: UnaryService < super :: MutateCustomerManagerLinkRequest > for MutateCustomerManagerLinkSvc < T > { type Response = super :: MutateCustomerManagerLinkResponse ; type Future = BoxFuture < tonic :: Response < Self :: Response > , tonic :: Status > ; fn call ( & mut self , request : tonic :: Request < super :: MutateCustomerManagerLinkRequest > ) -> Self :: Future { let inner = self . 0 . clone ( ) ; let fut = async move { inner . mutate_customer_manager_link ( request ) . await } ; Box :: pin ( fut ) } } let inner = self . inner . clone ( ) ; let fut = async move { let interceptor = inner . 1 . clone ( ) ; let inner = inner . 0 ; let method = MutateCustomerManagerLinkSvc ( inner ) ; let codec = tonic :: codec :: ProstCodec :: default ( ) ; let mut grpc = if let Some ( interceptor ) = interceptor { tonic :: server :: Grpc :: with_interceptor ( codec , interceptor ) } else { tonic :: server :: Grpc :: new ( codec ) } ; let res = grpc . unary ( method , req ) . await ; Ok ( res ) } ; Box :: pin ( fut ) } _ => Box :: pin ( async move { Ok ( http :: Response :: builder ( ) . status ( 200 ) . header ( "grpc-status" , "12" ) . body ( tonic :: body :: BoxBody :: empty ( ) ) . unwrap ( ) ) } ) , }
        }
    }
    impl<T: CustomerManagerLinkService> Clone for CustomerManagerLinkServiceServer<T> {
        fn clone(&self) -> Self {
            let inner = self.inner.clone();
            Self { inner }
        }
    }
    impl<T: CustomerManagerLinkService> Clone for _Inner<T> {
        fn clone(&self) -> Self {
            Self(self.0.clone(), self.1.clone())
        }
    }
    impl<T: std::fmt::Debug> std::fmt::Debug for _Inner<T> {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
            write!(f, "{:?}", self.0)
        }
    }
    impl<T: CustomerManagerLinkService> tonic::transport::NamedService
        for CustomerManagerLinkServiceServer<T>
    {
        const NAME: &'static str = "google.ads.googleads.v1.services.CustomerManagerLinkService";
    }
}
/// Request message for
/// [CustomerNegativeCriterionService.GetCustomerNegativeCriterion][google.ads.googleads.v1.services.CustomerNegativeCriterionService.GetCustomerNegativeCriterion].
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GetCustomerNegativeCriterionRequest {
    /// Required. The resource name of the criterion to fetch.
    #[prost(string, tag = "1")]
    pub resource_name: std::string::String,
}
/// Request message for
/// [CustomerNegativeCriterionService.MutateCustomerNegativeCriteria][google.ads.googleads.v1.services.CustomerNegativeCriterionService.MutateCustomerNegativeCriteria].
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct MutateCustomerNegativeCriteriaRequest {
    /// Required. The ID of the customer whose criteria are being modified.
    #[prost(string, tag = "1")]
    pub customer_id: std::string::String,
    /// Required. The list of operations to perform on individual criteria.
    #[prost(message, repeated, tag = "2")]
    pub operations: ::std::vec::Vec<CustomerNegativeCriterionOperation>,
    /// If true, successful operations will be carried out and invalid
    /// operations will return errors. If false, all operations will be carried
    /// out in one transaction if and only if they are all valid.
    /// Default is false.
    #[prost(bool, tag = "3")]
    pub partial_failure: bool,
    /// If true, the request is validated but not executed. Only errors are
    /// returned, not results.
    #[prost(bool, tag = "4")]
    pub validate_only: bool,
}
/// A single operation (create or remove) on a customer level negative criterion.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CustomerNegativeCriterionOperation {
    /// The mutate operation.
    #[prost(
        oneof = "customer_negative_criterion_operation::Operation",
        tags = "1, 2"
    )]
    pub operation: ::std::option::Option<customer_negative_criterion_operation::Operation>,
}
pub mod customer_negative_criterion_operation {
    /// The mutate operation.
    #[derive(Clone, PartialEq, ::prost::Oneof)]
    pub enum Operation {
        /// Create operation: No resource name is expected for the new criterion.
        #[prost(message, tag = "1")]
        Create(super::super::resources::CustomerNegativeCriterion),
        /// Remove operation: A resource name for the removed criterion is expected,
        /// in this format:
        ///
        /// `customers/{customer_id}/customerNegativeCriteria/{criterion_id}`
        #[prost(string, tag = "2")]
        Remove(std::string::String),
    }
}
/// Response message for customer negative criterion mutate.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct MutateCustomerNegativeCriteriaResponse {
    /// Errors that pertain to operation failures in the partial failure mode.
    /// Returned only when partial_failure = true and all errors occur inside the
    /// operations. If any errors occur outside the operations (e.g. auth errors),
    /// we return an RPC level error.
    #[prost(message, optional, tag = "3")]
    pub partial_failure_error: ::std::option::Option<super::super::super::super::rpc::Status>,
    /// All results for the mutate.
    #[prost(message, repeated, tag = "2")]
    pub results: ::std::vec::Vec<MutateCustomerNegativeCriteriaResult>,
}
/// The result for the criterion mutate.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct MutateCustomerNegativeCriteriaResult {
    /// Returned for successful operations.
    #[prost(string, tag = "1")]
    pub resource_name: std::string::String,
}
#[doc = r" Generated client implementations."]
pub mod customer_negative_criterion_service_client {
    #![allow(unused_variables, dead_code, missing_docs)]
    use tonic::codegen::*;
    #[doc = " Service to manage customer negative criteria."]
    pub struct CustomerNegativeCriterionServiceClient<T> {
        inner: tonic::client::Grpc<T>,
    }
    impl CustomerNegativeCriterionServiceClient<tonic::transport::Channel> {
        #[doc = r" Attempt to create a new client by connecting to a given endpoint."]
        pub async fn connect<D>(dst: D) -> Result<Self, tonic::transport::Error>
        where
            D: std::convert::TryInto<tonic::transport::Endpoint>,
            D::Error: Into<StdError>,
        {
            let conn = tonic::transport::Endpoint::new(dst)?.connect().await?;
            Ok(Self::new(conn))
        }
    }
    impl<T> CustomerNegativeCriterionServiceClient<T>
    where
        T: tonic::client::GrpcService<tonic::body::BoxBody>,
        T::ResponseBody: Body + HttpBody + Send + 'static,
        T::Error: Into<StdError>,
        <T::ResponseBody as HttpBody>::Error: Into<StdError> + Send,
    {
        pub fn new(inner: T) -> Self {
            let inner = tonic::client::Grpc::new(inner);
            Self { inner }
        }
        pub fn with_interceptor(inner: T, interceptor: impl Into<tonic::Interceptor>) -> Self {
            let inner = tonic::client::Grpc::with_interceptor(inner, interceptor);
            Self { inner }
        }
        #[doc = " Returns the requested criterion in full detail."]
        pub async fn get_customer_negative_criterion(
            &mut self,
            request: impl tonic::IntoRequest<super::GetCustomerNegativeCriterionRequest>,
        ) -> Result<
            tonic::Response<super::super::resources::CustomerNegativeCriterion>,
            tonic::Status,
        > {
            self.inner.ready().await.map_err(|e| {
                tonic::Status::new(
                    tonic::Code::Unknown,
                    format!("Service was not ready: {}", e.into()),
                )
            })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http :: uri :: PathAndQuery :: from_static ( "/google.ads.googleads.v1.services.CustomerNegativeCriterionService/GetCustomerNegativeCriterion" ) ;
            self.inner.unary(request.into_request(), path, codec).await
        }
        #[doc = " Creates or removes criteria. Operation statuses are returned."]
        pub async fn mutate_customer_negative_criteria(
            &mut self,
            request: impl tonic::IntoRequest<super::MutateCustomerNegativeCriteriaRequest>,
        ) -> Result<tonic::Response<super::MutateCustomerNegativeCriteriaResponse>, tonic::Status>
        {
            self.inner.ready().await.map_err(|e| {
                tonic::Status::new(
                    tonic::Code::Unknown,
                    format!("Service was not ready: {}", e.into()),
                )
            })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http :: uri :: PathAndQuery :: from_static ( "/google.ads.googleads.v1.services.CustomerNegativeCriterionService/MutateCustomerNegativeCriteria" ) ;
            self.inner.unary(request.into_request(), path, codec).await
        }
    }
    impl<T: Clone> Clone for CustomerNegativeCriterionServiceClient<T> {
        fn clone(&self) -> Self {
            Self {
                inner: self.inner.clone(),
            }
        }
    }
    impl<T> std::fmt::Debug for CustomerNegativeCriterionServiceClient<T> {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
            write!(f, "CustomerNegativeCriterionServiceClient {{ ... }}")
        }
    }
}
#[doc = r" Generated server implementations."]
pub mod customer_negative_criterion_service_server {
    #![allow(unused_variables, dead_code, missing_docs)]
    use tonic::codegen::*;
    #[doc = "Generated trait containing gRPC methods that should be implemented for use with CustomerNegativeCriterionServiceServer."]
    #[async_trait]
    pub trait CustomerNegativeCriterionService: Send + Sync + 'static {
        #[doc = " Returns the requested criterion in full detail."]
        async fn get_customer_negative_criterion(
            &self,
            request: tonic::Request<super::GetCustomerNegativeCriterionRequest>,
        ) -> Result<
            tonic::Response<super::super::resources::CustomerNegativeCriterion>,
            tonic::Status,
        >;
        #[doc = " Creates or removes criteria. Operation statuses are returned."]
        async fn mutate_customer_negative_criteria(
            &self,
            request: tonic::Request<super::MutateCustomerNegativeCriteriaRequest>,
        ) -> Result<tonic::Response<super::MutateCustomerNegativeCriteriaResponse>, tonic::Status>;
    }
    #[doc = " Service to manage customer negative criteria."]
    #[derive(Debug)]
    #[doc(hidden)]
    pub struct CustomerNegativeCriterionServiceServer<T: CustomerNegativeCriterionService> {
        inner: _Inner<T>,
    }
    struct _Inner<T>(Arc<T>, Option<tonic::Interceptor>);
    impl<T: CustomerNegativeCriterionService> CustomerNegativeCriterionServiceServer<T> {
        pub fn new(inner: T) -> Self {
            let inner = Arc::new(inner);
            let inner = _Inner(inner, None);
            Self { inner }
        }
        pub fn with_interceptor(inner: T, interceptor: impl Into<tonic::Interceptor>) -> Self {
            let inner = Arc::new(inner);
            let inner = _Inner(inner, Some(interceptor.into()));
            Self { inner }
        }
    }
    impl<T, B> Service<http::Request<B>> for CustomerNegativeCriterionServiceServer<T>
    where
        T: CustomerNegativeCriterionService,
        B: HttpBody + Send + Sync + 'static,
        B::Error: Into<StdError> + Send + 'static,
    {
        type Response = http::Response<tonic::body::BoxBody>;
        type Error = Never;
        type Future = BoxFuture<Self::Response, Self::Error>;
        fn poll_ready(&mut self, _cx: &mut Context<'_>) -> Poll<Result<(), Self::Error>> {
            Poll::Ready(Ok(()))
        }
        fn call(&mut self, req: http::Request<B>) -> Self::Future {
            let inner = self.inner.clone();
            match req . uri ( ) . path ( ) { "/google.ads.googleads.v1.services.CustomerNegativeCriterionService/GetCustomerNegativeCriterion" => { # [ allow ( non_camel_case_types ) ] struct GetCustomerNegativeCriterionSvc < T : CustomerNegativeCriterionService > ( pub Arc < T > ) ; impl < T : CustomerNegativeCriterionService > tonic :: server :: UnaryService < super :: GetCustomerNegativeCriterionRequest > for GetCustomerNegativeCriterionSvc < T > { type Response = super :: super :: resources :: CustomerNegativeCriterion ; type Future = BoxFuture < tonic :: Response < Self :: Response > , tonic :: Status > ; fn call ( & mut self , request : tonic :: Request < super :: GetCustomerNegativeCriterionRequest > ) -> Self :: Future { let inner = self . 0 . clone ( ) ; let fut = async move { inner . get_customer_negative_criterion ( request ) . await } ; Box :: pin ( fut ) } } let inner = self . inner . clone ( ) ; let fut = async move { let interceptor = inner . 1 . clone ( ) ; let inner = inner . 0 ; let method = GetCustomerNegativeCriterionSvc ( inner ) ; let codec = tonic :: codec :: ProstCodec :: default ( ) ; let mut grpc = if let Some ( interceptor ) = interceptor { tonic :: server :: Grpc :: with_interceptor ( codec , interceptor ) } else { tonic :: server :: Grpc :: new ( codec ) } ; let res = grpc . unary ( method , req ) . await ; Ok ( res ) } ; Box :: pin ( fut ) } "/google.ads.googleads.v1.services.CustomerNegativeCriterionService/MutateCustomerNegativeCriteria" => { # [ allow ( non_camel_case_types ) ] struct MutateCustomerNegativeCriteriaSvc < T : CustomerNegativeCriterionService > ( pub Arc < T > ) ; impl < T : CustomerNegativeCriterionService > tonic :: server :: UnaryService < super :: MutateCustomerNegativeCriteriaRequest > for MutateCustomerNegativeCriteriaSvc < T > { type Response = super :: MutateCustomerNegativeCriteriaResponse ; type Future = BoxFuture < tonic :: Response < Self :: Response > , tonic :: Status > ; fn call ( & mut self , request : tonic :: Request < super :: MutateCustomerNegativeCriteriaRequest > ) -> Self :: Future { let inner = self . 0 . clone ( ) ; let fut = async move { inner . mutate_customer_negative_criteria ( request ) . await } ; Box :: pin ( fut ) } } let inner = self . inner . clone ( ) ; let fut = async move { let interceptor = inner . 1 . clone ( ) ; let inner = inner . 0 ; let method = MutateCustomerNegativeCriteriaSvc ( inner ) ; let codec = tonic :: codec :: ProstCodec :: default ( ) ; let mut grpc = if let Some ( interceptor ) = interceptor { tonic :: server :: Grpc :: with_interceptor ( codec , interceptor ) } else { tonic :: server :: Grpc :: new ( codec ) } ; let res = grpc . unary ( method , req ) . await ; Ok ( res ) } ; Box :: pin ( fut ) } _ => Box :: pin ( async move { Ok ( http :: Response :: builder ( ) . status ( 200 ) . header ( "grpc-status" , "12" ) . body ( tonic :: body :: BoxBody :: empty ( ) ) . unwrap ( ) ) } ) , }
        }
    }
    impl<T: CustomerNegativeCriterionService> Clone for CustomerNegativeCriterionServiceServer<T> {
        fn clone(&self) -> Self {
            let inner = self.inner.clone();
            Self { inner }
        }
    }
    impl<T: CustomerNegativeCriterionService> Clone for _Inner<T> {
        fn clone(&self) -> Self {
            Self(self.0.clone(), self.1.clone())
        }
    }
    impl<T: std::fmt::Debug> std::fmt::Debug for _Inner<T> {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
            write!(f, "{:?}", self.0)
        }
    }
    impl<T: CustomerNegativeCriterionService> tonic::transport::NamedService
        for CustomerNegativeCriterionServiceServer<T>
    {
        const NAME: &'static str =
            "google.ads.googleads.v1.services.CustomerNegativeCriterionService";
    }
}
/// Request message for [CustomerService.GetCustomer][google.ads.googleads.v1.services.CustomerService.GetCustomer].
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GetCustomerRequest {
    /// Required. The resource name of the customer to fetch.
    #[prost(string, tag = "1")]
    pub resource_name: std::string::String,
}
/// Request message for [CustomerService.MutateCustomer][google.ads.googleads.v1.services.CustomerService.MutateCustomer].
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct MutateCustomerRequest {
    /// Required. The ID of the customer being modified.
    #[prost(string, tag = "1")]
    pub customer_id: std::string::String,
    /// Required. The operation to perform on the customer
    #[prost(message, optional, tag = "4")]
    pub operation: ::std::option::Option<CustomerOperation>,
    /// If true, the request is validated but not executed. Only errors are
    /// returned, not results.
    #[prost(bool, tag = "5")]
    pub validate_only: bool,
}
/// Request message for [CustomerService.CreateCustomerClient][google.ads.googleads.v1.services.CustomerService.CreateCustomerClient].
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CreateCustomerClientRequest {
    /// Required. The ID of the Manager under whom client customer is being created.
    #[prost(string, tag = "1")]
    pub customer_id: std::string::String,
    /// Required. The new client customer to create. The resource name on this customer
    /// will be ignored.
    #[prost(message, optional, tag = "2")]
    pub customer_client: ::std::option::Option<super::resources::Customer>,
}
/// A single update on a customer.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CustomerOperation {
    /// Mutate operation. Only updates are supported for customer.
    #[prost(message, optional, tag = "1")]
    pub update: ::std::option::Option<super::resources::Customer>,
    /// FieldMask that determines which resource fields are modified in an update.
    #[prost(message, optional, tag = "2")]
    pub update_mask: ::std::option::Option<::prost_types::FieldMask>,
}
/// Response message for CreateCustomerClient mutate.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CreateCustomerClientResponse {
    /// The resource name of the newly created customer client.
    #[prost(string, tag = "2")]
    pub resource_name: std::string::String,
}
/// Response message for customer mutate.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct MutateCustomerResponse {
    /// Result for the mutate.
    #[prost(message, optional, tag = "2")]
    pub result: ::std::option::Option<MutateCustomerResult>,
}
/// The result for the customer mutate.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct MutateCustomerResult {
    /// Returned for successful operations.
    #[prost(string, tag = "1")]
    pub resource_name: std::string::String,
}
/// Request message for [CustomerService.ListAccessibleCustomers][google.ads.googleads.v1.services.CustomerService.ListAccessibleCustomers].
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ListAccessibleCustomersRequest {}
/// Response message for [CustomerService.ListAccessibleCustomers][google.ads.googleads.v1.services.CustomerService.ListAccessibleCustomers].
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ListAccessibleCustomersResponse {
    /// Resource name of customers directly accessible by the
    /// user authenticating the call.
    #[prost(string, repeated, tag = "1")]
    pub resource_names: ::std::vec::Vec<std::string::String>,
}
#[doc = r" Generated client implementations."]
pub mod customer_service_client {
    #![allow(unused_variables, dead_code, missing_docs)]
    use tonic::codegen::*;
    #[doc = " Service to manage customers."]
    pub struct CustomerServiceClient<T> {
        inner: tonic::client::Grpc<T>,
    }
    impl CustomerServiceClient<tonic::transport::Channel> {
        #[doc = r" Attempt to create a new client by connecting to a given endpoint."]
        pub async fn connect<D>(dst: D) -> Result<Self, tonic::transport::Error>
        where
            D: std::convert::TryInto<tonic::transport::Endpoint>,
            D::Error: Into<StdError>,
        {
            let conn = tonic::transport::Endpoint::new(dst)?.connect().await?;
            Ok(Self::new(conn))
        }
    }
    impl<T> CustomerServiceClient<T>
    where
        T: tonic::client::GrpcService<tonic::body::BoxBody>,
        T::ResponseBody: Body + HttpBody + Send + 'static,
        T::Error: Into<StdError>,
        <T::ResponseBody as HttpBody>::Error: Into<StdError> + Send,
    {
        pub fn new(inner: T) -> Self {
            let inner = tonic::client::Grpc::new(inner);
            Self { inner }
        }
        pub fn with_interceptor(inner: T, interceptor: impl Into<tonic::Interceptor>) -> Self {
            let inner = tonic::client::Grpc::with_interceptor(inner, interceptor);
            Self { inner }
        }
        #[doc = " Returns the requested customer in full detail."]
        pub async fn get_customer(
            &mut self,
            request: impl tonic::IntoRequest<super::GetCustomerRequest>,
        ) -> Result<tonic::Response<super::super::resources::Customer>, tonic::Status> {
            self.inner.ready().await.map_err(|e| {
                tonic::Status::new(
                    tonic::Code::Unknown,
                    format!("Service was not ready: {}", e.into()),
                )
            })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.ads.googleads.v1.services.CustomerService/GetCustomer",
            );
            self.inner.unary(request.into_request(), path, codec).await
        }
        #[doc = " Updates a customer. Operation statuses are returned."]
        pub async fn mutate_customer(
            &mut self,
            request: impl tonic::IntoRequest<super::MutateCustomerRequest>,
        ) -> Result<tonic::Response<super::MutateCustomerResponse>, tonic::Status> {
            self.inner.ready().await.map_err(|e| {
                tonic::Status::new(
                    tonic::Code::Unknown,
                    format!("Service was not ready: {}", e.into()),
                )
            })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.ads.googleads.v1.services.CustomerService/MutateCustomer",
            );
            self.inner.unary(request.into_request(), path, codec).await
        }
        #[doc = " Returns resource names of customers directly accessible by the"]
        #[doc = " user authenticating the call."]
        pub async fn list_accessible_customers(
            &mut self,
            request: impl tonic::IntoRequest<super::ListAccessibleCustomersRequest>,
        ) -> Result<tonic::Response<super::ListAccessibleCustomersResponse>, tonic::Status>
        {
            self.inner.ready().await.map_err(|e| {
                tonic::Status::new(
                    tonic::Code::Unknown,
                    format!("Service was not ready: {}", e.into()),
                )
            })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.ads.googleads.v1.services.CustomerService/ListAccessibleCustomers",
            );
            self.inner.unary(request.into_request(), path, codec).await
        }
        #[doc = " Creates a new client under manager. The new client customer is returned."]
        pub async fn create_customer_client(
            &mut self,
            request: impl tonic::IntoRequest<super::CreateCustomerClientRequest>,
        ) -> Result<tonic::Response<super::CreateCustomerClientResponse>, tonic::Status> {
            self.inner.ready().await.map_err(|e| {
                tonic::Status::new(
                    tonic::Code::Unknown,
                    format!("Service was not ready: {}", e.into()),
                )
            })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.ads.googleads.v1.services.CustomerService/CreateCustomerClient",
            );
            self.inner.unary(request.into_request(), path, codec).await
        }
    }
    impl<T: Clone> Clone for CustomerServiceClient<T> {
        fn clone(&self) -> Self {
            Self {
                inner: self.inner.clone(),
            }
        }
    }
    impl<T> std::fmt::Debug for CustomerServiceClient<T> {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
            write!(f, "CustomerServiceClient {{ ... }}")
        }
    }
}
#[doc = r" Generated server implementations."]
pub mod customer_service_server {
    #![allow(unused_variables, dead_code, missing_docs)]
    use tonic::codegen::*;
    #[doc = "Generated trait containing gRPC methods that should be implemented for use with CustomerServiceServer."]
    #[async_trait]
    pub trait CustomerService: Send + Sync + 'static {
        #[doc = " Returns the requested customer in full detail."]
        async fn get_customer(
            &self,
            request: tonic::Request<super::GetCustomerRequest>,
        ) -> Result<tonic::Response<super::super::resources::Customer>, tonic::Status>;
        #[doc = " Updates a customer. Operation statuses are returned."]
        async fn mutate_customer(
            &self,
            request: tonic::Request<super::MutateCustomerRequest>,
        ) -> Result<tonic::Response<super::MutateCustomerResponse>, tonic::Status>;
        #[doc = " Returns resource names of customers directly accessible by the"]
        #[doc = " user authenticating the call."]
        async fn list_accessible_customers(
            &self,
            request: tonic::Request<super::ListAccessibleCustomersRequest>,
        ) -> Result<tonic::Response<super::ListAccessibleCustomersResponse>, tonic::Status>;
        #[doc = " Creates a new client under manager. The new client customer is returned."]
        async fn create_customer_client(
            &self,
            request: tonic::Request<super::CreateCustomerClientRequest>,
        ) -> Result<tonic::Response<super::CreateCustomerClientResponse>, tonic::Status>;
    }
    #[doc = " Service to manage customers."]
    #[derive(Debug)]
    #[doc(hidden)]
    pub struct CustomerServiceServer<T: CustomerService> {
        inner: _Inner<T>,
    }
    struct _Inner<T>(Arc<T>, Option<tonic::Interceptor>);
    impl<T: CustomerService> CustomerServiceServer<T> {
        pub fn new(inner: T) -> Self {
            let inner = Arc::new(inner);
            let inner = _Inner(inner, None);
            Self { inner }
        }
        pub fn with_interceptor(inner: T, interceptor: impl Into<tonic::Interceptor>) -> Self {
            let inner = Arc::new(inner);
            let inner = _Inner(inner, Some(interceptor.into()));
            Self { inner }
        }
    }
    impl<T, B> Service<http::Request<B>> for CustomerServiceServer<T>
    where
        T: CustomerService,
        B: HttpBody + Send + Sync + 'static,
        B::Error: Into<StdError> + Send + 'static,
    {
        type Response = http::Response<tonic::body::BoxBody>;
        type Error = Never;
        type Future = BoxFuture<Self::Response, Self::Error>;
        fn poll_ready(&mut self, _cx: &mut Context<'_>) -> Poll<Result<(), Self::Error>> {
            Poll::Ready(Ok(()))
        }
        fn call(&mut self, req: http::Request<B>) -> Self::Future {
            let inner = self.inner.clone();
            match req.uri().path() {
                "/google.ads.googleads.v1.services.CustomerService/GetCustomer" => {
                    #[allow(non_camel_case_types)]
                    struct GetCustomerSvc<T: CustomerService>(pub Arc<T>);
                    impl<T: CustomerService> tonic::server::UnaryService<super::GetCustomerRequest>
                        for GetCustomerSvc<T>
                    {
                        type Response = super::super::resources::Customer;
                        type Future = BoxFuture<tonic::Response<Self::Response>, tonic::Status>;
                        fn call(
                            &mut self,
                            request: tonic::Request<super::GetCustomerRequest>,
                        ) -> Self::Future {
                            let inner = self.0.clone();
                            let fut = async move { inner.get_customer(request).await };
                            Box::pin(fut)
                        }
                    }
                    let inner = self.inner.clone();
                    let fut = async move {
                        let interceptor = inner.1.clone();
                        let inner = inner.0;
                        let method = GetCustomerSvc(inner);
                        let codec = tonic::codec::ProstCodec::default();
                        let mut grpc = if let Some(interceptor) = interceptor {
                            tonic::server::Grpc::with_interceptor(codec, interceptor)
                        } else {
                            tonic::server::Grpc::new(codec)
                        };
                        let res = grpc.unary(method, req).await;
                        Ok(res)
                    };
                    Box::pin(fut)
                }
                "/google.ads.googleads.v1.services.CustomerService/MutateCustomer" => {
                    #[allow(non_camel_case_types)]
                    struct MutateCustomerSvc<T: CustomerService>(pub Arc<T>);
                    impl<T: CustomerService>
                        tonic::server::UnaryService<super::MutateCustomerRequest>
                        for MutateCustomerSvc<T>
                    {
                        type Response = super::MutateCustomerResponse;
                        type Future = BoxFuture<tonic::Response<Self::Response>, tonic::Status>;
                        fn call(
                            &mut self,
                            request: tonic::Request<super::MutateCustomerRequest>,
                        ) -> Self::Future {
                            let inner = self.0.clone();
                            let fut = async move { inner.mutate_customer(request).await };
                            Box::pin(fut)
                        }
                    }
                    let inner = self.inner.clone();
                    let fut = async move {
                        let interceptor = inner.1.clone();
                        let inner = inner.0;
                        let method = MutateCustomerSvc(inner);
                        let codec = tonic::codec::ProstCodec::default();
                        let mut grpc = if let Some(interceptor) = interceptor {
                            tonic::server::Grpc::with_interceptor(codec, interceptor)
                        } else {
                            tonic::server::Grpc::new(codec)
                        };
                        let res = grpc.unary(method, req).await;
                        Ok(res)
                    };
                    Box::pin(fut)
                }
                "/google.ads.googleads.v1.services.CustomerService/ListAccessibleCustomers" => {
                    #[allow(non_camel_case_types)]
                    struct ListAccessibleCustomersSvc<T: CustomerService>(pub Arc<T>);
                    impl<T: CustomerService>
                        tonic::server::UnaryService<super::ListAccessibleCustomersRequest>
                        for ListAccessibleCustomersSvc<T>
                    {
                        type Response = super::ListAccessibleCustomersResponse;
                        type Future = BoxFuture<tonic::Response<Self::Response>, tonic::Status>;
                        fn call(
                            &mut self,
                            request: tonic::Request<super::ListAccessibleCustomersRequest>,
                        ) -> Self::Future {
                            let inner = self.0.clone();
                            let fut = async move { inner.list_accessible_customers(request).await };
                            Box::pin(fut)
                        }
                    }
                    let inner = self.inner.clone();
                    let fut = async move {
                        let interceptor = inner.1.clone();
                        let inner = inner.0;
                        let method = ListAccessibleCustomersSvc(inner);
                        let codec = tonic::codec::ProstCodec::default();
                        let mut grpc = if let Some(interceptor) = interceptor {
                            tonic::server::Grpc::with_interceptor(codec, interceptor)
                        } else {
                            tonic::server::Grpc::new(codec)
                        };
                        let res = grpc.unary(method, req).await;
                        Ok(res)
                    };
                    Box::pin(fut)
                }
                "/google.ads.googleads.v1.services.CustomerService/CreateCustomerClient" => {
                    #[allow(non_camel_case_types)]
                    struct CreateCustomerClientSvc<T: CustomerService>(pub Arc<T>);
                    impl<T: CustomerService>
                        tonic::server::UnaryService<super::CreateCustomerClientRequest>
                        for CreateCustomerClientSvc<T>
                    {
                        type Response = super::CreateCustomerClientResponse;
                        type Future = BoxFuture<tonic::Response<Self::Response>, tonic::Status>;
                        fn call(
                            &mut self,
                            request: tonic::Request<super::CreateCustomerClientRequest>,
                        ) -> Self::Future {
                            let inner = self.0.clone();
                            let fut = async move { inner.create_customer_client(request).await };
                            Box::pin(fut)
                        }
                    }
                    let inner = self.inner.clone();
                    let fut = async move {
                        let interceptor = inner.1.clone();
                        let inner = inner.0;
                        let method = CreateCustomerClientSvc(inner);
                        let codec = tonic::codec::ProstCodec::default();
                        let mut grpc = if let Some(interceptor) = interceptor {
                            tonic::server::Grpc::with_interceptor(codec, interceptor)
                        } else {
                            tonic::server::Grpc::new(codec)
                        };
                        let res = grpc.unary(method, req).await;
                        Ok(res)
                    };
                    Box::pin(fut)
                }
                _ => Box::pin(async move {
                    Ok(http::Response::builder()
                        .status(200)
                        .header("grpc-status", "12")
                        .body(tonic::body::BoxBody::empty())
                        .unwrap())
                }),
            }
        }
    }
    impl<T: CustomerService> Clone for CustomerServiceServer<T> {
        fn clone(&self) -> Self {
            let inner = self.inner.clone();
            Self { inner }
        }
    }
    impl<T: CustomerService> Clone for _Inner<T> {
        fn clone(&self) -> Self {
            Self(self.0.clone(), self.1.clone())
        }
    }
    impl<T: std::fmt::Debug> std::fmt::Debug for _Inner<T> {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
            write!(f, "{:?}", self.0)
        }
    }
    impl<T: CustomerService> tonic::transport::NamedService for CustomerServiceServer<T> {
        const NAME: &'static str = "google.ads.googleads.v1.services.CustomerService";
    }
}
/// Request message for [DetailPlacementViewService.GetDetailPlacementView][google.ads.googleads.v1.services.DetailPlacementViewService.GetDetailPlacementView].
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GetDetailPlacementViewRequest {
    /// Required. The resource name of the Detail Placement view to fetch.
    #[prost(string, tag = "1")]
    pub resource_name: std::string::String,
}
#[doc = r" Generated client implementations."]
pub mod detail_placement_view_service_client {
    #![allow(unused_variables, dead_code, missing_docs)]
    use tonic::codegen::*;
    #[doc = " Service to fetch Detail Placement views."]
    pub struct DetailPlacementViewServiceClient<T> {
        inner: tonic::client::Grpc<T>,
    }
    impl DetailPlacementViewServiceClient<tonic::transport::Channel> {
        #[doc = r" Attempt to create a new client by connecting to a given endpoint."]
        pub async fn connect<D>(dst: D) -> Result<Self, tonic::transport::Error>
        where
            D: std::convert::TryInto<tonic::transport::Endpoint>,
            D::Error: Into<StdError>,
        {
            let conn = tonic::transport::Endpoint::new(dst)?.connect().await?;
            Ok(Self::new(conn))
        }
    }
    impl<T> DetailPlacementViewServiceClient<T>
    where
        T: tonic::client::GrpcService<tonic::body::BoxBody>,
        T::ResponseBody: Body + HttpBody + Send + 'static,
        T::Error: Into<StdError>,
        <T::ResponseBody as HttpBody>::Error: Into<StdError> + Send,
    {
        pub fn new(inner: T) -> Self {
            let inner = tonic::client::Grpc::new(inner);
            Self { inner }
        }
        pub fn with_interceptor(inner: T, interceptor: impl Into<tonic::Interceptor>) -> Self {
            let inner = tonic::client::Grpc::with_interceptor(inner, interceptor);
            Self { inner }
        }
        #[doc = " Returns the requested Detail Placement view in full detail."]
        pub async fn get_detail_placement_view(
            &mut self,
            request: impl tonic::IntoRequest<super::GetDetailPlacementViewRequest>,
        ) -> Result<tonic::Response<super::super::resources::DetailPlacementView>, tonic::Status>
        {
            self.inner.ready().await.map_err(|e| {
                tonic::Status::new(
                    tonic::Code::Unknown,
                    format!("Service was not ready: {}", e.into()),
                )
            })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http :: uri :: PathAndQuery :: from_static ( "/google.ads.googleads.v1.services.DetailPlacementViewService/GetDetailPlacementView" ) ;
            self.inner.unary(request.into_request(), path, codec).await
        }
    }
    impl<T: Clone> Clone for DetailPlacementViewServiceClient<T> {
        fn clone(&self) -> Self {
            Self {
                inner: self.inner.clone(),
            }
        }
    }
    impl<T> std::fmt::Debug for DetailPlacementViewServiceClient<T> {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
            write!(f, "DetailPlacementViewServiceClient {{ ... }}")
        }
    }
}
#[doc = r" Generated server implementations."]
pub mod detail_placement_view_service_server {
    #![allow(unused_variables, dead_code, missing_docs)]
    use tonic::codegen::*;
    #[doc = "Generated trait containing gRPC methods that should be implemented for use with DetailPlacementViewServiceServer."]
    #[async_trait]
    pub trait DetailPlacementViewService: Send + Sync + 'static {
        #[doc = " Returns the requested Detail Placement view in full detail."]
        async fn get_detail_placement_view(
            &self,
            request: tonic::Request<super::GetDetailPlacementViewRequest>,
        ) -> Result<tonic::Response<super::super::resources::DetailPlacementView>, tonic::Status>;
    }
    #[doc = " Service to fetch Detail Placement views."]
    #[derive(Debug)]
    #[doc(hidden)]
    pub struct DetailPlacementViewServiceServer<T: DetailPlacementViewService> {
        inner: _Inner<T>,
    }
    struct _Inner<T>(Arc<T>, Option<tonic::Interceptor>);
    impl<T: DetailPlacementViewService> DetailPlacementViewServiceServer<T> {
        pub fn new(inner: T) -> Self {
            let inner = Arc::new(inner);
            let inner = _Inner(inner, None);
            Self { inner }
        }
        pub fn with_interceptor(inner: T, interceptor: impl Into<tonic::Interceptor>) -> Self {
            let inner = Arc::new(inner);
            let inner = _Inner(inner, Some(interceptor.into()));
            Self { inner }
        }
    }
    impl<T, B> Service<http::Request<B>> for DetailPlacementViewServiceServer<T>
    where
        T: DetailPlacementViewService,
        B: HttpBody + Send + Sync + 'static,
        B::Error: Into<StdError> + Send + 'static,
    {
        type Response = http::Response<tonic::body::BoxBody>;
        type Error = Never;
        type Future = BoxFuture<Self::Response, Self::Error>;
        fn poll_ready(&mut self, _cx: &mut Context<'_>) -> Poll<Result<(), Self::Error>> {
            Poll::Ready(Ok(()))
        }
        fn call(&mut self, req: http::Request<B>) -> Self::Future {
            let inner = self.inner.clone();
            match req . uri ( ) . path ( ) { "/google.ads.googleads.v1.services.DetailPlacementViewService/GetDetailPlacementView" => { # [ allow ( non_camel_case_types ) ] struct GetDetailPlacementViewSvc < T : DetailPlacementViewService > ( pub Arc < T > ) ; impl < T : DetailPlacementViewService > tonic :: server :: UnaryService < super :: GetDetailPlacementViewRequest > for GetDetailPlacementViewSvc < T > { type Response = super :: super :: resources :: DetailPlacementView ; type Future = BoxFuture < tonic :: Response < Self :: Response > , tonic :: Status > ; fn call ( & mut self , request : tonic :: Request < super :: GetDetailPlacementViewRequest > ) -> Self :: Future { let inner = self . 0 . clone ( ) ; let fut = async move { inner . get_detail_placement_view ( request ) . await } ; Box :: pin ( fut ) } } let inner = self . inner . clone ( ) ; let fut = async move { let interceptor = inner . 1 . clone ( ) ; let inner = inner . 0 ; let method = GetDetailPlacementViewSvc ( inner ) ; let codec = tonic :: codec :: ProstCodec :: default ( ) ; let mut grpc = if let Some ( interceptor ) = interceptor { tonic :: server :: Grpc :: with_interceptor ( codec , interceptor ) } else { tonic :: server :: Grpc :: new ( codec ) } ; let res = grpc . unary ( method , req ) . await ; Ok ( res ) } ; Box :: pin ( fut ) } _ => Box :: pin ( async move { Ok ( http :: Response :: builder ( ) . status ( 200 ) . header ( "grpc-status" , "12" ) . body ( tonic :: body :: BoxBody :: empty ( ) ) . unwrap ( ) ) } ) , }
        }
    }
    impl<T: DetailPlacementViewService> Clone for DetailPlacementViewServiceServer<T> {
        fn clone(&self) -> Self {
            let inner = self.inner.clone();
            Self { inner }
        }
    }
    impl<T: DetailPlacementViewService> Clone for _Inner<T> {
        fn clone(&self) -> Self {
            Self(self.0.clone(), self.1.clone())
        }
    }
    impl<T: std::fmt::Debug> std::fmt::Debug for _Inner<T> {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
            write!(f, "{:?}", self.0)
        }
    }
    impl<T: DetailPlacementViewService> tonic::transport::NamedService
        for DetailPlacementViewServiceServer<T>
    {
        const NAME: &'static str = "google.ads.googleads.v1.services.DetailPlacementViewService";
    }
}
/// Request message for [DisplayKeywordViewService.GetDisplayKeywordView][google.ads.googleads.v1.services.DisplayKeywordViewService.GetDisplayKeywordView].
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GetDisplayKeywordViewRequest {
    /// Required. The resource name of the display keyword view to fetch.
    #[prost(string, tag = "1")]
    pub resource_name: std::string::String,
}
#[doc = r" Generated client implementations."]
pub mod display_keyword_view_service_client {
    #![allow(unused_variables, dead_code, missing_docs)]
    use tonic::codegen::*;
    #[doc = " Service to manage display keyword views."]
    pub struct DisplayKeywordViewServiceClient<T> {
        inner: tonic::client::Grpc<T>,
    }
    impl DisplayKeywordViewServiceClient<tonic::transport::Channel> {
        #[doc = r" Attempt to create a new client by connecting to a given endpoint."]
        pub async fn connect<D>(dst: D) -> Result<Self, tonic::transport::Error>
        where
            D: std::convert::TryInto<tonic::transport::Endpoint>,
            D::Error: Into<StdError>,
        {
            let conn = tonic::transport::Endpoint::new(dst)?.connect().await?;
            Ok(Self::new(conn))
        }
    }
    impl<T> DisplayKeywordViewServiceClient<T>
    where
        T: tonic::client::GrpcService<tonic::body::BoxBody>,
        T::ResponseBody: Body + HttpBody + Send + 'static,
        T::Error: Into<StdError>,
        <T::ResponseBody as HttpBody>::Error: Into<StdError> + Send,
    {
        pub fn new(inner: T) -> Self {
            let inner = tonic::client::Grpc::new(inner);
            Self { inner }
        }
        pub fn with_interceptor(inner: T, interceptor: impl Into<tonic::Interceptor>) -> Self {
            let inner = tonic::client::Grpc::with_interceptor(inner, interceptor);
            Self { inner }
        }
        #[doc = " Returns the requested display keyword view in full detail."]
        pub async fn get_display_keyword_view(
            &mut self,
            request: impl tonic::IntoRequest<super::GetDisplayKeywordViewRequest>,
        ) -> Result<tonic::Response<super::super::resources::DisplayKeywordView>, tonic::Status>
        {
            self.inner.ready().await.map_err(|e| {
                tonic::Status::new(
                    tonic::Code::Unknown,
                    format!("Service was not ready: {}", e.into()),
                )
            })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.ads.googleads.v1.services.DisplayKeywordViewService/GetDisplayKeywordView",
            );
            self.inner.unary(request.into_request(), path, codec).await
        }
    }
    impl<T: Clone> Clone for DisplayKeywordViewServiceClient<T> {
        fn clone(&self) -> Self {
            Self {
                inner: self.inner.clone(),
            }
        }
    }
    impl<T> std::fmt::Debug for DisplayKeywordViewServiceClient<T> {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
            write!(f, "DisplayKeywordViewServiceClient {{ ... }}")
        }
    }
}
#[doc = r" Generated server implementations."]
pub mod display_keyword_view_service_server {
    #![allow(unused_variables, dead_code, missing_docs)]
    use tonic::codegen::*;
    #[doc = "Generated trait containing gRPC methods that should be implemented for use with DisplayKeywordViewServiceServer."]
    #[async_trait]
    pub trait DisplayKeywordViewService: Send + Sync + 'static {
        #[doc = " Returns the requested display keyword view in full detail."]
        async fn get_display_keyword_view(
            &self,
            request: tonic::Request<super::GetDisplayKeywordViewRequest>,
        ) -> Result<tonic::Response<super::super::resources::DisplayKeywordView>, tonic::Status>;
    }
    #[doc = " Service to manage display keyword views."]
    #[derive(Debug)]
    #[doc(hidden)]
    pub struct DisplayKeywordViewServiceServer<T: DisplayKeywordViewService> {
        inner: _Inner<T>,
    }
    struct _Inner<T>(Arc<T>, Option<tonic::Interceptor>);
    impl<T: DisplayKeywordViewService> DisplayKeywordViewServiceServer<T> {
        pub fn new(inner: T) -> Self {
            let inner = Arc::new(inner);
            let inner = _Inner(inner, None);
            Self { inner }
        }
        pub fn with_interceptor(inner: T, interceptor: impl Into<tonic::Interceptor>) -> Self {
            let inner = Arc::new(inner);
            let inner = _Inner(inner, Some(interceptor.into()));
            Self { inner }
        }
    }
    impl<T, B> Service<http::Request<B>> for DisplayKeywordViewServiceServer<T>
    where
        T: DisplayKeywordViewService,
        B: HttpBody + Send + Sync + 'static,
        B::Error: Into<StdError> + Send + 'static,
    {
        type Response = http::Response<tonic::body::BoxBody>;
        type Error = Never;
        type Future = BoxFuture<Self::Response, Self::Error>;
        fn poll_ready(&mut self, _cx: &mut Context<'_>) -> Poll<Result<(), Self::Error>> {
            Poll::Ready(Ok(()))
        }
        fn call(&mut self, req: http::Request<B>) -> Self::Future {
            let inner = self.inner.clone();
            match req . uri ( ) . path ( ) { "/google.ads.googleads.v1.services.DisplayKeywordViewService/GetDisplayKeywordView" => { # [ allow ( non_camel_case_types ) ] struct GetDisplayKeywordViewSvc < T : DisplayKeywordViewService > ( pub Arc < T > ) ; impl < T : DisplayKeywordViewService > tonic :: server :: UnaryService < super :: GetDisplayKeywordViewRequest > for GetDisplayKeywordViewSvc < T > { type Response = super :: super :: resources :: DisplayKeywordView ; type Future = BoxFuture < tonic :: Response < Self :: Response > , tonic :: Status > ; fn call ( & mut self , request : tonic :: Request < super :: GetDisplayKeywordViewRequest > ) -> Self :: Future { let inner = self . 0 . clone ( ) ; let fut = async move { inner . get_display_keyword_view ( request ) . await } ; Box :: pin ( fut ) } } let inner = self . inner . clone ( ) ; let fut = async move { let interceptor = inner . 1 . clone ( ) ; let inner = inner . 0 ; let method = GetDisplayKeywordViewSvc ( inner ) ; let codec = tonic :: codec :: ProstCodec :: default ( ) ; let mut grpc = if let Some ( interceptor ) = interceptor { tonic :: server :: Grpc :: with_interceptor ( codec , interceptor ) } else { tonic :: server :: Grpc :: new ( codec ) } ; let res = grpc . unary ( method , req ) . await ; Ok ( res ) } ; Box :: pin ( fut ) } _ => Box :: pin ( async move { Ok ( http :: Response :: builder ( ) . status ( 200 ) . header ( "grpc-status" , "12" ) . body ( tonic :: body :: BoxBody :: empty ( ) ) . unwrap ( ) ) } ) , }
        }
    }
    impl<T: DisplayKeywordViewService> Clone for DisplayKeywordViewServiceServer<T> {
        fn clone(&self) -> Self {
            let inner = self.inner.clone();
            Self { inner }
        }
    }
    impl<T: DisplayKeywordViewService> Clone for _Inner<T> {
        fn clone(&self) -> Self {
            Self(self.0.clone(), self.1.clone())
        }
    }
    impl<T: std::fmt::Debug> std::fmt::Debug for _Inner<T> {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
            write!(f, "{:?}", self.0)
        }
    }
    impl<T: DisplayKeywordViewService> tonic::transport::NamedService
        for DisplayKeywordViewServiceServer<T>
    {
        const NAME: &'static str = "google.ads.googleads.v1.services.DisplayKeywordViewService";
    }
}
/// Request message for
/// [DomainCategoryService.GetDomainCategory][google.ads.googleads.v1.services.DomainCategoryService.GetDomainCategory].
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GetDomainCategoryRequest {
    /// Required. Resource name of the domain category to fetch.
    #[prost(string, tag = "1")]
    pub resource_name: std::string::String,
}
#[doc = r" Generated client implementations."]
pub mod domain_category_service_client {
    #![allow(unused_variables, dead_code, missing_docs)]
    use tonic::codegen::*;
    #[doc = " Service to fetch domain categories."]
    pub struct DomainCategoryServiceClient<T> {
        inner: tonic::client::Grpc<T>,
    }
    impl DomainCategoryServiceClient<tonic::transport::Channel> {
        #[doc = r" Attempt to create a new client by connecting to a given endpoint."]
        pub async fn connect<D>(dst: D) -> Result<Self, tonic::transport::Error>
        where
            D: std::convert::TryInto<tonic::transport::Endpoint>,
            D::Error: Into<StdError>,
        {
            let conn = tonic::transport::Endpoint::new(dst)?.connect().await?;
            Ok(Self::new(conn))
        }
    }
    impl<T> DomainCategoryServiceClient<T>
    where
        T: tonic::client::GrpcService<tonic::body::BoxBody>,
        T::ResponseBody: Body + HttpBody + Send + 'static,
        T::Error: Into<StdError>,
        <T::ResponseBody as HttpBody>::Error: Into<StdError> + Send,
    {
        pub fn new(inner: T) -> Self {
            let inner = tonic::client::Grpc::new(inner);
            Self { inner }
        }
        pub fn with_interceptor(inner: T, interceptor: impl Into<tonic::Interceptor>) -> Self {
            let inner = tonic::client::Grpc::with_interceptor(inner, interceptor);
            Self { inner }
        }
        #[doc = " Returns the requested domain category."]
        pub async fn get_domain_category(
            &mut self,
            request: impl tonic::IntoRequest<super::GetDomainCategoryRequest>,
        ) -> Result<tonic::Response<super::super::resources::DomainCategory>, tonic::Status>
        {
            self.inner.ready().await.map_err(|e| {
                tonic::Status::new(
                    tonic::Code::Unknown,
                    format!("Service was not ready: {}", e.into()),
                )
            })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.ads.googleads.v1.services.DomainCategoryService/GetDomainCategory",
            );
            self.inner.unary(request.into_request(), path, codec).await
        }
    }
    impl<T: Clone> Clone for DomainCategoryServiceClient<T> {
        fn clone(&self) -> Self {
            Self {
                inner: self.inner.clone(),
            }
        }
    }
    impl<T> std::fmt::Debug for DomainCategoryServiceClient<T> {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
            write!(f, "DomainCategoryServiceClient {{ ... }}")
        }
    }
}
#[doc = r" Generated server implementations."]
pub mod domain_category_service_server {
    #![allow(unused_variables, dead_code, missing_docs)]
    use tonic::codegen::*;
    #[doc = "Generated trait containing gRPC methods that should be implemented for use with DomainCategoryServiceServer."]
    #[async_trait]
    pub trait DomainCategoryService: Send + Sync + 'static {
        #[doc = " Returns the requested domain category."]
        async fn get_domain_category(
            &self,
            request: tonic::Request<super::GetDomainCategoryRequest>,
        ) -> Result<tonic::Response<super::super::resources::DomainCategory>, tonic::Status>;
    }
    #[doc = " Service to fetch domain categories."]
    #[derive(Debug)]
    #[doc(hidden)]
    pub struct DomainCategoryServiceServer<T: DomainCategoryService> {
        inner: _Inner<T>,
    }
    struct _Inner<T>(Arc<T>, Option<tonic::Interceptor>);
    impl<T: DomainCategoryService> DomainCategoryServiceServer<T> {
        pub fn new(inner: T) -> Self {
            let inner = Arc::new(inner);
            let inner = _Inner(inner, None);
            Self { inner }
        }
        pub fn with_interceptor(inner: T, interceptor: impl Into<tonic::Interceptor>) -> Self {
            let inner = Arc::new(inner);
            let inner = _Inner(inner, Some(interceptor.into()));
            Self { inner }
        }
    }
    impl<T, B> Service<http::Request<B>> for DomainCategoryServiceServer<T>
    where
        T: DomainCategoryService,
        B: HttpBody + Send + Sync + 'static,
        B::Error: Into<StdError> + Send + 'static,
    {
        type Response = http::Response<tonic::body::BoxBody>;
        type Error = Never;
        type Future = BoxFuture<Self::Response, Self::Error>;
        fn poll_ready(&mut self, _cx: &mut Context<'_>) -> Poll<Result<(), Self::Error>> {
            Poll::Ready(Ok(()))
        }
        fn call(&mut self, req: http::Request<B>) -> Self::Future {
            let inner = self.inner.clone();
            match req.uri().path() {
                "/google.ads.googleads.v1.services.DomainCategoryService/GetDomainCategory" => {
                    #[allow(non_camel_case_types)]
                    struct GetDomainCategorySvc<T: DomainCategoryService>(pub Arc<T>);
                    impl<T: DomainCategoryService>
                        tonic::server::UnaryService<super::GetDomainCategoryRequest>
                        for GetDomainCategorySvc<T>
                    {
                        type Response = super::super::resources::DomainCategory;
                        type Future = BoxFuture<tonic::Response<Self::Response>, tonic::Status>;
                        fn call(
                            &mut self,
                            request: tonic::Request<super::GetDomainCategoryRequest>,
                        ) -> Self::Future {
                            let inner = self.0.clone();
                            let fut = async move { inner.get_domain_category(request).await };
                            Box::pin(fut)
                        }
                    }
                    let inner = self.inner.clone();
                    let fut = async move {
                        let interceptor = inner.1.clone();
                        let inner = inner.0;
                        let method = GetDomainCategorySvc(inner);
                        let codec = tonic::codec::ProstCodec::default();
                        let mut grpc = if let Some(interceptor) = interceptor {
                            tonic::server::Grpc::with_interceptor(codec, interceptor)
                        } else {
                            tonic::server::Grpc::new(codec)
                        };
                        let res = grpc.unary(method, req).await;
                        Ok(res)
                    };
                    Box::pin(fut)
                }
                _ => Box::pin(async move {
                    Ok(http::Response::builder()
                        .status(200)
                        .header("grpc-status", "12")
                        .body(tonic::body::BoxBody::empty())
                        .unwrap())
                }),
            }
        }
    }
    impl<T: DomainCategoryService> Clone for DomainCategoryServiceServer<T> {
        fn clone(&self) -> Self {
            let inner = self.inner.clone();
            Self { inner }
        }
    }
    impl<T: DomainCategoryService> Clone for _Inner<T> {
        fn clone(&self) -> Self {
            Self(self.0.clone(), self.1.clone())
        }
    }
    impl<T: std::fmt::Debug> std::fmt::Debug for _Inner<T> {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
            write!(f, "{:?}", self.0)
        }
    }
    impl<T: DomainCategoryService> tonic::transport::NamedService for DomainCategoryServiceServer<T> {
        const NAME: &'static str = "google.ads.googleads.v1.services.DomainCategoryService";
    }
}
/// Request message for
/// [DynamicSearchAdsSearchTermViewService.GetDynamicSearchAdsSearchTermView][google.ads.googleads.v1.services.DynamicSearchAdsSearchTermViewService.GetDynamicSearchAdsSearchTermView].
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GetDynamicSearchAdsSearchTermViewRequest {
    /// Required. The resource name of the dynamic search ads search term view to fetch.
    #[prost(string, tag = "1")]
    pub resource_name: std::string::String,
}
#[doc = r" Generated client implementations."]
pub mod dynamic_search_ads_search_term_view_service_client {
    #![allow(unused_variables, dead_code, missing_docs)]
    use tonic::codegen::*;
    #[doc = " Service to fetch dynamic search ads views."]
    pub struct DynamicSearchAdsSearchTermViewServiceClient<T> {
        inner: tonic::client::Grpc<T>,
    }
    impl DynamicSearchAdsSearchTermViewServiceClient<tonic::transport::Channel> {
        #[doc = r" Attempt to create a new client by connecting to a given endpoint."]
        pub async fn connect<D>(dst: D) -> Result<Self, tonic::transport::Error>
        where
            D: std::convert::TryInto<tonic::transport::Endpoint>,
            D::Error: Into<StdError>,
        {
            let conn = tonic::transport::Endpoint::new(dst)?.connect().await?;
            Ok(Self::new(conn))
        }
    }
    impl<T> DynamicSearchAdsSearchTermViewServiceClient<T>
    where
        T: tonic::client::GrpcService<tonic::body::BoxBody>,
        T::ResponseBody: Body + HttpBody + Send + 'static,
        T::Error: Into<StdError>,
        <T::ResponseBody as HttpBody>::Error: Into<StdError> + Send,
    {
        pub fn new(inner: T) -> Self {
            let inner = tonic::client::Grpc::new(inner);
            Self { inner }
        }
        pub fn with_interceptor(inner: T, interceptor: impl Into<tonic::Interceptor>) -> Self {
            let inner = tonic::client::Grpc::with_interceptor(inner, interceptor);
            Self { inner }
        }
        #[doc = " Returns the requested dynamic search ads search term view in full detail."]
        pub async fn get_dynamic_search_ads_search_term_view(
            &mut self,
            request: impl tonic::IntoRequest<super::GetDynamicSearchAdsSearchTermViewRequest>,
        ) -> Result<
            tonic::Response<super::super::resources::DynamicSearchAdsSearchTermView>,
            tonic::Status,
        > {
            self.inner.ready().await.map_err(|e| {
                tonic::Status::new(
                    tonic::Code::Unknown,
                    format!("Service was not ready: {}", e.into()),
                )
            })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http :: uri :: PathAndQuery :: from_static ( "/google.ads.googleads.v1.services.DynamicSearchAdsSearchTermViewService/GetDynamicSearchAdsSearchTermView" ) ;
            self.inner.unary(request.into_request(), path, codec).await
        }
    }
    impl<T: Clone> Clone for DynamicSearchAdsSearchTermViewServiceClient<T> {
        fn clone(&self) -> Self {
            Self {
                inner: self.inner.clone(),
            }
        }
    }
    impl<T> std::fmt::Debug for DynamicSearchAdsSearchTermViewServiceClient<T> {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
            write!(f, "DynamicSearchAdsSearchTermViewServiceClient {{ ... }}")
        }
    }
}
#[doc = r" Generated server implementations."]
pub mod dynamic_search_ads_search_term_view_service_server {
    #![allow(unused_variables, dead_code, missing_docs)]
    use tonic::codegen::*;
    #[doc = "Generated trait containing gRPC methods that should be implemented for use with DynamicSearchAdsSearchTermViewServiceServer."]
    #[async_trait]
    pub trait DynamicSearchAdsSearchTermViewService: Send + Sync + 'static {
        #[doc = " Returns the requested dynamic search ads search term view in full detail."]
        async fn get_dynamic_search_ads_search_term_view(
            &self,
            request: tonic::Request<super::GetDynamicSearchAdsSearchTermViewRequest>,
        ) -> Result<
            tonic::Response<super::super::resources::DynamicSearchAdsSearchTermView>,
            tonic::Status,
        >;
    }
    #[doc = " Service to fetch dynamic search ads views."]
    #[derive(Debug)]
    #[doc(hidden)]
    pub struct DynamicSearchAdsSearchTermViewServiceServer<T: DynamicSearchAdsSearchTermViewService> {
        inner: _Inner<T>,
    }
    struct _Inner<T>(Arc<T>, Option<tonic::Interceptor>);
    impl<T: DynamicSearchAdsSearchTermViewService> DynamicSearchAdsSearchTermViewServiceServer<T> {
        pub fn new(inner: T) -> Self {
            let inner = Arc::new(inner);
            let inner = _Inner(inner, None);
            Self { inner }
        }
        pub fn with_interceptor(inner: T, interceptor: impl Into<tonic::Interceptor>) -> Self {
            let inner = Arc::new(inner);
            let inner = _Inner(inner, Some(interceptor.into()));
            Self { inner }
        }
    }
    impl<T, B> Service<http::Request<B>> for DynamicSearchAdsSearchTermViewServiceServer<T>
    where
        T: DynamicSearchAdsSearchTermViewService,
        B: HttpBody + Send + Sync + 'static,
        B::Error: Into<StdError> + Send + 'static,
    {
        type Response = http::Response<tonic::body::BoxBody>;
        type Error = Never;
        type Future = BoxFuture<Self::Response, Self::Error>;
        fn poll_ready(&mut self, _cx: &mut Context<'_>) -> Poll<Result<(), Self::Error>> {
            Poll::Ready(Ok(()))
        }
        fn call(&mut self, req: http::Request<B>) -> Self::Future {
            let inner = self.inner.clone();
            match req . uri ( ) . path ( ) { "/google.ads.googleads.v1.services.DynamicSearchAdsSearchTermViewService/GetDynamicSearchAdsSearchTermView" => { # [ allow ( non_camel_case_types ) ] struct GetDynamicSearchAdsSearchTermViewSvc < T : DynamicSearchAdsSearchTermViewService > ( pub Arc < T > ) ; impl < T : DynamicSearchAdsSearchTermViewService > tonic :: server :: UnaryService < super :: GetDynamicSearchAdsSearchTermViewRequest > for GetDynamicSearchAdsSearchTermViewSvc < T > { type Response = super :: super :: resources :: DynamicSearchAdsSearchTermView ; type Future = BoxFuture < tonic :: Response < Self :: Response > , tonic :: Status > ; fn call ( & mut self , request : tonic :: Request < super :: GetDynamicSearchAdsSearchTermViewRequest > ) -> Self :: Future { let inner = self . 0 . clone ( ) ; let fut = async move { inner . get_dynamic_search_ads_search_term_view ( request ) . await } ; Box :: pin ( fut ) } } let inner = self . inner . clone ( ) ; let fut = async move { let interceptor = inner . 1 . clone ( ) ; let inner = inner . 0 ; let method = GetDynamicSearchAdsSearchTermViewSvc ( inner ) ; let codec = tonic :: codec :: ProstCodec :: default ( ) ; let mut grpc = if let Some ( interceptor ) = interceptor { tonic :: server :: Grpc :: with_interceptor ( codec , interceptor ) } else { tonic :: server :: Grpc :: new ( codec ) } ; let res = grpc . unary ( method , req ) . await ; Ok ( res ) } ; Box :: pin ( fut ) } _ => Box :: pin ( async move { Ok ( http :: Response :: builder ( ) . status ( 200 ) . header ( "grpc-status" , "12" ) . body ( tonic :: body :: BoxBody :: empty ( ) ) . unwrap ( ) ) } ) , }
        }
    }
    impl<T: DynamicSearchAdsSearchTermViewService> Clone
        for DynamicSearchAdsSearchTermViewServiceServer<T>
    {
        fn clone(&self) -> Self {
            let inner = self.inner.clone();
            Self { inner }
        }
    }
    impl<T: DynamicSearchAdsSearchTermViewService> Clone for _Inner<T> {
        fn clone(&self) -> Self {
            Self(self.0.clone(), self.1.clone())
        }
    }
    impl<T: std::fmt::Debug> std::fmt::Debug for _Inner<T> {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
            write!(f, "{:?}", self.0)
        }
    }
    impl<T: DynamicSearchAdsSearchTermViewService> tonic::transport::NamedService
        for DynamicSearchAdsSearchTermViewServiceServer<T>
    {
        const NAME: &'static str =
            "google.ads.googleads.v1.services.DynamicSearchAdsSearchTermViewService";
    }
}
/// Request message for
/// [ExpandedLandingPageViewService.GetExpandedLandingPageView][google.ads.googleads.v1.services.ExpandedLandingPageViewService.GetExpandedLandingPageView].
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GetExpandedLandingPageViewRequest {
    /// Required. The resource name of the expanded landing page view to fetch.
    #[prost(string, tag = "1")]
    pub resource_name: std::string::String,
}
#[doc = r" Generated client implementations."]
pub mod expanded_landing_page_view_service_client {
    #![allow(unused_variables, dead_code, missing_docs)]
    use tonic::codegen::*;
    #[doc = " Service to fetch expanded landing page views."]
    pub struct ExpandedLandingPageViewServiceClient<T> {
        inner: tonic::client::Grpc<T>,
    }
    impl ExpandedLandingPageViewServiceClient<tonic::transport::Channel> {
        #[doc = r" Attempt to create a new client by connecting to a given endpoint."]
        pub async fn connect<D>(dst: D) -> Result<Self, tonic::transport::Error>
        where
            D: std::convert::TryInto<tonic::transport::Endpoint>,
            D::Error: Into<StdError>,
        {
            let conn = tonic::transport::Endpoint::new(dst)?.connect().await?;
            Ok(Self::new(conn))
        }
    }
    impl<T> ExpandedLandingPageViewServiceClient<T>
    where
        T: tonic::client::GrpcService<tonic::body::BoxBody>,
        T::ResponseBody: Body + HttpBody + Send + 'static,
        T::Error: Into<StdError>,
        <T::ResponseBody as HttpBody>::Error: Into<StdError> + Send,
    {
        pub fn new(inner: T) -> Self {
            let inner = tonic::client::Grpc::new(inner);
            Self { inner }
        }
        pub fn with_interceptor(inner: T, interceptor: impl Into<tonic::Interceptor>) -> Self {
            let inner = tonic::client::Grpc::with_interceptor(inner, interceptor);
            Self { inner }
        }
        #[doc = " Returns the requested expanded landing page view in full detail."]
        pub async fn get_expanded_landing_page_view(
            &mut self,
            request: impl tonic::IntoRequest<super::GetExpandedLandingPageViewRequest>,
        ) -> Result<tonic::Response<super::super::resources::ExpandedLandingPageView>, tonic::Status>
        {
            self.inner.ready().await.map_err(|e| {
                tonic::Status::new(
                    tonic::Code::Unknown,
                    format!("Service was not ready: {}", e.into()),
                )
            })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http :: uri :: PathAndQuery :: from_static ( "/google.ads.googleads.v1.services.ExpandedLandingPageViewService/GetExpandedLandingPageView" ) ;
            self.inner.unary(request.into_request(), path, codec).await
        }
    }
    impl<T: Clone> Clone for ExpandedLandingPageViewServiceClient<T> {
        fn clone(&self) -> Self {
            Self {
                inner: self.inner.clone(),
            }
        }
    }
    impl<T> std::fmt::Debug for ExpandedLandingPageViewServiceClient<T> {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
            write!(f, "ExpandedLandingPageViewServiceClient {{ ... }}")
        }
    }
}
#[doc = r" Generated server implementations."]
pub mod expanded_landing_page_view_service_server {
    #![allow(unused_variables, dead_code, missing_docs)]
    use tonic::codegen::*;
    #[doc = "Generated trait containing gRPC methods that should be implemented for use with ExpandedLandingPageViewServiceServer."]
    #[async_trait]
    pub trait ExpandedLandingPageViewService: Send + Sync + 'static {
        #[doc = " Returns the requested expanded landing page view in full detail."]
        async fn get_expanded_landing_page_view(
            &self,
            request: tonic::Request<super::GetExpandedLandingPageViewRequest>,
        ) -> Result<tonic::Response<super::super::resources::ExpandedLandingPageView>, tonic::Status>;
    }
    #[doc = " Service to fetch expanded landing page views."]
    #[derive(Debug)]
    #[doc(hidden)]
    pub struct ExpandedLandingPageViewServiceServer<T: ExpandedLandingPageViewService> {
        inner: _Inner<T>,
    }
    struct _Inner<T>(Arc<T>, Option<tonic::Interceptor>);
    impl<T: ExpandedLandingPageViewService> ExpandedLandingPageViewServiceServer<T> {
        pub fn new(inner: T) -> Self {
            let inner = Arc::new(inner);
            let inner = _Inner(inner, None);
            Self { inner }
        }
        pub fn with_interceptor(inner: T, interceptor: impl Into<tonic::Interceptor>) -> Self {
            let inner = Arc::new(inner);
            let inner = _Inner(inner, Some(interceptor.into()));
            Self { inner }
        }
    }
    impl<T, B> Service<http::Request<B>> for ExpandedLandingPageViewServiceServer<T>
    where
        T: ExpandedLandingPageViewService,
        B: HttpBody + Send + Sync + 'static,
        B::Error: Into<StdError> + Send + 'static,
    {
        type Response = http::Response<tonic::body::BoxBody>;
        type Error = Never;
        type Future = BoxFuture<Self::Response, Self::Error>;
        fn poll_ready(&mut self, _cx: &mut Context<'_>) -> Poll<Result<(), Self::Error>> {
            Poll::Ready(Ok(()))
        }
        fn call(&mut self, req: http::Request<B>) -> Self::Future {
            let inner = self.inner.clone();
            match req . uri ( ) . path ( ) { "/google.ads.googleads.v1.services.ExpandedLandingPageViewService/GetExpandedLandingPageView" => { # [ allow ( non_camel_case_types ) ] struct GetExpandedLandingPageViewSvc < T : ExpandedLandingPageViewService > ( pub Arc < T > ) ; impl < T : ExpandedLandingPageViewService > tonic :: server :: UnaryService < super :: GetExpandedLandingPageViewRequest > for GetExpandedLandingPageViewSvc < T > { type Response = super :: super :: resources :: ExpandedLandingPageView ; type Future = BoxFuture < tonic :: Response < Self :: Response > , tonic :: Status > ; fn call ( & mut self , request : tonic :: Request < super :: GetExpandedLandingPageViewRequest > ) -> Self :: Future { let inner = self . 0 . clone ( ) ; let fut = async move { inner . get_expanded_landing_page_view ( request ) . await } ; Box :: pin ( fut ) } } let inner = self . inner . clone ( ) ; let fut = async move { let interceptor = inner . 1 . clone ( ) ; let inner = inner . 0 ; let method = GetExpandedLandingPageViewSvc ( inner ) ; let codec = tonic :: codec :: ProstCodec :: default ( ) ; let mut grpc = if let Some ( interceptor ) = interceptor { tonic :: server :: Grpc :: with_interceptor ( codec , interceptor ) } else { tonic :: server :: Grpc :: new ( codec ) } ; let res = grpc . unary ( method , req ) . await ; Ok ( res ) } ; Box :: pin ( fut ) } _ => Box :: pin ( async move { Ok ( http :: Response :: builder ( ) . status ( 200 ) . header ( "grpc-status" , "12" ) . body ( tonic :: body :: BoxBody :: empty ( ) ) . unwrap ( ) ) } ) , }
        }
    }
    impl<T: ExpandedLandingPageViewService> Clone for ExpandedLandingPageViewServiceServer<T> {
        fn clone(&self) -> Self {
            let inner = self.inner.clone();
            Self { inner }
        }
    }
    impl<T: ExpandedLandingPageViewService> Clone for _Inner<T> {
        fn clone(&self) -> Self {
            Self(self.0.clone(), self.1.clone())
        }
    }
    impl<T: std::fmt::Debug> std::fmt::Debug for _Inner<T> {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
            write!(f, "{:?}", self.0)
        }
    }
    impl<T: ExpandedLandingPageViewService> tonic::transport::NamedService
        for ExpandedLandingPageViewServiceServer<T>
    {
        const NAME: &'static str =
            "google.ads.googleads.v1.services.ExpandedLandingPageViewService";
    }
}
/// Request message for [ExtensionFeedItemService.GetExtensionFeedItem][google.ads.googleads.v1.services.ExtensionFeedItemService.GetExtensionFeedItem].
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GetExtensionFeedItemRequest {
    /// Required. The resource name of the extension feed item to fetch.
    #[prost(string, tag = "1")]
    pub resource_name: std::string::String,
}
/// Request message for [ExtensionFeedItemService.MutateExtensionFeedItems][google.ads.googleads.v1.services.ExtensionFeedItemService.MutateExtensionFeedItems].
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct MutateExtensionFeedItemsRequest {
    /// Required. The ID of the customer whose extension feed items are being
    /// modified.
    #[prost(string, tag = "1")]
    pub customer_id: std::string::String,
    /// Required. The list of operations to perform on individual extension feed items.
    #[prost(message, repeated, tag = "2")]
    pub operations: ::std::vec::Vec<ExtensionFeedItemOperation>,
    /// If true, the request is validated but not executed. Only errors are
    /// returned, not results.
    #[prost(bool, tag = "4")]
    pub validate_only: bool,
}
/// A single operation (create, update, remove) on an extension feed item.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ExtensionFeedItemOperation {
    /// FieldMask that determines which resource fields are modified in an update.
    #[prost(message, optional, tag = "4")]
    pub update_mask: ::std::option::Option<::prost_types::FieldMask>,
    /// The mutate operation.
    #[prost(oneof = "extension_feed_item_operation::Operation", tags = "1, 2, 3")]
    pub operation: ::std::option::Option<extension_feed_item_operation::Operation>,
}
pub mod extension_feed_item_operation {
    /// The mutate operation.
    #[derive(Clone, PartialEq, ::prost::Oneof)]
    pub enum Operation {
        /// Create operation: No resource name is expected for the new extension
        /// feed item.
        #[prost(message, tag = "1")]
        Create(super::super::resources::ExtensionFeedItem),
        /// Update operation: The extension feed item is expected to have a
        /// valid resource name.
        #[prost(message, tag = "2")]
        Update(super::super::resources::ExtensionFeedItem),
        /// Remove operation: A resource name for the removed extension feed item
        /// is expected, in this format:
        ///
        /// `customers/{customer_id}/extensionFeedItems/{feed_item_id}`
        #[prost(string, tag = "3")]
        Remove(std::string::String),
    }
}
/// Response message for an extension feed item mutate.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct MutateExtensionFeedItemsResponse {
    /// All results for the mutate.
    #[prost(message, repeated, tag = "2")]
    pub results: ::std::vec::Vec<MutateExtensionFeedItemResult>,
}
/// The result for the extension feed item mutate.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct MutateExtensionFeedItemResult {
    /// Returned for successful operations.
    #[prost(string, tag = "1")]
    pub resource_name: std::string::String,
}
#[doc = r" Generated client implementations."]
pub mod extension_feed_item_service_client {
    #![allow(unused_variables, dead_code, missing_docs)]
    use tonic::codegen::*;
    #[doc = " Service to manage extension feed items."]
    pub struct ExtensionFeedItemServiceClient<T> {
        inner: tonic::client::Grpc<T>,
    }
    impl ExtensionFeedItemServiceClient<tonic::transport::Channel> {
        #[doc = r" Attempt to create a new client by connecting to a given endpoint."]
        pub async fn connect<D>(dst: D) -> Result<Self, tonic::transport::Error>
        where
            D: std::convert::TryInto<tonic::transport::Endpoint>,
            D::Error: Into<StdError>,
        {
            let conn = tonic::transport::Endpoint::new(dst)?.connect().await?;
            Ok(Self::new(conn))
        }
    }
    impl<T> ExtensionFeedItemServiceClient<T>
    where
        T: tonic::client::GrpcService<tonic::body::BoxBody>,
        T::ResponseBody: Body + HttpBody + Send + 'static,
        T::Error: Into<StdError>,
        <T::ResponseBody as HttpBody>::Error: Into<StdError> + Send,
    {
        pub fn new(inner: T) -> Self {
            let inner = tonic::client::Grpc::new(inner);
            Self { inner }
        }
        pub fn with_interceptor(inner: T, interceptor: impl Into<tonic::Interceptor>) -> Self {
            let inner = tonic::client::Grpc::with_interceptor(inner, interceptor);
            Self { inner }
        }
        #[doc = " Returns the requested extension feed item in full detail."]
        pub async fn get_extension_feed_item(
            &mut self,
            request: impl tonic::IntoRequest<super::GetExtensionFeedItemRequest>,
        ) -> Result<tonic::Response<super::super::resources::ExtensionFeedItem>, tonic::Status>
        {
            self.inner.ready().await.map_err(|e| {
                tonic::Status::new(
                    tonic::Code::Unknown,
                    format!("Service was not ready: {}", e.into()),
                )
            })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.ads.googleads.v1.services.ExtensionFeedItemService/GetExtensionFeedItem",
            );
            self.inner.unary(request.into_request(), path, codec).await
        }
        #[doc = " Creates, updates, or removes extension feed items. Operation"]
        #[doc = " statuses are returned."]
        pub async fn mutate_extension_feed_items(
            &mut self,
            request: impl tonic::IntoRequest<super::MutateExtensionFeedItemsRequest>,
        ) -> Result<tonic::Response<super::MutateExtensionFeedItemsResponse>, tonic::Status>
        {
            self.inner.ready().await.map_err(|e| {
                tonic::Status::new(
                    tonic::Code::Unknown,
                    format!("Service was not ready: {}", e.into()),
                )
            })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http :: uri :: PathAndQuery :: from_static ( "/google.ads.googleads.v1.services.ExtensionFeedItemService/MutateExtensionFeedItems" ) ;
            self.inner.unary(request.into_request(), path, codec).await
        }
    }
    impl<T: Clone> Clone for ExtensionFeedItemServiceClient<T> {
        fn clone(&self) -> Self {
            Self {
                inner: self.inner.clone(),
            }
        }
    }
    impl<T> std::fmt::Debug for ExtensionFeedItemServiceClient<T> {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
            write!(f, "ExtensionFeedItemServiceClient {{ ... }}")
        }
    }
}
#[doc = r" Generated server implementations."]
pub mod extension_feed_item_service_server {
    #![allow(unused_variables, dead_code, missing_docs)]
    use tonic::codegen::*;
    #[doc = "Generated trait containing gRPC methods that should be implemented for use with ExtensionFeedItemServiceServer."]
    #[async_trait]
    pub trait ExtensionFeedItemService: Send + Sync + 'static {
        #[doc = " Returns the requested extension feed item in full detail."]
        async fn get_extension_feed_item(
            &self,
            request: tonic::Request<super::GetExtensionFeedItemRequest>,
        ) -> Result<tonic::Response<super::super::resources::ExtensionFeedItem>, tonic::Status>;
        #[doc = " Creates, updates, or removes extension feed items. Operation"]
        #[doc = " statuses are returned."]
        async fn mutate_extension_feed_items(
            &self,
            request: tonic::Request<super::MutateExtensionFeedItemsRequest>,
        ) -> Result<tonic::Response<super::MutateExtensionFeedItemsResponse>, tonic::Status>;
    }
    #[doc = " Service to manage extension feed items."]
    #[derive(Debug)]
    #[doc(hidden)]
    pub struct ExtensionFeedItemServiceServer<T: ExtensionFeedItemService> {
        inner: _Inner<T>,
    }
    struct _Inner<T>(Arc<T>, Option<tonic::Interceptor>);
    impl<T: ExtensionFeedItemService> ExtensionFeedItemServiceServer<T> {
        pub fn new(inner: T) -> Self {
            let inner = Arc::new(inner);
            let inner = _Inner(inner, None);
            Self { inner }
        }
        pub fn with_interceptor(inner: T, interceptor: impl Into<tonic::Interceptor>) -> Self {
            let inner = Arc::new(inner);
            let inner = _Inner(inner, Some(interceptor.into()));
            Self { inner }
        }
    }
    impl<T, B> Service<http::Request<B>> for ExtensionFeedItemServiceServer<T>
    where
        T: ExtensionFeedItemService,
        B: HttpBody + Send + Sync + 'static,
        B::Error: Into<StdError> + Send + 'static,
    {
        type Response = http::Response<tonic::body::BoxBody>;
        type Error = Never;
        type Future = BoxFuture<Self::Response, Self::Error>;
        fn poll_ready(&mut self, _cx: &mut Context<'_>) -> Poll<Result<(), Self::Error>> {
            Poll::Ready(Ok(()))
        }
        fn call(&mut self, req: http::Request<B>) -> Self::Future {
            let inner = self.inner.clone();
            match req . uri ( ) . path ( ) { "/google.ads.googleads.v1.services.ExtensionFeedItemService/GetExtensionFeedItem" => { # [ allow ( non_camel_case_types ) ] struct GetExtensionFeedItemSvc < T : ExtensionFeedItemService > ( pub Arc < T > ) ; impl < T : ExtensionFeedItemService > tonic :: server :: UnaryService < super :: GetExtensionFeedItemRequest > for GetExtensionFeedItemSvc < T > { type Response = super :: super :: resources :: ExtensionFeedItem ; type Future = BoxFuture < tonic :: Response < Self :: Response > , tonic :: Status > ; fn call ( & mut self , request : tonic :: Request < super :: GetExtensionFeedItemRequest > ) -> Self :: Future { let inner = self . 0 . clone ( ) ; let fut = async move { inner . get_extension_feed_item ( request ) . await } ; Box :: pin ( fut ) } } let inner = self . inner . clone ( ) ; let fut = async move { let interceptor = inner . 1 . clone ( ) ; let inner = inner . 0 ; let method = GetExtensionFeedItemSvc ( inner ) ; let codec = tonic :: codec :: ProstCodec :: default ( ) ; let mut grpc = if let Some ( interceptor ) = interceptor { tonic :: server :: Grpc :: with_interceptor ( codec , interceptor ) } else { tonic :: server :: Grpc :: new ( codec ) } ; let res = grpc . unary ( method , req ) . await ; Ok ( res ) } ; Box :: pin ( fut ) } "/google.ads.googleads.v1.services.ExtensionFeedItemService/MutateExtensionFeedItems" => { # [ allow ( non_camel_case_types ) ] struct MutateExtensionFeedItemsSvc < T : ExtensionFeedItemService > ( pub Arc < T > ) ; impl < T : ExtensionFeedItemService > tonic :: server :: UnaryService < super :: MutateExtensionFeedItemsRequest > for MutateExtensionFeedItemsSvc < T > { type Response = super :: MutateExtensionFeedItemsResponse ; type Future = BoxFuture < tonic :: Response < Self :: Response > , tonic :: Status > ; fn call ( & mut self , request : tonic :: Request < super :: MutateExtensionFeedItemsRequest > ) -> Self :: Future { let inner = self . 0 . clone ( ) ; let fut = async move { inner . mutate_extension_feed_items ( request ) . await } ; Box :: pin ( fut ) } } let inner = self . inner . clone ( ) ; let fut = async move { let interceptor = inner . 1 . clone ( ) ; let inner = inner . 0 ; let method = MutateExtensionFeedItemsSvc ( inner ) ; let codec = tonic :: codec :: ProstCodec :: default ( ) ; let mut grpc = if let Some ( interceptor ) = interceptor { tonic :: server :: Grpc :: with_interceptor ( codec , interceptor ) } else { tonic :: server :: Grpc :: new ( codec ) } ; let res = grpc . unary ( method , req ) . await ; Ok ( res ) } ; Box :: pin ( fut ) } _ => Box :: pin ( async move { Ok ( http :: Response :: builder ( ) . status ( 200 ) . header ( "grpc-status" , "12" ) . body ( tonic :: body :: BoxBody :: empty ( ) ) . unwrap ( ) ) } ) , }
        }
    }
    impl<T: ExtensionFeedItemService> Clone for ExtensionFeedItemServiceServer<T> {
        fn clone(&self) -> Self {
            let inner = self.inner.clone();
            Self { inner }
        }
    }
    impl<T: ExtensionFeedItemService> Clone for _Inner<T> {
        fn clone(&self) -> Self {
            Self(self.0.clone(), self.1.clone())
        }
    }
    impl<T: std::fmt::Debug> std::fmt::Debug for _Inner<T> {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
            write!(f, "{:?}", self.0)
        }
    }
    impl<T: ExtensionFeedItemService> tonic::transport::NamedService
        for ExtensionFeedItemServiceServer<T>
    {
        const NAME: &'static str = "google.ads.googleads.v1.services.ExtensionFeedItemService";
    }
}
/// Request message for [FeedItemService.GetFeedItem][google.ads.googleads.v1.services.FeedItemService.GetFeedItem].
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GetFeedItemRequest {
    /// Required. The resource name of the feed item to fetch.
    #[prost(string, tag = "1")]
    pub resource_name: std::string::String,
}
/// Request message for [FeedItemService.MutateFeedItems][google.ads.googleads.v1.services.FeedItemService.MutateFeedItems].
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct MutateFeedItemsRequest {
    /// Required. The ID of the customer whose feed items are being modified.
    #[prost(string, tag = "1")]
    pub customer_id: std::string::String,
    /// Required. The list of operations to perform on individual feed items.
    #[prost(message, repeated, tag = "2")]
    pub operations: ::std::vec::Vec<FeedItemOperation>,
    /// If true, successful operations will be carried out and invalid
    /// operations will return errors. If false, all operations will be carried
    /// out in one transaction if and only if they are all valid.
    /// Default is false.
    #[prost(bool, tag = "3")]
    pub partial_failure: bool,
    /// If true, the request is validated but not executed. Only errors are
    /// returned, not results.
    #[prost(bool, tag = "4")]
    pub validate_only: bool,
}
/// A single operation (create, update, remove) on an feed item.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct FeedItemOperation {
    /// FieldMask that determines which resource fields are modified in an update.
    #[prost(message, optional, tag = "4")]
    pub update_mask: ::std::option::Option<::prost_types::FieldMask>,
    /// The mutate operation.
    #[prost(oneof = "feed_item_operation::Operation", tags = "1, 2, 3")]
    pub operation: ::std::option::Option<feed_item_operation::Operation>,
}
pub mod feed_item_operation {
    /// The mutate operation.
    #[derive(Clone, PartialEq, ::prost::Oneof)]
    pub enum Operation {
        /// Create operation: No resource name is expected for the new feed item.
        #[prost(message, tag = "1")]
        Create(super::super::resources::FeedItem),
        /// Update operation: The feed item is expected to have a valid resource
        /// name.
        #[prost(message, tag = "2")]
        Update(super::super::resources::FeedItem),
        /// Remove operation: A resource name for the removed feed item is
        /// expected, in this format:
        ///
        /// `customers/{customer_id}/feedItems/{feed_id}~{feed_item_id}`
        #[prost(string, tag = "3")]
        Remove(std::string::String),
    }
}
/// Response message for an feed item mutate.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct MutateFeedItemsResponse {
    /// Errors that pertain to operation failures in the partial failure mode.
    /// Returned only when partial_failure = true and all errors occur inside the
    /// operations. If any errors occur outside the operations (e.g. auth errors),
    /// we return an RPC level error.
    #[prost(message, optional, tag = "3")]
    pub partial_failure_error: ::std::option::Option<super::super::super::super::rpc::Status>,
    /// All results for the mutate.
    #[prost(message, repeated, tag = "2")]
    pub results: ::std::vec::Vec<MutateFeedItemResult>,
}
/// The result for the feed item mutate.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct MutateFeedItemResult {
    /// Returned for successful operations.
    #[prost(string, tag = "1")]
    pub resource_name: std::string::String,
}
#[doc = r" Generated client implementations."]
pub mod feed_item_service_client {
    #![allow(unused_variables, dead_code, missing_docs)]
    use tonic::codegen::*;
    #[doc = " Service to manage feed items."]
    pub struct FeedItemServiceClient<T> {
        inner: tonic::client::Grpc<T>,
    }
    impl FeedItemServiceClient<tonic::transport::Channel> {
        #[doc = r" Attempt to create a new client by connecting to a given endpoint."]
        pub async fn connect<D>(dst: D) -> Result<Self, tonic::transport::Error>
        where
            D: std::convert::TryInto<tonic::transport::Endpoint>,
            D::Error: Into<StdError>,
        {
            let conn = tonic::transport::Endpoint::new(dst)?.connect().await?;
            Ok(Self::new(conn))
        }
    }
    impl<T> FeedItemServiceClient<T>
    where
        T: tonic::client::GrpcService<tonic::body::BoxBody>,
        T::ResponseBody: Body + HttpBody + Send + 'static,
        T::Error: Into<StdError>,
        <T::ResponseBody as HttpBody>::Error: Into<StdError> + Send,
    {
        pub fn new(inner: T) -> Self {
            let inner = tonic::client::Grpc::new(inner);
            Self { inner }
        }
        pub fn with_interceptor(inner: T, interceptor: impl Into<tonic::Interceptor>) -> Self {
            let inner = tonic::client::Grpc::with_interceptor(inner, interceptor);
            Self { inner }
        }
        #[doc = " Returns the requested feed item in full detail."]
        pub async fn get_feed_item(
            &mut self,
            request: impl tonic::IntoRequest<super::GetFeedItemRequest>,
        ) -> Result<tonic::Response<super::super::resources::FeedItem>, tonic::Status> {
            self.inner.ready().await.map_err(|e| {
                tonic::Status::new(
                    tonic::Code::Unknown,
                    format!("Service was not ready: {}", e.into()),
                )
            })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.ads.googleads.v1.services.FeedItemService/GetFeedItem",
            );
            self.inner.unary(request.into_request(), path, codec).await
        }
        #[doc = " Creates, updates, or removes feed items. Operation statuses are"]
        #[doc = " returned."]
        pub async fn mutate_feed_items(
            &mut self,
            request: impl tonic::IntoRequest<super::MutateFeedItemsRequest>,
        ) -> Result<tonic::Response<super::MutateFeedItemsResponse>, tonic::Status> {
            self.inner.ready().await.map_err(|e| {
                tonic::Status::new(
                    tonic::Code::Unknown,
                    format!("Service was not ready: {}", e.into()),
                )
            })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.ads.googleads.v1.services.FeedItemService/MutateFeedItems",
            );
            self.inner.unary(request.into_request(), path, codec).await
        }
    }
    impl<T: Clone> Clone for FeedItemServiceClient<T> {
        fn clone(&self) -> Self {
            Self {
                inner: self.inner.clone(),
            }
        }
    }
    impl<T> std::fmt::Debug for FeedItemServiceClient<T> {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
            write!(f, "FeedItemServiceClient {{ ... }}")
        }
    }
}
#[doc = r" Generated server implementations."]
pub mod feed_item_service_server {
    #![allow(unused_variables, dead_code, missing_docs)]
    use tonic::codegen::*;
    #[doc = "Generated trait containing gRPC methods that should be implemented for use with FeedItemServiceServer."]
    #[async_trait]
    pub trait FeedItemService: Send + Sync + 'static {
        #[doc = " Returns the requested feed item in full detail."]
        async fn get_feed_item(
            &self,
            request: tonic::Request<super::GetFeedItemRequest>,
        ) -> Result<tonic::Response<super::super::resources::FeedItem>, tonic::Status>;
        #[doc = " Creates, updates, or removes feed items. Operation statuses are"]
        #[doc = " returned."]
        async fn mutate_feed_items(
            &self,
            request: tonic::Request<super::MutateFeedItemsRequest>,
        ) -> Result<tonic::Response<super::MutateFeedItemsResponse>, tonic::Status>;
    }
    #[doc = " Service to manage feed items."]
    #[derive(Debug)]
    #[doc(hidden)]
    pub struct FeedItemServiceServer<T: FeedItemService> {
        inner: _Inner<T>,
    }
    struct _Inner<T>(Arc<T>, Option<tonic::Interceptor>);
    impl<T: FeedItemService> FeedItemServiceServer<T> {
        pub fn new(inner: T) -> Self {
            let inner = Arc::new(inner);
            let inner = _Inner(inner, None);
            Self { inner }
        }
        pub fn with_interceptor(inner: T, interceptor: impl Into<tonic::Interceptor>) -> Self {
            let inner = Arc::new(inner);
            let inner = _Inner(inner, Some(interceptor.into()));
            Self { inner }
        }
    }
    impl<T, B> Service<http::Request<B>> for FeedItemServiceServer<T>
    where
        T: FeedItemService,
        B: HttpBody + Send + Sync + 'static,
        B::Error: Into<StdError> + Send + 'static,
    {
        type Response = http::Response<tonic::body::BoxBody>;
        type Error = Never;
        type Future = BoxFuture<Self::Response, Self::Error>;
        fn poll_ready(&mut self, _cx: &mut Context<'_>) -> Poll<Result<(), Self::Error>> {
            Poll::Ready(Ok(()))
        }
        fn call(&mut self, req: http::Request<B>) -> Self::Future {
            let inner = self.inner.clone();
            match req.uri().path() {
                "/google.ads.googleads.v1.services.FeedItemService/GetFeedItem" => {
                    #[allow(non_camel_case_types)]
                    struct GetFeedItemSvc<T: FeedItemService>(pub Arc<T>);
                    impl<T: FeedItemService> tonic::server::UnaryService<super::GetFeedItemRequest>
                        for GetFeedItemSvc<T>
                    {
                        type Response = super::super::resources::FeedItem;
                        type Future = BoxFuture<tonic::Response<Self::Response>, tonic::Status>;
                        fn call(
                            &mut self,
                            request: tonic::Request<super::GetFeedItemRequest>,
                        ) -> Self::Future {
                            let inner = self.0.clone();
                            let fut = async move { inner.get_feed_item(request).await };
                            Box::pin(fut)
                        }
                    }
                    let inner = self.inner.clone();
                    let fut = async move {
                        let interceptor = inner.1.clone();
                        let inner = inner.0;
                        let method = GetFeedItemSvc(inner);
                        let codec = tonic::codec::ProstCodec::default();
                        let mut grpc = if let Some(interceptor) = interceptor {
                            tonic::server::Grpc::with_interceptor(codec, interceptor)
                        } else {
                            tonic::server::Grpc::new(codec)
                        };
                        let res = grpc.unary(method, req).await;
                        Ok(res)
                    };
                    Box::pin(fut)
                }
                "/google.ads.googleads.v1.services.FeedItemService/MutateFeedItems" => {
                    #[allow(non_camel_case_types)]
                    struct MutateFeedItemsSvc<T: FeedItemService>(pub Arc<T>);
                    impl<T: FeedItemService>
                        tonic::server::UnaryService<super::MutateFeedItemsRequest>
                        for MutateFeedItemsSvc<T>
                    {
                        type Response = super::MutateFeedItemsResponse;
                        type Future = BoxFuture<tonic::Response<Self::Response>, tonic::Status>;
                        fn call(
                            &mut self,
                            request: tonic::Request<super::MutateFeedItemsRequest>,
                        ) -> Self::Future {
                            let inner = self.0.clone();
                            let fut = async move { inner.mutate_feed_items(request).await };
                            Box::pin(fut)
                        }
                    }
                    let inner = self.inner.clone();
                    let fut = async move {
                        let interceptor = inner.1.clone();
                        let inner = inner.0;
                        let method = MutateFeedItemsSvc(inner);
                        let codec = tonic::codec::ProstCodec::default();
                        let mut grpc = if let Some(interceptor) = interceptor {
                            tonic::server::Grpc::with_interceptor(codec, interceptor)
                        } else {
                            tonic::server::Grpc::new(codec)
                        };
                        let res = grpc.unary(method, req).await;
                        Ok(res)
                    };
                    Box::pin(fut)
                }
                _ => Box::pin(async move {
                    Ok(http::Response::builder()
                        .status(200)
                        .header("grpc-status", "12")
                        .body(tonic::body::BoxBody::empty())
                        .unwrap())
                }),
            }
        }
    }
    impl<T: FeedItemService> Clone for FeedItemServiceServer<T> {
        fn clone(&self) -> Self {
            let inner = self.inner.clone();
            Self { inner }
        }
    }
    impl<T: FeedItemService> Clone for _Inner<T> {
        fn clone(&self) -> Self {
            Self(self.0.clone(), self.1.clone())
        }
    }
    impl<T: std::fmt::Debug> std::fmt::Debug for _Inner<T> {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
            write!(f, "{:?}", self.0)
        }
    }
    impl<T: FeedItemService> tonic::transport::NamedService for FeedItemServiceServer<T> {
        const NAME: &'static str = "google.ads.googleads.v1.services.FeedItemService";
    }
}
/// Request message for [FeedItemTargetService.GetFeedItemTarget][google.ads.googleads.v1.services.FeedItemTargetService.GetFeedItemTarget].
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GetFeedItemTargetRequest {
    /// Required. The resource name of the feed item targets to fetch.
    #[prost(string, tag = "1")]
    pub resource_name: std::string::String,
}
/// Request message for [FeedItemTargetService.MutateFeedItemTargets][google.ads.googleads.v1.services.FeedItemTargetService.MutateFeedItemTargets].
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct MutateFeedItemTargetsRequest {
    /// Required. The ID of the customer whose feed item targets are being modified.
    #[prost(string, tag = "1")]
    pub customer_id: std::string::String,
    /// Required. The list of operations to perform on individual feed item targets.
    #[prost(message, repeated, tag = "2")]
    pub operations: ::std::vec::Vec<FeedItemTargetOperation>,
}
/// A single operation (create, remove) on an feed item target.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct FeedItemTargetOperation {
    /// The mutate operation.
    #[prost(oneof = "feed_item_target_operation::Operation", tags = "1, 2")]
    pub operation: ::std::option::Option<feed_item_target_operation::Operation>,
}
pub mod feed_item_target_operation {
    /// The mutate operation.
    #[derive(Clone, PartialEq, ::prost::Oneof)]
    pub enum Operation {
        /// Create operation: No resource name is expected for the new feed item
        /// target.
        #[prost(message, tag = "1")]
        Create(super::super::resources::FeedItemTarget),
        /// Remove operation: A resource name for the removed feed item target is
        /// expected, in this format:
        ///
        /// `customers/{customer_id}/feedItemTargets/{feed_id}~{feed_item_id}~{feed_item_target_type}~{feed_item_target_id}`
        #[prost(string, tag = "2")]
        Remove(std::string::String),
    }
}
/// Response message for an feed item target mutate.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct MutateFeedItemTargetsResponse {
    /// All results for the mutate.
    #[prost(message, repeated, tag = "2")]
    pub results: ::std::vec::Vec<MutateFeedItemTargetResult>,
}
/// The result for the feed item target mutate.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct MutateFeedItemTargetResult {
    /// Returned for successful operations.
    #[prost(string, tag = "1")]
    pub resource_name: std::string::String,
}
#[doc = r" Generated client implementations."]
pub mod feed_item_target_service_client {
    #![allow(unused_variables, dead_code, missing_docs)]
    use tonic::codegen::*;
    #[doc = " Service to manage feed item targets."]
    pub struct FeedItemTargetServiceClient<T> {
        inner: tonic::client::Grpc<T>,
    }
    impl FeedItemTargetServiceClient<tonic::transport::Channel> {
        #[doc = r" Attempt to create a new client by connecting to a given endpoint."]
        pub async fn connect<D>(dst: D) -> Result<Self, tonic::transport::Error>
        where
            D: std::convert::TryInto<tonic::transport::Endpoint>,
            D::Error: Into<StdError>,
        {
            let conn = tonic::transport::Endpoint::new(dst)?.connect().await?;
            Ok(Self::new(conn))
        }
    }
    impl<T> FeedItemTargetServiceClient<T>
    where
        T: tonic::client::GrpcService<tonic::body::BoxBody>,
        T::ResponseBody: Body + HttpBody + Send + 'static,
        T::Error: Into<StdError>,
        <T::ResponseBody as HttpBody>::Error: Into<StdError> + Send,
    {
        pub fn new(inner: T) -> Self {
            let inner = tonic::client::Grpc::new(inner);
            Self { inner }
        }
        pub fn with_interceptor(inner: T, interceptor: impl Into<tonic::Interceptor>) -> Self {
            let inner = tonic::client::Grpc::with_interceptor(inner, interceptor);
            Self { inner }
        }
        #[doc = " Returns the requested feed item targets in full detail."]
        pub async fn get_feed_item_target(
            &mut self,
            request: impl tonic::IntoRequest<super::GetFeedItemTargetRequest>,
        ) -> Result<tonic::Response<super::super::resources::FeedItemTarget>, tonic::Status>
        {
            self.inner.ready().await.map_err(|e| {
                tonic::Status::new(
                    tonic::Code::Unknown,
                    format!("Service was not ready: {}", e.into()),
                )
            })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.ads.googleads.v1.services.FeedItemTargetService/GetFeedItemTarget",
            );
            self.inner.unary(request.into_request(), path, codec).await
        }
        #[doc = " Creates or removes feed item targets. Operation statuses are returned."]
        pub async fn mutate_feed_item_targets(
            &mut self,
            request: impl tonic::IntoRequest<super::MutateFeedItemTargetsRequest>,
        ) -> Result<tonic::Response<super::MutateFeedItemTargetsResponse>, tonic::Status> {
            self.inner.ready().await.map_err(|e| {
                tonic::Status::new(
                    tonic::Code::Unknown,
                    format!("Service was not ready: {}", e.into()),
                )
            })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.ads.googleads.v1.services.FeedItemTargetService/MutateFeedItemTargets",
            );
            self.inner.unary(request.into_request(), path, codec).await
        }
    }
    impl<T: Clone> Clone for FeedItemTargetServiceClient<T> {
        fn clone(&self) -> Self {
            Self {
                inner: self.inner.clone(),
            }
        }
    }
    impl<T> std::fmt::Debug for FeedItemTargetServiceClient<T> {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
            write!(f, "FeedItemTargetServiceClient {{ ... }}")
        }
    }
}
#[doc = r" Generated server implementations."]
pub mod feed_item_target_service_server {
    #![allow(unused_variables, dead_code, missing_docs)]
    use tonic::codegen::*;
    #[doc = "Generated trait containing gRPC methods that should be implemented for use with FeedItemTargetServiceServer."]
    #[async_trait]
    pub trait FeedItemTargetService: Send + Sync + 'static {
        #[doc = " Returns the requested feed item targets in full detail."]
        async fn get_feed_item_target(
            &self,
            request: tonic::Request<super::GetFeedItemTargetRequest>,
        ) -> Result<tonic::Response<super::super::resources::FeedItemTarget>, tonic::Status>;
        #[doc = " Creates or removes feed item targets. Operation statuses are returned."]
        async fn mutate_feed_item_targets(
            &self,
            request: tonic::Request<super::MutateFeedItemTargetsRequest>,
        ) -> Result<tonic::Response<super::MutateFeedItemTargetsResponse>, tonic::Status>;
    }
    #[doc = " Service to manage feed item targets."]
    #[derive(Debug)]
    #[doc(hidden)]
    pub struct FeedItemTargetServiceServer<T: FeedItemTargetService> {
        inner: _Inner<T>,
    }
    struct _Inner<T>(Arc<T>, Option<tonic::Interceptor>);
    impl<T: FeedItemTargetService> FeedItemTargetServiceServer<T> {
        pub fn new(inner: T) -> Self {
            let inner = Arc::new(inner);
            let inner = _Inner(inner, None);
            Self { inner }
        }
        pub fn with_interceptor(inner: T, interceptor: impl Into<tonic::Interceptor>) -> Self {
            let inner = Arc::new(inner);
            let inner = _Inner(inner, Some(interceptor.into()));
            Self { inner }
        }
    }
    impl<T, B> Service<http::Request<B>> for FeedItemTargetServiceServer<T>
    where
        T: FeedItemTargetService,
        B: HttpBody + Send + Sync + 'static,
        B::Error: Into<StdError> + Send + 'static,
    {
        type Response = http::Response<tonic::body::BoxBody>;
        type Error = Never;
        type Future = BoxFuture<Self::Response, Self::Error>;
        fn poll_ready(&mut self, _cx: &mut Context<'_>) -> Poll<Result<(), Self::Error>> {
            Poll::Ready(Ok(()))
        }
        fn call(&mut self, req: http::Request<B>) -> Self::Future {
            let inner = self.inner.clone();
            match req.uri().path() {
                "/google.ads.googleads.v1.services.FeedItemTargetService/GetFeedItemTarget" => {
                    #[allow(non_camel_case_types)]
                    struct GetFeedItemTargetSvc<T: FeedItemTargetService>(pub Arc<T>);
                    impl<T: FeedItemTargetService>
                        tonic::server::UnaryService<super::GetFeedItemTargetRequest>
                        for GetFeedItemTargetSvc<T>
                    {
                        type Response = super::super::resources::FeedItemTarget;
                        type Future = BoxFuture<tonic::Response<Self::Response>, tonic::Status>;
                        fn call(
                            &mut self,
                            request: tonic::Request<super::GetFeedItemTargetRequest>,
                        ) -> Self::Future {
                            let inner = self.0.clone();
                            let fut = async move { inner.get_feed_item_target(request).await };
                            Box::pin(fut)
                        }
                    }
                    let inner = self.inner.clone();
                    let fut = async move {
                        let interceptor = inner.1.clone();
                        let inner = inner.0;
                        let method = GetFeedItemTargetSvc(inner);
                        let codec = tonic::codec::ProstCodec::default();
                        let mut grpc = if let Some(interceptor) = interceptor {
                            tonic::server::Grpc::with_interceptor(codec, interceptor)
                        } else {
                            tonic::server::Grpc::new(codec)
                        };
                        let res = grpc.unary(method, req).await;
                        Ok(res)
                    };
                    Box::pin(fut)
                }
                "/google.ads.googleads.v1.services.FeedItemTargetService/MutateFeedItemTargets" => {
                    #[allow(non_camel_case_types)]
                    struct MutateFeedItemTargetsSvc<T: FeedItemTargetService>(pub Arc<T>);
                    impl<T: FeedItemTargetService>
                        tonic::server::UnaryService<super::MutateFeedItemTargetsRequest>
                        for MutateFeedItemTargetsSvc<T>
                    {
                        type Response = super::MutateFeedItemTargetsResponse;
                        type Future = BoxFuture<tonic::Response<Self::Response>, tonic::Status>;
                        fn call(
                            &mut self,
                            request: tonic::Request<super::MutateFeedItemTargetsRequest>,
                        ) -> Self::Future {
                            let inner = self.0.clone();
                            let fut = async move { inner.mutate_feed_item_targets(request).await };
                            Box::pin(fut)
                        }
                    }
                    let inner = self.inner.clone();
                    let fut = async move {
                        let interceptor = inner.1.clone();
                        let inner = inner.0;
                        let method = MutateFeedItemTargetsSvc(inner);
                        let codec = tonic::codec::ProstCodec::default();
                        let mut grpc = if let Some(interceptor) = interceptor {
                            tonic::server::Grpc::with_interceptor(codec, interceptor)
                        } else {
                            tonic::server::Grpc::new(codec)
                        };
                        let res = grpc.unary(method, req).await;
                        Ok(res)
                    };
                    Box::pin(fut)
                }
                _ => Box::pin(async move {
                    Ok(http::Response::builder()
                        .status(200)
                        .header("grpc-status", "12")
                        .body(tonic::body::BoxBody::empty())
                        .unwrap())
                }),
            }
        }
    }
    impl<T: FeedItemTargetService> Clone for FeedItemTargetServiceServer<T> {
        fn clone(&self) -> Self {
            let inner = self.inner.clone();
            Self { inner }
        }
    }
    impl<T: FeedItemTargetService> Clone for _Inner<T> {
        fn clone(&self) -> Self {
            Self(self.0.clone(), self.1.clone())
        }
    }
    impl<T: std::fmt::Debug> std::fmt::Debug for _Inner<T> {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
            write!(f, "{:?}", self.0)
        }
    }
    impl<T: FeedItemTargetService> tonic::transport::NamedService for FeedItemTargetServiceServer<T> {
        const NAME: &'static str = "google.ads.googleads.v1.services.FeedItemTargetService";
    }
}
/// Request message for [FeedMappingService.GetFeedMapping][google.ads.googleads.v1.services.FeedMappingService.GetFeedMapping].
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GetFeedMappingRequest {
    /// Required. The resource name of the feed mapping to fetch.
    #[prost(string, tag = "1")]
    pub resource_name: std::string::String,
}
/// Request message for [FeedMappingService.MutateFeedMappings][google.ads.googleads.v1.services.FeedMappingService.MutateFeedMappings].
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct MutateFeedMappingsRequest {
    /// Required. The ID of the customer whose feed mappings are being modified.
    #[prost(string, tag = "1")]
    pub customer_id: std::string::String,
    /// Required. The list of operations to perform on individual feed mappings.
    #[prost(message, repeated, tag = "2")]
    pub operations: ::std::vec::Vec<FeedMappingOperation>,
    /// If true, successful operations will be carried out and invalid
    /// operations will return errors. If false, all operations will be carried
    /// out in one transaction if and only if they are all valid.
    /// Default is false.
    #[prost(bool, tag = "3")]
    pub partial_failure: bool,
    /// If true, the request is validated but not executed. Only errors are
    /// returned, not results.
    #[prost(bool, tag = "4")]
    pub validate_only: bool,
}
/// A single operation (create, remove) on a feed mapping.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct FeedMappingOperation {
    /// The mutate operation.
    #[prost(oneof = "feed_mapping_operation::Operation", tags = "1, 3")]
    pub operation: ::std::option::Option<feed_mapping_operation::Operation>,
}
pub mod feed_mapping_operation {
    /// The mutate operation.
    #[derive(Clone, PartialEq, ::prost::Oneof)]
    pub enum Operation {
        /// Create operation: No resource name is expected for the new feed mapping.
        #[prost(message, tag = "1")]
        Create(super::super::resources::FeedMapping),
        /// Remove operation: A resource name for the removed feed mapping is
        /// expected, in this format:
        ///
        /// `customers/{customer_id}/feedMappings/{feed_id}~{feed_mapping_id}`
        #[prost(string, tag = "3")]
        Remove(std::string::String),
    }
}
/// Response message for a feed mapping mutate.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct MutateFeedMappingsResponse {
    /// Errors that pertain to operation failures in the partial failure mode.
    /// Returned only when partial_failure = true and all errors occur inside the
    /// operations. If any errors occur outside the operations (e.g. auth errors),
    /// we return an RPC level error.
    #[prost(message, optional, tag = "3")]
    pub partial_failure_error: ::std::option::Option<super::super::super::super::rpc::Status>,
    /// All results for the mutate.
    #[prost(message, repeated, tag = "2")]
    pub results: ::std::vec::Vec<MutateFeedMappingResult>,
}
/// The result for the feed mapping mutate.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct MutateFeedMappingResult {
    /// Returned for successful operations.
    #[prost(string, tag = "1")]
    pub resource_name: std::string::String,
}
#[doc = r" Generated client implementations."]
pub mod feed_mapping_service_client {
    #![allow(unused_variables, dead_code, missing_docs)]
    use tonic::codegen::*;
    #[doc = " Service to manage feed mappings."]
    pub struct FeedMappingServiceClient<T> {
        inner: tonic::client::Grpc<T>,
    }
    impl FeedMappingServiceClient<tonic::transport::Channel> {
        #[doc = r" Attempt to create a new client by connecting to a given endpoint."]
        pub async fn connect<D>(dst: D) -> Result<Self, tonic::transport::Error>
        where
            D: std::convert::TryInto<tonic::transport::Endpoint>,
            D::Error: Into<StdError>,
        {
            let conn = tonic::transport::Endpoint::new(dst)?.connect().await?;
            Ok(Self::new(conn))
        }
    }
    impl<T> FeedMappingServiceClient<T>
    where
        T: tonic::client::GrpcService<tonic::body::BoxBody>,
        T::ResponseBody: Body + HttpBody + Send + 'static,
        T::Error: Into<StdError>,
        <T::ResponseBody as HttpBody>::Error: Into<StdError> + Send,
    {
        pub fn new(inner: T) -> Self {
            let inner = tonic::client::Grpc::new(inner);
            Self { inner }
        }
        pub fn with_interceptor(inner: T, interceptor: impl Into<tonic::Interceptor>) -> Self {
            let inner = tonic::client::Grpc::with_interceptor(inner, interceptor);
            Self { inner }
        }
        #[doc = " Returns the requested feed mapping in full detail."]
        pub async fn get_feed_mapping(
            &mut self,
            request: impl tonic::IntoRequest<super::GetFeedMappingRequest>,
        ) -> Result<tonic::Response<super::super::resources::FeedMapping>, tonic::Status> {
            self.inner.ready().await.map_err(|e| {
                tonic::Status::new(
                    tonic::Code::Unknown,
                    format!("Service was not ready: {}", e.into()),
                )
            })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.ads.googleads.v1.services.FeedMappingService/GetFeedMapping",
            );
            self.inner.unary(request.into_request(), path, codec).await
        }
        #[doc = " Creates or removes feed mappings. Operation statuses are"]
        #[doc = " returned."]
        pub async fn mutate_feed_mappings(
            &mut self,
            request: impl tonic::IntoRequest<super::MutateFeedMappingsRequest>,
        ) -> Result<tonic::Response<super::MutateFeedMappingsResponse>, tonic::Status> {
            self.inner.ready().await.map_err(|e| {
                tonic::Status::new(
                    tonic::Code::Unknown,
                    format!("Service was not ready: {}", e.into()),
                )
            })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.ads.googleads.v1.services.FeedMappingService/MutateFeedMappings",
            );
            self.inner.unary(request.into_request(), path, codec).await
        }
    }
    impl<T: Clone> Clone for FeedMappingServiceClient<T> {
        fn clone(&self) -> Self {
            Self {
                inner: self.inner.clone(),
            }
        }
    }
    impl<T> std::fmt::Debug for FeedMappingServiceClient<T> {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
            write!(f, "FeedMappingServiceClient {{ ... }}")
        }
    }
}
#[doc = r" Generated server implementations."]
pub mod feed_mapping_service_server {
    #![allow(unused_variables, dead_code, missing_docs)]
    use tonic::codegen::*;
    #[doc = "Generated trait containing gRPC methods that should be implemented for use with FeedMappingServiceServer."]
    #[async_trait]
    pub trait FeedMappingService: Send + Sync + 'static {
        #[doc = " Returns the requested feed mapping in full detail."]
        async fn get_feed_mapping(
            &self,
            request: tonic::Request<super::GetFeedMappingRequest>,
        ) -> Result<tonic::Response<super::super::resources::FeedMapping>, tonic::Status>;
        #[doc = " Creates or removes feed mappings. Operation statuses are"]
        #[doc = " returned."]
        async fn mutate_feed_mappings(
            &self,
            request: tonic::Request<super::MutateFeedMappingsRequest>,
        ) -> Result<tonic::Response<super::MutateFeedMappingsResponse>, tonic::Status>;
    }
    #[doc = " Service to manage feed mappings."]
    #[derive(Debug)]
    #[doc(hidden)]
    pub struct FeedMappingServiceServer<T: FeedMappingService> {
        inner: _Inner<T>,
    }
    struct _Inner<T>(Arc<T>, Option<tonic::Interceptor>);
    impl<T: FeedMappingService> FeedMappingServiceServer<T> {
        pub fn new(inner: T) -> Self {
            let inner = Arc::new(inner);
            let inner = _Inner(inner, None);
            Self { inner }
        }
        pub fn with_interceptor(inner: T, interceptor: impl Into<tonic::Interceptor>) -> Self {
            let inner = Arc::new(inner);
            let inner = _Inner(inner, Some(interceptor.into()));
            Self { inner }
        }
    }
    impl<T, B> Service<http::Request<B>> for FeedMappingServiceServer<T>
    where
        T: FeedMappingService,
        B: HttpBody + Send + Sync + 'static,
        B::Error: Into<StdError> + Send + 'static,
    {
        type Response = http::Response<tonic::body::BoxBody>;
        type Error = Never;
        type Future = BoxFuture<Self::Response, Self::Error>;
        fn poll_ready(&mut self, _cx: &mut Context<'_>) -> Poll<Result<(), Self::Error>> {
            Poll::Ready(Ok(()))
        }
        fn call(&mut self, req: http::Request<B>) -> Self::Future {
            let inner = self.inner.clone();
            match req.uri().path() {
                "/google.ads.googleads.v1.services.FeedMappingService/GetFeedMapping" => {
                    #[allow(non_camel_case_types)]
                    struct GetFeedMappingSvc<T: FeedMappingService>(pub Arc<T>);
                    impl<T: FeedMappingService>
                        tonic::server::UnaryService<super::GetFeedMappingRequest>
                        for GetFeedMappingSvc<T>
                    {
                        type Response = super::super::resources::FeedMapping;
                        type Future = BoxFuture<tonic::Response<Self::Response>, tonic::Status>;
                        fn call(
                            &mut self,
                            request: tonic::Request<super::GetFeedMappingRequest>,
                        ) -> Self::Future {
                            let inner = self.0.clone();
                            let fut = async move { inner.get_feed_mapping(request).await };
                            Box::pin(fut)
                        }
                    }
                    let inner = self.inner.clone();
                    let fut = async move {
                        let interceptor = inner.1.clone();
                        let inner = inner.0;
                        let method = GetFeedMappingSvc(inner);
                        let codec = tonic::codec::ProstCodec::default();
                        let mut grpc = if let Some(interceptor) = interceptor {
                            tonic::server::Grpc::with_interceptor(codec, interceptor)
                        } else {
                            tonic::server::Grpc::new(codec)
                        };
                        let res = grpc.unary(method, req).await;
                        Ok(res)
                    };
                    Box::pin(fut)
                }
                "/google.ads.googleads.v1.services.FeedMappingService/MutateFeedMappings" => {
                    #[allow(non_camel_case_types)]
                    struct MutateFeedMappingsSvc<T: FeedMappingService>(pub Arc<T>);
                    impl<T: FeedMappingService>
                        tonic::server::UnaryService<super::MutateFeedMappingsRequest>
                        for MutateFeedMappingsSvc<T>
                    {
                        type Response = super::MutateFeedMappingsResponse;
                        type Future = BoxFuture<tonic::Response<Self::Response>, tonic::Status>;
                        fn call(
                            &mut self,
                            request: tonic::Request<super::MutateFeedMappingsRequest>,
                        ) -> Self::Future {
                            let inner = self.0.clone();
                            let fut = async move { inner.mutate_feed_mappings(request).await };
                            Box::pin(fut)
                        }
                    }
                    let inner = self.inner.clone();
                    let fut = async move {
                        let interceptor = inner.1.clone();
                        let inner = inner.0;
                        let method = MutateFeedMappingsSvc(inner);
                        let codec = tonic::codec::ProstCodec::default();
                        let mut grpc = if let Some(interceptor) = interceptor {
                            tonic::server::Grpc::with_interceptor(codec, interceptor)
                        } else {
                            tonic::server::Grpc::new(codec)
                        };
                        let res = grpc.unary(method, req).await;
                        Ok(res)
                    };
                    Box::pin(fut)
                }
                _ => Box::pin(async move {
                    Ok(http::Response::builder()
                        .status(200)
                        .header("grpc-status", "12")
                        .body(tonic::body::BoxBody::empty())
                        .unwrap())
                }),
            }
        }
    }
    impl<T: FeedMappingService> Clone for FeedMappingServiceServer<T> {
        fn clone(&self) -> Self {
            let inner = self.inner.clone();
            Self { inner }
        }
    }
    impl<T: FeedMappingService> Clone for _Inner<T> {
        fn clone(&self) -> Self {
            Self(self.0.clone(), self.1.clone())
        }
    }
    impl<T: std::fmt::Debug> std::fmt::Debug for _Inner<T> {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
            write!(f, "{:?}", self.0)
        }
    }
    impl<T: FeedMappingService> tonic::transport::NamedService for FeedMappingServiceServer<T> {
        const NAME: &'static str = "google.ads.googleads.v1.services.FeedMappingService";
    }
}
/// Request message for [FeedPlaceholderViewService.GetFeedPlaceholderView][google.ads.googleads.v1.services.FeedPlaceholderViewService.GetFeedPlaceholderView].
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GetFeedPlaceholderViewRequest {
    /// Required. The resource name of the feed placeholder view to fetch.
    #[prost(string, tag = "1")]
    pub resource_name: std::string::String,
}
#[doc = r" Generated client implementations."]
pub mod feed_placeholder_view_service_client {
    #![allow(unused_variables, dead_code, missing_docs)]
    use tonic::codegen::*;
    #[doc = " Service to fetch feed placeholder views."]
    pub struct FeedPlaceholderViewServiceClient<T> {
        inner: tonic::client::Grpc<T>,
    }
    impl FeedPlaceholderViewServiceClient<tonic::transport::Channel> {
        #[doc = r" Attempt to create a new client by connecting to a given endpoint."]
        pub async fn connect<D>(dst: D) -> Result<Self, tonic::transport::Error>
        where
            D: std::convert::TryInto<tonic::transport::Endpoint>,
            D::Error: Into<StdError>,
        {
            let conn = tonic::transport::Endpoint::new(dst)?.connect().await?;
            Ok(Self::new(conn))
        }
    }
    impl<T> FeedPlaceholderViewServiceClient<T>
    where
        T: tonic::client::GrpcService<tonic::body::BoxBody>,
        T::ResponseBody: Body + HttpBody + Send + 'static,
        T::Error: Into<StdError>,
        <T::ResponseBody as HttpBody>::Error: Into<StdError> + Send,
    {
        pub fn new(inner: T) -> Self {
            let inner = tonic::client::Grpc::new(inner);
            Self { inner }
        }
        pub fn with_interceptor(inner: T, interceptor: impl Into<tonic::Interceptor>) -> Self {
            let inner = tonic::client::Grpc::with_interceptor(inner, interceptor);
            Self { inner }
        }
        #[doc = " Returns the requested feed placeholder view in full detail."]
        pub async fn get_feed_placeholder_view(
            &mut self,
            request: impl tonic::IntoRequest<super::GetFeedPlaceholderViewRequest>,
        ) -> Result<tonic::Response<super::super::resources::FeedPlaceholderView>, tonic::Status>
        {
            self.inner.ready().await.map_err(|e| {
                tonic::Status::new(
                    tonic::Code::Unknown,
                    format!("Service was not ready: {}", e.into()),
                )
            })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http :: uri :: PathAndQuery :: from_static ( "/google.ads.googleads.v1.services.FeedPlaceholderViewService/GetFeedPlaceholderView" ) ;
            self.inner.unary(request.into_request(), path, codec).await
        }
    }
    impl<T: Clone> Clone for FeedPlaceholderViewServiceClient<T> {
        fn clone(&self) -> Self {
            Self {
                inner: self.inner.clone(),
            }
        }
    }
    impl<T> std::fmt::Debug for FeedPlaceholderViewServiceClient<T> {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
            write!(f, "FeedPlaceholderViewServiceClient {{ ... }}")
        }
    }
}
#[doc = r" Generated server implementations."]
pub mod feed_placeholder_view_service_server {
    #![allow(unused_variables, dead_code, missing_docs)]
    use tonic::codegen::*;
    #[doc = "Generated trait containing gRPC methods that should be implemented for use with FeedPlaceholderViewServiceServer."]
    #[async_trait]
    pub trait FeedPlaceholderViewService: Send + Sync + 'static {
        #[doc = " Returns the requested feed placeholder view in full detail."]
        async fn get_feed_placeholder_view(
            &self,
            request: tonic::Request<super::GetFeedPlaceholderViewRequest>,
        ) -> Result<tonic::Response<super::super::resources::FeedPlaceholderView>, tonic::Status>;
    }
    #[doc = " Service to fetch feed placeholder views."]
    #[derive(Debug)]
    #[doc(hidden)]
    pub struct FeedPlaceholderViewServiceServer<T: FeedPlaceholderViewService> {
        inner: _Inner<T>,
    }
    struct _Inner<T>(Arc<T>, Option<tonic::Interceptor>);
    impl<T: FeedPlaceholderViewService> FeedPlaceholderViewServiceServer<T> {
        pub fn new(inner: T) -> Self {
            let inner = Arc::new(inner);
            let inner = _Inner(inner, None);
            Self { inner }
        }
        pub fn with_interceptor(inner: T, interceptor: impl Into<tonic::Interceptor>) -> Self {
            let inner = Arc::new(inner);
            let inner = _Inner(inner, Some(interceptor.into()));
            Self { inner }
        }
    }
    impl<T, B> Service<http::Request<B>> for FeedPlaceholderViewServiceServer<T>
    where
        T: FeedPlaceholderViewService,
        B: HttpBody + Send + Sync + 'static,
        B::Error: Into<StdError> + Send + 'static,
    {
        type Response = http::Response<tonic::body::BoxBody>;
        type Error = Never;
        type Future = BoxFuture<Self::Response, Self::Error>;
        fn poll_ready(&mut self, _cx: &mut Context<'_>) -> Poll<Result<(), Self::Error>> {
            Poll::Ready(Ok(()))
        }
        fn call(&mut self, req: http::Request<B>) -> Self::Future {
            let inner = self.inner.clone();
            match req . uri ( ) . path ( ) { "/google.ads.googleads.v1.services.FeedPlaceholderViewService/GetFeedPlaceholderView" => { # [ allow ( non_camel_case_types ) ] struct GetFeedPlaceholderViewSvc < T : FeedPlaceholderViewService > ( pub Arc < T > ) ; impl < T : FeedPlaceholderViewService > tonic :: server :: UnaryService < super :: GetFeedPlaceholderViewRequest > for GetFeedPlaceholderViewSvc < T > { type Response = super :: super :: resources :: FeedPlaceholderView ; type Future = BoxFuture < tonic :: Response < Self :: Response > , tonic :: Status > ; fn call ( & mut self , request : tonic :: Request < super :: GetFeedPlaceholderViewRequest > ) -> Self :: Future { let inner = self . 0 . clone ( ) ; let fut = async move { inner . get_feed_placeholder_view ( request ) . await } ; Box :: pin ( fut ) } } let inner = self . inner . clone ( ) ; let fut = async move { let interceptor = inner . 1 . clone ( ) ; let inner = inner . 0 ; let method = GetFeedPlaceholderViewSvc ( inner ) ; let codec = tonic :: codec :: ProstCodec :: default ( ) ; let mut grpc = if let Some ( interceptor ) = interceptor { tonic :: server :: Grpc :: with_interceptor ( codec , interceptor ) } else { tonic :: server :: Grpc :: new ( codec ) } ; let res = grpc . unary ( method , req ) . await ; Ok ( res ) } ; Box :: pin ( fut ) } _ => Box :: pin ( async move { Ok ( http :: Response :: builder ( ) . status ( 200 ) . header ( "grpc-status" , "12" ) . body ( tonic :: body :: BoxBody :: empty ( ) ) . unwrap ( ) ) } ) , }
        }
    }
    impl<T: FeedPlaceholderViewService> Clone for FeedPlaceholderViewServiceServer<T> {
        fn clone(&self) -> Self {
            let inner = self.inner.clone();
            Self { inner }
        }
    }
    impl<T: FeedPlaceholderViewService> Clone for _Inner<T> {
        fn clone(&self) -> Self {
            Self(self.0.clone(), self.1.clone())
        }
    }
    impl<T: std::fmt::Debug> std::fmt::Debug for _Inner<T> {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
            write!(f, "{:?}", self.0)
        }
    }
    impl<T: FeedPlaceholderViewService> tonic::transport::NamedService
        for FeedPlaceholderViewServiceServer<T>
    {
        const NAME: &'static str = "google.ads.googleads.v1.services.FeedPlaceholderViewService";
    }
}
/// Request message for [FeedService.GetFeed][google.ads.googleads.v1.services.FeedService.GetFeed].
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GetFeedRequest {
    /// Required. The resource name of the feed to fetch.
    #[prost(string, tag = "1")]
    pub resource_name: std::string::String,
}
/// Request message for [FeedService.MutateFeeds][google.ads.googleads.v1.services.FeedService.MutateFeeds].
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct MutateFeedsRequest {
    /// Required. The ID of the customer whose feeds are being modified.
    #[prost(string, tag = "1")]
    pub customer_id: std::string::String,
    /// Required. The list of operations to perform on individual feeds.
    #[prost(message, repeated, tag = "2")]
    pub operations: ::std::vec::Vec<FeedOperation>,
    /// If true, successful operations will be carried out and invalid
    /// operations will return errors. If false, all operations will be carried
    /// out in one transaction if and only if they are all valid.
    /// Default is false.
    #[prost(bool, tag = "3")]
    pub partial_failure: bool,
    /// If true, the request is validated but not executed. Only errors are
    /// returned, not results.
    #[prost(bool, tag = "4")]
    pub validate_only: bool,
}
/// A single operation (create, update, remove) on an feed.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct FeedOperation {
    /// FieldMask that determines which resource fields are modified in an update.
    #[prost(message, optional, tag = "4")]
    pub update_mask: ::std::option::Option<::prost_types::FieldMask>,
    /// The mutate operation.
    #[prost(oneof = "feed_operation::Operation", tags = "1, 2, 3")]
    pub operation: ::std::option::Option<feed_operation::Operation>,
}
pub mod feed_operation {
    /// The mutate operation.
    #[derive(Clone, PartialEq, ::prost::Oneof)]
    pub enum Operation {
        /// Create operation: No resource name is expected for the new feed.
        #[prost(message, tag = "1")]
        Create(super::super::resources::Feed),
        /// Update operation: The feed is expected to have a valid resource
        /// name.
        #[prost(message, tag = "2")]
        Update(super::super::resources::Feed),
        /// Remove operation: A resource name for the removed feed is
        /// expected, in this format:
        ///
        /// `customers/{customer_id}/feeds/{feed_id}`
        #[prost(string, tag = "3")]
        Remove(std::string::String),
    }
}
/// Response message for an feed mutate.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct MutateFeedsResponse {
    /// Errors that pertain to operation failures in the partial failure mode.
    /// Returned only when partial_failure = true and all errors occur inside the
    /// operations. If any errors occur outside the operations (e.g. auth errors),
    /// we return an RPC level error.
    #[prost(message, optional, tag = "3")]
    pub partial_failure_error: ::std::option::Option<super::super::super::super::rpc::Status>,
    /// All results for the mutate.
    #[prost(message, repeated, tag = "2")]
    pub results: ::std::vec::Vec<MutateFeedResult>,
}
/// The result for the feed mutate.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct MutateFeedResult {
    /// Returned for successful operations.
    #[prost(string, tag = "1")]
    pub resource_name: std::string::String,
}
#[doc = r" Generated client implementations."]
pub mod feed_service_client {
    #![allow(unused_variables, dead_code, missing_docs)]
    use tonic::codegen::*;
    #[doc = " Service to manage feeds."]
    pub struct FeedServiceClient<T> {
        inner: tonic::client::Grpc<T>,
    }
    impl FeedServiceClient<tonic::transport::Channel> {
        #[doc = r" Attempt to create a new client by connecting to a given endpoint."]
        pub async fn connect<D>(dst: D) -> Result<Self, tonic::transport::Error>
        where
            D: std::convert::TryInto<tonic::transport::Endpoint>,
            D::Error: Into<StdError>,
        {
            let conn = tonic::transport::Endpoint::new(dst)?.connect().await?;
            Ok(Self::new(conn))
        }
    }
    impl<T> FeedServiceClient<T>
    where
        T: tonic::client::GrpcService<tonic::body::BoxBody>,
        T::ResponseBody: Body + HttpBody + Send + 'static,
        T::Error: Into<StdError>,
        <T::ResponseBody as HttpBody>::Error: Into<StdError> + Send,
    {
        pub fn new(inner: T) -> Self {
            let inner = tonic::client::Grpc::new(inner);
            Self { inner }
        }
        pub fn with_interceptor(inner: T, interceptor: impl Into<tonic::Interceptor>) -> Self {
            let inner = tonic::client::Grpc::with_interceptor(inner, interceptor);
            Self { inner }
        }
        #[doc = " Returns the requested feed in full detail."]
        pub async fn get_feed(
            &mut self,
            request: impl tonic::IntoRequest<super::GetFeedRequest>,
        ) -> Result<tonic::Response<super::super::resources::Feed>, tonic::Status> {
            self.inner.ready().await.map_err(|e| {
                tonic::Status::new(
                    tonic::Code::Unknown,
                    format!("Service was not ready: {}", e.into()),
                )
            })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.ads.googleads.v1.services.FeedService/GetFeed",
            );
            self.inner.unary(request.into_request(), path, codec).await
        }
        #[doc = " Creates, updates, or removes feeds. Operation statuses are"]
        #[doc = " returned."]
        pub async fn mutate_feeds(
            &mut self,
            request: impl tonic::IntoRequest<super::MutateFeedsRequest>,
        ) -> Result<tonic::Response<super::MutateFeedsResponse>, tonic::Status> {
            self.inner.ready().await.map_err(|e| {
                tonic::Status::new(
                    tonic::Code::Unknown,
                    format!("Service was not ready: {}", e.into()),
                )
            })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.ads.googleads.v1.services.FeedService/MutateFeeds",
            );
            self.inner.unary(request.into_request(), path, codec).await
        }
    }
    impl<T: Clone> Clone for FeedServiceClient<T> {
        fn clone(&self) -> Self {
            Self {
                inner: self.inner.clone(),
            }
        }
    }
    impl<T> std::fmt::Debug for FeedServiceClient<T> {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
            write!(f, "FeedServiceClient {{ ... }}")
        }
    }
}
#[doc = r" Generated server implementations."]
pub mod feed_service_server {
    #![allow(unused_variables, dead_code, missing_docs)]
    use tonic::codegen::*;
    #[doc = "Generated trait containing gRPC methods that should be implemented for use with FeedServiceServer."]
    #[async_trait]
    pub trait FeedService: Send + Sync + 'static {
        #[doc = " Returns the requested feed in full detail."]
        async fn get_feed(
            &self,
            request: tonic::Request<super::GetFeedRequest>,
        ) -> Result<tonic::Response<super::super::resources::Feed>, tonic::Status>;
        #[doc = " Creates, updates, or removes feeds. Operation statuses are"]
        #[doc = " returned."]
        async fn mutate_feeds(
            &self,
            request: tonic::Request<super::MutateFeedsRequest>,
        ) -> Result<tonic::Response<super::MutateFeedsResponse>, tonic::Status>;
    }
    #[doc = " Service to manage feeds."]
    #[derive(Debug)]
    #[doc(hidden)]
    pub struct FeedServiceServer<T: FeedService> {
        inner: _Inner<T>,
    }
    struct _Inner<T>(Arc<T>, Option<tonic::Interceptor>);
    impl<T: FeedService> FeedServiceServer<T> {
        pub fn new(inner: T) -> Self {
            let inner = Arc::new(inner);
            let inner = _Inner(inner, None);
            Self { inner }
        }
        pub fn with_interceptor(inner: T, interceptor: impl Into<tonic::Interceptor>) -> Self {
            let inner = Arc::new(inner);
            let inner = _Inner(inner, Some(interceptor.into()));
            Self { inner }
        }
    }
    impl<T, B> Service<http::Request<B>> for FeedServiceServer<T>
    where
        T: FeedService,
        B: HttpBody + Send + Sync + 'static,
        B::Error: Into<StdError> + Send + 'static,
    {
        type Response = http::Response<tonic::body::BoxBody>;
        type Error = Never;
        type Future = BoxFuture<Self::Response, Self::Error>;
        fn poll_ready(&mut self, _cx: &mut Context<'_>) -> Poll<Result<(), Self::Error>> {
            Poll::Ready(Ok(()))
        }
        fn call(&mut self, req: http::Request<B>) -> Self::Future {
            let inner = self.inner.clone();
            match req.uri().path() {
                "/google.ads.googleads.v1.services.FeedService/GetFeed" => {
                    #[allow(non_camel_case_types)]
                    struct GetFeedSvc<T: FeedService>(pub Arc<T>);
                    impl<T: FeedService> tonic::server::UnaryService<super::GetFeedRequest> for GetFeedSvc<T> {
                        type Response = super::super::resources::Feed;
                        type Future = BoxFuture<tonic::Response<Self::Response>, tonic::Status>;
                        fn call(
                            &mut self,
                            request: tonic::Request<super::GetFeedRequest>,
                        ) -> Self::Future {
                            let inner = self.0.clone();
                            let fut = async move { inner.get_feed(request).await };
                            Box::pin(fut)
                        }
                    }
                    let inner = self.inner.clone();
                    let fut = async move {
                        let interceptor = inner.1.clone();
                        let inner = inner.0;
                        let method = GetFeedSvc(inner);
                        let codec = tonic::codec::ProstCodec::default();
                        let mut grpc = if let Some(interceptor) = interceptor {
                            tonic::server::Grpc::with_interceptor(codec, interceptor)
                        } else {
                            tonic::server::Grpc::new(codec)
                        };
                        let res = grpc.unary(method, req).await;
                        Ok(res)
                    };
                    Box::pin(fut)
                }
                "/google.ads.googleads.v1.services.FeedService/MutateFeeds" => {
                    #[allow(non_camel_case_types)]
                    struct MutateFeedsSvc<T: FeedService>(pub Arc<T>);
                    impl<T: FeedService> tonic::server::UnaryService<super::MutateFeedsRequest> for MutateFeedsSvc<T> {
                        type Response = super::MutateFeedsResponse;
                        type Future = BoxFuture<tonic::Response<Self::Response>, tonic::Status>;
                        fn call(
                            &mut self,
                            request: tonic::Request<super::MutateFeedsRequest>,
                        ) -> Self::Future {
                            let inner = self.0.clone();
                            let fut = async move { inner.mutate_feeds(request).await };
                            Box::pin(fut)
                        }
                    }
                    let inner = self.inner.clone();
                    let fut = async move {
                        let interceptor = inner.1.clone();
                        let inner = inner.0;
                        let method = MutateFeedsSvc(inner);
                        let codec = tonic::codec::ProstCodec::default();
                        let mut grpc = if let Some(interceptor) = interceptor {
                            tonic::server::Grpc::with_interceptor(codec, interceptor)
                        } else {
                            tonic::server::Grpc::new(codec)
                        };
                        let res = grpc.unary(method, req).await;
                        Ok(res)
                    };
                    Box::pin(fut)
                }
                _ => Box::pin(async move {
                    Ok(http::Response::builder()
                        .status(200)
                        .header("grpc-status", "12")
                        .body(tonic::body::BoxBody::empty())
                        .unwrap())
                }),
            }
        }
    }
    impl<T: FeedService> Clone for FeedServiceServer<T> {
        fn clone(&self) -> Self {
            let inner = self.inner.clone();
            Self { inner }
        }
    }
    impl<T: FeedService> Clone for _Inner<T> {
        fn clone(&self) -> Self {
            Self(self.0.clone(), self.1.clone())
        }
    }
    impl<T: std::fmt::Debug> std::fmt::Debug for _Inner<T> {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
            write!(f, "{:?}", self.0)
        }
    }
    impl<T: FeedService> tonic::transport::NamedService for FeedServiceServer<T> {
        const NAME: &'static str = "google.ads.googleads.v1.services.FeedService";
    }
}
/// Request message for [GenderViewService.GetGenderView][google.ads.googleads.v1.services.GenderViewService.GetGenderView].
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GetGenderViewRequest {
    /// Required. The resource name of the gender view to fetch.
    #[prost(string, tag = "1")]
    pub resource_name: std::string::String,
}
#[doc = r" Generated client implementations."]
pub mod gender_view_service_client {
    #![allow(unused_variables, dead_code, missing_docs)]
    use tonic::codegen::*;
    #[doc = " Service to manage gender views."]
    pub struct GenderViewServiceClient<T> {
        inner: tonic::client::Grpc<T>,
    }
    impl GenderViewServiceClient<tonic::transport::Channel> {
        #[doc = r" Attempt to create a new client by connecting to a given endpoint."]
        pub async fn connect<D>(dst: D) -> Result<Self, tonic::transport::Error>
        where
            D: std::convert::TryInto<tonic::transport::Endpoint>,
            D::Error: Into<StdError>,
        {
            let conn = tonic::transport::Endpoint::new(dst)?.connect().await?;
            Ok(Self::new(conn))
        }
    }
    impl<T> GenderViewServiceClient<T>
    where
        T: tonic::client::GrpcService<tonic::body::BoxBody>,
        T::ResponseBody: Body + HttpBody + Send + 'static,
        T::Error: Into<StdError>,
        <T::ResponseBody as HttpBody>::Error: Into<StdError> + Send,
    {
        pub fn new(inner: T) -> Self {
            let inner = tonic::client::Grpc::new(inner);
            Self { inner }
        }
        pub fn with_interceptor(inner: T, interceptor: impl Into<tonic::Interceptor>) -> Self {
            let inner = tonic::client::Grpc::with_interceptor(inner, interceptor);
            Self { inner }
        }
        #[doc = " Returns the requested gender view in full detail."]
        pub async fn get_gender_view(
            &mut self,
            request: impl tonic::IntoRequest<super::GetGenderViewRequest>,
        ) -> Result<tonic::Response<super::super::resources::GenderView>, tonic::Status> {
            self.inner.ready().await.map_err(|e| {
                tonic::Status::new(
                    tonic::Code::Unknown,
                    format!("Service was not ready: {}", e.into()),
                )
            })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.ads.googleads.v1.services.GenderViewService/GetGenderView",
            );
            self.inner.unary(request.into_request(), path, codec).await
        }
    }
    impl<T: Clone> Clone for GenderViewServiceClient<T> {
        fn clone(&self) -> Self {
            Self {
                inner: self.inner.clone(),
            }
        }
    }
    impl<T> std::fmt::Debug for GenderViewServiceClient<T> {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
            write!(f, "GenderViewServiceClient {{ ... }}")
        }
    }
}
#[doc = r" Generated server implementations."]
pub mod gender_view_service_server {
    #![allow(unused_variables, dead_code, missing_docs)]
    use tonic::codegen::*;
    #[doc = "Generated trait containing gRPC methods that should be implemented for use with GenderViewServiceServer."]
    #[async_trait]
    pub trait GenderViewService: Send + Sync + 'static {
        #[doc = " Returns the requested gender view in full detail."]
        async fn get_gender_view(
            &self,
            request: tonic::Request<super::GetGenderViewRequest>,
        ) -> Result<tonic::Response<super::super::resources::GenderView>, tonic::Status>;
    }
    #[doc = " Service to manage gender views."]
    #[derive(Debug)]
    #[doc(hidden)]
    pub struct GenderViewServiceServer<T: GenderViewService> {
        inner: _Inner<T>,
    }
    struct _Inner<T>(Arc<T>, Option<tonic::Interceptor>);
    impl<T: GenderViewService> GenderViewServiceServer<T> {
        pub fn new(inner: T) -> Self {
            let inner = Arc::new(inner);
            let inner = _Inner(inner, None);
            Self { inner }
        }
        pub fn with_interceptor(inner: T, interceptor: impl Into<tonic::Interceptor>) -> Self {
            let inner = Arc::new(inner);
            let inner = _Inner(inner, Some(interceptor.into()));
            Self { inner }
        }
    }
    impl<T, B> Service<http::Request<B>> for GenderViewServiceServer<T>
    where
        T: GenderViewService,
        B: HttpBody + Send + Sync + 'static,
        B::Error: Into<StdError> + Send + 'static,
    {
        type Response = http::Response<tonic::body::BoxBody>;
        type Error = Never;
        type Future = BoxFuture<Self::Response, Self::Error>;
        fn poll_ready(&mut self, _cx: &mut Context<'_>) -> Poll<Result<(), Self::Error>> {
            Poll::Ready(Ok(()))
        }
        fn call(&mut self, req: http::Request<B>) -> Self::Future {
            let inner = self.inner.clone();
            match req.uri().path() {
                "/google.ads.googleads.v1.services.GenderViewService/GetGenderView" => {
                    #[allow(non_camel_case_types)]
                    struct GetGenderViewSvc<T: GenderViewService>(pub Arc<T>);
                    impl<T: GenderViewService>
                        tonic::server::UnaryService<super::GetGenderViewRequest>
                        for GetGenderViewSvc<T>
                    {
                        type Response = super::super::resources::GenderView;
                        type Future = BoxFuture<tonic::Response<Self::Response>, tonic::Status>;
                        fn call(
                            &mut self,
                            request: tonic::Request<super::GetGenderViewRequest>,
                        ) -> Self::Future {
                            let inner = self.0.clone();
                            let fut = async move { inner.get_gender_view(request).await };
                            Box::pin(fut)
                        }
                    }
                    let inner = self.inner.clone();
                    let fut = async move {
                        let interceptor = inner.1.clone();
                        let inner = inner.0;
                        let method = GetGenderViewSvc(inner);
                        let codec = tonic::codec::ProstCodec::default();
                        let mut grpc = if let Some(interceptor) = interceptor {
                            tonic::server::Grpc::with_interceptor(codec, interceptor)
                        } else {
                            tonic::server::Grpc::new(codec)
                        };
                        let res = grpc.unary(method, req).await;
                        Ok(res)
                    };
                    Box::pin(fut)
                }
                _ => Box::pin(async move {
                    Ok(http::Response::builder()
                        .status(200)
                        .header("grpc-status", "12")
                        .body(tonic::body::BoxBody::empty())
                        .unwrap())
                }),
            }
        }
    }
    impl<T: GenderViewService> Clone for GenderViewServiceServer<T> {
        fn clone(&self) -> Self {
            let inner = self.inner.clone();
            Self { inner }
        }
    }
    impl<T: GenderViewService> Clone for _Inner<T> {
        fn clone(&self) -> Self {
            Self(self.0.clone(), self.1.clone())
        }
    }
    impl<T: std::fmt::Debug> std::fmt::Debug for _Inner<T> {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
            write!(f, "{:?}", self.0)
        }
    }
    impl<T: GenderViewService> tonic::transport::NamedService for GenderViewServiceServer<T> {
        const NAME: &'static str = "google.ads.googleads.v1.services.GenderViewService";
    }
}
/// Request message for [GeoTargetConstantService.GetGeoTargetConstant][google.ads.googleads.v1.services.GeoTargetConstantService.GetGeoTargetConstant].
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GetGeoTargetConstantRequest {
    /// Required. The resource name of the geo target constant to fetch.
    #[prost(string, tag = "1")]
    pub resource_name: std::string::String,
}
/// Request message for
/// [GeoTargetConstantService.SuggestGeoTargetConstantsRequest][].
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct SuggestGeoTargetConstantsRequest {
    /// If possible, returned geo targets are translated using this locale. If not,
    /// en is used by default. This is also used as a hint for returned geo
    /// targets.
    #[prost(message, optional, tag = "3")]
    pub locale: ::std::option::Option<::std::string::String>,
    /// Returned geo targets are restricted to this country code.
    #[prost(message, optional, tag = "5")]
    pub country_code: ::std::option::Option<::std::string::String>,
    /// Required. A selector of geo target constants.
    #[prost(oneof = "suggest_geo_target_constants_request::Query", tags = "1, 2")]
    pub query: ::std::option::Option<suggest_geo_target_constants_request::Query>,
}
pub mod suggest_geo_target_constants_request {
    /// A list of location names.
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct LocationNames {
        /// A list of location names.
        #[prost(message, repeated, tag = "1")]
        pub names: ::std::vec::Vec<::std::string::String>,
    }
    /// A list of geo target constant resource names.
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct GeoTargets {
        /// A list of geo target constant resource names.
        #[prost(message, repeated, tag = "1")]
        pub geo_target_constants: ::std::vec::Vec<::std::string::String>,
    }
    /// Required. A selector of geo target constants.
    #[derive(Clone, PartialEq, ::prost::Oneof)]
    pub enum Query {
        /// The location names to search by. At most 25 names can be set.
        #[prost(message, tag = "1")]
        LocationNames(LocationNames),
        /// The geo target constant resource names to filter by.
        #[prost(message, tag = "2")]
        GeoTargets(GeoTargets),
    }
}
/// Response message for [GeoTargetConstantService.SuggestGeoTargetConstants][google.ads.googleads.v1.services.GeoTargetConstantService.SuggestGeoTargetConstants]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct SuggestGeoTargetConstantsResponse {
    /// Geo target constant suggestions.
    #[prost(message, repeated, tag = "1")]
    pub geo_target_constant_suggestions: ::std::vec::Vec<GeoTargetConstantSuggestion>,
}
/// A geo target constant suggestion.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GeoTargetConstantSuggestion {
    /// The language this GeoTargetConstantSuggestion is currently translated to.
    /// It affects the name of geo target fields. For example, if locale=en, then
    /// name=Spain. If locale=es, then name=España. The default locale will be
    /// returned if no translation exists for the locale in the request.
    #[prost(message, optional, tag = "1")]
    pub locale: ::std::option::Option<::std::string::String>,
    /// Approximate user population that will be targeted, rounded to the
    /// nearest 100.
    #[prost(message, optional, tag = "2")]
    pub reach: ::std::option::Option<i64>,
    /// If the request searched by location name, this is the location name that
    /// matched the geo target.
    #[prost(message, optional, tag = "3")]
    pub search_term: ::std::option::Option<::std::string::String>,
    /// The GeoTargetConstant result.
    #[prost(message, optional, tag = "4")]
    pub geo_target_constant: ::std::option::Option<super::resources::GeoTargetConstant>,
    /// The list of parents of the geo target constant.
    #[prost(message, repeated, tag = "5")]
    pub geo_target_constant_parents: ::std::vec::Vec<super::resources::GeoTargetConstant>,
}
#[doc = r" Generated client implementations."]
pub mod geo_target_constant_service_client {
    #![allow(unused_variables, dead_code, missing_docs)]
    use tonic::codegen::*;
    #[doc = " Service to fetch geo target constants."]
    pub struct GeoTargetConstantServiceClient<T> {
        inner: tonic::client::Grpc<T>,
    }
    impl GeoTargetConstantServiceClient<tonic::transport::Channel> {
        #[doc = r" Attempt to create a new client by connecting to a given endpoint."]
        pub async fn connect<D>(dst: D) -> Result<Self, tonic::transport::Error>
        where
            D: std::convert::TryInto<tonic::transport::Endpoint>,
            D::Error: Into<StdError>,
        {
            let conn = tonic::transport::Endpoint::new(dst)?.connect().await?;
            Ok(Self::new(conn))
        }
    }
    impl<T> GeoTargetConstantServiceClient<T>
    where
        T: tonic::client::GrpcService<tonic::body::BoxBody>,
        T::ResponseBody: Body + HttpBody + Send + 'static,
        T::Error: Into<StdError>,
        <T::ResponseBody as HttpBody>::Error: Into<StdError> + Send,
    {
        pub fn new(inner: T) -> Self {
            let inner = tonic::client::Grpc::new(inner);
            Self { inner }
        }
        pub fn with_interceptor(inner: T, interceptor: impl Into<tonic::Interceptor>) -> Self {
            let inner = tonic::client::Grpc::with_interceptor(inner, interceptor);
            Self { inner }
        }
        #[doc = " Returns the requested geo target constant in full detail."]
        pub async fn get_geo_target_constant(
            &mut self,
            request: impl tonic::IntoRequest<super::GetGeoTargetConstantRequest>,
        ) -> Result<tonic::Response<super::super::resources::GeoTargetConstant>, tonic::Status>
        {
            self.inner.ready().await.map_err(|e| {
                tonic::Status::new(
                    tonic::Code::Unknown,
                    format!("Service was not ready: {}", e.into()),
                )
            })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.ads.googleads.v1.services.GeoTargetConstantService/GetGeoTargetConstant",
            );
            self.inner.unary(request.into_request(), path, codec).await
        }
        #[doc = " Returns GeoTargetConstant suggestions by location name or by resource name."]
        pub async fn suggest_geo_target_constants(
            &mut self,
            request: impl tonic::IntoRequest<super::SuggestGeoTargetConstantsRequest>,
        ) -> Result<tonic::Response<super::SuggestGeoTargetConstantsResponse>, tonic::Status>
        {
            self.inner.ready().await.map_err(|e| {
                tonic::Status::new(
                    tonic::Code::Unknown,
                    format!("Service was not ready: {}", e.into()),
                )
            })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http :: uri :: PathAndQuery :: from_static ( "/google.ads.googleads.v1.services.GeoTargetConstantService/SuggestGeoTargetConstants" ) ;
            self.inner.unary(request.into_request(), path, codec).await
        }
    }
    impl<T: Clone> Clone for GeoTargetConstantServiceClient<T> {
        fn clone(&self) -> Self {
            Self {
                inner: self.inner.clone(),
            }
        }
    }
    impl<T> std::fmt::Debug for GeoTargetConstantServiceClient<T> {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
            write!(f, "GeoTargetConstantServiceClient {{ ... }}")
        }
    }
}
#[doc = r" Generated server implementations."]
pub mod geo_target_constant_service_server {
    #![allow(unused_variables, dead_code, missing_docs)]
    use tonic::codegen::*;
    #[doc = "Generated trait containing gRPC methods that should be implemented for use with GeoTargetConstantServiceServer."]
    #[async_trait]
    pub trait GeoTargetConstantService: Send + Sync + 'static {
        #[doc = " Returns the requested geo target constant in full detail."]
        async fn get_geo_target_constant(
            &self,
            request: tonic::Request<super::GetGeoTargetConstantRequest>,
        ) -> Result<tonic::Response<super::super::resources::GeoTargetConstant>, tonic::Status>;
        #[doc = " Returns GeoTargetConstant suggestions by location name or by resource name."]
        async fn suggest_geo_target_constants(
            &self,
            request: tonic::Request<super::SuggestGeoTargetConstantsRequest>,
        ) -> Result<tonic::Response<super::SuggestGeoTargetConstantsResponse>, tonic::Status>;
    }
    #[doc = " Service to fetch geo target constants."]
    #[derive(Debug)]
    #[doc(hidden)]
    pub struct GeoTargetConstantServiceServer<T: GeoTargetConstantService> {
        inner: _Inner<T>,
    }
    struct _Inner<T>(Arc<T>, Option<tonic::Interceptor>);
    impl<T: GeoTargetConstantService> GeoTargetConstantServiceServer<T> {
        pub fn new(inner: T) -> Self {
            let inner = Arc::new(inner);
            let inner = _Inner(inner, None);
            Self { inner }
        }
        pub fn with_interceptor(inner: T, interceptor: impl Into<tonic::Interceptor>) -> Self {
            let inner = Arc::new(inner);
            let inner = _Inner(inner, Some(interceptor.into()));
            Self { inner }
        }
    }
    impl<T, B> Service<http::Request<B>> for GeoTargetConstantServiceServer<T>
    where
        T: GeoTargetConstantService,
        B: HttpBody + Send + Sync + 'static,
        B::Error: Into<StdError> + Send + 'static,
    {
        type Response = http::Response<tonic::body::BoxBody>;
        type Error = Never;
        type Future = BoxFuture<Self::Response, Self::Error>;
        fn poll_ready(&mut self, _cx: &mut Context<'_>) -> Poll<Result<(), Self::Error>> {
            Poll::Ready(Ok(()))
        }
        fn call(&mut self, req: http::Request<B>) -> Self::Future {
            let inner = self.inner.clone();
            match req . uri ( ) . path ( ) { "/google.ads.googleads.v1.services.GeoTargetConstantService/GetGeoTargetConstant" => { # [ allow ( non_camel_case_types ) ] struct GetGeoTargetConstantSvc < T : GeoTargetConstantService > ( pub Arc < T > ) ; impl < T : GeoTargetConstantService > tonic :: server :: UnaryService < super :: GetGeoTargetConstantRequest > for GetGeoTargetConstantSvc < T > { type Response = super :: super :: resources :: GeoTargetConstant ; type Future = BoxFuture < tonic :: Response < Self :: Response > , tonic :: Status > ; fn call ( & mut self , request : tonic :: Request < super :: GetGeoTargetConstantRequest > ) -> Self :: Future { let inner = self . 0 . clone ( ) ; let fut = async move { inner . get_geo_target_constant ( request ) . await } ; Box :: pin ( fut ) } } let inner = self . inner . clone ( ) ; let fut = async move { let interceptor = inner . 1 . clone ( ) ; let inner = inner . 0 ; let method = GetGeoTargetConstantSvc ( inner ) ; let codec = tonic :: codec :: ProstCodec :: default ( ) ; let mut grpc = if let Some ( interceptor ) = interceptor { tonic :: server :: Grpc :: with_interceptor ( codec , interceptor ) } else { tonic :: server :: Grpc :: new ( codec ) } ; let res = grpc . unary ( method , req ) . await ; Ok ( res ) } ; Box :: pin ( fut ) } "/google.ads.googleads.v1.services.GeoTargetConstantService/SuggestGeoTargetConstants" => { # [ allow ( non_camel_case_types ) ] struct SuggestGeoTargetConstantsSvc < T : GeoTargetConstantService > ( pub Arc < T > ) ; impl < T : GeoTargetConstantService > tonic :: server :: UnaryService < super :: SuggestGeoTargetConstantsRequest > for SuggestGeoTargetConstantsSvc < T > { type Response = super :: SuggestGeoTargetConstantsResponse ; type Future = BoxFuture < tonic :: Response < Self :: Response > , tonic :: Status > ; fn call ( & mut self , request : tonic :: Request < super :: SuggestGeoTargetConstantsRequest > ) -> Self :: Future { let inner = self . 0 . clone ( ) ; let fut = async move { inner . suggest_geo_target_constants ( request ) . await } ; Box :: pin ( fut ) } } let inner = self . inner . clone ( ) ; let fut = async move { let interceptor = inner . 1 . clone ( ) ; let inner = inner . 0 ; let method = SuggestGeoTargetConstantsSvc ( inner ) ; let codec = tonic :: codec :: ProstCodec :: default ( ) ; let mut grpc = if let Some ( interceptor ) = interceptor { tonic :: server :: Grpc :: with_interceptor ( codec , interceptor ) } else { tonic :: server :: Grpc :: new ( codec ) } ; let res = grpc . unary ( method , req ) . await ; Ok ( res ) } ; Box :: pin ( fut ) } _ => Box :: pin ( async move { Ok ( http :: Response :: builder ( ) . status ( 200 ) . header ( "grpc-status" , "12" ) . body ( tonic :: body :: BoxBody :: empty ( ) ) . unwrap ( ) ) } ) , }
        }
    }
    impl<T: GeoTargetConstantService> Clone for GeoTargetConstantServiceServer<T> {
        fn clone(&self) -> Self {
            let inner = self.inner.clone();
            Self { inner }
        }
    }
    impl<T: GeoTargetConstantService> Clone for _Inner<T> {
        fn clone(&self) -> Self {
            Self(self.0.clone(), self.1.clone())
        }
    }
    impl<T: std::fmt::Debug> std::fmt::Debug for _Inner<T> {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
            write!(f, "{:?}", self.0)
        }
    }
    impl<T: GeoTargetConstantService> tonic::transport::NamedService
        for GeoTargetConstantServiceServer<T>
    {
        const NAME: &'static str = "google.ads.googleads.v1.services.GeoTargetConstantService";
    }
}
/// Request message for [GeographicViewService.GetGeographicView][google.ads.googleads.v1.services.GeographicViewService.GetGeographicView].
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GetGeographicViewRequest {
    /// Required. The resource name of the geographic view to fetch.
    #[prost(string, tag = "1")]
    pub resource_name: std::string::String,
}
#[doc = r" Generated client implementations."]
pub mod geographic_view_service_client {
    #![allow(unused_variables, dead_code, missing_docs)]
    use tonic::codegen::*;
    #[doc = " Service to manage geographic views."]
    pub struct GeographicViewServiceClient<T> {
        inner: tonic::client::Grpc<T>,
    }
    impl GeographicViewServiceClient<tonic::transport::Channel> {
        #[doc = r" Attempt to create a new client by connecting to a given endpoint."]
        pub async fn connect<D>(dst: D) -> Result<Self, tonic::transport::Error>
        where
            D: std::convert::TryInto<tonic::transport::Endpoint>,
            D::Error: Into<StdError>,
        {
            let conn = tonic::transport::Endpoint::new(dst)?.connect().await?;
            Ok(Self::new(conn))
        }
    }
    impl<T> GeographicViewServiceClient<T>
    where
        T: tonic::client::GrpcService<tonic::body::BoxBody>,
        T::ResponseBody: Body + HttpBody + Send + 'static,
        T::Error: Into<StdError>,
        <T::ResponseBody as HttpBody>::Error: Into<StdError> + Send,
    {
        pub fn new(inner: T) -> Self {
            let inner = tonic::client::Grpc::new(inner);
            Self { inner }
        }
        pub fn with_interceptor(inner: T, interceptor: impl Into<tonic::Interceptor>) -> Self {
            let inner = tonic::client::Grpc::with_interceptor(inner, interceptor);
            Self { inner }
        }
        #[doc = " Returns the requested geographic view in full detail."]
        pub async fn get_geographic_view(
            &mut self,
            request: impl tonic::IntoRequest<super::GetGeographicViewRequest>,
        ) -> Result<tonic::Response<super::super::resources::GeographicView>, tonic::Status>
        {
            self.inner.ready().await.map_err(|e| {
                tonic::Status::new(
                    tonic::Code::Unknown,
                    format!("Service was not ready: {}", e.into()),
                )
            })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.ads.googleads.v1.services.GeographicViewService/GetGeographicView",
            );
            self.inner.unary(request.into_request(), path, codec).await
        }
    }
    impl<T: Clone> Clone for GeographicViewServiceClient<T> {
        fn clone(&self) -> Self {
            Self {
                inner: self.inner.clone(),
            }
        }
    }
    impl<T> std::fmt::Debug for GeographicViewServiceClient<T> {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
            write!(f, "GeographicViewServiceClient {{ ... }}")
        }
    }
}
#[doc = r" Generated server implementations."]
pub mod geographic_view_service_server {
    #![allow(unused_variables, dead_code, missing_docs)]
    use tonic::codegen::*;
    #[doc = "Generated trait containing gRPC methods that should be implemented for use with GeographicViewServiceServer."]
    #[async_trait]
    pub trait GeographicViewService: Send + Sync + 'static {
        #[doc = " Returns the requested geographic view in full detail."]
        async fn get_geographic_view(
            &self,
            request: tonic::Request<super::GetGeographicViewRequest>,
        ) -> Result<tonic::Response<super::super::resources::GeographicView>, tonic::Status>;
    }
    #[doc = " Service to manage geographic views."]
    #[derive(Debug)]
    #[doc(hidden)]
    pub struct GeographicViewServiceServer<T: GeographicViewService> {
        inner: _Inner<T>,
    }
    struct _Inner<T>(Arc<T>, Option<tonic::Interceptor>);
    impl<T: GeographicViewService> GeographicViewServiceServer<T> {
        pub fn new(inner: T) -> Self {
            let inner = Arc::new(inner);
            let inner = _Inner(inner, None);
            Self { inner }
        }
        pub fn with_interceptor(inner: T, interceptor: impl Into<tonic::Interceptor>) -> Self {
            let inner = Arc::new(inner);
            let inner = _Inner(inner, Some(interceptor.into()));
            Self { inner }
        }
    }
    impl<T, B> Service<http::Request<B>> for GeographicViewServiceServer<T>
    where
        T: GeographicViewService,
        B: HttpBody + Send + Sync + 'static,
        B::Error: Into<StdError> + Send + 'static,
    {
        type Response = http::Response<tonic::body::BoxBody>;
        type Error = Never;
        type Future = BoxFuture<Self::Response, Self::Error>;
        fn poll_ready(&mut self, _cx: &mut Context<'_>) -> Poll<Result<(), Self::Error>> {
            Poll::Ready(Ok(()))
        }
        fn call(&mut self, req: http::Request<B>) -> Self::Future {
            let inner = self.inner.clone();
            match req.uri().path() {
                "/google.ads.googleads.v1.services.GeographicViewService/GetGeographicView" => {
                    #[allow(non_camel_case_types)]
                    struct GetGeographicViewSvc<T: GeographicViewService>(pub Arc<T>);
                    impl<T: GeographicViewService>
                        tonic::server::UnaryService<super::GetGeographicViewRequest>
                        for GetGeographicViewSvc<T>
                    {
                        type Response = super::super::resources::GeographicView;
                        type Future = BoxFuture<tonic::Response<Self::Response>, tonic::Status>;
                        fn call(
                            &mut self,
                            request: tonic::Request<super::GetGeographicViewRequest>,
                        ) -> Self::Future {
                            let inner = self.0.clone();
                            let fut = async move { inner.get_geographic_view(request).await };
                            Box::pin(fut)
                        }
                    }
                    let inner = self.inner.clone();
                    let fut = async move {
                        let interceptor = inner.1.clone();
                        let inner = inner.0;
                        let method = GetGeographicViewSvc(inner);
                        let codec = tonic::codec::ProstCodec::default();
                        let mut grpc = if let Some(interceptor) = interceptor {
                            tonic::server::Grpc::with_interceptor(codec, interceptor)
                        } else {
                            tonic::server::Grpc::new(codec)
                        };
                        let res = grpc.unary(method, req).await;
                        Ok(res)
                    };
                    Box::pin(fut)
                }
                _ => Box::pin(async move {
                    Ok(http::Response::builder()
                        .status(200)
                        .header("grpc-status", "12")
                        .body(tonic::body::BoxBody::empty())
                        .unwrap())
                }),
            }
        }
    }
    impl<T: GeographicViewService> Clone for GeographicViewServiceServer<T> {
        fn clone(&self) -> Self {
            let inner = self.inner.clone();
            Self { inner }
        }
    }
    impl<T: GeographicViewService> Clone for _Inner<T> {
        fn clone(&self) -> Self {
            Self(self.0.clone(), self.1.clone())
        }
    }
    impl<T: std::fmt::Debug> std::fmt::Debug for _Inner<T> {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
            write!(f, "{:?}", self.0)
        }
    }
    impl<T: GeographicViewService> tonic::transport::NamedService for GeographicViewServiceServer<T> {
        const NAME: &'static str = "google.ads.googleads.v1.services.GeographicViewService";
    }
}
/// Request message for [GoogleAdsFieldService.GetGoogleAdsField][google.ads.googleads.v1.services.GoogleAdsFieldService.GetGoogleAdsField].
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GetGoogleAdsFieldRequest {
    /// Required. The resource name of the field to get.
    #[prost(string, tag = "1")]
    pub resource_name: std::string::String,
}
/// Request message for [GoogleAdsFieldService.SearchGoogleAdsFields][google.ads.googleads.v1.services.GoogleAdsFieldService.SearchGoogleAdsFields].
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct SearchGoogleAdsFieldsRequest {
    /// Required. The query string.
    #[prost(string, tag = "1")]
    pub query: std::string::String,
    /// Token of the page to retrieve. If not specified, the first page of
    /// results will be returned. Use the value obtained from `next_page_token`
    /// in the previous response in order to request the next page of results.
    #[prost(string, tag = "2")]
    pub page_token: std::string::String,
    /// Number of elements to retrieve in a single page.
    /// When too large a page is requested, the server may decide to further
    /// limit the number of returned resources.
    #[prost(int32, tag = "3")]
    pub page_size: i32,
}
/// Response message for [GoogleAdsFieldService.SearchGoogleAdsFields][google.ads.googleads.v1.services.GoogleAdsFieldService.SearchGoogleAdsFields].
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct SearchGoogleAdsFieldsResponse {
    /// The list of fields that matched the query.
    #[prost(message, repeated, tag = "1")]
    pub results: ::std::vec::Vec<super::resources::GoogleAdsField>,
    /// Pagination token used to retrieve the next page of results. Pass the
    /// content of this string as the `page_token` attribute of the next request.
    /// `next_page_token` is not returned for the last page.
    #[prost(string, tag = "2")]
    pub next_page_token: std::string::String,
    /// Total number of results that match the query ignoring the LIMIT clause.
    #[prost(int64, tag = "3")]
    pub total_results_count: i64,
}
#[doc = r" Generated client implementations."]
pub mod google_ads_field_service_client {
    #![allow(unused_variables, dead_code, missing_docs)]
    use tonic::codegen::*;
    #[doc = " Service to fetch Google Ads API fields."]
    pub struct GoogleAdsFieldServiceClient<T> {
        inner: tonic::client::Grpc<T>,
    }
    impl GoogleAdsFieldServiceClient<tonic::transport::Channel> {
        #[doc = r" Attempt to create a new client by connecting to a given endpoint."]
        pub async fn connect<D>(dst: D) -> Result<Self, tonic::transport::Error>
        where
            D: std::convert::TryInto<tonic::transport::Endpoint>,
            D::Error: Into<StdError>,
        {
            let conn = tonic::transport::Endpoint::new(dst)?.connect().await?;
            Ok(Self::new(conn))
        }
    }
    impl<T> GoogleAdsFieldServiceClient<T>
    where
        T: tonic::client::GrpcService<tonic::body::BoxBody>,
        T::ResponseBody: Body + HttpBody + Send + 'static,
        T::Error: Into<StdError>,
        <T::ResponseBody as HttpBody>::Error: Into<StdError> + Send,
    {
        pub fn new(inner: T) -> Self {
            let inner = tonic::client::Grpc::new(inner);
            Self { inner }
        }
        pub fn with_interceptor(inner: T, interceptor: impl Into<tonic::Interceptor>) -> Self {
            let inner = tonic::client::Grpc::with_interceptor(inner, interceptor);
            Self { inner }
        }
        #[doc = " Returns just the requested field."]
        pub async fn get_google_ads_field(
            &mut self,
            request: impl tonic::IntoRequest<super::GetGoogleAdsFieldRequest>,
        ) -> Result<tonic::Response<super::super::resources::GoogleAdsField>, tonic::Status>
        {
            self.inner.ready().await.map_err(|e| {
                tonic::Status::new(
                    tonic::Code::Unknown,
                    format!("Service was not ready: {}", e.into()),
                )
            })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.ads.googleads.v1.services.GoogleAdsFieldService/GetGoogleAdsField",
            );
            self.inner.unary(request.into_request(), path, codec).await
        }
        #[doc = " Returns all fields that match the search query."]
        pub async fn search_google_ads_fields(
            &mut self,
            request: impl tonic::IntoRequest<super::SearchGoogleAdsFieldsRequest>,
        ) -> Result<tonic::Response<super::SearchGoogleAdsFieldsResponse>, tonic::Status> {
            self.inner.ready().await.map_err(|e| {
                tonic::Status::new(
                    tonic::Code::Unknown,
                    format!("Service was not ready: {}", e.into()),
                )
            })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.ads.googleads.v1.services.GoogleAdsFieldService/SearchGoogleAdsFields",
            );
            self.inner.unary(request.into_request(), path, codec).await
        }
    }
    impl<T: Clone> Clone for GoogleAdsFieldServiceClient<T> {
        fn clone(&self) -> Self {
            Self {
                inner: self.inner.clone(),
            }
        }
    }
    impl<T> std::fmt::Debug for GoogleAdsFieldServiceClient<T> {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
            write!(f, "GoogleAdsFieldServiceClient {{ ... }}")
        }
    }
}
#[doc = r" Generated server implementations."]
pub mod google_ads_field_service_server {
    #![allow(unused_variables, dead_code, missing_docs)]
    use tonic::codegen::*;
    #[doc = "Generated trait containing gRPC methods that should be implemented for use with GoogleAdsFieldServiceServer."]
    #[async_trait]
    pub trait GoogleAdsFieldService: Send + Sync + 'static {
        #[doc = " Returns just the requested field."]
        async fn get_google_ads_field(
            &self,
            request: tonic::Request<super::GetGoogleAdsFieldRequest>,
        ) -> Result<tonic::Response<super::super::resources::GoogleAdsField>, tonic::Status>;
        #[doc = " Returns all fields that match the search query."]
        async fn search_google_ads_fields(
            &self,
            request: tonic::Request<super::SearchGoogleAdsFieldsRequest>,
        ) -> Result<tonic::Response<super::SearchGoogleAdsFieldsResponse>, tonic::Status>;
    }
    #[doc = " Service to fetch Google Ads API fields."]
    #[derive(Debug)]
    #[doc(hidden)]
    pub struct GoogleAdsFieldServiceServer<T: GoogleAdsFieldService> {
        inner: _Inner<T>,
    }
    struct _Inner<T>(Arc<T>, Option<tonic::Interceptor>);
    impl<T: GoogleAdsFieldService> GoogleAdsFieldServiceServer<T> {
        pub fn new(inner: T) -> Self {
            let inner = Arc::new(inner);
            let inner = _Inner(inner, None);
            Self { inner }
        }
        pub fn with_interceptor(inner: T, interceptor: impl Into<tonic::Interceptor>) -> Self {
            let inner = Arc::new(inner);
            let inner = _Inner(inner, Some(interceptor.into()));
            Self { inner }
        }
    }
    impl<T, B> Service<http::Request<B>> for GoogleAdsFieldServiceServer<T>
    where
        T: GoogleAdsFieldService,
        B: HttpBody + Send + Sync + 'static,
        B::Error: Into<StdError> + Send + 'static,
    {
        type Response = http::Response<tonic::body::BoxBody>;
        type Error = Never;
        type Future = BoxFuture<Self::Response, Self::Error>;
        fn poll_ready(&mut self, _cx: &mut Context<'_>) -> Poll<Result<(), Self::Error>> {
            Poll::Ready(Ok(()))
        }
        fn call(&mut self, req: http::Request<B>) -> Self::Future {
            let inner = self.inner.clone();
            match req.uri().path() {
                "/google.ads.googleads.v1.services.GoogleAdsFieldService/GetGoogleAdsField" => {
                    #[allow(non_camel_case_types)]
                    struct GetGoogleAdsFieldSvc<T: GoogleAdsFieldService>(pub Arc<T>);
                    impl<T: GoogleAdsFieldService>
                        tonic::server::UnaryService<super::GetGoogleAdsFieldRequest>
                        for GetGoogleAdsFieldSvc<T>
                    {
                        type Response = super::super::resources::GoogleAdsField;
                        type Future = BoxFuture<tonic::Response<Self::Response>, tonic::Status>;
                        fn call(
                            &mut self,
                            request: tonic::Request<super::GetGoogleAdsFieldRequest>,
                        ) -> Self::Future {
                            let inner = self.0.clone();
                            let fut = async move { inner.get_google_ads_field(request).await };
                            Box::pin(fut)
                        }
                    }
                    let inner = self.inner.clone();
                    let fut = async move {
                        let interceptor = inner.1.clone();
                        let inner = inner.0;
                        let method = GetGoogleAdsFieldSvc(inner);
                        let codec = tonic::codec::ProstCodec::default();
                        let mut grpc = if let Some(interceptor) = interceptor {
                            tonic::server::Grpc::with_interceptor(codec, interceptor)
                        } else {
                            tonic::server::Grpc::new(codec)
                        };
                        let res = grpc.unary(method, req).await;
                        Ok(res)
                    };
                    Box::pin(fut)
                }
                "/google.ads.googleads.v1.services.GoogleAdsFieldService/SearchGoogleAdsFields" => {
                    #[allow(non_camel_case_types)]
                    struct SearchGoogleAdsFieldsSvc<T: GoogleAdsFieldService>(pub Arc<T>);
                    impl<T: GoogleAdsFieldService>
                        tonic::server::UnaryService<super::SearchGoogleAdsFieldsRequest>
                        for SearchGoogleAdsFieldsSvc<T>
                    {
                        type Response = super::SearchGoogleAdsFieldsResponse;
                        type Future = BoxFuture<tonic::Response<Self::Response>, tonic::Status>;
                        fn call(
                            &mut self,
                            request: tonic::Request<super::SearchGoogleAdsFieldsRequest>,
                        ) -> Self::Future {
                            let inner = self.0.clone();
                            let fut = async move { inner.search_google_ads_fields(request).await };
                            Box::pin(fut)
                        }
                    }
                    let inner = self.inner.clone();
                    let fut = async move {
                        let interceptor = inner.1.clone();
                        let inner = inner.0;
                        let method = SearchGoogleAdsFieldsSvc(inner);
                        let codec = tonic::codec::ProstCodec::default();
                        let mut grpc = if let Some(interceptor) = interceptor {
                            tonic::server::Grpc::with_interceptor(codec, interceptor)
                        } else {
                            tonic::server::Grpc::new(codec)
                        };
                        let res = grpc.unary(method, req).await;
                        Ok(res)
                    };
                    Box::pin(fut)
                }
                _ => Box::pin(async move {
                    Ok(http::Response::builder()
                        .status(200)
                        .header("grpc-status", "12")
                        .body(tonic::body::BoxBody::empty())
                        .unwrap())
                }),
            }
        }
    }
    impl<T: GoogleAdsFieldService> Clone for GoogleAdsFieldServiceServer<T> {
        fn clone(&self) -> Self {
            let inner = self.inner.clone();
            Self { inner }
        }
    }
    impl<T: GoogleAdsFieldService> Clone for _Inner<T> {
        fn clone(&self) -> Self {
            Self(self.0.clone(), self.1.clone())
        }
    }
    impl<T: std::fmt::Debug> std::fmt::Debug for _Inner<T> {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
            write!(f, "{:?}", self.0)
        }
    }
    impl<T: GoogleAdsFieldService> tonic::transport::NamedService for GoogleAdsFieldServiceServer<T> {
        const NAME: &'static str = "google.ads.googleads.v1.services.GoogleAdsFieldService";
    }
}
/// Request message for [LabelService.GetLabel][google.ads.googleads.v1.services.LabelService.GetLabel].
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GetLabelRequest {
    /// Required. The resource name of the label to fetch.
    #[prost(string, tag = "1")]
    pub resource_name: std::string::String,
}
/// Request message for [LabelService.MutateLabels][google.ads.googleads.v1.services.LabelService.MutateLabels].
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct MutateLabelsRequest {
    /// Required. ID of the customer whose labels are being modified.
    #[prost(string, tag = "1")]
    pub customer_id: std::string::String,
    /// Required. The list of operations to perform on labels.
    #[prost(message, repeated, tag = "2")]
    pub operations: ::std::vec::Vec<LabelOperation>,
    /// If true, successful operations will be carried out and invalid
    /// operations will return errors. If false, all operations will be carried
    /// out in one transaction if and only if they are all valid.
    /// Default is false.
    #[prost(bool, tag = "3")]
    pub partial_failure: bool,
    /// If true, the request is validated but not executed. Only errors are
    /// returned, not results.
    #[prost(bool, tag = "4")]
    pub validate_only: bool,
}
/// A single operation (create, remove, update) on a label.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct LabelOperation {
    /// FieldMask that determines which resource fields are modified in an update.
    #[prost(message, optional, tag = "4")]
    pub update_mask: ::std::option::Option<::prost_types::FieldMask>,
    /// The mutate operation.
    #[prost(oneof = "label_operation::Operation", tags = "1, 2, 3")]
    pub operation: ::std::option::Option<label_operation::Operation>,
}
pub mod label_operation {
    /// The mutate operation.
    #[derive(Clone, PartialEq, ::prost::Oneof)]
    pub enum Operation {
        /// Create operation: No resource name is expected for the new label.
        #[prost(message, tag = "1")]
        Create(super::super::resources::Label),
        /// Update operation: The label is expected to have a valid resource name.
        #[prost(message, tag = "2")]
        Update(super::super::resources::Label),
        /// Remove operation: A resource name for the label being removed, in
        /// this format:
        ///
        /// `customers/{customer_id}/labels/{label_id}`
        #[prost(string, tag = "3")]
        Remove(std::string::String),
    }
}
/// Response message for a labels mutate.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct MutateLabelsResponse {
    /// Errors that pertain to operation failures in the partial failure mode.
    /// Returned only when partial_failure = true and all errors occur inside the
    /// operations. If any errors occur outside the operations (e.g. auth errors),
    /// we return an RPC level error.
    #[prost(message, optional, tag = "3")]
    pub partial_failure_error: ::std::option::Option<super::super::super::super::rpc::Status>,
    /// All results for the mutate.
    #[prost(message, repeated, tag = "2")]
    pub results: ::std::vec::Vec<MutateLabelResult>,
}
/// The result for a label mutate.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct MutateLabelResult {
    /// Returned for successful operations.
    #[prost(string, tag = "1")]
    pub resource_name: std::string::String,
}
#[doc = r" Generated client implementations."]
pub mod label_service_client {
    #![allow(unused_variables, dead_code, missing_docs)]
    use tonic::codegen::*;
    #[doc = " Service to manage labels."]
    pub struct LabelServiceClient<T> {
        inner: tonic::client::Grpc<T>,
    }
    impl LabelServiceClient<tonic::transport::Channel> {
        #[doc = r" Attempt to create a new client by connecting to a given endpoint."]
        pub async fn connect<D>(dst: D) -> Result<Self, tonic::transport::Error>
        where
            D: std::convert::TryInto<tonic::transport::Endpoint>,
            D::Error: Into<StdError>,
        {
            let conn = tonic::transport::Endpoint::new(dst)?.connect().await?;
            Ok(Self::new(conn))
        }
    }
    impl<T> LabelServiceClient<T>
    where
        T: tonic::client::GrpcService<tonic::body::BoxBody>,
        T::ResponseBody: Body + HttpBody + Send + 'static,
        T::Error: Into<StdError>,
        <T::ResponseBody as HttpBody>::Error: Into<StdError> + Send,
    {
        pub fn new(inner: T) -> Self {
            let inner = tonic::client::Grpc::new(inner);
            Self { inner }
        }
        pub fn with_interceptor(inner: T, interceptor: impl Into<tonic::Interceptor>) -> Self {
            let inner = tonic::client::Grpc::with_interceptor(inner, interceptor);
            Self { inner }
        }
        #[doc = " Returns the requested label in full detail."]
        pub async fn get_label(
            &mut self,
            request: impl tonic::IntoRequest<super::GetLabelRequest>,
        ) -> Result<tonic::Response<super::super::resources::Label>, tonic::Status> {
            self.inner.ready().await.map_err(|e| {
                tonic::Status::new(
                    tonic::Code::Unknown,
                    format!("Service was not ready: {}", e.into()),
                )
            })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.ads.googleads.v1.services.LabelService/GetLabel",
            );
            self.inner.unary(request.into_request(), path, codec).await
        }
        #[doc = " Creates, updates, or removes labels. Operation statuses are returned."]
        pub async fn mutate_labels(
            &mut self,
            request: impl tonic::IntoRequest<super::MutateLabelsRequest>,
        ) -> Result<tonic::Response<super::MutateLabelsResponse>, tonic::Status> {
            self.inner.ready().await.map_err(|e| {
                tonic::Status::new(
                    tonic::Code::Unknown,
                    format!("Service was not ready: {}", e.into()),
                )
            })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.ads.googleads.v1.services.LabelService/MutateLabels",
            );
            self.inner.unary(request.into_request(), path, codec).await
        }
    }
    impl<T: Clone> Clone for LabelServiceClient<T> {
        fn clone(&self) -> Self {
            Self {
                inner: self.inner.clone(),
            }
        }
    }
    impl<T> std::fmt::Debug for LabelServiceClient<T> {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
            write!(f, "LabelServiceClient {{ ... }}")
        }
    }
}
#[doc = r" Generated server implementations."]
pub mod label_service_server {
    #![allow(unused_variables, dead_code, missing_docs)]
    use tonic::codegen::*;
    #[doc = "Generated trait containing gRPC methods that should be implemented for use with LabelServiceServer."]
    #[async_trait]
    pub trait LabelService: Send + Sync + 'static {
        #[doc = " Returns the requested label in full detail."]
        async fn get_label(
            &self,
            request: tonic::Request<super::GetLabelRequest>,
        ) -> Result<tonic::Response<super::super::resources::Label>, tonic::Status>;
        #[doc = " Creates, updates, or removes labels. Operation statuses are returned."]
        async fn mutate_labels(
            &self,
            request: tonic::Request<super::MutateLabelsRequest>,
        ) -> Result<tonic::Response<super::MutateLabelsResponse>, tonic::Status>;
    }
    #[doc = " Service to manage labels."]
    #[derive(Debug)]
    #[doc(hidden)]
    pub struct LabelServiceServer<T: LabelService> {
        inner: _Inner<T>,
    }
    struct _Inner<T>(Arc<T>, Option<tonic::Interceptor>);
    impl<T: LabelService> LabelServiceServer<T> {
        pub fn new(inner: T) -> Self {
            let inner = Arc::new(inner);
            let inner = _Inner(inner, None);
            Self { inner }
        }
        pub fn with_interceptor(inner: T, interceptor: impl Into<tonic::Interceptor>) -> Self {
            let inner = Arc::new(inner);
            let inner = _Inner(inner, Some(interceptor.into()));
            Self { inner }
        }
    }
    impl<T, B> Service<http::Request<B>> for LabelServiceServer<T>
    where
        T: LabelService,
        B: HttpBody + Send + Sync + 'static,
        B::Error: Into<StdError> + Send + 'static,
    {
        type Response = http::Response<tonic::body::BoxBody>;
        type Error = Never;
        type Future = BoxFuture<Self::Response, Self::Error>;
        fn poll_ready(&mut self, _cx: &mut Context<'_>) -> Poll<Result<(), Self::Error>> {
            Poll::Ready(Ok(()))
        }
        fn call(&mut self, req: http::Request<B>) -> Self::Future {
            let inner = self.inner.clone();
            match req.uri().path() {
                "/google.ads.googleads.v1.services.LabelService/GetLabel" => {
                    #[allow(non_camel_case_types)]
                    struct GetLabelSvc<T: LabelService>(pub Arc<T>);
                    impl<T: LabelService> tonic::server::UnaryService<super::GetLabelRequest> for GetLabelSvc<T> {
                        type Response = super::super::resources::Label;
                        type Future = BoxFuture<tonic::Response<Self::Response>, tonic::Status>;
                        fn call(
                            &mut self,
                            request: tonic::Request<super::GetLabelRequest>,
                        ) -> Self::Future {
                            let inner = self.0.clone();
                            let fut = async move { inner.get_label(request).await };
                            Box::pin(fut)
                        }
                    }
                    let inner = self.inner.clone();
                    let fut = async move {
                        let interceptor = inner.1.clone();
                        let inner = inner.0;
                        let method = GetLabelSvc(inner);
                        let codec = tonic::codec::ProstCodec::default();
                        let mut grpc = if let Some(interceptor) = interceptor {
                            tonic::server::Grpc::with_interceptor(codec, interceptor)
                        } else {
                            tonic::server::Grpc::new(codec)
                        };
                        let res = grpc.unary(method, req).await;
                        Ok(res)
                    };
                    Box::pin(fut)
                }
                "/google.ads.googleads.v1.services.LabelService/MutateLabels" => {
                    #[allow(non_camel_case_types)]
                    struct MutateLabelsSvc<T: LabelService>(pub Arc<T>);
                    impl<T: LabelService> tonic::server::UnaryService<super::MutateLabelsRequest>
                        for MutateLabelsSvc<T>
                    {
                        type Response = super::MutateLabelsResponse;
                        type Future = BoxFuture<tonic::Response<Self::Response>, tonic::Status>;
                        fn call(
                            &mut self,
                            request: tonic::Request<super::MutateLabelsRequest>,
                        ) -> Self::Future {
                            let inner = self.0.clone();
                            let fut = async move { inner.mutate_labels(request).await };
                            Box::pin(fut)
                        }
                    }
                    let inner = self.inner.clone();
                    let fut = async move {
                        let interceptor = inner.1.clone();
                        let inner = inner.0;
                        let method = MutateLabelsSvc(inner);
                        let codec = tonic::codec::ProstCodec::default();
                        let mut grpc = if let Some(interceptor) = interceptor {
                            tonic::server::Grpc::with_interceptor(codec, interceptor)
                        } else {
                            tonic::server::Grpc::new(codec)
                        };
                        let res = grpc.unary(method, req).await;
                        Ok(res)
                    };
                    Box::pin(fut)
                }
                _ => Box::pin(async move {
                    Ok(http::Response::builder()
                        .status(200)
                        .header("grpc-status", "12")
                        .body(tonic::body::BoxBody::empty())
                        .unwrap())
                }),
            }
        }
    }
    impl<T: LabelService> Clone for LabelServiceServer<T> {
        fn clone(&self) -> Self {
            let inner = self.inner.clone();
            Self { inner }
        }
    }
    impl<T: LabelService> Clone for _Inner<T> {
        fn clone(&self) -> Self {
            Self(self.0.clone(), self.1.clone())
        }
    }
    impl<T: std::fmt::Debug> std::fmt::Debug for _Inner<T> {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
            write!(f, "{:?}", self.0)
        }
    }
    impl<T: LabelService> tonic::transport::NamedService for LabelServiceServer<T> {
        const NAME: &'static str = "google.ads.googleads.v1.services.LabelService";
    }
}
/// Request message for [MediaFileService.GetMediaFile][google.ads.googleads.v1.services.MediaFileService.GetMediaFile]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GetMediaFileRequest {
    /// Required. The resource name of the media file to fetch.
    #[prost(string, tag = "1")]
    pub resource_name: std::string::String,
}
/// Request message for [MediaFileService.MutateMediaFiles][google.ads.googleads.v1.services.MediaFileService.MutateMediaFiles]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct MutateMediaFilesRequest {
    /// Required. The ID of the customer whose media files are being modified.
    #[prost(string, tag = "1")]
    pub customer_id: std::string::String,
    /// Required. The list of operations to perform on individual media file.
    #[prost(message, repeated, tag = "2")]
    pub operations: ::std::vec::Vec<MediaFileOperation>,
    /// If true, successful operations will be carried out and invalid
    /// operations will return errors. If false, all operations will be carried
    /// out in one transaction if and only if they are all valid.
    /// Default is false.
    #[prost(bool, tag = "3")]
    pub partial_failure: bool,
    /// If true, the request is validated but not executed. Only errors are
    /// returned, not results.
    #[prost(bool, tag = "4")]
    pub validate_only: bool,
}
/// A single operation to create media file.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct MediaFileOperation {
    /// The mutate operation.
    #[prost(oneof = "media_file_operation::Operation", tags = "1")]
    pub operation: ::std::option::Option<media_file_operation::Operation>,
}
pub mod media_file_operation {
    /// The mutate operation.
    #[derive(Clone, PartialEq, ::prost::Oneof)]
    pub enum Operation {
        /// Create operation: No resource name is expected for the new media file.
        #[prost(message, tag = "1")]
        Create(super::super::resources::MediaFile),
    }
}
/// Response message for a media file mutate.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct MutateMediaFilesResponse {
    /// Errors that pertain to operation failures in the partial failure mode.
    /// Returned only when partial_failure = true and all errors occur inside the
    /// operations. If any errors occur outside the operations (e.g. auth errors),
    /// we return an RPC level error.
    #[prost(message, optional, tag = "3")]
    pub partial_failure_error: ::std::option::Option<super::super::super::super::rpc::Status>,
    /// All results for the mutate.
    #[prost(message, repeated, tag = "2")]
    pub results: ::std::vec::Vec<MutateMediaFileResult>,
}
/// The result for the media file mutate.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct MutateMediaFileResult {
    /// The resource name returned for successful operations.
    #[prost(string, tag = "1")]
    pub resource_name: std::string::String,
}
#[doc = r" Generated client implementations."]
pub mod media_file_service_client {
    #![allow(unused_variables, dead_code, missing_docs)]
    use tonic::codegen::*;
    #[doc = " Service to manage media files."]
    pub struct MediaFileServiceClient<T> {
        inner: tonic::client::Grpc<T>,
    }
    impl MediaFileServiceClient<tonic::transport::Channel> {
        #[doc = r" Attempt to create a new client by connecting to a given endpoint."]
        pub async fn connect<D>(dst: D) -> Result<Self, tonic::transport::Error>
        where
            D: std::convert::TryInto<tonic::transport::Endpoint>,
            D::Error: Into<StdError>,
        {
            let conn = tonic::transport::Endpoint::new(dst)?.connect().await?;
            Ok(Self::new(conn))
        }
    }
    impl<T> MediaFileServiceClient<T>
    where
        T: tonic::client::GrpcService<tonic::body::BoxBody>,
        T::ResponseBody: Body + HttpBody + Send + 'static,
        T::Error: Into<StdError>,
        <T::ResponseBody as HttpBody>::Error: Into<StdError> + Send,
    {
        pub fn new(inner: T) -> Self {
            let inner = tonic::client::Grpc::new(inner);
            Self { inner }
        }
        pub fn with_interceptor(inner: T, interceptor: impl Into<tonic::Interceptor>) -> Self {
            let inner = tonic::client::Grpc::with_interceptor(inner, interceptor);
            Self { inner }
        }
        #[doc = " Returns the requested media file in full detail."]
        pub async fn get_media_file(
            &mut self,
            request: impl tonic::IntoRequest<super::GetMediaFileRequest>,
        ) -> Result<tonic::Response<super::super::resources::MediaFile>, tonic::Status> {
            self.inner.ready().await.map_err(|e| {
                tonic::Status::new(
                    tonic::Code::Unknown,
                    format!("Service was not ready: {}", e.into()),
                )
            })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.ads.googleads.v1.services.MediaFileService/GetMediaFile",
            );
            self.inner.unary(request.into_request(), path, codec).await
        }
        #[doc = " Creates media files. Operation statuses are returned."]
        pub async fn mutate_media_files(
            &mut self,
            request: impl tonic::IntoRequest<super::MutateMediaFilesRequest>,
        ) -> Result<tonic::Response<super::MutateMediaFilesResponse>, tonic::Status> {
            self.inner.ready().await.map_err(|e| {
                tonic::Status::new(
                    tonic::Code::Unknown,
                    format!("Service was not ready: {}", e.into()),
                )
            })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.ads.googleads.v1.services.MediaFileService/MutateMediaFiles",
            );
            self.inner.unary(request.into_request(), path, codec).await
        }
    }
    impl<T: Clone> Clone for MediaFileServiceClient<T> {
        fn clone(&self) -> Self {
            Self {
                inner: self.inner.clone(),
            }
        }
    }
    impl<T> std::fmt::Debug for MediaFileServiceClient<T> {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
            write!(f, "MediaFileServiceClient {{ ... }}")
        }
    }
}
#[doc = r" Generated server implementations."]
pub mod media_file_service_server {
    #![allow(unused_variables, dead_code, missing_docs)]
    use tonic::codegen::*;
    #[doc = "Generated trait containing gRPC methods that should be implemented for use with MediaFileServiceServer."]
    #[async_trait]
    pub trait MediaFileService: Send + Sync + 'static {
        #[doc = " Returns the requested media file in full detail."]
        async fn get_media_file(
            &self,
            request: tonic::Request<super::GetMediaFileRequest>,
        ) -> Result<tonic::Response<super::super::resources::MediaFile>, tonic::Status>;
        #[doc = " Creates media files. Operation statuses are returned."]
        async fn mutate_media_files(
            &self,
            request: tonic::Request<super::MutateMediaFilesRequest>,
        ) -> Result<tonic::Response<super::MutateMediaFilesResponse>, tonic::Status>;
    }
    #[doc = " Service to manage media files."]
    #[derive(Debug)]
    #[doc(hidden)]
    pub struct MediaFileServiceServer<T: MediaFileService> {
        inner: _Inner<T>,
    }
    struct _Inner<T>(Arc<T>, Option<tonic::Interceptor>);
    impl<T: MediaFileService> MediaFileServiceServer<T> {
        pub fn new(inner: T) -> Self {
            let inner = Arc::new(inner);
            let inner = _Inner(inner, None);
            Self { inner }
        }
        pub fn with_interceptor(inner: T, interceptor: impl Into<tonic::Interceptor>) -> Self {
            let inner = Arc::new(inner);
            let inner = _Inner(inner, Some(interceptor.into()));
            Self { inner }
        }
    }
    impl<T, B> Service<http::Request<B>> for MediaFileServiceServer<T>
    where
        T: MediaFileService,
        B: HttpBody + Send + Sync + 'static,
        B::Error: Into<StdError> + Send + 'static,
    {
        type Response = http::Response<tonic::body::BoxBody>;
        type Error = Never;
        type Future = BoxFuture<Self::Response, Self::Error>;
        fn poll_ready(&mut self, _cx: &mut Context<'_>) -> Poll<Result<(), Self::Error>> {
            Poll::Ready(Ok(()))
        }
        fn call(&mut self, req: http::Request<B>) -> Self::Future {
            let inner = self.inner.clone();
            match req.uri().path() {
                "/google.ads.googleads.v1.services.MediaFileService/GetMediaFile" => {
                    #[allow(non_camel_case_types)]
                    struct GetMediaFileSvc<T: MediaFileService>(pub Arc<T>);
                    impl<T: MediaFileService>
                        tonic::server::UnaryService<super::GetMediaFileRequest>
                        for GetMediaFileSvc<T>
                    {
                        type Response = super::super::resources::MediaFile;
                        type Future = BoxFuture<tonic::Response<Self::Response>, tonic::Status>;
                        fn call(
                            &mut self,
                            request: tonic::Request<super::GetMediaFileRequest>,
                        ) -> Self::Future {
                            let inner = self.0.clone();
                            let fut = async move { inner.get_media_file(request).await };
                            Box::pin(fut)
                        }
                    }
                    let inner = self.inner.clone();
                    let fut = async move {
                        let interceptor = inner.1.clone();
                        let inner = inner.0;
                        let method = GetMediaFileSvc(inner);
                        let codec = tonic::codec::ProstCodec::default();
                        let mut grpc = if let Some(interceptor) = interceptor {
                            tonic::server::Grpc::with_interceptor(codec, interceptor)
                        } else {
                            tonic::server::Grpc::new(codec)
                        };
                        let res = grpc.unary(method, req).await;
                        Ok(res)
                    };
                    Box::pin(fut)
                }
                "/google.ads.googleads.v1.services.MediaFileService/MutateMediaFiles" => {
                    #[allow(non_camel_case_types)]
                    struct MutateMediaFilesSvc<T: MediaFileService>(pub Arc<T>);
                    impl<T: MediaFileService>
                        tonic::server::UnaryService<super::MutateMediaFilesRequest>
                        for MutateMediaFilesSvc<T>
                    {
                        type Response = super::MutateMediaFilesResponse;
                        type Future = BoxFuture<tonic::Response<Self::Response>, tonic::Status>;
                        fn call(
                            &mut self,
                            request: tonic::Request<super::MutateMediaFilesRequest>,
                        ) -> Self::Future {
                            let inner = self.0.clone();
                            let fut = async move { inner.mutate_media_files(request).await };
                            Box::pin(fut)
                        }
                    }
                    let inner = self.inner.clone();
                    let fut = async move {
                        let interceptor = inner.1.clone();
                        let inner = inner.0;
                        let method = MutateMediaFilesSvc(inner);
                        let codec = tonic::codec::ProstCodec::default();
                        let mut grpc = if let Some(interceptor) = interceptor {
                            tonic::server::Grpc::with_interceptor(codec, interceptor)
                        } else {
                            tonic::server::Grpc::new(codec)
                        };
                        let res = grpc.unary(method, req).await;
                        Ok(res)
                    };
                    Box::pin(fut)
                }
                _ => Box::pin(async move {
                    Ok(http::Response::builder()
                        .status(200)
                        .header("grpc-status", "12")
                        .body(tonic::body::BoxBody::empty())
                        .unwrap())
                }),
            }
        }
    }
    impl<T: MediaFileService> Clone for MediaFileServiceServer<T> {
        fn clone(&self) -> Self {
            let inner = self.inner.clone();
            Self { inner }
        }
    }
    impl<T: MediaFileService> Clone for _Inner<T> {
        fn clone(&self) -> Self {
            Self(self.0.clone(), self.1.clone())
        }
    }
    impl<T: std::fmt::Debug> std::fmt::Debug for _Inner<T> {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
            write!(f, "{:?}", self.0)
        }
    }
    impl<T: MediaFileService> tonic::transport::NamedService for MediaFileServiceServer<T> {
        const NAME: &'static str = "google.ads.googleads.v1.services.MediaFileService";
    }
}
/// Request message for [RemarketingActionService.GetRemarketingAction][google.ads.googleads.v1.services.RemarketingActionService.GetRemarketingAction].
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GetRemarketingActionRequest {
    /// Required. The resource name of the remarketing action to fetch.
    #[prost(string, tag = "1")]
    pub resource_name: std::string::String,
}
/// Request message for [RemarketingActionService.MutateRemarketingActions][google.ads.googleads.v1.services.RemarketingActionService.MutateRemarketingActions].
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct MutateRemarketingActionsRequest {
    /// Required. The ID of the customer whose remarketing actions are being modified.
    #[prost(string, tag = "1")]
    pub customer_id: std::string::String,
    /// Required. The list of operations to perform on individual remarketing actions.
    #[prost(message, repeated, tag = "2")]
    pub operations: ::std::vec::Vec<RemarketingActionOperation>,
    /// If true, successful operations will be carried out and invalid
    /// operations will return errors. If false, all operations will be carried
    /// out in one transaction if and only if they are all valid.
    /// Default is false.
    #[prost(bool, tag = "3")]
    pub partial_failure: bool,
    /// If true, the request is validated but not executed. Only errors are
    /// returned, not results.
    #[prost(bool, tag = "4")]
    pub validate_only: bool,
}
/// A single operation (create, update) on a remarketing action.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct RemarketingActionOperation {
    /// FieldMask that determines which resource fields are modified in an update.
    #[prost(message, optional, tag = "4")]
    pub update_mask: ::std::option::Option<::prost_types::FieldMask>,
    /// The mutate operation.
    #[prost(oneof = "remarketing_action_operation::Operation", tags = "1, 2")]
    pub operation: ::std::option::Option<remarketing_action_operation::Operation>,
}
pub mod remarketing_action_operation {
    /// The mutate operation.
    #[derive(Clone, PartialEq, ::prost::Oneof)]
    pub enum Operation {
        /// Create operation: No resource name is expected for the new remarketing
        /// action.
        #[prost(message, tag = "1")]
        Create(super::super::resources::RemarketingAction),
        /// Update operation: The remarketing action is expected to have a valid
        /// resource name.
        #[prost(message, tag = "2")]
        Update(super::super::resources::RemarketingAction),
    }
}
/// Response message for remarketing action mutate.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct MutateRemarketingActionsResponse {
    /// Errors that pertain to operation failures in the partial failure mode.
    /// Returned only when partial_failure = true and all errors occur inside the
    /// operations. If any errors occur outside the operations (e.g. auth errors),
    /// we return an RPC level error.
    #[prost(message, optional, tag = "3")]
    pub partial_failure_error: ::std::option::Option<super::super::super::super::rpc::Status>,
    /// All results for the mutate.
    #[prost(message, repeated, tag = "2")]
    pub results: ::std::vec::Vec<MutateRemarketingActionResult>,
}
/// The result for the remarketing action mutate.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct MutateRemarketingActionResult {
    /// Returned for successful operations.
    #[prost(string, tag = "1")]
    pub resource_name: std::string::String,
}
#[doc = r" Generated client implementations."]
pub mod remarketing_action_service_client {
    #![allow(unused_variables, dead_code, missing_docs)]
    use tonic::codegen::*;
    #[doc = " Service to manage remarketing actions."]
    pub struct RemarketingActionServiceClient<T> {
        inner: tonic::client::Grpc<T>,
    }
    impl RemarketingActionServiceClient<tonic::transport::Channel> {
        #[doc = r" Attempt to create a new client by connecting to a given endpoint."]
        pub async fn connect<D>(dst: D) -> Result<Self, tonic::transport::Error>
        where
            D: std::convert::TryInto<tonic::transport::Endpoint>,
            D::Error: Into<StdError>,
        {
            let conn = tonic::transport::Endpoint::new(dst)?.connect().await?;
            Ok(Self::new(conn))
        }
    }
    impl<T> RemarketingActionServiceClient<T>
    where
        T: tonic::client::GrpcService<tonic::body::BoxBody>,
        T::ResponseBody: Body + HttpBody + Send + 'static,
        T::Error: Into<StdError>,
        <T::ResponseBody as HttpBody>::Error: Into<StdError> + Send,
    {
        pub fn new(inner: T) -> Self {
            let inner = tonic::client::Grpc::new(inner);
            Self { inner }
        }
        pub fn with_interceptor(inner: T, interceptor: impl Into<tonic::Interceptor>) -> Self {
            let inner = tonic::client::Grpc::with_interceptor(inner, interceptor);
            Self { inner }
        }
        #[doc = " Returns the requested remarketing action in full detail."]
        pub async fn get_remarketing_action(
            &mut self,
            request: impl tonic::IntoRequest<super::GetRemarketingActionRequest>,
        ) -> Result<tonic::Response<super::super::resources::RemarketingAction>, tonic::Status>
        {
            self.inner.ready().await.map_err(|e| {
                tonic::Status::new(
                    tonic::Code::Unknown,
                    format!("Service was not ready: {}", e.into()),
                )
            })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.ads.googleads.v1.services.RemarketingActionService/GetRemarketingAction",
            );
            self.inner.unary(request.into_request(), path, codec).await
        }
        #[doc = " Creates or updates remarketing actions. Operation statuses are returned."]
        pub async fn mutate_remarketing_actions(
            &mut self,
            request: impl tonic::IntoRequest<super::MutateRemarketingActionsRequest>,
        ) -> Result<tonic::Response<super::MutateRemarketingActionsResponse>, tonic::Status>
        {
            self.inner.ready().await.map_err(|e| {
                tonic::Status::new(
                    tonic::Code::Unknown,
                    format!("Service was not ready: {}", e.into()),
                )
            })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http :: uri :: PathAndQuery :: from_static ( "/google.ads.googleads.v1.services.RemarketingActionService/MutateRemarketingActions" ) ;
            self.inner.unary(request.into_request(), path, codec).await
        }
    }
    impl<T: Clone> Clone for RemarketingActionServiceClient<T> {
        fn clone(&self) -> Self {
            Self {
                inner: self.inner.clone(),
            }
        }
    }
    impl<T> std::fmt::Debug for RemarketingActionServiceClient<T> {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
            write!(f, "RemarketingActionServiceClient {{ ... }}")
        }
    }
}
#[doc = r" Generated server implementations."]
pub mod remarketing_action_service_server {
    #![allow(unused_variables, dead_code, missing_docs)]
    use tonic::codegen::*;
    #[doc = "Generated trait containing gRPC methods that should be implemented for use with RemarketingActionServiceServer."]
    #[async_trait]
    pub trait RemarketingActionService: Send + Sync + 'static {
        #[doc = " Returns the requested remarketing action in full detail."]
        async fn get_remarketing_action(
            &self,
            request: tonic::Request<super::GetRemarketingActionRequest>,
        ) -> Result<tonic::Response<super::super::resources::RemarketingAction>, tonic::Status>;
        #[doc = " Creates or updates remarketing actions. Operation statuses are returned."]
        async fn mutate_remarketing_actions(
            &self,
            request: tonic::Request<super::MutateRemarketingActionsRequest>,
        ) -> Result<tonic::Response<super::MutateRemarketingActionsResponse>, tonic::Status>;
    }
    #[doc = " Service to manage remarketing actions."]
    #[derive(Debug)]
    #[doc(hidden)]
    pub struct RemarketingActionServiceServer<T: RemarketingActionService> {
        inner: _Inner<T>,
    }
    struct _Inner<T>(Arc<T>, Option<tonic::Interceptor>);
    impl<T: RemarketingActionService> RemarketingActionServiceServer<T> {
        pub fn new(inner: T) -> Self {
            let inner = Arc::new(inner);
            let inner = _Inner(inner, None);
            Self { inner }
        }
        pub fn with_interceptor(inner: T, interceptor: impl Into<tonic::Interceptor>) -> Self {
            let inner = Arc::new(inner);
            let inner = _Inner(inner, Some(interceptor.into()));
            Self { inner }
        }
    }
    impl<T, B> Service<http::Request<B>> for RemarketingActionServiceServer<T>
    where
        T: RemarketingActionService,
        B: HttpBody + Send + Sync + 'static,
        B::Error: Into<StdError> + Send + 'static,
    {
        type Response = http::Response<tonic::body::BoxBody>;
        type Error = Never;
        type Future = BoxFuture<Self::Response, Self::Error>;
        fn poll_ready(&mut self, _cx: &mut Context<'_>) -> Poll<Result<(), Self::Error>> {
            Poll::Ready(Ok(()))
        }
        fn call(&mut self, req: http::Request<B>) -> Self::Future {
            let inner = self.inner.clone();
            match req . uri ( ) . path ( ) { "/google.ads.googleads.v1.services.RemarketingActionService/GetRemarketingAction" => { # [ allow ( non_camel_case_types ) ] struct GetRemarketingActionSvc < T : RemarketingActionService > ( pub Arc < T > ) ; impl < T : RemarketingActionService > tonic :: server :: UnaryService < super :: GetRemarketingActionRequest > for GetRemarketingActionSvc < T > { type Response = super :: super :: resources :: RemarketingAction ; type Future = BoxFuture < tonic :: Response < Self :: Response > , tonic :: Status > ; fn call ( & mut self , request : tonic :: Request < super :: GetRemarketingActionRequest > ) -> Self :: Future { let inner = self . 0 . clone ( ) ; let fut = async move { inner . get_remarketing_action ( request ) . await } ; Box :: pin ( fut ) } } let inner = self . inner . clone ( ) ; let fut = async move { let interceptor = inner . 1 . clone ( ) ; let inner = inner . 0 ; let method = GetRemarketingActionSvc ( inner ) ; let codec = tonic :: codec :: ProstCodec :: default ( ) ; let mut grpc = if let Some ( interceptor ) = interceptor { tonic :: server :: Grpc :: with_interceptor ( codec , interceptor ) } else { tonic :: server :: Grpc :: new ( codec ) } ; let res = grpc . unary ( method , req ) . await ; Ok ( res ) } ; Box :: pin ( fut ) } "/google.ads.googleads.v1.services.RemarketingActionService/MutateRemarketingActions" => { # [ allow ( non_camel_case_types ) ] struct MutateRemarketingActionsSvc < T : RemarketingActionService > ( pub Arc < T > ) ; impl < T : RemarketingActionService > tonic :: server :: UnaryService < super :: MutateRemarketingActionsRequest > for MutateRemarketingActionsSvc < T > { type Response = super :: MutateRemarketingActionsResponse ; type Future = BoxFuture < tonic :: Response < Self :: Response > , tonic :: Status > ; fn call ( & mut self , request : tonic :: Request < super :: MutateRemarketingActionsRequest > ) -> Self :: Future { let inner = self . 0 . clone ( ) ; let fut = async move { inner . mutate_remarketing_actions ( request ) . await } ; Box :: pin ( fut ) } } let inner = self . inner . clone ( ) ; let fut = async move { let interceptor = inner . 1 . clone ( ) ; let inner = inner . 0 ; let method = MutateRemarketingActionsSvc ( inner ) ; let codec = tonic :: codec :: ProstCodec :: default ( ) ; let mut grpc = if let Some ( interceptor ) = interceptor { tonic :: server :: Grpc :: with_interceptor ( codec , interceptor ) } else { tonic :: server :: Grpc :: new ( codec ) } ; let res = grpc . unary ( method , req ) . await ; Ok ( res ) } ; Box :: pin ( fut ) } _ => Box :: pin ( async move { Ok ( http :: Response :: builder ( ) . status ( 200 ) . header ( "grpc-status" , "12" ) . body ( tonic :: body :: BoxBody :: empty ( ) ) . unwrap ( ) ) } ) , }
        }
    }
    impl<T: RemarketingActionService> Clone for RemarketingActionServiceServer<T> {
        fn clone(&self) -> Self {
            let inner = self.inner.clone();
            Self { inner }
        }
    }
    impl<T: RemarketingActionService> Clone for _Inner<T> {
        fn clone(&self) -> Self {
            Self(self.0.clone(), self.1.clone())
        }
    }
    impl<T: std::fmt::Debug> std::fmt::Debug for _Inner<T> {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
            write!(f, "{:?}", self.0)
        }
    }
    impl<T: RemarketingActionService> tonic::transport::NamedService
        for RemarketingActionServiceServer<T>
    {
        const NAME: &'static str = "google.ads.googleads.v1.services.RemarketingActionService";
    }
}
/// Request message for [SharedCriterionService.GetSharedCriterion][google.ads.googleads.v1.services.SharedCriterionService.GetSharedCriterion].
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GetSharedCriterionRequest {
    /// Required. The resource name of the shared criterion to fetch.
    #[prost(string, tag = "1")]
    pub resource_name: std::string::String,
}
/// Request message for [SharedCriterionService.MutateSharedCriteria][google.ads.googleads.v1.services.SharedCriterionService.MutateSharedCriteria].
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct MutateSharedCriteriaRequest {
    /// Required. The ID of the customer whose shared criteria are being modified.
    #[prost(string, tag = "1")]
    pub customer_id: std::string::String,
    /// Required. The list of operations to perform on individual shared criteria.
    #[prost(message, repeated, tag = "2")]
    pub operations: ::std::vec::Vec<SharedCriterionOperation>,
    /// If true, successful operations will be carried out and invalid
    /// operations will return errors. If false, all operations will be carried
    /// out in one transaction if and only if they are all valid.
    /// Default is false.
    #[prost(bool, tag = "3")]
    pub partial_failure: bool,
    /// If true, the request is validated but not executed. Only errors are
    /// returned, not results.
    #[prost(bool, tag = "4")]
    pub validate_only: bool,
}
/// A single operation (create, remove) on an shared criterion.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct SharedCriterionOperation {
    /// The mutate operation.
    #[prost(oneof = "shared_criterion_operation::Operation", tags = "1, 3")]
    pub operation: ::std::option::Option<shared_criterion_operation::Operation>,
}
pub mod shared_criterion_operation {
    /// The mutate operation.
    #[derive(Clone, PartialEq, ::prost::Oneof)]
    pub enum Operation {
        /// Create operation: No resource name is expected for the new shared
        /// criterion.
        #[prost(message, tag = "1")]
        Create(super::super::resources::SharedCriterion),
        /// Remove operation: A resource name for the removed shared criterion is
        /// expected, in this format:
        ///
        /// `customers/{customer_id}/sharedCriteria/{shared_set_id}~{criterion_id}`
        #[prost(string, tag = "3")]
        Remove(std::string::String),
    }
}
/// Response message for a shared criterion mutate.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct MutateSharedCriteriaResponse {
    /// Errors that pertain to operation failures in the partial failure mode.
    /// Returned only when partial_failure = true and all errors occur inside the
    /// operations. If any errors occur outside the operations (e.g. auth errors),
    /// we return an RPC level error.
    #[prost(message, optional, tag = "3")]
    pub partial_failure_error: ::std::option::Option<super::super::super::super::rpc::Status>,
    /// All results for the mutate.
    #[prost(message, repeated, tag = "2")]
    pub results: ::std::vec::Vec<MutateSharedCriterionResult>,
}
/// The result for the shared criterion mutate.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct MutateSharedCriterionResult {
    /// Returned for successful operations.
    #[prost(string, tag = "1")]
    pub resource_name: std::string::String,
}
#[doc = r" Generated client implementations."]
pub mod shared_criterion_service_client {
    #![allow(unused_variables, dead_code, missing_docs)]
    use tonic::codegen::*;
    #[doc = " Service to manage shared criteria."]
    pub struct SharedCriterionServiceClient<T> {
        inner: tonic::client::Grpc<T>,
    }
    impl SharedCriterionServiceClient<tonic::transport::Channel> {
        #[doc = r" Attempt to create a new client by connecting to a given endpoint."]
        pub async fn connect<D>(dst: D) -> Result<Self, tonic::transport::Error>
        where
            D: std::convert::TryInto<tonic::transport::Endpoint>,
            D::Error: Into<StdError>,
        {
            let conn = tonic::transport::Endpoint::new(dst)?.connect().await?;
            Ok(Self::new(conn))
        }
    }
    impl<T> SharedCriterionServiceClient<T>
    where
        T: tonic::client::GrpcService<tonic::body::BoxBody>,
        T::ResponseBody: Body + HttpBody + Send + 'static,
        T::Error: Into<StdError>,
        <T::ResponseBody as HttpBody>::Error: Into<StdError> + Send,
    {
        pub fn new(inner: T) -> Self {
            let inner = tonic::client::Grpc::new(inner);
            Self { inner }
        }
        pub fn with_interceptor(inner: T, interceptor: impl Into<tonic::Interceptor>) -> Self {
            let inner = tonic::client::Grpc::with_interceptor(inner, interceptor);
            Self { inner }
        }
        #[doc = " Returns the requested shared criterion in full detail."]
        pub async fn get_shared_criterion(
            &mut self,
            request: impl tonic::IntoRequest<super::GetSharedCriterionRequest>,
        ) -> Result<tonic::Response<super::super::resources::SharedCriterion>, tonic::Status>
        {
            self.inner.ready().await.map_err(|e| {
                tonic::Status::new(
                    tonic::Code::Unknown,
                    format!("Service was not ready: {}", e.into()),
                )
            })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.ads.googleads.v1.services.SharedCriterionService/GetSharedCriterion",
            );
            self.inner.unary(request.into_request(), path, codec).await
        }
        #[doc = " Creates or removes shared criteria. Operation statuses are returned."]
        pub async fn mutate_shared_criteria(
            &mut self,
            request: impl tonic::IntoRequest<super::MutateSharedCriteriaRequest>,
        ) -> Result<tonic::Response<super::MutateSharedCriteriaResponse>, tonic::Status> {
            self.inner.ready().await.map_err(|e| {
                tonic::Status::new(
                    tonic::Code::Unknown,
                    format!("Service was not ready: {}", e.into()),
                )
            })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.ads.googleads.v1.services.SharedCriterionService/MutateSharedCriteria",
            );
            self.inner.unary(request.into_request(), path, codec).await
        }
    }
    impl<T: Clone> Clone for SharedCriterionServiceClient<T> {
        fn clone(&self) -> Self {
            Self {
                inner: self.inner.clone(),
            }
        }
    }
    impl<T> std::fmt::Debug for SharedCriterionServiceClient<T> {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
            write!(f, "SharedCriterionServiceClient {{ ... }}")
        }
    }
}
#[doc = r" Generated server implementations."]
pub mod shared_criterion_service_server {
    #![allow(unused_variables, dead_code, missing_docs)]
    use tonic::codegen::*;
    #[doc = "Generated trait containing gRPC methods that should be implemented for use with SharedCriterionServiceServer."]
    #[async_trait]
    pub trait SharedCriterionService: Send + Sync + 'static {
        #[doc = " Returns the requested shared criterion in full detail."]
        async fn get_shared_criterion(
            &self,
            request: tonic::Request<super::GetSharedCriterionRequest>,
        ) -> Result<tonic::Response<super::super::resources::SharedCriterion>, tonic::Status>;
        #[doc = " Creates or removes shared criteria. Operation statuses are returned."]
        async fn mutate_shared_criteria(
            &self,
            request: tonic::Request<super::MutateSharedCriteriaRequest>,
        ) -> Result<tonic::Response<super::MutateSharedCriteriaResponse>, tonic::Status>;
    }
    #[doc = " Service to manage shared criteria."]
    #[derive(Debug)]
    #[doc(hidden)]
    pub struct SharedCriterionServiceServer<T: SharedCriterionService> {
        inner: _Inner<T>,
    }
    struct _Inner<T>(Arc<T>, Option<tonic::Interceptor>);
    impl<T: SharedCriterionService> SharedCriterionServiceServer<T> {
        pub fn new(inner: T) -> Self {
            let inner = Arc::new(inner);
            let inner = _Inner(inner, None);
            Self { inner }
        }
        pub fn with_interceptor(inner: T, interceptor: impl Into<tonic::Interceptor>) -> Self {
            let inner = Arc::new(inner);
            let inner = _Inner(inner, Some(interceptor.into()));
            Self { inner }
        }
    }
    impl<T, B> Service<http::Request<B>> for SharedCriterionServiceServer<T>
    where
        T: SharedCriterionService,
        B: HttpBody + Send + Sync + 'static,
        B::Error: Into<StdError> + Send + 'static,
    {
        type Response = http::Response<tonic::body::BoxBody>;
        type Error = Never;
        type Future = BoxFuture<Self::Response, Self::Error>;
        fn poll_ready(&mut self, _cx: &mut Context<'_>) -> Poll<Result<(), Self::Error>> {
            Poll::Ready(Ok(()))
        }
        fn call(&mut self, req: http::Request<B>) -> Self::Future {
            let inner = self.inner.clone();
            match req.uri().path() {
                "/google.ads.googleads.v1.services.SharedCriterionService/GetSharedCriterion" => {
                    #[allow(non_camel_case_types)]
                    struct GetSharedCriterionSvc<T: SharedCriterionService>(pub Arc<T>);
                    impl<T: SharedCriterionService>
                        tonic::server::UnaryService<super::GetSharedCriterionRequest>
                        for GetSharedCriterionSvc<T>
                    {
                        type Response = super::super::resources::SharedCriterion;
                        type Future = BoxFuture<tonic::Response<Self::Response>, tonic::Status>;
                        fn call(
                            &mut self,
                            request: tonic::Request<super::GetSharedCriterionRequest>,
                        ) -> Self::Future {
                            let inner = self.0.clone();
                            let fut = async move { inner.get_shared_criterion(request).await };
                            Box::pin(fut)
                        }
                    }
                    let inner = self.inner.clone();
                    let fut = async move {
                        let interceptor = inner.1.clone();
                        let inner = inner.0;
                        let method = GetSharedCriterionSvc(inner);
                        let codec = tonic::codec::ProstCodec::default();
                        let mut grpc = if let Some(interceptor) = interceptor {
                            tonic::server::Grpc::with_interceptor(codec, interceptor)
                        } else {
                            tonic::server::Grpc::new(codec)
                        };
                        let res = grpc.unary(method, req).await;
                        Ok(res)
                    };
                    Box::pin(fut)
                }
                "/google.ads.googleads.v1.services.SharedCriterionService/MutateSharedCriteria" => {
                    #[allow(non_camel_case_types)]
                    struct MutateSharedCriteriaSvc<T: SharedCriterionService>(pub Arc<T>);
                    impl<T: SharedCriterionService>
                        tonic::server::UnaryService<super::MutateSharedCriteriaRequest>
                        for MutateSharedCriteriaSvc<T>
                    {
                        type Response = super::MutateSharedCriteriaResponse;
                        type Future = BoxFuture<tonic::Response<Self::Response>, tonic::Status>;
                        fn call(
                            &mut self,
                            request: tonic::Request<super::MutateSharedCriteriaRequest>,
                        ) -> Self::Future {
                            let inner = self.0.clone();
                            let fut = async move { inner.mutate_shared_criteria(request).await };
                            Box::pin(fut)
                        }
                    }
                    let inner = self.inner.clone();
                    let fut = async move {
                        let interceptor = inner.1.clone();
                        let inner = inner.0;
                        let method = MutateSharedCriteriaSvc(inner);
                        let codec = tonic::codec::ProstCodec::default();
                        let mut grpc = if let Some(interceptor) = interceptor {
                            tonic::server::Grpc::with_interceptor(codec, interceptor)
                        } else {
                            tonic::server::Grpc::new(codec)
                        };
                        let res = grpc.unary(method, req).await;
                        Ok(res)
                    };
                    Box::pin(fut)
                }
                _ => Box::pin(async move {
                    Ok(http::Response::builder()
                        .status(200)
                        .header("grpc-status", "12")
                        .body(tonic::body::BoxBody::empty())
                        .unwrap())
                }),
            }
        }
    }
    impl<T: SharedCriterionService> Clone for SharedCriterionServiceServer<T> {
        fn clone(&self) -> Self {
            let inner = self.inner.clone();
            Self { inner }
        }
    }
    impl<T: SharedCriterionService> Clone for _Inner<T> {
        fn clone(&self) -> Self {
            Self(self.0.clone(), self.1.clone())
        }
    }
    impl<T: std::fmt::Debug> std::fmt::Debug for _Inner<T> {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
            write!(f, "{:?}", self.0)
        }
    }
    impl<T: SharedCriterionService> tonic::transport::NamedService for SharedCriterionServiceServer<T> {
        const NAME: &'static str = "google.ads.googleads.v1.services.SharedCriterionService";
    }
}
/// Request message for [SharedSetService.GetSharedSet][google.ads.googleads.v1.services.SharedSetService.GetSharedSet].
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GetSharedSetRequest {
    /// Required. The resource name of the shared set to fetch.
    #[prost(string, tag = "1")]
    pub resource_name: std::string::String,
}
/// Request message for [SharedSetService.MutateSharedSets][google.ads.googleads.v1.services.SharedSetService.MutateSharedSets].
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct MutateSharedSetsRequest {
    /// Required. The ID of the customer whose shared sets are being modified.
    #[prost(string, tag = "1")]
    pub customer_id: std::string::String,
    /// Required. The list of operations to perform on individual shared sets.
    #[prost(message, repeated, tag = "2")]
    pub operations: ::std::vec::Vec<SharedSetOperation>,
    /// If true, successful operations will be carried out and invalid
    /// operations will return errors. If false, all operations will be carried
    /// out in one transaction if and only if they are all valid.
    /// Default is false.
    #[prost(bool, tag = "3")]
    pub partial_failure: bool,
    /// If true, the request is validated but not executed. Only errors are
    /// returned, not results.
    #[prost(bool, tag = "4")]
    pub validate_only: bool,
}
/// A single operation (create, update, remove) on an shared set.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct SharedSetOperation {
    /// FieldMask that determines which resource fields are modified in an update.
    #[prost(message, optional, tag = "4")]
    pub update_mask: ::std::option::Option<::prost_types::FieldMask>,
    /// The mutate operation.
    #[prost(oneof = "shared_set_operation::Operation", tags = "1, 2, 3")]
    pub operation: ::std::option::Option<shared_set_operation::Operation>,
}
pub mod shared_set_operation {
    /// The mutate operation.
    #[derive(Clone, PartialEq, ::prost::Oneof)]
    pub enum Operation {
        /// Create operation: No resource name is expected for the new shared set.
        #[prost(message, tag = "1")]
        Create(super::super::resources::SharedSet),
        /// Update operation: The shared set is expected to have a valid resource
        /// name.
        #[prost(message, tag = "2")]
        Update(super::super::resources::SharedSet),
        /// Remove operation: A resource name for the removed shared set is expected,
        /// in this format:
        ///
        /// `customers/{customer_id}/sharedSets/{shared_set_id}`
        #[prost(string, tag = "3")]
        Remove(std::string::String),
    }
}
/// Response message for a shared set mutate.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct MutateSharedSetsResponse {
    /// Errors that pertain to operation failures in the partial failure mode.
    /// Returned only when partial_failure = true and all errors occur inside the
    /// operations. If any errors occur outside the operations (e.g. auth errors),
    /// we return an RPC level error.
    #[prost(message, optional, tag = "3")]
    pub partial_failure_error: ::std::option::Option<super::super::super::super::rpc::Status>,
    /// All results for the mutate.
    #[prost(message, repeated, tag = "2")]
    pub results: ::std::vec::Vec<MutateSharedSetResult>,
}
/// The result for the shared set mutate.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct MutateSharedSetResult {
    /// Returned for successful operations.
    #[prost(string, tag = "1")]
    pub resource_name: std::string::String,
}
#[doc = r" Generated client implementations."]
pub mod shared_set_service_client {
    #![allow(unused_variables, dead_code, missing_docs)]
    use tonic::codegen::*;
    #[doc = " Service to manage shared sets."]
    pub struct SharedSetServiceClient<T> {
        inner: tonic::client::Grpc<T>,
    }
    impl SharedSetServiceClient<tonic::transport::Channel> {
        #[doc = r" Attempt to create a new client by connecting to a given endpoint."]
        pub async fn connect<D>(dst: D) -> Result<Self, tonic::transport::Error>
        where
            D: std::convert::TryInto<tonic::transport::Endpoint>,
            D::Error: Into<StdError>,
        {
            let conn = tonic::transport::Endpoint::new(dst)?.connect().await?;
            Ok(Self::new(conn))
        }
    }
    impl<T> SharedSetServiceClient<T>
    where
        T: tonic::client::GrpcService<tonic::body::BoxBody>,
        T::ResponseBody: Body + HttpBody + Send + 'static,
        T::Error: Into<StdError>,
        <T::ResponseBody as HttpBody>::Error: Into<StdError> + Send,
    {
        pub fn new(inner: T) -> Self {
            let inner = tonic::client::Grpc::new(inner);
            Self { inner }
        }
        pub fn with_interceptor(inner: T, interceptor: impl Into<tonic::Interceptor>) -> Self {
            let inner = tonic::client::Grpc::with_interceptor(inner, interceptor);
            Self { inner }
        }
        #[doc = " Returns the requested shared set in full detail."]
        pub async fn get_shared_set(
            &mut self,
            request: impl tonic::IntoRequest<super::GetSharedSetRequest>,
        ) -> Result<tonic::Response<super::super::resources::SharedSet>, tonic::Status> {
            self.inner.ready().await.map_err(|e| {
                tonic::Status::new(
                    tonic::Code::Unknown,
                    format!("Service was not ready: {}", e.into()),
                )
            })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.ads.googleads.v1.services.SharedSetService/GetSharedSet",
            );
            self.inner.unary(request.into_request(), path, codec).await
        }
        #[doc = " Creates, updates, or removes shared sets. Operation statuses are returned."]
        pub async fn mutate_shared_sets(
            &mut self,
            request: impl tonic::IntoRequest<super::MutateSharedSetsRequest>,
        ) -> Result<tonic::Response<super::MutateSharedSetsResponse>, tonic::Status> {
            self.inner.ready().await.map_err(|e| {
                tonic::Status::new(
                    tonic::Code::Unknown,
                    format!("Service was not ready: {}", e.into()),
                )
            })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.ads.googleads.v1.services.SharedSetService/MutateSharedSets",
            );
            self.inner.unary(request.into_request(), path, codec).await
        }
    }
    impl<T: Clone> Clone for SharedSetServiceClient<T> {
        fn clone(&self) -> Self {
            Self {
                inner: self.inner.clone(),
            }
        }
    }
    impl<T> std::fmt::Debug for SharedSetServiceClient<T> {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
            write!(f, "SharedSetServiceClient {{ ... }}")
        }
    }
}
#[doc = r" Generated server implementations."]
pub mod shared_set_service_server {
    #![allow(unused_variables, dead_code, missing_docs)]
    use tonic::codegen::*;
    #[doc = "Generated trait containing gRPC methods that should be implemented for use with SharedSetServiceServer."]
    #[async_trait]
    pub trait SharedSetService: Send + Sync + 'static {
        #[doc = " Returns the requested shared set in full detail."]
        async fn get_shared_set(
            &self,
            request: tonic::Request<super::GetSharedSetRequest>,
        ) -> Result<tonic::Response<super::super::resources::SharedSet>, tonic::Status>;
        #[doc = " Creates, updates, or removes shared sets. Operation statuses are returned."]
        async fn mutate_shared_sets(
            &self,
            request: tonic::Request<super::MutateSharedSetsRequest>,
        ) -> Result<tonic::Response<super::MutateSharedSetsResponse>, tonic::Status>;
    }
    #[doc = " Service to manage shared sets."]
    #[derive(Debug)]
    #[doc(hidden)]
    pub struct SharedSetServiceServer<T: SharedSetService> {
        inner: _Inner<T>,
    }
    struct _Inner<T>(Arc<T>, Option<tonic::Interceptor>);
    impl<T: SharedSetService> SharedSetServiceServer<T> {
        pub fn new(inner: T) -> Self {
            let inner = Arc::new(inner);
            let inner = _Inner(inner, None);
            Self { inner }
        }
        pub fn with_interceptor(inner: T, interceptor: impl Into<tonic::Interceptor>) -> Self {
            let inner = Arc::new(inner);
            let inner = _Inner(inner, Some(interceptor.into()));
            Self { inner }
        }
    }
    impl<T, B> Service<http::Request<B>> for SharedSetServiceServer<T>
    where
        T: SharedSetService,
        B: HttpBody + Send + Sync + 'static,
        B::Error: Into<StdError> + Send + 'static,
    {
        type Response = http::Response<tonic::body::BoxBody>;
        type Error = Never;
        type Future = BoxFuture<Self::Response, Self::Error>;
        fn poll_ready(&mut self, _cx: &mut Context<'_>) -> Poll<Result<(), Self::Error>> {
            Poll::Ready(Ok(()))
        }
        fn call(&mut self, req: http::Request<B>) -> Self::Future {
            let inner = self.inner.clone();
            match req.uri().path() {
                "/google.ads.googleads.v1.services.SharedSetService/GetSharedSet" => {
                    #[allow(non_camel_case_types)]
                    struct GetSharedSetSvc<T: SharedSetService>(pub Arc<T>);
                    impl<T: SharedSetService>
                        tonic::server::UnaryService<super::GetSharedSetRequest>
                        for GetSharedSetSvc<T>
                    {
                        type Response = super::super::resources::SharedSet;
                        type Future = BoxFuture<tonic::Response<Self::Response>, tonic::Status>;
                        fn call(
                            &mut self,
                            request: tonic::Request<super::GetSharedSetRequest>,
                        ) -> Self::Future {
                            let inner = self.0.clone();
                            let fut = async move { inner.get_shared_set(request).await };
                            Box::pin(fut)
                        }
                    }
                    let inner = self.inner.clone();
                    let fut = async move {
                        let interceptor = inner.1.clone();
                        let inner = inner.0;
                        let method = GetSharedSetSvc(inner);
                        let codec = tonic::codec::ProstCodec::default();
                        let mut grpc = if let Some(interceptor) = interceptor {
                            tonic::server::Grpc::with_interceptor(codec, interceptor)
                        } else {
                            tonic::server::Grpc::new(codec)
                        };
                        let res = grpc.unary(method, req).await;
                        Ok(res)
                    };
                    Box::pin(fut)
                }
                "/google.ads.googleads.v1.services.SharedSetService/MutateSharedSets" => {
                    #[allow(non_camel_case_types)]
                    struct MutateSharedSetsSvc<T: SharedSetService>(pub Arc<T>);
                    impl<T: SharedSetService>
                        tonic::server::UnaryService<super::MutateSharedSetsRequest>
                        for MutateSharedSetsSvc<T>
                    {
                        type Response = super::MutateSharedSetsResponse;
                        type Future = BoxFuture<tonic::Response<Self::Response>, tonic::Status>;
                        fn call(
                            &mut self,
                            request: tonic::Request<super::MutateSharedSetsRequest>,
                        ) -> Self::Future {
                            let inner = self.0.clone();
                            let fut = async move { inner.mutate_shared_sets(request).await };
                            Box::pin(fut)
                        }
                    }
                    let inner = self.inner.clone();
                    let fut = async move {
                        let interceptor = inner.1.clone();
                        let inner = inner.0;
                        let method = MutateSharedSetsSvc(inner);
                        let codec = tonic::codec::ProstCodec::default();
                        let mut grpc = if let Some(interceptor) = interceptor {
                            tonic::server::Grpc::with_interceptor(codec, interceptor)
                        } else {
                            tonic::server::Grpc::new(codec)
                        };
                        let res = grpc.unary(method, req).await;
                        Ok(res)
                    };
                    Box::pin(fut)
                }
                _ => Box::pin(async move {
                    Ok(http::Response::builder()
                        .status(200)
                        .header("grpc-status", "12")
                        .body(tonic::body::BoxBody::empty())
                        .unwrap())
                }),
            }
        }
    }
    impl<T: SharedSetService> Clone for SharedSetServiceServer<T> {
        fn clone(&self) -> Self {
            let inner = self.inner.clone();
            Self { inner }
        }
    }
    impl<T: SharedSetService> Clone for _Inner<T> {
        fn clone(&self) -> Self {
            Self(self.0.clone(), self.1.clone())
        }
    }
    impl<T: std::fmt::Debug> std::fmt::Debug for _Inner<T> {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
            write!(f, "{:?}", self.0)
        }
    }
    impl<T: SharedSetService> tonic::transport::NamedService for SharedSetServiceServer<T> {
        const NAME: &'static str = "google.ads.googleads.v1.services.SharedSetService";
    }
}
/// Request message for [UserListService.GetUserList][google.ads.googleads.v1.services.UserListService.GetUserList].
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GetUserListRequest {
    /// Required. The resource name of the user list to fetch.
    #[prost(string, tag = "1")]
    pub resource_name: std::string::String,
}
/// Request message for [UserListService.MutateUserLists][google.ads.googleads.v1.services.UserListService.MutateUserLists].
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct MutateUserListsRequest {
    /// Required. The ID of the customer whose user lists are being modified.
    #[prost(string, tag = "1")]
    pub customer_id: std::string::String,
    /// Required. The list of operations to perform on individual user lists.
    #[prost(message, repeated, tag = "2")]
    pub operations: ::std::vec::Vec<UserListOperation>,
    /// If true, successful operations will be carried out and invalid
    /// operations will return errors. If false, all operations will be carried
    /// out in one transaction if and only if they are all valid.
    /// Default is false.
    #[prost(bool, tag = "3")]
    pub partial_failure: bool,
    /// If true, the request is validated but not executed. Only errors are
    /// returned, not results.
    #[prost(bool, tag = "4")]
    pub validate_only: bool,
}
/// A single operation (create, update) on a user list.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct UserListOperation {
    /// FieldMask that determines which resource fields are modified in an update.
    #[prost(message, optional, tag = "4")]
    pub update_mask: ::std::option::Option<::prost_types::FieldMask>,
    /// The mutate operation.
    #[prost(oneof = "user_list_operation::Operation", tags = "1, 2, 3")]
    pub operation: ::std::option::Option<user_list_operation::Operation>,
}
pub mod user_list_operation {
    /// The mutate operation.
    #[derive(Clone, PartialEq, ::prost::Oneof)]
    pub enum Operation {
        /// Create operation: No resource name is expected for the new user list.
        #[prost(message, tag = "1")]
        Create(super::super::resources::UserList),
        /// Update operation: The user list is expected to have a valid resource
        /// name.
        #[prost(message, tag = "2")]
        Update(super::super::resources::UserList),
        /// Remove operation: A resource name for the removed user list is expected,
        /// in this format:
        ///
        /// `customers/{customer_id}/userLists/{user_list_id}`
        #[prost(string, tag = "3")]
        Remove(std::string::String),
    }
}
/// Response message for user list mutate.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct MutateUserListsResponse {
    /// Errors that pertain to operation failures in the partial failure mode.
    /// Returned only when partial_failure = true and all errors occur inside the
    /// operations. If any errors occur outside the operations (e.g. auth errors),
    /// we return an RPC level error.
    #[prost(message, optional, tag = "3")]
    pub partial_failure_error: ::std::option::Option<super::super::super::super::rpc::Status>,
    /// All results for the mutate.
    #[prost(message, repeated, tag = "2")]
    pub results: ::std::vec::Vec<MutateUserListResult>,
}
/// The result for the user list mutate.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct MutateUserListResult {
    /// Returned for successful operations.
    #[prost(string, tag = "1")]
    pub resource_name: std::string::String,
}
#[doc = r" Generated client implementations."]
pub mod user_list_service_client {
    #![allow(unused_variables, dead_code, missing_docs)]
    use tonic::codegen::*;
    #[doc = " Service to manage user lists."]
    pub struct UserListServiceClient<T> {
        inner: tonic::client::Grpc<T>,
    }
    impl UserListServiceClient<tonic::transport::Channel> {
        #[doc = r" Attempt to create a new client by connecting to a given endpoint."]
        pub async fn connect<D>(dst: D) -> Result<Self, tonic::transport::Error>
        where
            D: std::convert::TryInto<tonic::transport::Endpoint>,
            D::Error: Into<StdError>,
        {
            let conn = tonic::transport::Endpoint::new(dst)?.connect().await?;
            Ok(Self::new(conn))
        }
    }
    impl<T> UserListServiceClient<T>
    where
        T: tonic::client::GrpcService<tonic::body::BoxBody>,
        T::ResponseBody: Body + HttpBody + Send + 'static,
        T::Error: Into<StdError>,
        <T::ResponseBody as HttpBody>::Error: Into<StdError> + Send,
    {
        pub fn new(inner: T) -> Self {
            let inner = tonic::client::Grpc::new(inner);
            Self { inner }
        }
        pub fn with_interceptor(inner: T, interceptor: impl Into<tonic::Interceptor>) -> Self {
            let inner = tonic::client::Grpc::with_interceptor(inner, interceptor);
            Self { inner }
        }
        #[doc = " Returns the requested user list."]
        pub async fn get_user_list(
            &mut self,
            request: impl tonic::IntoRequest<super::GetUserListRequest>,
        ) -> Result<tonic::Response<super::super::resources::UserList>, tonic::Status> {
            self.inner.ready().await.map_err(|e| {
                tonic::Status::new(
                    tonic::Code::Unknown,
                    format!("Service was not ready: {}", e.into()),
                )
            })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.ads.googleads.v1.services.UserListService/GetUserList",
            );
            self.inner.unary(request.into_request(), path, codec).await
        }
        #[doc = " Creates or updates user lists. Operation statuses are returned."]
        pub async fn mutate_user_lists(
            &mut self,
            request: impl tonic::IntoRequest<super::MutateUserListsRequest>,
        ) -> Result<tonic::Response<super::MutateUserListsResponse>, tonic::Status> {
            self.inner.ready().await.map_err(|e| {
                tonic::Status::new(
                    tonic::Code::Unknown,
                    format!("Service was not ready: {}", e.into()),
                )
            })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.ads.googleads.v1.services.UserListService/MutateUserLists",
            );
            self.inner.unary(request.into_request(), path, codec).await
        }
    }
    impl<T: Clone> Clone for UserListServiceClient<T> {
        fn clone(&self) -> Self {
            Self {
                inner: self.inner.clone(),
            }
        }
    }
    impl<T> std::fmt::Debug for UserListServiceClient<T> {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
            write!(f, "UserListServiceClient {{ ... }}")
        }
    }
}
#[doc = r" Generated server implementations."]
pub mod user_list_service_server {
    #![allow(unused_variables, dead_code, missing_docs)]
    use tonic::codegen::*;
    #[doc = "Generated trait containing gRPC methods that should be implemented for use with UserListServiceServer."]
    #[async_trait]
    pub trait UserListService: Send + Sync + 'static {
        #[doc = " Returns the requested user list."]
        async fn get_user_list(
            &self,
            request: tonic::Request<super::GetUserListRequest>,
        ) -> Result<tonic::Response<super::super::resources::UserList>, tonic::Status>;
        #[doc = " Creates or updates user lists. Operation statuses are returned."]
        async fn mutate_user_lists(
            &self,
            request: tonic::Request<super::MutateUserListsRequest>,
        ) -> Result<tonic::Response<super::MutateUserListsResponse>, tonic::Status>;
    }
    #[doc = " Service to manage user lists."]
    #[derive(Debug)]
    #[doc(hidden)]
    pub struct UserListServiceServer<T: UserListService> {
        inner: _Inner<T>,
    }
    struct _Inner<T>(Arc<T>, Option<tonic::Interceptor>);
    impl<T: UserListService> UserListServiceServer<T> {
        pub fn new(inner: T) -> Self {
            let inner = Arc::new(inner);
            let inner = _Inner(inner, None);
            Self { inner }
        }
        pub fn with_interceptor(inner: T, interceptor: impl Into<tonic::Interceptor>) -> Self {
            let inner = Arc::new(inner);
            let inner = _Inner(inner, Some(interceptor.into()));
            Self { inner }
        }
    }
    impl<T, B> Service<http::Request<B>> for UserListServiceServer<T>
    where
        T: UserListService,
        B: HttpBody + Send + Sync + 'static,
        B::Error: Into<StdError> + Send + 'static,
    {
        type Response = http::Response<tonic::body::BoxBody>;
        type Error = Never;
        type Future = BoxFuture<Self::Response, Self::Error>;
        fn poll_ready(&mut self, _cx: &mut Context<'_>) -> Poll<Result<(), Self::Error>> {
            Poll::Ready(Ok(()))
        }
        fn call(&mut self, req: http::Request<B>) -> Self::Future {
            let inner = self.inner.clone();
            match req.uri().path() {
                "/google.ads.googleads.v1.services.UserListService/GetUserList" => {
                    #[allow(non_camel_case_types)]
                    struct GetUserListSvc<T: UserListService>(pub Arc<T>);
                    impl<T: UserListService> tonic::server::UnaryService<super::GetUserListRequest>
                        for GetUserListSvc<T>
                    {
                        type Response = super::super::resources::UserList;
                        type Future = BoxFuture<tonic::Response<Self::Response>, tonic::Status>;
                        fn call(
                            &mut self,
                            request: tonic::Request<super::GetUserListRequest>,
                        ) -> Self::Future {
                            let inner = self.0.clone();
                            let fut = async move { inner.get_user_list(request).await };
                            Box::pin(fut)
                        }
                    }
                    let inner = self.inner.clone();
                    let fut = async move {
                        let interceptor = inner.1.clone();
                        let inner = inner.0;
                        let method = GetUserListSvc(inner);
                        let codec = tonic::codec::ProstCodec::default();
                        let mut grpc = if let Some(interceptor) = interceptor {
                            tonic::server::Grpc::with_interceptor(codec, interceptor)
                        } else {
                            tonic::server::Grpc::new(codec)
                        };
                        let res = grpc.unary(method, req).await;
                        Ok(res)
                    };
                    Box::pin(fut)
                }
                "/google.ads.googleads.v1.services.UserListService/MutateUserLists" => {
                    #[allow(non_camel_case_types)]
                    struct MutateUserListsSvc<T: UserListService>(pub Arc<T>);
                    impl<T: UserListService>
                        tonic::server::UnaryService<super::MutateUserListsRequest>
                        for MutateUserListsSvc<T>
                    {
                        type Response = super::MutateUserListsResponse;
                        type Future = BoxFuture<tonic::Response<Self::Response>, tonic::Status>;
                        fn call(
                            &mut self,
                            request: tonic::Request<super::MutateUserListsRequest>,
                        ) -> Self::Future {
                            let inner = self.0.clone();
                            let fut = async move { inner.mutate_user_lists(request).await };
                            Box::pin(fut)
                        }
                    }
                    let inner = self.inner.clone();
                    let fut = async move {
                        let interceptor = inner.1.clone();
                        let inner = inner.0;
                        let method = MutateUserListsSvc(inner);
                        let codec = tonic::codec::ProstCodec::default();
                        let mut grpc = if let Some(interceptor) = interceptor {
                            tonic::server::Grpc::with_interceptor(codec, interceptor)
                        } else {
                            tonic::server::Grpc::new(codec)
                        };
                        let res = grpc.unary(method, req).await;
                        Ok(res)
                    };
                    Box::pin(fut)
                }
                _ => Box::pin(async move {
                    Ok(http::Response::builder()
                        .status(200)
                        .header("grpc-status", "12")
                        .body(tonic::body::BoxBody::empty())
                        .unwrap())
                }),
            }
        }
    }
    impl<T: UserListService> Clone for UserListServiceServer<T> {
        fn clone(&self) -> Self {
            let inner = self.inner.clone();
            Self { inner }
        }
    }
    impl<T: UserListService> Clone for _Inner<T> {
        fn clone(&self) -> Self {
            Self(self.0.clone(), self.1.clone())
        }
    }
    impl<T: std::fmt::Debug> std::fmt::Debug for _Inner<T> {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
            write!(f, "{:?}", self.0)
        }
    }
    impl<T: UserListService> tonic::transport::NamedService for UserListServiceServer<T> {
        const NAME: &'static str = "google.ads.googleads.v1.services.UserListService";
    }
}
/// Request message for [GoogleAdsService.Search][google.ads.googleads.v1.services.GoogleAdsService.Search].
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct SearchGoogleAdsRequest {
    /// Required. The ID of the customer being queried.
    #[prost(string, tag = "1")]
    pub customer_id: std::string::String,
    /// Required. The query string.
    #[prost(string, tag = "2")]
    pub query: std::string::String,
    /// Token of the page to retrieve. If not specified, the first
    /// page of results will be returned. Use the value obtained from
    /// `next_page_token` in the previous response in order to request
    /// the next page of results.
    #[prost(string, tag = "3")]
    pub page_token: std::string::String,
    /// Number of elements to retrieve in a single page.
    /// When too large a page is requested, the server may decide to
    /// further limit the number of returned resources.
    #[prost(int32, tag = "4")]
    pub page_size: i32,
    /// If true, the request is validated but not executed.
    #[prost(bool, tag = "5")]
    pub validate_only: bool,
}
/// Response message for [GoogleAdsService.Search][google.ads.googleads.v1.services.GoogleAdsService.Search].
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct SearchGoogleAdsResponse {
    /// The list of rows that matched the query.
    #[prost(message, repeated, tag = "1")]
    pub results: ::std::vec::Vec<GoogleAdsRow>,
    /// Pagination token used to retrieve the next page of results.
    /// Pass the content of this string as the `page_token` attribute of
    /// the next request. `next_page_token` is not returned for the last
    /// page.
    #[prost(string, tag = "2")]
    pub next_page_token: std::string::String,
    /// Total number of results that match the query ignoring the LIMIT
    /// clause.
    #[prost(int64, tag = "3")]
    pub total_results_count: i64,
    /// FieldMask that represents what fields were requested by the user.
    #[prost(message, optional, tag = "5")]
    pub field_mask: ::std::option::Option<::prost_types::FieldMask>,
}
/// A returned row from the query.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GoogleAdsRow {
    /// The account budget in the query.
    #[prost(message, optional, tag = "42")]
    pub account_budget: ::std::option::Option<super::resources::AccountBudget>,
    /// The account budget proposal referenced in the query.
    #[prost(message, optional, tag = "43")]
    pub account_budget_proposal: ::std::option::Option<super::resources::AccountBudgetProposal>,
    /// The ad group referenced in the query.
    #[prost(message, optional, tag = "3")]
    pub ad_group: ::std::option::Option<super::resources::AdGroup>,
    /// The ad referenced in the query.
    #[prost(message, optional, tag = "16")]
    pub ad_group_ad: ::std::option::Option<super::resources::AdGroupAd>,
    /// The ad group ad label referenced in the query.
    #[prost(message, optional, tag = "120")]
    pub ad_group_ad_label: ::std::option::Option<super::resources::AdGroupAdLabel>,
    /// The ad group audience view referenced in the query.
    #[prost(message, optional, tag = "57")]
    pub ad_group_audience_view: ::std::option::Option<super::resources::AdGroupAudienceView>,
    /// The bid modifier referenced in the query.
    #[prost(message, optional, tag = "24")]
    pub ad_group_bid_modifier: ::std::option::Option<super::resources::AdGroupBidModifier>,
    /// The criterion referenced in the query.
    #[prost(message, optional, tag = "17")]
    pub ad_group_criterion: ::std::option::Option<super::resources::AdGroupCriterion>,
    /// The ad group criterion label referenced in the query.
    #[prost(message, optional, tag = "121")]
    pub ad_group_criterion_label: ::std::option::Option<super::resources::AdGroupCriterionLabel>,
    /// The ad group criterion simulation referenced in the query.
    #[prost(message, optional, tag = "110")]
    pub ad_group_criterion_simulation:
        ::std::option::Option<super::resources::AdGroupCriterionSimulation>,
    /// The ad group extension setting referenced in the query.
    #[prost(message, optional, tag = "112")]
    pub ad_group_extension_setting:
        ::std::option::Option<super::resources::AdGroupExtensionSetting>,
    /// The ad group feed referenced in the query.
    #[prost(message, optional, tag = "67")]
    pub ad_group_feed: ::std::option::Option<super::resources::AdGroupFeed>,
    /// The ad group label referenced in the query.
    #[prost(message, optional, tag = "115")]
    pub ad_group_label: ::std::option::Option<super::resources::AdGroupLabel>,
    /// The ad group simulation referenced in the query.
    #[prost(message, optional, tag = "107")]
    pub ad_group_simulation: ::std::option::Option<super::resources::AdGroupSimulation>,
    /// The ad parameter referenced in the query.
    #[prost(message, optional, tag = "130")]
    pub ad_parameter: ::std::option::Option<super::resources::AdParameter>,
    /// The age range view referenced in the query.
    #[prost(message, optional, tag = "48")]
    pub age_range_view: ::std::option::Option<super::resources::AgeRangeView>,
    /// The ad schedule view referenced in the query.
    #[prost(message, optional, tag = "89")]
    pub ad_schedule_view: ::std::option::Option<super::resources::AdScheduleView>,
    /// The domain category referenced in the query.
    #[prost(message, optional, tag = "91")]
    pub domain_category: ::std::option::Option<super::resources::DomainCategory>,
    /// The asset referenced in the query.
    #[prost(message, optional, tag = "105")]
    pub asset: ::std::option::Option<super::resources::Asset>,
    /// The bidding strategy referenced in the query.
    #[prost(message, optional, tag = "18")]
    pub bidding_strategy: ::std::option::Option<super::resources::BiddingStrategy>,
    /// The billing setup referenced in the query.
    #[prost(message, optional, tag = "41")]
    pub billing_setup: ::std::option::Option<super::resources::BillingSetup>,
    /// The campaign budget referenced in the query.
    #[prost(message, optional, tag = "19")]
    pub campaign_budget: ::std::option::Option<super::resources::CampaignBudget>,
    /// The campaign referenced in the query.
    #[prost(message, optional, tag = "2")]
    pub campaign: ::std::option::Option<super::resources::Campaign>,
    /// The campaign audience view referenced in the query.
    #[prost(message, optional, tag = "69")]
    pub campaign_audience_view: ::std::option::Option<super::resources::CampaignAudienceView>,
    /// The campaign bid modifier referenced in the query.
    #[prost(message, optional, tag = "26")]
    pub campaign_bid_modifier: ::std::option::Option<super::resources::CampaignBidModifier>,
    /// The campaign criterion referenced in the query.
    #[prost(message, optional, tag = "20")]
    pub campaign_criterion: ::std::option::Option<super::resources::CampaignCriterion>,
    /// The campaign criterion simulation referenced in the query.
    #[prost(message, optional, tag = "111")]
    pub campaign_criterion_simulation:
        ::std::option::Option<super::resources::CampaignCriterionSimulation>,
    /// The campaign draft referenced in the query.
    #[prost(message, optional, tag = "49")]
    pub campaign_draft: ::std::option::Option<super::resources::CampaignDraft>,
    /// The campaign experiment referenced in the query.
    #[prost(message, optional, tag = "84")]
    pub campaign_experiment: ::std::option::Option<super::resources::CampaignExperiment>,
    /// The campaign extension setting referenced in the query.
    #[prost(message, optional, tag = "113")]
    pub campaign_extension_setting:
        ::std::option::Option<super::resources::CampaignExtensionSetting>,
    /// The campaign feed referenced in the query.
    #[prost(message, optional, tag = "63")]
    pub campaign_feed: ::std::option::Option<super::resources::CampaignFeed>,
    /// The campaign label referenced in the query.
    #[prost(message, optional, tag = "108")]
    pub campaign_label: ::std::option::Option<super::resources::CampaignLabel>,
    /// Campaign Shared Set referenced in AWQL query.
    #[prost(message, optional, tag = "30")]
    pub campaign_shared_set: ::std::option::Option<super::resources::CampaignSharedSet>,
    /// The carrier constant referenced in the query.
    #[prost(message, optional, tag = "66")]
    pub carrier_constant: ::std::option::Option<super::resources::CarrierConstant>,
    /// The ChangeStatus referenced in the query.
    #[prost(message, optional, tag = "37")]
    pub change_status: ::std::option::Option<super::resources::ChangeStatus>,
    /// The conversion action referenced in the query.
    #[prost(message, optional, tag = "103")]
    pub conversion_action: ::std::option::Option<super::resources::ConversionAction>,
    /// The ClickView referenced in the query.
    #[prost(message, optional, tag = "122")]
    pub click_view: ::std::option::Option<super::resources::ClickView>,
    /// The CustomInterest referenced in the query.
    #[prost(message, optional, tag = "104")]
    pub custom_interest: ::std::option::Option<super::resources::CustomInterest>,
    /// The customer referenced in the query.
    #[prost(message, optional, tag = "1")]
    pub customer: ::std::option::Option<super::resources::Customer>,
    /// The CustomerManagerLink referenced in the query.
    #[prost(message, optional, tag = "61")]
    pub customer_manager_link: ::std::option::Option<super::resources::CustomerManagerLink>,
    /// The CustomerClientLink referenced in the query.
    #[prost(message, optional, tag = "62")]
    pub customer_client_link: ::std::option::Option<super::resources::CustomerClientLink>,
    /// The CustomerClient referenced in the query.
    #[prost(message, optional, tag = "70")]
    pub customer_client: ::std::option::Option<super::resources::CustomerClient>,
    /// The customer extension setting referenced in the query.
    #[prost(message, optional, tag = "114")]
    pub customer_extension_setting:
        ::std::option::Option<super::resources::CustomerExtensionSetting>,
    /// The customer feed referenced in the query.
    #[prost(message, optional, tag = "64")]
    pub customer_feed: ::std::option::Option<super::resources::CustomerFeed>,
    /// The customer label referenced in the query.
    #[prost(message, optional, tag = "124")]
    pub customer_label: ::std::option::Option<super::resources::CustomerLabel>,
    /// The customer negative criterion referenced in the query.
    #[prost(message, optional, tag = "88")]
    pub customer_negative_criterion:
        ::std::option::Option<super::resources::CustomerNegativeCriterion>,
    /// The detail placement view referenced in the query.
    #[prost(message, optional, tag = "118")]
    pub detail_placement_view: ::std::option::Option<super::resources::DetailPlacementView>,
    /// The display keyword view referenced in the query.
    #[prost(message, optional, tag = "47")]
    pub display_keyword_view: ::std::option::Option<super::resources::DisplayKeywordView>,
    /// The dynamic search ads search term view referenced in the query.
    #[prost(message, optional, tag = "106")]
    pub dynamic_search_ads_search_term_view:
        ::std::option::Option<super::resources::DynamicSearchAdsSearchTermView>,
    /// The expanded landing page view referenced in the query.
    #[prost(message, optional, tag = "128")]
    pub expanded_landing_page_view:
        ::std::option::Option<super::resources::ExpandedLandingPageView>,
    /// The extension feed item referenced in the query.
    #[prost(message, optional, tag = "85")]
    pub extension_feed_item: ::std::option::Option<super::resources::ExtensionFeedItem>,
    /// The feed referenced in the query.
    #[prost(message, optional, tag = "46")]
    pub feed: ::std::option::Option<super::resources::Feed>,
    /// The feed item referenced in the query.
    #[prost(message, optional, tag = "50")]
    pub feed_item: ::std::option::Option<super::resources::FeedItem>,
    /// The feed item target referenced in the query.
    #[prost(message, optional, tag = "116")]
    pub feed_item_target: ::std::option::Option<super::resources::FeedItemTarget>,
    /// The feed mapping referenced in the query.
    #[prost(message, optional, tag = "58")]
    pub feed_mapping: ::std::option::Option<super::resources::FeedMapping>,
    /// The feed placeholder view referenced in the query.
    #[prost(message, optional, tag = "97")]
    pub feed_placeholder_view: ::std::option::Option<super::resources::FeedPlaceholderView>,
    /// The gender view referenced in the query.
    #[prost(message, optional, tag = "40")]
    pub gender_view: ::std::option::Option<super::resources::GenderView>,
    /// The geo target constant referenced in the query.
    #[prost(message, optional, tag = "23")]
    pub geo_target_constant: ::std::option::Option<super::resources::GeoTargetConstant>,
    /// The geographic view referenced in the query.
    #[prost(message, optional, tag = "125")]
    pub geographic_view: ::std::option::Option<super::resources::GeographicView>,
    /// The group placement view referenced in the query.
    #[prost(message, optional, tag = "119")]
    pub group_placement_view: ::std::option::Option<super::resources::GroupPlacementView>,
    /// The hotel group view referenced in the query.
    #[prost(message, optional, tag = "51")]
    pub hotel_group_view: ::std::option::Option<super::resources::HotelGroupView>,
    /// The hotel performance view referenced in the query.
    #[prost(message, optional, tag = "71")]
    pub hotel_performance_view: ::std::option::Option<super::resources::HotelPerformanceView>,
    /// The keyword view referenced in the query.
    #[prost(message, optional, tag = "21")]
    pub keyword_view: ::std::option::Option<super::resources::KeywordView>,
    /// The keyword plan referenced in the query.
    #[prost(message, optional, tag = "32")]
    pub keyword_plan: ::std::option::Option<super::resources::KeywordPlan>,
    /// The keyword plan campaign referenced in the query.
    #[prost(message, optional, tag = "33")]
    pub keyword_plan_campaign: ::std::option::Option<super::resources::KeywordPlanCampaign>,
    /// The keyword plan negative keyword referenced in the query.
    #[prost(message, optional, tag = "34")]
    pub keyword_plan_negative_keyword:
        ::std::option::Option<super::resources::KeywordPlanNegativeKeyword>,
    /// The keyword plan ad group referenced in the query.
    #[prost(message, optional, tag = "35")]
    pub keyword_plan_ad_group: ::std::option::Option<super::resources::KeywordPlanAdGroup>,
    /// The keyword plan keyword referenced in the query.
    #[prost(message, optional, tag = "36")]
    pub keyword_plan_keyword: ::std::option::Option<super::resources::KeywordPlanKeyword>,
    /// The label referenced in the query.
    #[prost(message, optional, tag = "52")]
    pub label: ::std::option::Option<super::resources::Label>,
    /// The landing page view referenced in the query.
    #[prost(message, optional, tag = "126")]
    pub landing_page_view: ::std::option::Option<super::resources::LandingPageView>,
    /// The language constant referenced in the query.
    #[prost(message, optional, tag = "55")]
    pub language_constant: ::std::option::Option<super::resources::LanguageConstant>,
    /// The location view referenced in the query.
    #[prost(message, optional, tag = "123")]
    pub location_view: ::std::option::Option<super::resources::LocationView>,
    /// The managed placement view referenced in the query.
    #[prost(message, optional, tag = "53")]
    pub managed_placement_view: ::std::option::Option<super::resources::ManagedPlacementView>,
    /// The media file referenced in the query.
    #[prost(message, optional, tag = "90")]
    pub media_file: ::std::option::Option<super::resources::MediaFile>,
    /// The mobile app category constant referenced in the query.
    #[prost(message, optional, tag = "87")]
    pub mobile_app_category_constant:
        ::std::option::Option<super::resources::MobileAppCategoryConstant>,
    /// The mobile device constant referenced in the query.
    #[prost(message, optional, tag = "98")]
    pub mobile_device_constant: ::std::option::Option<super::resources::MobileDeviceConstant>,
    /// The mutate job referenced in the query.
    #[prost(message, optional, tag = "127")]
    pub mutate_job: ::std::option::Option<super::resources::MutateJob>,
    /// The operating system version constant referenced in the query.
    #[prost(message, optional, tag = "86")]
    pub operating_system_version_constant:
        ::std::option::Option<super::resources::OperatingSystemVersionConstant>,
    /// The paid organic search term view referenced in the query.
    #[prost(message, optional, tag = "129")]
    pub paid_organic_search_term_view:
        ::std::option::Option<super::resources::PaidOrganicSearchTermView>,
    /// The parental status view referenced in the query.
    #[prost(message, optional, tag = "45")]
    pub parental_status_view: ::std::option::Option<super::resources::ParentalStatusView>,
    /// The Product Bidding Category referenced in the query.
    #[prost(message, optional, tag = "109")]
    pub product_bidding_category_constant:
        ::std::option::Option<super::resources::ProductBiddingCategoryConstant>,
    /// The product group view referenced in the query.
    #[prost(message, optional, tag = "54")]
    pub product_group_view: ::std::option::Option<super::resources::ProductGroupView>,
    /// The recommendation referenced in the query.
    #[prost(message, optional, tag = "22")]
    pub recommendation: ::std::option::Option<super::resources::Recommendation>,
    /// The search term view referenced in the query.
    #[prost(message, optional, tag = "68")]
    pub search_term_view: ::std::option::Option<super::resources::SearchTermView>,
    /// The shared set referenced in the query.
    #[prost(message, optional, tag = "29")]
    pub shared_criterion: ::std::option::Option<super::resources::SharedCriterion>,
    /// The shared set referenced in the query.
    #[prost(message, optional, tag = "27")]
    pub shared_set: ::std::option::Option<super::resources::SharedSet>,
    /// The shopping performance view referenced in the query.
    #[prost(message, optional, tag = "117")]
    pub shopping_performance_view: ::std::option::Option<super::resources::ShoppingPerformanceView>,
    /// The topic view referenced in the query.
    #[prost(message, optional, tag = "44")]
    pub topic_view: ::std::option::Option<super::resources::TopicView>,
    /// The user interest referenced in the query.
    #[prost(message, optional, tag = "59")]
    pub user_interest: ::std::option::Option<super::resources::UserInterest>,
    /// The user list referenced in the query.
    #[prost(message, optional, tag = "38")]
    pub user_list: ::std::option::Option<super::resources::UserList>,
    /// The remarketing action referenced in the query.
    #[prost(message, optional, tag = "60")]
    pub remarketing_action: ::std::option::Option<super::resources::RemarketingAction>,
    /// The topic constant referenced in the query.
    #[prost(message, optional, tag = "31")]
    pub topic_constant: ::std::option::Option<super::resources::TopicConstant>,
    /// The video referenced in the query.
    #[prost(message, optional, tag = "39")]
    pub video: ::std::option::Option<super::resources::Video>,
    /// The metrics.
    #[prost(message, optional, tag = "4")]
    pub metrics: ::std::option::Option<super::common::Metrics>,
    /// The segments.
    #[prost(message, optional, tag = "102")]
    pub segments: ::std::option::Option<super::common::Segments>,
}
/// Request message for [GoogleAdsService.Mutate][google.ads.googleads.v1.services.GoogleAdsService.Mutate].
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct MutateGoogleAdsRequest {
    /// Required. The ID of the customer whose resources are being modified.
    #[prost(string, tag = "1")]
    pub customer_id: std::string::String,
    /// Required. The list of operations to perform on individual resources.
    #[prost(message, repeated, tag = "2")]
    pub mutate_operations: ::std::vec::Vec<MutateOperation>,
    /// If true, successful operations will be carried out and invalid
    /// operations will return errors. If false, all operations will be carried
    /// out in one transaction if and only if they are all valid.
    /// Default is false.
    #[prost(bool, tag = "3")]
    pub partial_failure: bool,
    /// If true, the request is validated but not executed. Only errors are
    /// returned, not results.
    #[prost(bool, tag = "4")]
    pub validate_only: bool,
}
/// Response message for [GoogleAdsService.Mutate][google.ads.googleads.v1.services.GoogleAdsService.Mutate].
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct MutateGoogleAdsResponse {
    /// Errors that pertain to operation failures in the partial failure mode.
    /// Returned only when partial_failure = true and all errors occur inside the
    /// operations. If any errors occur outside the operations (e.g., auth errors),
    /// we return an RPC level error.
    #[prost(message, optional, tag = "3")]
    pub partial_failure_error: ::std::option::Option<super::super::super::super::rpc::Status>,
    /// All responses for the mutate.
    #[prost(message, repeated, tag = "1")]
    pub mutate_operation_responses: ::std::vec::Vec<MutateOperationResponse>,
}
/// A single operation (create, update, remove) on a resource.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct MutateOperation {
    /// The mutate operation.
    #[prost(
        oneof = "mutate_operation::Operation",
        tags = "17, 1, 2, 18, 3, 19, 20, 21, 5, 22, 23, 6, 7, 8, 13, 24, 25, 26, 27, 28, 10, 11, 12, 30, 31, 32, 34, 35, 36, 37, 38, 39, 40, 41, 42, 43, 14, 15, 16"
    )]
    pub operation: ::std::option::Option<mutate_operation::Operation>,
}
pub mod mutate_operation {
    /// The mutate operation.
    #[derive(Clone, PartialEq, ::prost::Oneof)]
    pub enum Operation {
        /// An ad group ad label mutate operation.
        #[prost(message, tag = "17")]
        AdGroupAdLabelOperation(super::AdGroupAdLabelOperation),
        /// An ad group ad mutate operation.
        #[prost(message, tag = "1")]
        AdGroupAdOperation(super::AdGroupAdOperation),
        /// An ad group bid modifier mutate operation.
        #[prost(message, tag = "2")]
        AdGroupBidModifierOperation(super::AdGroupBidModifierOperation),
        /// An ad group criterion label mutate operation.
        #[prost(message, tag = "18")]
        AdGroupCriterionLabelOperation(super::AdGroupCriterionLabelOperation),
        /// An ad group criterion mutate operation.
        #[prost(message, tag = "3")]
        AdGroupCriterionOperation(super::AdGroupCriterionOperation),
        /// An ad group extension setting mutate operation.
        #[prost(message, tag = "19")]
        AdGroupExtensionSettingOperation(super::AdGroupExtensionSettingOperation),
        /// An ad group feed mutate operation.
        #[prost(message, tag = "20")]
        AdGroupFeedOperation(super::AdGroupFeedOperation),
        /// An ad group label mutate operation.
        #[prost(message, tag = "21")]
        AdGroupLabelOperation(super::AdGroupLabelOperation),
        /// An ad group mutate operation.
        #[prost(message, tag = "5")]
        AdGroupOperation(super::AdGroupOperation),
        /// An ad parameter mutate operation.
        #[prost(message, tag = "22")]
        AdParameterOperation(super::AdParameterOperation),
        /// An asset mutate operation.
        #[prost(message, tag = "23")]
        AssetOperation(super::AssetOperation),
        /// A bidding strategy mutate operation.
        #[prost(message, tag = "6")]
        BiddingStrategyOperation(super::BiddingStrategyOperation),
        /// A campaign bid modifier mutate operation.
        #[prost(message, tag = "7")]
        CampaignBidModifierOperation(super::CampaignBidModifierOperation),
        /// A campaign budget mutate operation.
        #[prost(message, tag = "8")]
        CampaignBudgetOperation(super::CampaignBudgetOperation),
        /// A campaign criterion mutate operation.
        #[prost(message, tag = "13")]
        CampaignCriterionOperation(super::CampaignCriterionOperation),
        /// A campaign draft mutate operation.
        #[prost(message, tag = "24")]
        CampaignDraftOperation(super::CampaignDraftOperation),
        /// A campaign experiment mutate operation.
        #[prost(message, tag = "25")]
        CampaignExperimentOperation(super::CampaignExperimentOperation),
        /// A campaign extension setting mutate operation.
        #[prost(message, tag = "26")]
        CampaignExtensionSettingOperation(super::CampaignExtensionSettingOperation),
        /// A campaign feed mutate operation.
        #[prost(message, tag = "27")]
        CampaignFeedOperation(super::CampaignFeedOperation),
        /// A campaign label mutate operation.
        #[prost(message, tag = "28")]
        CampaignLabelOperation(super::CampaignLabelOperation),
        /// A campaign mutate operation.
        #[prost(message, tag = "10")]
        CampaignOperation(super::CampaignOperation),
        /// A campaign shared set mutate operation.
        #[prost(message, tag = "11")]
        CampaignSharedSetOperation(super::CampaignSharedSetOperation),
        /// A conversion action mutate operation.
        #[prost(message, tag = "12")]
        ConversionActionOperation(super::ConversionActionOperation),
        /// A customer extension setting mutate operation.
        #[prost(message, tag = "30")]
        CustomerExtensionSettingOperation(super::CustomerExtensionSettingOperation),
        /// A customer feed mutate operation.
        #[prost(message, tag = "31")]
        CustomerFeedOperation(super::CustomerFeedOperation),
        /// A customer label mutate operation.
        #[prost(message, tag = "32")]
        CustomerLabelOperation(super::CustomerLabelOperation),
        /// A customer negative criterion mutate operation.
        #[prost(message, tag = "34")]
        CustomerNegativeCriterionOperation(super::CustomerNegativeCriterionOperation),
        /// A customer mutate operation.
        #[prost(message, tag = "35")]
        CustomerOperation(super::CustomerOperation),
        /// An extension feed item mutate operation.
        #[prost(message, tag = "36")]
        ExtensionFeedItemOperation(super::ExtensionFeedItemOperation),
        /// A feed item mutate operation.
        #[prost(message, tag = "37")]
        FeedItemOperation(super::FeedItemOperation),
        /// A feed item target mutate operation.
        #[prost(message, tag = "38")]
        FeedItemTargetOperation(super::FeedItemTargetOperation),
        /// A feed mapping mutate operation.
        #[prost(message, tag = "39")]
        FeedMappingOperation(super::FeedMappingOperation),
        /// A feed mutate operation.
        #[prost(message, tag = "40")]
        FeedOperation(super::FeedOperation),
        /// A label mutate operation.
        #[prost(message, tag = "41")]
        LabelOperation(super::LabelOperation),
        /// A media file mutate operation.
        #[prost(message, tag = "42")]
        MediaFileOperation(super::MediaFileOperation),
        /// A remarketing action mutate operation.
        #[prost(message, tag = "43")]
        RemarketingActionOperation(super::RemarketingActionOperation),
        /// A shared criterion mutate operation.
        #[prost(message, tag = "14")]
        SharedCriterionOperation(super::SharedCriterionOperation),
        /// A shared set mutate operation.
        #[prost(message, tag = "15")]
        SharedSetOperation(super::SharedSetOperation),
        /// A user list mutate operation.
        #[prost(message, tag = "16")]
        UserListOperation(super::UserListOperation),
    }
}
/// Response message for the resource mutate.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct MutateOperationResponse {
    /// The mutate response.
    #[prost(
        oneof = "mutate_operation_response::Response",
        tags = "17, 1, 2, 18, 3, 19, 20, 21, 5, 22, 23, 6, 7, 8, 13, 24, 25, 26, 27, 28, 10, 11, 12, 30, 31, 32, 34, 35, 36, 37, 38, 39, 40, 41, 42, 43, 14, 15, 16"
    )]
    pub response: ::std::option::Option<mutate_operation_response::Response>,
}
pub mod mutate_operation_response {
    /// The mutate response.
    #[derive(Clone, PartialEq, ::prost::Oneof)]
    pub enum Response {
        /// The result for the ad group ad label mutate.
        #[prost(message, tag = "17")]
        AdGroupAdLabelResult(super::MutateAdGroupAdLabelResult),
        /// The result for the ad group ad mutate.
        #[prost(message, tag = "1")]
        AdGroupAdResult(super::MutateAdGroupAdResult),
        /// The result for the ad group bid modifier mutate.
        #[prost(message, tag = "2")]
        AdGroupBidModifierResult(super::MutateAdGroupBidModifierResult),
        /// The result for the ad group criterion label mutate.
        #[prost(message, tag = "18")]
        AdGroupCriterionLabelResult(super::MutateAdGroupCriterionLabelResult),
        /// The result for the ad group criterion mutate.
        #[prost(message, tag = "3")]
        AdGroupCriterionResult(super::MutateAdGroupCriterionResult),
        /// The result for the ad group extension setting mutate.
        #[prost(message, tag = "19")]
        AdGroupExtensionSettingResult(super::MutateAdGroupExtensionSettingResult),
        /// The result for the ad group feed mutate.
        #[prost(message, tag = "20")]
        AdGroupFeedResult(super::MutateAdGroupFeedResult),
        /// The result for the ad group label mutate.
        #[prost(message, tag = "21")]
        AdGroupLabelResult(super::MutateAdGroupLabelResult),
        /// The result for the ad group mutate.
        #[prost(message, tag = "5")]
        AdGroupResult(super::MutateAdGroupResult),
        /// The result for the ad parameter mutate.
        #[prost(message, tag = "22")]
        AdParameterResult(super::MutateAdParameterResult),
        /// The result for the asset mutate.
        #[prost(message, tag = "23")]
        AssetResult(super::MutateAssetResult),
        /// The result for the bidding strategy mutate.
        #[prost(message, tag = "6")]
        BiddingStrategyResult(super::MutateBiddingStrategyResult),
        /// The result for the campaign bid modifier mutate.
        #[prost(message, tag = "7")]
        CampaignBidModifierResult(super::MutateCampaignBidModifierResult),
        /// The result for the campaign budget mutate.
        #[prost(message, tag = "8")]
        CampaignBudgetResult(super::MutateCampaignBudgetResult),
        /// The result for the campaign criterion mutate.
        #[prost(message, tag = "13")]
        CampaignCriterionResult(super::MutateCampaignCriterionResult),
        /// The result for the campaign draft mutate.
        #[prost(message, tag = "24")]
        CampaignDraftResult(super::MutateCampaignDraftResult),
        /// The result for the campaign experiment mutate.
        #[prost(message, tag = "25")]
        CampaignExperimentResult(super::MutateCampaignExperimentResult),
        /// The result for the campaign extension setting mutate.
        #[prost(message, tag = "26")]
        CampaignExtensionSettingResult(super::MutateCampaignExtensionSettingResult),
        /// The result for the campaign feed mutate.
        #[prost(message, tag = "27")]
        CampaignFeedResult(super::MutateCampaignFeedResult),
        /// The result for the campaign label mutate.
        #[prost(message, tag = "28")]
        CampaignLabelResult(super::MutateCampaignLabelResult),
        /// The result for the campaign mutate.
        #[prost(message, tag = "10")]
        CampaignResult(super::MutateCampaignResult),
        /// The result for the campaign shared set mutate.
        #[prost(message, tag = "11")]
        CampaignSharedSetResult(super::MutateCampaignSharedSetResult),
        /// The result for the conversion action mutate.
        #[prost(message, tag = "12")]
        ConversionActionResult(super::MutateConversionActionResult),
        /// The result for the customer extension setting mutate.
        #[prost(message, tag = "30")]
        CustomerExtensionSettingResult(super::MutateCustomerExtensionSettingResult),
        /// The result for the customer feed mutate.
        #[prost(message, tag = "31")]
        CustomerFeedResult(super::MutateCustomerFeedResult),
        /// The result for the customer label mutate.
        #[prost(message, tag = "32")]
        CustomerLabelResult(super::MutateCustomerLabelResult),
        /// The result for the customer negative criterion mutate.
        #[prost(message, tag = "34")]
        CustomerNegativeCriterionResult(super::MutateCustomerNegativeCriteriaResult),
        /// The result for the customer mutate.
        #[prost(message, tag = "35")]
        CustomerResult(super::MutateCustomerResult),
        /// The result for the extension feed item mutate.
        #[prost(message, tag = "36")]
        ExtensionFeedItemResult(super::MutateExtensionFeedItemResult),
        /// The result for the feed item mutate.
        #[prost(message, tag = "37")]
        FeedItemResult(super::MutateFeedItemResult),
        /// The result for the feed item target mutate.
        #[prost(message, tag = "38")]
        FeedItemTargetResult(super::MutateFeedItemTargetResult),
        /// The result for the feed mapping mutate.
        #[prost(message, tag = "39")]
        FeedMappingResult(super::MutateFeedMappingResult),
        /// The result for the feed mutate.
        #[prost(message, tag = "40")]
        FeedResult(super::MutateFeedResult),
        /// The result for the label mutate.
        #[prost(message, tag = "41")]
        LabelResult(super::MutateLabelResult),
        /// The result for the media file mutate.
        #[prost(message, tag = "42")]
        MediaFileResult(super::MutateMediaFileResult),
        /// The result for the remarketing action mutate.
        #[prost(message, tag = "43")]
        RemarketingActionResult(super::MutateRemarketingActionResult),
        /// The result for the shared criterion mutate.
        #[prost(message, tag = "14")]
        SharedCriterionResult(super::MutateSharedCriterionResult),
        /// The result for the shared set mutate.
        #[prost(message, tag = "15")]
        SharedSetResult(super::MutateSharedSetResult),
        /// The result for the user list mutate.
        #[prost(message, tag = "16")]
        UserListResult(super::MutateUserListResult),
    }
}
#[doc = r" Generated client implementations."]
pub mod google_ads_service_client {
    #![allow(unused_variables, dead_code, missing_docs)]
    use tonic::codegen::*;
    #[doc = " Service to fetch data and metrics across resources."]
    pub struct GoogleAdsServiceClient<T> {
        inner: tonic::client::Grpc<T>,
    }
    impl GoogleAdsServiceClient<tonic::transport::Channel> {
        #[doc = r" Attempt to create a new client by connecting to a given endpoint."]
        pub async fn connect<D>(dst: D) -> Result<Self, tonic::transport::Error>
        where
            D: std::convert::TryInto<tonic::transport::Endpoint>,
            D::Error: Into<StdError>,
        {
            let conn = tonic::transport::Endpoint::new(dst)?.connect().await?;
            Ok(Self::new(conn))
        }
    }
    impl<T> GoogleAdsServiceClient<T>
    where
        T: tonic::client::GrpcService<tonic::body::BoxBody>,
        T::ResponseBody: Body + HttpBody + Send + 'static,
        T::Error: Into<StdError>,
        <T::ResponseBody as HttpBody>::Error: Into<StdError> + Send,
    {
        pub fn new(inner: T) -> Self {
            let inner = tonic::client::Grpc::new(inner);
            Self { inner }
        }
        pub fn with_interceptor(inner: T, interceptor: impl Into<tonic::Interceptor>) -> Self {
            let inner = tonic::client::Grpc::with_interceptor(inner, interceptor);
            Self { inner }
        }
        #[doc = " Returns all rows that match the search query."]
        pub async fn search(
            &mut self,
            request: impl tonic::IntoRequest<super::SearchGoogleAdsRequest>,
        ) -> Result<tonic::Response<super::SearchGoogleAdsResponse>, tonic::Status> {
            self.inner.ready().await.map_err(|e| {
                tonic::Status::new(
                    tonic::Code::Unknown,
                    format!("Service was not ready: {}", e.into()),
                )
            })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.ads.googleads.v1.services.GoogleAdsService/Search",
            );
            self.inner.unary(request.into_request(), path, codec).await
        }
        #[doc = " Creates, updates, or removes resources. This method supports atomic"]
        #[doc = " transactions with multiple types of resources. For example, you can"]
        #[doc = " atomically create a campaign and a campaign budget, or perform up to"]
        #[doc = " thousands of mutates atomically."]
        #[doc = ""]
        #[doc = " This method is essentially a wrapper around a series of mutate methods. The"]
        #[doc = " only features it offers over calling those methods directly are:"]
        #[doc = ""]
        #[doc = " - Atomic transactions"]
        #[doc = " - Temp resource names (described below)"]
        #[doc = " - Somewhat reduced latency over making a series of mutate calls"]
        #[doc = ""]
        #[doc = " Note: Only resources that support atomic transactions are included, so this"]
        #[doc = " method can't replace all calls to individual services."]
        #[doc = ""]
        #[doc = " ## Atomic Transaction Benefits"]
        #[doc = ""]
        #[doc = " Atomicity makes error handling much easier. If you're making a series of"]
        #[doc = " changes and one fails, it can leave your account in an inconsistent state."]
        #[doc = " With atomicity, you either reach the desired state directly, or the request"]
        #[doc = " fails and you can retry."]
        #[doc = ""]
        #[doc = " ## Temp Resource Names"]
        #[doc = ""]
        #[doc = " Temp resource names are a special type of resource name used to create a"]
        #[doc = " resource and reference that resource in the same request. For example, if a"]
        #[doc = " campaign budget is created with `resource_name` equal to"]
        #[doc = " `customers/123/campaignBudgets/-1`, that resource name can be reused in"]
        #[doc = " the `Campaign.budget` field in the same request. That way, the two"]
        #[doc = " resources are created and linked atomically."]
        #[doc = ""]
        #[doc = " To create a temp resource name, put a negative number in the part of the"]
        #[doc = " name that the server would normally allocate."]
        #[doc = ""]
        #[doc = " Note:"]
        #[doc = ""]
        #[doc = " - Resources must be created with a temp name before the name can be reused."]
        #[doc = "   For example, the previous CampaignBudget+Campaign example would fail if"]
        #[doc = "   the mutate order was reversed."]
        #[doc = " - Temp names are not remembered across requests."]
        #[doc = " - There's no limit to the number of temp names in a request."]
        #[doc = " - Each temp name must use a unique negative number, even if the resource"]
        #[doc = "   types differ."]
        #[doc = ""]
        #[doc = " ## Latency"]
        #[doc = ""]
        #[doc = " It's important to group mutates by resource type or the request may time"]
        #[doc = " out and fail. Latency is roughly equal to a series of calls to individual"]
        #[doc = " mutate methods, where each change in resource type is a new call. For"]
        #[doc = " example, mutating 10 campaigns then 10 ad groups is like 2 calls, while"]
        #[doc = " mutating 1 campaign, 1 ad group, 1 campaign, 1 ad group is like 4 calls."]
        pub async fn mutate(
            &mut self,
            request: impl tonic::IntoRequest<super::MutateGoogleAdsRequest>,
        ) -> Result<tonic::Response<super::MutateGoogleAdsResponse>, tonic::Status> {
            self.inner.ready().await.map_err(|e| {
                tonic::Status::new(
                    tonic::Code::Unknown,
                    format!("Service was not ready: {}", e.into()),
                )
            })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.ads.googleads.v1.services.GoogleAdsService/Mutate",
            );
            self.inner.unary(request.into_request(), path, codec).await
        }
    }
    impl<T: Clone> Clone for GoogleAdsServiceClient<T> {
        fn clone(&self) -> Self {
            Self {
                inner: self.inner.clone(),
            }
        }
    }
    impl<T> std::fmt::Debug for GoogleAdsServiceClient<T> {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
            write!(f, "GoogleAdsServiceClient {{ ... }}")
        }
    }
}
#[doc = r" Generated server implementations."]
pub mod google_ads_service_server {
    #![allow(unused_variables, dead_code, missing_docs)]
    use tonic::codegen::*;
    #[doc = "Generated trait containing gRPC methods that should be implemented for use with GoogleAdsServiceServer."]
    #[async_trait]
    pub trait GoogleAdsService: Send + Sync + 'static {
        #[doc = " Returns all rows that match the search query."]
        async fn search(
            &self,
            request: tonic::Request<super::SearchGoogleAdsRequest>,
        ) -> Result<tonic::Response<super::SearchGoogleAdsResponse>, tonic::Status>;
        #[doc = " Creates, updates, or removes resources. This method supports atomic"]
        #[doc = " transactions with multiple types of resources. For example, you can"]
        #[doc = " atomically create a campaign and a campaign budget, or perform up to"]
        #[doc = " thousands of mutates atomically."]
        #[doc = ""]
        #[doc = " This method is essentially a wrapper around a series of mutate methods. The"]
        #[doc = " only features it offers over calling those methods directly are:"]
        #[doc = ""]
        #[doc = " - Atomic transactions"]
        #[doc = " - Temp resource names (described below)"]
        #[doc = " - Somewhat reduced latency over making a series of mutate calls"]
        #[doc = ""]
        #[doc = " Note: Only resources that support atomic transactions are included, so this"]
        #[doc = " method can't replace all calls to individual services."]
        #[doc = ""]
        #[doc = " ## Atomic Transaction Benefits"]
        #[doc = ""]
        #[doc = " Atomicity makes error handling much easier. If you're making a series of"]
        #[doc = " changes and one fails, it can leave your account in an inconsistent state."]
        #[doc = " With atomicity, you either reach the desired state directly, or the request"]
        #[doc = " fails and you can retry."]
        #[doc = ""]
        #[doc = " ## Temp Resource Names"]
        #[doc = ""]
        #[doc = " Temp resource names are a special type of resource name used to create a"]
        #[doc = " resource and reference that resource in the same request. For example, if a"]
        #[doc = " campaign budget is created with `resource_name` equal to"]
        #[doc = " `customers/123/campaignBudgets/-1`, that resource name can be reused in"]
        #[doc = " the `Campaign.budget` field in the same request. That way, the two"]
        #[doc = " resources are created and linked atomically."]
        #[doc = ""]
        #[doc = " To create a temp resource name, put a negative number in the part of the"]
        #[doc = " name that the server would normally allocate."]
        #[doc = ""]
        #[doc = " Note:"]
        #[doc = ""]
        #[doc = " - Resources must be created with a temp name before the name can be reused."]
        #[doc = "   For example, the previous CampaignBudget+Campaign example would fail if"]
        #[doc = "   the mutate order was reversed."]
        #[doc = " - Temp names are not remembered across requests."]
        #[doc = " - There's no limit to the number of temp names in a request."]
        #[doc = " - Each temp name must use a unique negative number, even if the resource"]
        #[doc = "   types differ."]
        #[doc = ""]
        #[doc = " ## Latency"]
        #[doc = ""]
        #[doc = " It's important to group mutates by resource type or the request may time"]
        #[doc = " out and fail. Latency is roughly equal to a series of calls to individual"]
        #[doc = " mutate methods, where each change in resource type is a new call. For"]
        #[doc = " example, mutating 10 campaigns then 10 ad groups is like 2 calls, while"]
        #[doc = " mutating 1 campaign, 1 ad group, 1 campaign, 1 ad group is like 4 calls."]
        async fn mutate(
            &self,
            request: tonic::Request<super::MutateGoogleAdsRequest>,
        ) -> Result<tonic::Response<super::MutateGoogleAdsResponse>, tonic::Status>;
    }
    #[doc = " Service to fetch data and metrics across resources."]
    #[derive(Debug)]
    #[doc(hidden)]
    pub struct GoogleAdsServiceServer<T: GoogleAdsService> {
        inner: _Inner<T>,
    }
    struct _Inner<T>(Arc<T>, Option<tonic::Interceptor>);
    impl<T: GoogleAdsService> GoogleAdsServiceServer<T> {
        pub fn new(inner: T) -> Self {
            let inner = Arc::new(inner);
            let inner = _Inner(inner, None);
            Self { inner }
        }
        pub fn with_interceptor(inner: T, interceptor: impl Into<tonic::Interceptor>) -> Self {
            let inner = Arc::new(inner);
            let inner = _Inner(inner, Some(interceptor.into()));
            Self { inner }
        }
    }
    impl<T, B> Service<http::Request<B>> for GoogleAdsServiceServer<T>
    where
        T: GoogleAdsService,
        B: HttpBody + Send + Sync + 'static,
        B::Error: Into<StdError> + Send + 'static,
    {
        type Response = http::Response<tonic::body::BoxBody>;
        type Error = Never;
        type Future = BoxFuture<Self::Response, Self::Error>;
        fn poll_ready(&mut self, _cx: &mut Context<'_>) -> Poll<Result<(), Self::Error>> {
            Poll::Ready(Ok(()))
        }
        fn call(&mut self, req: http::Request<B>) -> Self::Future {
            let inner = self.inner.clone();
            match req.uri().path() {
                "/google.ads.googleads.v1.services.GoogleAdsService/Search" => {
                    #[allow(non_camel_case_types)]
                    struct SearchSvc<T: GoogleAdsService>(pub Arc<T>);
                    impl<T: GoogleAdsService>
                        tonic::server::UnaryService<super::SearchGoogleAdsRequest>
                        for SearchSvc<T>
                    {
                        type Response = super::SearchGoogleAdsResponse;
                        type Future = BoxFuture<tonic::Response<Self::Response>, tonic::Status>;
                        fn call(
                            &mut self,
                            request: tonic::Request<super::SearchGoogleAdsRequest>,
                        ) -> Self::Future {
                            let inner = self.0.clone();
                            let fut = async move { inner.search(request).await };
                            Box::pin(fut)
                        }
                    }
                    let inner = self.inner.clone();
                    let fut = async move {
                        let interceptor = inner.1.clone();
                        let inner = inner.0;
                        let method = SearchSvc(inner);
                        let codec = tonic::codec::ProstCodec::default();
                        let mut grpc = if let Some(interceptor) = interceptor {
                            tonic::server::Grpc::with_interceptor(codec, interceptor)
                        } else {
                            tonic::server::Grpc::new(codec)
                        };
                        let res = grpc.unary(method, req).await;
                        Ok(res)
                    };
                    Box::pin(fut)
                }
                "/google.ads.googleads.v1.services.GoogleAdsService/Mutate" => {
                    #[allow(non_camel_case_types)]
                    struct MutateSvc<T: GoogleAdsService>(pub Arc<T>);
                    impl<T: GoogleAdsService>
                        tonic::server::UnaryService<super::MutateGoogleAdsRequest>
                        for MutateSvc<T>
                    {
                        type Response = super::MutateGoogleAdsResponse;
                        type Future = BoxFuture<tonic::Response<Self::Response>, tonic::Status>;
                        fn call(
                            &mut self,
                            request: tonic::Request<super::MutateGoogleAdsRequest>,
                        ) -> Self::Future {
                            let inner = self.0.clone();
                            let fut = async move { inner.mutate(request).await };
                            Box::pin(fut)
                        }
                    }
                    let inner = self.inner.clone();
                    let fut = async move {
                        let interceptor = inner.1.clone();
                        let inner = inner.0;
                        let method = MutateSvc(inner);
                        let codec = tonic::codec::ProstCodec::default();
                        let mut grpc = if let Some(interceptor) = interceptor {
                            tonic::server::Grpc::with_interceptor(codec, interceptor)
                        } else {
                            tonic::server::Grpc::new(codec)
                        };
                        let res = grpc.unary(method, req).await;
                        Ok(res)
                    };
                    Box::pin(fut)
                }
                _ => Box::pin(async move {
                    Ok(http::Response::builder()
                        .status(200)
                        .header("grpc-status", "12")
                        .body(tonic::body::BoxBody::empty())
                        .unwrap())
                }),
            }
        }
    }
    impl<T: GoogleAdsService> Clone for GoogleAdsServiceServer<T> {
        fn clone(&self) -> Self {
            let inner = self.inner.clone();
            Self { inner }
        }
    }
    impl<T: GoogleAdsService> Clone for _Inner<T> {
        fn clone(&self) -> Self {
            Self(self.0.clone(), self.1.clone())
        }
    }
    impl<T: std::fmt::Debug> std::fmt::Debug for _Inner<T> {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
            write!(f, "{:?}", self.0)
        }
    }
    impl<T: GoogleAdsService> tonic::transport::NamedService for GoogleAdsServiceServer<T> {
        const NAME: &'static str = "google.ads.googleads.v1.services.GoogleAdsService";
    }
}
/// Request message for [GroupPlacementViewService.GetGroupPlacementView][google.ads.googleads.v1.services.GroupPlacementViewService.GetGroupPlacementView].
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GetGroupPlacementViewRequest {
    /// Required. The resource name of the Group Placement view to fetch.
    #[prost(string, tag = "1")]
    pub resource_name: std::string::String,
}
#[doc = r" Generated client implementations."]
pub mod group_placement_view_service_client {
    #![allow(unused_variables, dead_code, missing_docs)]
    use tonic::codegen::*;
    #[doc = " Service to fetch Group Placement views."]
    pub struct GroupPlacementViewServiceClient<T> {
        inner: tonic::client::Grpc<T>,
    }
    impl GroupPlacementViewServiceClient<tonic::transport::Channel> {
        #[doc = r" Attempt to create a new client by connecting to a given endpoint."]
        pub async fn connect<D>(dst: D) -> Result<Self, tonic::transport::Error>
        where
            D: std::convert::TryInto<tonic::transport::Endpoint>,
            D::Error: Into<StdError>,
        {
            let conn = tonic::transport::Endpoint::new(dst)?.connect().await?;
            Ok(Self::new(conn))
        }
    }
    impl<T> GroupPlacementViewServiceClient<T>
    where
        T: tonic::client::GrpcService<tonic::body::BoxBody>,
        T::ResponseBody: Body + HttpBody + Send + 'static,
        T::Error: Into<StdError>,
        <T::ResponseBody as HttpBody>::Error: Into<StdError> + Send,
    {
        pub fn new(inner: T) -> Self {
            let inner = tonic::client::Grpc::new(inner);
            Self { inner }
        }
        pub fn with_interceptor(inner: T, interceptor: impl Into<tonic::Interceptor>) -> Self {
            let inner = tonic::client::Grpc::with_interceptor(inner, interceptor);
            Self { inner }
        }
        #[doc = " Returns the requested Group Placement view in full detail."]
        pub async fn get_group_placement_view(
            &mut self,
            request: impl tonic::IntoRequest<super::GetGroupPlacementViewRequest>,
        ) -> Result<tonic::Response<super::super::resources::GroupPlacementView>, tonic::Status>
        {
            self.inner.ready().await.map_err(|e| {
                tonic::Status::new(
                    tonic::Code::Unknown,
                    format!("Service was not ready: {}", e.into()),
                )
            })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.ads.googleads.v1.services.GroupPlacementViewService/GetGroupPlacementView",
            );
            self.inner.unary(request.into_request(), path, codec).await
        }
    }
    impl<T: Clone> Clone for GroupPlacementViewServiceClient<T> {
        fn clone(&self) -> Self {
            Self {
                inner: self.inner.clone(),
            }
        }
    }
    impl<T> std::fmt::Debug for GroupPlacementViewServiceClient<T> {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
            write!(f, "GroupPlacementViewServiceClient {{ ... }}")
        }
    }
}
#[doc = r" Generated server implementations."]
pub mod group_placement_view_service_server {
    #![allow(unused_variables, dead_code, missing_docs)]
    use tonic::codegen::*;
    #[doc = "Generated trait containing gRPC methods that should be implemented for use with GroupPlacementViewServiceServer."]
    #[async_trait]
    pub trait GroupPlacementViewService: Send + Sync + 'static {
        #[doc = " Returns the requested Group Placement view in full detail."]
        async fn get_group_placement_view(
            &self,
            request: tonic::Request<super::GetGroupPlacementViewRequest>,
        ) -> Result<tonic::Response<super::super::resources::GroupPlacementView>, tonic::Status>;
    }
    #[doc = " Service to fetch Group Placement views."]
    #[derive(Debug)]
    #[doc(hidden)]
    pub struct GroupPlacementViewServiceServer<T: GroupPlacementViewService> {
        inner: _Inner<T>,
    }
    struct _Inner<T>(Arc<T>, Option<tonic::Interceptor>);
    impl<T: GroupPlacementViewService> GroupPlacementViewServiceServer<T> {
        pub fn new(inner: T) -> Self {
            let inner = Arc::new(inner);
            let inner = _Inner(inner, None);
            Self { inner }
        }
        pub fn with_interceptor(inner: T, interceptor: impl Into<tonic::Interceptor>) -> Self {
            let inner = Arc::new(inner);
            let inner = _Inner(inner, Some(interceptor.into()));
            Self { inner }
        }
    }
    impl<T, B> Service<http::Request<B>> for GroupPlacementViewServiceServer<T>
    where
        T: GroupPlacementViewService,
        B: HttpBody + Send + Sync + 'static,
        B::Error: Into<StdError> + Send + 'static,
    {
        type Response = http::Response<tonic::body::BoxBody>;
        type Error = Never;
        type Future = BoxFuture<Self::Response, Self::Error>;
        fn poll_ready(&mut self, _cx: &mut Context<'_>) -> Poll<Result<(), Self::Error>> {
            Poll::Ready(Ok(()))
        }
        fn call(&mut self, req: http::Request<B>) -> Self::Future {
            let inner = self.inner.clone();
            match req . uri ( ) . path ( ) { "/google.ads.googleads.v1.services.GroupPlacementViewService/GetGroupPlacementView" => { # [ allow ( non_camel_case_types ) ] struct GetGroupPlacementViewSvc < T : GroupPlacementViewService > ( pub Arc < T > ) ; impl < T : GroupPlacementViewService > tonic :: server :: UnaryService < super :: GetGroupPlacementViewRequest > for GetGroupPlacementViewSvc < T > { type Response = super :: super :: resources :: GroupPlacementView ; type Future = BoxFuture < tonic :: Response < Self :: Response > , tonic :: Status > ; fn call ( & mut self , request : tonic :: Request < super :: GetGroupPlacementViewRequest > ) -> Self :: Future { let inner = self . 0 . clone ( ) ; let fut = async move { inner . get_group_placement_view ( request ) . await } ; Box :: pin ( fut ) } } let inner = self . inner . clone ( ) ; let fut = async move { let interceptor = inner . 1 . clone ( ) ; let inner = inner . 0 ; let method = GetGroupPlacementViewSvc ( inner ) ; let codec = tonic :: codec :: ProstCodec :: default ( ) ; let mut grpc = if let Some ( interceptor ) = interceptor { tonic :: server :: Grpc :: with_interceptor ( codec , interceptor ) } else { tonic :: server :: Grpc :: new ( codec ) } ; let res = grpc . unary ( method , req ) . await ; Ok ( res ) } ; Box :: pin ( fut ) } _ => Box :: pin ( async move { Ok ( http :: Response :: builder ( ) . status ( 200 ) . header ( "grpc-status" , "12" ) . body ( tonic :: body :: BoxBody :: empty ( ) ) . unwrap ( ) ) } ) , }
        }
    }
    impl<T: GroupPlacementViewService> Clone for GroupPlacementViewServiceServer<T> {
        fn clone(&self) -> Self {
            let inner = self.inner.clone();
            Self { inner }
        }
    }
    impl<T: GroupPlacementViewService> Clone for _Inner<T> {
        fn clone(&self) -> Self {
            Self(self.0.clone(), self.1.clone())
        }
    }
    impl<T: std::fmt::Debug> std::fmt::Debug for _Inner<T> {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
            write!(f, "{:?}", self.0)
        }
    }
    impl<T: GroupPlacementViewService> tonic::transport::NamedService
        for GroupPlacementViewServiceServer<T>
    {
        const NAME: &'static str = "google.ads.googleads.v1.services.GroupPlacementViewService";
    }
}
/// Request message for [HotelGroupViewService.GetHotelGroupView][google.ads.googleads.v1.services.HotelGroupViewService.GetHotelGroupView].
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GetHotelGroupViewRequest {
    /// Required. Resource name of the Hotel Group View to fetch.
    #[prost(string, tag = "1")]
    pub resource_name: std::string::String,
}
#[doc = r" Generated client implementations."]
pub mod hotel_group_view_service_client {
    #![allow(unused_variables, dead_code, missing_docs)]
    use tonic::codegen::*;
    #[doc = " Service to manage Hotel Group Views."]
    pub struct HotelGroupViewServiceClient<T> {
        inner: tonic::client::Grpc<T>,
    }
    impl HotelGroupViewServiceClient<tonic::transport::Channel> {
        #[doc = r" Attempt to create a new client by connecting to a given endpoint."]
        pub async fn connect<D>(dst: D) -> Result<Self, tonic::transport::Error>
        where
            D: std::convert::TryInto<tonic::transport::Endpoint>,
            D::Error: Into<StdError>,
        {
            let conn = tonic::transport::Endpoint::new(dst)?.connect().await?;
            Ok(Self::new(conn))
        }
    }
    impl<T> HotelGroupViewServiceClient<T>
    where
        T: tonic::client::GrpcService<tonic::body::BoxBody>,
        T::ResponseBody: Body + HttpBody + Send + 'static,
        T::Error: Into<StdError>,
        <T::ResponseBody as HttpBody>::Error: Into<StdError> + Send,
    {
        pub fn new(inner: T) -> Self {
            let inner = tonic::client::Grpc::new(inner);
            Self { inner }
        }
        pub fn with_interceptor(inner: T, interceptor: impl Into<tonic::Interceptor>) -> Self {
            let inner = tonic::client::Grpc::with_interceptor(inner, interceptor);
            Self { inner }
        }
        #[doc = " Returns the requested Hotel Group View in full detail."]
        pub async fn get_hotel_group_view(
            &mut self,
            request: impl tonic::IntoRequest<super::GetHotelGroupViewRequest>,
        ) -> Result<tonic::Response<super::super::resources::HotelGroupView>, tonic::Status>
        {
            self.inner.ready().await.map_err(|e| {
                tonic::Status::new(
                    tonic::Code::Unknown,
                    format!("Service was not ready: {}", e.into()),
                )
            })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.ads.googleads.v1.services.HotelGroupViewService/GetHotelGroupView",
            );
            self.inner.unary(request.into_request(), path, codec).await
        }
    }
    impl<T: Clone> Clone for HotelGroupViewServiceClient<T> {
        fn clone(&self) -> Self {
            Self {
                inner: self.inner.clone(),
            }
        }
    }
    impl<T> std::fmt::Debug for HotelGroupViewServiceClient<T> {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
            write!(f, "HotelGroupViewServiceClient {{ ... }}")
        }
    }
}
#[doc = r" Generated server implementations."]
pub mod hotel_group_view_service_server {
    #![allow(unused_variables, dead_code, missing_docs)]
    use tonic::codegen::*;
    #[doc = "Generated trait containing gRPC methods that should be implemented for use with HotelGroupViewServiceServer."]
    #[async_trait]
    pub trait HotelGroupViewService: Send + Sync + 'static {
        #[doc = " Returns the requested Hotel Group View in full detail."]
        async fn get_hotel_group_view(
            &self,
            request: tonic::Request<super::GetHotelGroupViewRequest>,
        ) -> Result<tonic::Response<super::super::resources::HotelGroupView>, tonic::Status>;
    }
    #[doc = " Service to manage Hotel Group Views."]
    #[derive(Debug)]
    #[doc(hidden)]
    pub struct HotelGroupViewServiceServer<T: HotelGroupViewService> {
        inner: _Inner<T>,
    }
    struct _Inner<T>(Arc<T>, Option<tonic::Interceptor>);
    impl<T: HotelGroupViewService> HotelGroupViewServiceServer<T> {
        pub fn new(inner: T) -> Self {
            let inner = Arc::new(inner);
            let inner = _Inner(inner, None);
            Self { inner }
        }
        pub fn with_interceptor(inner: T, interceptor: impl Into<tonic::Interceptor>) -> Self {
            let inner = Arc::new(inner);
            let inner = _Inner(inner, Some(interceptor.into()));
            Self { inner }
        }
    }
    impl<T, B> Service<http::Request<B>> for HotelGroupViewServiceServer<T>
    where
        T: HotelGroupViewService,
        B: HttpBody + Send + Sync + 'static,
        B::Error: Into<StdError> + Send + 'static,
    {
        type Response = http::Response<tonic::body::BoxBody>;
        type Error = Never;
        type Future = BoxFuture<Self::Response, Self::Error>;
        fn poll_ready(&mut self, _cx: &mut Context<'_>) -> Poll<Result<(), Self::Error>> {
            Poll::Ready(Ok(()))
        }
        fn call(&mut self, req: http::Request<B>) -> Self::Future {
            let inner = self.inner.clone();
            match req.uri().path() {
                "/google.ads.googleads.v1.services.HotelGroupViewService/GetHotelGroupView" => {
                    #[allow(non_camel_case_types)]
                    struct GetHotelGroupViewSvc<T: HotelGroupViewService>(pub Arc<T>);
                    impl<T: HotelGroupViewService>
                        tonic::server::UnaryService<super::GetHotelGroupViewRequest>
                        for GetHotelGroupViewSvc<T>
                    {
                        type Response = super::super::resources::HotelGroupView;
                        type Future = BoxFuture<tonic::Response<Self::Response>, tonic::Status>;
                        fn call(
                            &mut self,
                            request: tonic::Request<super::GetHotelGroupViewRequest>,
                        ) -> Self::Future {
                            let inner = self.0.clone();
                            let fut = async move { inner.get_hotel_group_view(request).await };
                            Box::pin(fut)
                        }
                    }
                    let inner = self.inner.clone();
                    let fut = async move {
                        let interceptor = inner.1.clone();
                        let inner = inner.0;
                        let method = GetHotelGroupViewSvc(inner);
                        let codec = tonic::codec::ProstCodec::default();
                        let mut grpc = if let Some(interceptor) = interceptor {
                            tonic::server::Grpc::with_interceptor(codec, interceptor)
                        } else {
                            tonic::server::Grpc::new(codec)
                        };
                        let res = grpc.unary(method, req).await;
                        Ok(res)
                    };
                    Box::pin(fut)
                }
                _ => Box::pin(async move {
                    Ok(http::Response::builder()
                        .status(200)
                        .header("grpc-status", "12")
                        .body(tonic::body::BoxBody::empty())
                        .unwrap())
                }),
            }
        }
    }
    impl<T: HotelGroupViewService> Clone for HotelGroupViewServiceServer<T> {
        fn clone(&self) -> Self {
            let inner = self.inner.clone();
            Self { inner }
        }
    }
    impl<T: HotelGroupViewService> Clone for _Inner<T> {
        fn clone(&self) -> Self {
            Self(self.0.clone(), self.1.clone())
        }
    }
    impl<T: std::fmt::Debug> std::fmt::Debug for _Inner<T> {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
            write!(f, "{:?}", self.0)
        }
    }
    impl<T: HotelGroupViewService> tonic::transport::NamedService for HotelGroupViewServiceServer<T> {
        const NAME: &'static str = "google.ads.googleads.v1.services.HotelGroupViewService";
    }
}
/// Request message for [HotelPerformanceViewService.GetHotelPerformanceView][google.ads.googleads.v1.services.HotelPerformanceViewService.GetHotelPerformanceView].
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GetHotelPerformanceViewRequest {
    /// Required. Resource name of the Hotel Performance View to fetch.
    #[prost(string, tag = "1")]
    pub resource_name: std::string::String,
}
#[doc = r" Generated client implementations."]
pub mod hotel_performance_view_service_client {
    #![allow(unused_variables, dead_code, missing_docs)]
    use tonic::codegen::*;
    #[doc = " Service to manage Hotel Performance Views."]
    pub struct HotelPerformanceViewServiceClient<T> {
        inner: tonic::client::Grpc<T>,
    }
    impl HotelPerformanceViewServiceClient<tonic::transport::Channel> {
        #[doc = r" Attempt to create a new client by connecting to a given endpoint."]
        pub async fn connect<D>(dst: D) -> Result<Self, tonic::transport::Error>
        where
            D: std::convert::TryInto<tonic::transport::Endpoint>,
            D::Error: Into<StdError>,
        {
            let conn = tonic::transport::Endpoint::new(dst)?.connect().await?;
            Ok(Self::new(conn))
        }
    }
    impl<T> HotelPerformanceViewServiceClient<T>
    where
        T: tonic::client::GrpcService<tonic::body::BoxBody>,
        T::ResponseBody: Body + HttpBody + Send + 'static,
        T::Error: Into<StdError>,
        <T::ResponseBody as HttpBody>::Error: Into<StdError> + Send,
    {
        pub fn new(inner: T) -> Self {
            let inner = tonic::client::Grpc::new(inner);
            Self { inner }
        }
        pub fn with_interceptor(inner: T, interceptor: impl Into<tonic::Interceptor>) -> Self {
            let inner = tonic::client::Grpc::with_interceptor(inner, interceptor);
            Self { inner }
        }
        #[doc = " Returns the requested Hotel Performance View in full detail."]
        pub async fn get_hotel_performance_view(
            &mut self,
            request: impl tonic::IntoRequest<super::GetHotelPerformanceViewRequest>,
        ) -> Result<tonic::Response<super::super::resources::HotelPerformanceView>, tonic::Status>
        {
            self.inner.ready().await.map_err(|e| {
                tonic::Status::new(
                    tonic::Code::Unknown,
                    format!("Service was not ready: {}", e.into()),
                )
            })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http :: uri :: PathAndQuery :: from_static ( "/google.ads.googleads.v1.services.HotelPerformanceViewService/GetHotelPerformanceView" ) ;
            self.inner.unary(request.into_request(), path, codec).await
        }
    }
    impl<T: Clone> Clone for HotelPerformanceViewServiceClient<T> {
        fn clone(&self) -> Self {
            Self {
                inner: self.inner.clone(),
            }
        }
    }
    impl<T> std::fmt::Debug for HotelPerformanceViewServiceClient<T> {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
            write!(f, "HotelPerformanceViewServiceClient {{ ... }}")
        }
    }
}
#[doc = r" Generated server implementations."]
pub mod hotel_performance_view_service_server {
    #![allow(unused_variables, dead_code, missing_docs)]
    use tonic::codegen::*;
    #[doc = "Generated trait containing gRPC methods that should be implemented for use with HotelPerformanceViewServiceServer."]
    #[async_trait]
    pub trait HotelPerformanceViewService: Send + Sync + 'static {
        #[doc = " Returns the requested Hotel Performance View in full detail."]
        async fn get_hotel_performance_view(
            &self,
            request: tonic::Request<super::GetHotelPerformanceViewRequest>,
        ) -> Result<tonic::Response<super::super::resources::HotelPerformanceView>, tonic::Status>;
    }
    #[doc = " Service to manage Hotel Performance Views."]
    #[derive(Debug)]
    #[doc(hidden)]
    pub struct HotelPerformanceViewServiceServer<T: HotelPerformanceViewService> {
        inner: _Inner<T>,
    }
    struct _Inner<T>(Arc<T>, Option<tonic::Interceptor>);
    impl<T: HotelPerformanceViewService> HotelPerformanceViewServiceServer<T> {
        pub fn new(inner: T) -> Self {
            let inner = Arc::new(inner);
            let inner = _Inner(inner, None);
            Self { inner }
        }
        pub fn with_interceptor(inner: T, interceptor: impl Into<tonic::Interceptor>) -> Self {
            let inner = Arc::new(inner);
            let inner = _Inner(inner, Some(interceptor.into()));
            Self { inner }
        }
    }
    impl<T, B> Service<http::Request<B>> for HotelPerformanceViewServiceServer<T>
    where
        T: HotelPerformanceViewService,
        B: HttpBody + Send + Sync + 'static,
        B::Error: Into<StdError> + Send + 'static,
    {
        type Response = http::Response<tonic::body::BoxBody>;
        type Error = Never;
        type Future = BoxFuture<Self::Response, Self::Error>;
        fn poll_ready(&mut self, _cx: &mut Context<'_>) -> Poll<Result<(), Self::Error>> {
            Poll::Ready(Ok(()))
        }
        fn call(&mut self, req: http::Request<B>) -> Self::Future {
            let inner = self.inner.clone();
            match req . uri ( ) . path ( ) { "/google.ads.googleads.v1.services.HotelPerformanceViewService/GetHotelPerformanceView" => { # [ allow ( non_camel_case_types ) ] struct GetHotelPerformanceViewSvc < T : HotelPerformanceViewService > ( pub Arc < T > ) ; impl < T : HotelPerformanceViewService > tonic :: server :: UnaryService < super :: GetHotelPerformanceViewRequest > for GetHotelPerformanceViewSvc < T > { type Response = super :: super :: resources :: HotelPerformanceView ; type Future = BoxFuture < tonic :: Response < Self :: Response > , tonic :: Status > ; fn call ( & mut self , request : tonic :: Request < super :: GetHotelPerformanceViewRequest > ) -> Self :: Future { let inner = self . 0 . clone ( ) ; let fut = async move { inner . get_hotel_performance_view ( request ) . await } ; Box :: pin ( fut ) } } let inner = self . inner . clone ( ) ; let fut = async move { let interceptor = inner . 1 . clone ( ) ; let inner = inner . 0 ; let method = GetHotelPerformanceViewSvc ( inner ) ; let codec = tonic :: codec :: ProstCodec :: default ( ) ; let mut grpc = if let Some ( interceptor ) = interceptor { tonic :: server :: Grpc :: with_interceptor ( codec , interceptor ) } else { tonic :: server :: Grpc :: new ( codec ) } ; let res = grpc . unary ( method , req ) . await ; Ok ( res ) } ; Box :: pin ( fut ) } _ => Box :: pin ( async move { Ok ( http :: Response :: builder ( ) . status ( 200 ) . header ( "grpc-status" , "12" ) . body ( tonic :: body :: BoxBody :: empty ( ) ) . unwrap ( ) ) } ) , }
        }
    }
    impl<T: HotelPerformanceViewService> Clone for HotelPerformanceViewServiceServer<T> {
        fn clone(&self) -> Self {
            let inner = self.inner.clone();
            Self { inner }
        }
    }
    impl<T: HotelPerformanceViewService> Clone for _Inner<T> {
        fn clone(&self) -> Self {
            Self(self.0.clone(), self.1.clone())
        }
    }
    impl<T: std::fmt::Debug> std::fmt::Debug for _Inner<T> {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
            write!(f, "{:?}", self.0)
        }
    }
    impl<T: HotelPerformanceViewService> tonic::transport::NamedService
        for HotelPerformanceViewServiceServer<T>
    {
        const NAME: &'static str = "google.ads.googleads.v1.services.HotelPerformanceViewService";
    }
}
/// Request message for [KeywordPlanAdGroupService.GetKeywordPlanAdGroup][google.ads.googleads.v1.services.KeywordPlanAdGroupService.GetKeywordPlanAdGroup].
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GetKeywordPlanAdGroupRequest {
    /// Required. The resource name of the Keyword Plan ad group to fetch.
    #[prost(string, tag = "1")]
    pub resource_name: std::string::String,
}
/// Request message for [KeywordPlanAdGroupService.MutateKeywordPlanAdGroups][google.ads.googleads.v1.services.KeywordPlanAdGroupService.MutateKeywordPlanAdGroups].
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct MutateKeywordPlanAdGroupsRequest {
    /// Required. The ID of the customer whose Keyword Plan ad groups are being modified.
    #[prost(string, tag = "1")]
    pub customer_id: std::string::String,
    /// Required. The list of operations to perform on individual Keyword Plan ad groups.
    #[prost(message, repeated, tag = "2")]
    pub operations: ::std::vec::Vec<KeywordPlanAdGroupOperation>,
    /// If true, successful operations will be carried out and invalid
    /// operations will return errors. If false, all operations will be carried
    /// out in one transaction if and only if they are all valid.
    /// Default is false.
    #[prost(bool, tag = "3")]
    pub partial_failure: bool,
    /// If true, the request is validated but not executed. Only errors are
    /// returned, not results.
    #[prost(bool, tag = "4")]
    pub validate_only: bool,
}
/// A single operation (create, update, remove) on a Keyword Plan ad group.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct KeywordPlanAdGroupOperation {
    /// The FieldMask that determines which resource fields are modified in an
    /// update.
    #[prost(message, optional, tag = "4")]
    pub update_mask: ::std::option::Option<::prost_types::FieldMask>,
    /// The mutate operation.
    #[prost(oneof = "keyword_plan_ad_group_operation::Operation", tags = "1, 2, 3")]
    pub operation: ::std::option::Option<keyword_plan_ad_group_operation::Operation>,
}
pub mod keyword_plan_ad_group_operation {
    /// The mutate operation.
    #[derive(Clone, PartialEq, ::prost::Oneof)]
    pub enum Operation {
        /// Create operation: No resource name is expected for the new Keyword Plan
        /// ad group.
        #[prost(message, tag = "1")]
        Create(super::super::resources::KeywordPlanAdGroup),
        /// Update operation: The Keyword Plan ad group is expected to have a valid
        /// resource name.
        #[prost(message, tag = "2")]
        Update(super::super::resources::KeywordPlanAdGroup),
        /// Remove operation: A resource name for the removed Keyword Plan ad group
        /// is expected, in this format:
        ///
        /// `customers/{customer_id}/keywordPlanAdGroups/{kp_ad_group_id}`
        #[prost(string, tag = "3")]
        Remove(std::string::String),
    }
}
/// Response message for a Keyword Plan ad group mutate.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct MutateKeywordPlanAdGroupsResponse {
    /// Errors that pertain to operation failures in the partial failure mode.
    /// Returned only when partial_failure = true and all errors occur inside the
    /// operations. If any errors occur outside the operations (e.g. auth errors),
    /// we return an RPC level error.
    #[prost(message, optional, tag = "3")]
    pub partial_failure_error: ::std::option::Option<super::super::super::super::rpc::Status>,
    /// All results for the mutate.
    #[prost(message, repeated, tag = "2")]
    pub results: ::std::vec::Vec<MutateKeywordPlanAdGroupResult>,
}
/// The result for the Keyword Plan ad group mutate.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct MutateKeywordPlanAdGroupResult {
    /// Returned for successful operations.
    #[prost(string, tag = "1")]
    pub resource_name: std::string::String,
}
#[doc = r" Generated client implementations."]
pub mod keyword_plan_ad_group_service_client {
    #![allow(unused_variables, dead_code, missing_docs)]
    use tonic::codegen::*;
    #[doc = " Service to manage Keyword Plan ad groups."]
    pub struct KeywordPlanAdGroupServiceClient<T> {
        inner: tonic::client::Grpc<T>,
    }
    impl KeywordPlanAdGroupServiceClient<tonic::transport::Channel> {
        #[doc = r" Attempt to create a new client by connecting to a given endpoint."]
        pub async fn connect<D>(dst: D) -> Result<Self, tonic::transport::Error>
        where
            D: std::convert::TryInto<tonic::transport::Endpoint>,
            D::Error: Into<StdError>,
        {
            let conn = tonic::transport::Endpoint::new(dst)?.connect().await?;
            Ok(Self::new(conn))
        }
    }
    impl<T> KeywordPlanAdGroupServiceClient<T>
    where
        T: tonic::client::GrpcService<tonic::body::BoxBody>,
        T::ResponseBody: Body + HttpBody + Send + 'static,
        T::Error: Into<StdError>,
        <T::ResponseBody as HttpBody>::Error: Into<StdError> + Send,
    {
        pub fn new(inner: T) -> Self {
            let inner = tonic::client::Grpc::new(inner);
            Self { inner }
        }
        pub fn with_interceptor(inner: T, interceptor: impl Into<tonic::Interceptor>) -> Self {
            let inner = tonic::client::Grpc::with_interceptor(inner, interceptor);
            Self { inner }
        }
        #[doc = " Returns the requested Keyword Plan ad group in full detail."]
        pub async fn get_keyword_plan_ad_group(
            &mut self,
            request: impl tonic::IntoRequest<super::GetKeywordPlanAdGroupRequest>,
        ) -> Result<tonic::Response<super::super::resources::KeywordPlanAdGroup>, tonic::Status>
        {
            self.inner.ready().await.map_err(|e| {
                tonic::Status::new(
                    tonic::Code::Unknown,
                    format!("Service was not ready: {}", e.into()),
                )
            })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.ads.googleads.v1.services.KeywordPlanAdGroupService/GetKeywordPlanAdGroup",
            );
            self.inner.unary(request.into_request(), path, codec).await
        }
        #[doc = " Creates, updates, or removes Keyword Plan ad groups. Operation statuses are"]
        #[doc = " returned."]
        pub async fn mutate_keyword_plan_ad_groups(
            &mut self,
            request: impl tonic::IntoRequest<super::MutateKeywordPlanAdGroupsRequest>,
        ) -> Result<tonic::Response<super::MutateKeywordPlanAdGroupsResponse>, tonic::Status>
        {
            self.inner.ready().await.map_err(|e| {
                tonic::Status::new(
                    tonic::Code::Unknown,
                    format!("Service was not ready: {}", e.into()),
                )
            })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http :: uri :: PathAndQuery :: from_static ( "/google.ads.googleads.v1.services.KeywordPlanAdGroupService/MutateKeywordPlanAdGroups" ) ;
            self.inner.unary(request.into_request(), path, codec).await
        }
    }
    impl<T: Clone> Clone for KeywordPlanAdGroupServiceClient<T> {
        fn clone(&self) -> Self {
            Self {
                inner: self.inner.clone(),
            }
        }
    }
    impl<T> std::fmt::Debug for KeywordPlanAdGroupServiceClient<T> {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
            write!(f, "KeywordPlanAdGroupServiceClient {{ ... }}")
        }
    }
}
#[doc = r" Generated server implementations."]
pub mod keyword_plan_ad_group_service_server {
    #![allow(unused_variables, dead_code, missing_docs)]
    use tonic::codegen::*;
    #[doc = "Generated trait containing gRPC methods that should be implemented for use with KeywordPlanAdGroupServiceServer."]
    #[async_trait]
    pub trait KeywordPlanAdGroupService: Send + Sync + 'static {
        #[doc = " Returns the requested Keyword Plan ad group in full detail."]
        async fn get_keyword_plan_ad_group(
            &self,
            request: tonic::Request<super::GetKeywordPlanAdGroupRequest>,
        ) -> Result<tonic::Response<super::super::resources::KeywordPlanAdGroup>, tonic::Status>;
        #[doc = " Creates, updates, or removes Keyword Plan ad groups. Operation statuses are"]
        #[doc = " returned."]
        async fn mutate_keyword_plan_ad_groups(
            &self,
            request: tonic::Request<super::MutateKeywordPlanAdGroupsRequest>,
        ) -> Result<tonic::Response<super::MutateKeywordPlanAdGroupsResponse>, tonic::Status>;
    }
    #[doc = " Service to manage Keyword Plan ad groups."]
    #[derive(Debug)]
    #[doc(hidden)]
    pub struct KeywordPlanAdGroupServiceServer<T: KeywordPlanAdGroupService> {
        inner: _Inner<T>,
    }
    struct _Inner<T>(Arc<T>, Option<tonic::Interceptor>);
    impl<T: KeywordPlanAdGroupService> KeywordPlanAdGroupServiceServer<T> {
        pub fn new(inner: T) -> Self {
            let inner = Arc::new(inner);
            let inner = _Inner(inner, None);
            Self { inner }
        }
        pub fn with_interceptor(inner: T, interceptor: impl Into<tonic::Interceptor>) -> Self {
            let inner = Arc::new(inner);
            let inner = _Inner(inner, Some(interceptor.into()));
            Self { inner }
        }
    }
    impl<T, B> Service<http::Request<B>> for KeywordPlanAdGroupServiceServer<T>
    where
        T: KeywordPlanAdGroupService,
        B: HttpBody + Send + Sync + 'static,
        B::Error: Into<StdError> + Send + 'static,
    {
        type Response = http::Response<tonic::body::BoxBody>;
        type Error = Never;
        type Future = BoxFuture<Self::Response, Self::Error>;
        fn poll_ready(&mut self, _cx: &mut Context<'_>) -> Poll<Result<(), Self::Error>> {
            Poll::Ready(Ok(()))
        }
        fn call(&mut self, req: http::Request<B>) -> Self::Future {
            let inner = self.inner.clone();
            match req . uri ( ) . path ( ) { "/google.ads.googleads.v1.services.KeywordPlanAdGroupService/GetKeywordPlanAdGroup" => { # [ allow ( non_camel_case_types ) ] struct GetKeywordPlanAdGroupSvc < T : KeywordPlanAdGroupService > ( pub Arc < T > ) ; impl < T : KeywordPlanAdGroupService > tonic :: server :: UnaryService < super :: GetKeywordPlanAdGroupRequest > for GetKeywordPlanAdGroupSvc < T > { type Response = super :: super :: resources :: KeywordPlanAdGroup ; type Future = BoxFuture < tonic :: Response < Self :: Response > , tonic :: Status > ; fn call ( & mut self , request : tonic :: Request < super :: GetKeywordPlanAdGroupRequest > ) -> Self :: Future { let inner = self . 0 . clone ( ) ; let fut = async move { inner . get_keyword_plan_ad_group ( request ) . await } ; Box :: pin ( fut ) } } let inner = self . inner . clone ( ) ; let fut = async move { let interceptor = inner . 1 . clone ( ) ; let inner = inner . 0 ; let method = GetKeywordPlanAdGroupSvc ( inner ) ; let codec = tonic :: codec :: ProstCodec :: default ( ) ; let mut grpc = if let Some ( interceptor ) = interceptor { tonic :: server :: Grpc :: with_interceptor ( codec , interceptor ) } else { tonic :: server :: Grpc :: new ( codec ) } ; let res = grpc . unary ( method , req ) . await ; Ok ( res ) } ; Box :: pin ( fut ) } "/google.ads.googleads.v1.services.KeywordPlanAdGroupService/MutateKeywordPlanAdGroups" => { # [ allow ( non_camel_case_types ) ] struct MutateKeywordPlanAdGroupsSvc < T : KeywordPlanAdGroupService > ( pub Arc < T > ) ; impl < T : KeywordPlanAdGroupService > tonic :: server :: UnaryService < super :: MutateKeywordPlanAdGroupsRequest > for MutateKeywordPlanAdGroupsSvc < T > { type Response = super :: MutateKeywordPlanAdGroupsResponse ; type Future = BoxFuture < tonic :: Response < Self :: Response > , tonic :: Status > ; fn call ( & mut self , request : tonic :: Request < super :: MutateKeywordPlanAdGroupsRequest > ) -> Self :: Future { let inner = self . 0 . clone ( ) ; let fut = async move { inner . mutate_keyword_plan_ad_groups ( request ) . await } ; Box :: pin ( fut ) } } let inner = self . inner . clone ( ) ; let fut = async move { let interceptor = inner . 1 . clone ( ) ; let inner = inner . 0 ; let method = MutateKeywordPlanAdGroupsSvc ( inner ) ; let codec = tonic :: codec :: ProstCodec :: default ( ) ; let mut grpc = if let Some ( interceptor ) = interceptor { tonic :: server :: Grpc :: with_interceptor ( codec , interceptor ) } else { tonic :: server :: Grpc :: new ( codec ) } ; let res = grpc . unary ( method , req ) . await ; Ok ( res ) } ; Box :: pin ( fut ) } _ => Box :: pin ( async move { Ok ( http :: Response :: builder ( ) . status ( 200 ) . header ( "grpc-status" , "12" ) . body ( tonic :: body :: BoxBody :: empty ( ) ) . unwrap ( ) ) } ) , }
        }
    }
    impl<T: KeywordPlanAdGroupService> Clone for KeywordPlanAdGroupServiceServer<T> {
        fn clone(&self) -> Self {
            let inner = self.inner.clone();
            Self { inner }
        }
    }
    impl<T: KeywordPlanAdGroupService> Clone for _Inner<T> {
        fn clone(&self) -> Self {
            Self(self.0.clone(), self.1.clone())
        }
    }
    impl<T: std::fmt::Debug> std::fmt::Debug for _Inner<T> {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
            write!(f, "{:?}", self.0)
        }
    }
    impl<T: KeywordPlanAdGroupService> tonic::transport::NamedService
        for KeywordPlanAdGroupServiceServer<T>
    {
        const NAME: &'static str = "google.ads.googleads.v1.services.KeywordPlanAdGroupService";
    }
}
/// Request message for [KeywordPlanCampaignService.GetKeywordPlanCampaign][google.ads.googleads.v1.services.KeywordPlanCampaignService.GetKeywordPlanCampaign].
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GetKeywordPlanCampaignRequest {
    /// Required. The resource name of the Keyword Plan campaign to fetch.
    #[prost(string, tag = "1")]
    pub resource_name: std::string::String,
}
/// Request message for
/// [KeywordPlanCampaignService.MutateKeywordPlanCampaigns][google.ads.googleads.v1.services.KeywordPlanCampaignService.MutateKeywordPlanCampaigns].
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct MutateKeywordPlanCampaignsRequest {
    /// Required. The ID of the customer whose Keyword Plan campaigns are being modified.
    #[prost(string, tag = "1")]
    pub customer_id: std::string::String,
    /// Required. The list of operations to perform on individual Keyword Plan campaigns.
    #[prost(message, repeated, tag = "2")]
    pub operations: ::std::vec::Vec<KeywordPlanCampaignOperation>,
    /// If true, successful operations will be carried out and invalid
    /// operations will return errors. If false, all operations will be carried
    /// out in one transaction if and only if they are all valid.
    /// Default is false.
    #[prost(bool, tag = "3")]
    pub partial_failure: bool,
    /// If true, the request is validated but not executed. Only errors are
    /// returned, not results.
    #[prost(bool, tag = "4")]
    pub validate_only: bool,
}
/// A single operation (create, update, remove) on a Keyword Plan campaign.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct KeywordPlanCampaignOperation {
    /// The FieldMask that determines which resource fields are modified in an
    /// update.
    #[prost(message, optional, tag = "4")]
    pub update_mask: ::std::option::Option<::prost_types::FieldMask>,
    /// The mutate operation.
    #[prost(oneof = "keyword_plan_campaign_operation::Operation", tags = "1, 2, 3")]
    pub operation: ::std::option::Option<keyword_plan_campaign_operation::Operation>,
}
pub mod keyword_plan_campaign_operation {
    /// The mutate operation.
    #[derive(Clone, PartialEq, ::prost::Oneof)]
    pub enum Operation {
        /// Create operation: No resource name is expected for the new Keyword Plan
        /// campaign.
        #[prost(message, tag = "1")]
        Create(super::super::resources::KeywordPlanCampaign),
        /// Update operation: The Keyword Plan campaign is expected to have a valid
        /// resource name.
        #[prost(message, tag = "2")]
        Update(super::super::resources::KeywordPlanCampaign),
        /// Remove operation: A resource name for the removed Keyword Plan campaign
        /// is expected, in this format:
        ///
        /// `customers/{customer_id}/keywordPlanCampaigns/{keywordPlan_campaign_id}`
        #[prost(string, tag = "3")]
        Remove(std::string::String),
    }
}
/// Response message for a Keyword Plan campaign mutate.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct MutateKeywordPlanCampaignsResponse {
    /// Errors that pertain to operation failures in the partial failure mode.
    /// Returned only when partial_failure = true and all errors occur inside the
    /// operations. If any errors occur outside the operations (e.g. auth errors),
    /// we return an RPC level error.
    #[prost(message, optional, tag = "3")]
    pub partial_failure_error: ::std::option::Option<super::super::super::super::rpc::Status>,
    /// All results for the mutate.
    #[prost(message, repeated, tag = "2")]
    pub results: ::std::vec::Vec<MutateKeywordPlanCampaignResult>,
}
/// The result for the Keyword Plan campaign mutate.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct MutateKeywordPlanCampaignResult {
    /// Returned for successful operations.
    #[prost(string, tag = "1")]
    pub resource_name: std::string::String,
}
#[doc = r" Generated client implementations."]
pub mod keyword_plan_campaign_service_client {
    #![allow(unused_variables, dead_code, missing_docs)]
    use tonic::codegen::*;
    #[doc = " Service to manage Keyword Plan campaigns."]
    pub struct KeywordPlanCampaignServiceClient<T> {
        inner: tonic::client::Grpc<T>,
    }
    impl KeywordPlanCampaignServiceClient<tonic::transport::Channel> {
        #[doc = r" Attempt to create a new client by connecting to a given endpoint."]
        pub async fn connect<D>(dst: D) -> Result<Self, tonic::transport::Error>
        where
            D: std::convert::TryInto<tonic::transport::Endpoint>,
            D::Error: Into<StdError>,
        {
            let conn = tonic::transport::Endpoint::new(dst)?.connect().await?;
            Ok(Self::new(conn))
        }
    }
    impl<T> KeywordPlanCampaignServiceClient<T>
    where
        T: tonic::client::GrpcService<tonic::body::BoxBody>,
        T::ResponseBody: Body + HttpBody + Send + 'static,
        T::Error: Into<StdError>,
        <T::ResponseBody as HttpBody>::Error: Into<StdError> + Send,
    {
        pub fn new(inner: T) -> Self {
            let inner = tonic::client::Grpc::new(inner);
            Self { inner }
        }
        pub fn with_interceptor(inner: T, interceptor: impl Into<tonic::Interceptor>) -> Self {
            let inner = tonic::client::Grpc::with_interceptor(inner, interceptor);
            Self { inner }
        }
        #[doc = " Returns the requested Keyword Plan campaign in full detail."]
        pub async fn get_keyword_plan_campaign(
            &mut self,
            request: impl tonic::IntoRequest<super::GetKeywordPlanCampaignRequest>,
        ) -> Result<tonic::Response<super::super::resources::KeywordPlanCampaign>, tonic::Status>
        {
            self.inner.ready().await.map_err(|e| {
                tonic::Status::new(
                    tonic::Code::Unknown,
                    format!("Service was not ready: {}", e.into()),
                )
            })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http :: uri :: PathAndQuery :: from_static ( "/google.ads.googleads.v1.services.KeywordPlanCampaignService/GetKeywordPlanCampaign" ) ;
            self.inner.unary(request.into_request(), path, codec).await
        }
        #[doc = " Creates, updates, or removes Keyword Plan campaigns. Operation statuses are"]
        #[doc = " returned."]
        pub async fn mutate_keyword_plan_campaigns(
            &mut self,
            request: impl tonic::IntoRequest<super::MutateKeywordPlanCampaignsRequest>,
        ) -> Result<tonic::Response<super::MutateKeywordPlanCampaignsResponse>, tonic::Status>
        {
            self.inner.ready().await.map_err(|e| {
                tonic::Status::new(
                    tonic::Code::Unknown,
                    format!("Service was not ready: {}", e.into()),
                )
            })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http :: uri :: PathAndQuery :: from_static ( "/google.ads.googleads.v1.services.KeywordPlanCampaignService/MutateKeywordPlanCampaigns" ) ;
            self.inner.unary(request.into_request(), path, codec).await
        }
    }
    impl<T: Clone> Clone for KeywordPlanCampaignServiceClient<T> {
        fn clone(&self) -> Self {
            Self {
                inner: self.inner.clone(),
            }
        }
    }
    impl<T> std::fmt::Debug for KeywordPlanCampaignServiceClient<T> {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
            write!(f, "KeywordPlanCampaignServiceClient {{ ... }}")
        }
    }
}
#[doc = r" Generated server implementations."]
pub mod keyword_plan_campaign_service_server {
    #![allow(unused_variables, dead_code, missing_docs)]
    use tonic::codegen::*;
    #[doc = "Generated trait containing gRPC methods that should be implemented for use with KeywordPlanCampaignServiceServer."]
    #[async_trait]
    pub trait KeywordPlanCampaignService: Send + Sync + 'static {
        #[doc = " Returns the requested Keyword Plan campaign in full detail."]
        async fn get_keyword_plan_campaign(
            &self,
            request: tonic::Request<super::GetKeywordPlanCampaignRequest>,
        ) -> Result<tonic::Response<super::super::resources::KeywordPlanCampaign>, tonic::Status>;
        #[doc = " Creates, updates, or removes Keyword Plan campaigns. Operation statuses are"]
        #[doc = " returned."]
        async fn mutate_keyword_plan_campaigns(
            &self,
            request: tonic::Request<super::MutateKeywordPlanCampaignsRequest>,
        ) -> Result<tonic::Response<super::MutateKeywordPlanCampaignsResponse>, tonic::Status>;
    }
    #[doc = " Service to manage Keyword Plan campaigns."]
    #[derive(Debug)]
    #[doc(hidden)]
    pub struct KeywordPlanCampaignServiceServer<T: KeywordPlanCampaignService> {
        inner: _Inner<T>,
    }
    struct _Inner<T>(Arc<T>, Option<tonic::Interceptor>);
    impl<T: KeywordPlanCampaignService> KeywordPlanCampaignServiceServer<T> {
        pub fn new(inner: T) -> Self {
            let inner = Arc::new(inner);
            let inner = _Inner(inner, None);
            Self { inner }
        }
        pub fn with_interceptor(inner: T, interceptor: impl Into<tonic::Interceptor>) -> Self {
            let inner = Arc::new(inner);
            let inner = _Inner(inner, Some(interceptor.into()));
            Self { inner }
        }
    }
    impl<T, B> Service<http::Request<B>> for KeywordPlanCampaignServiceServer<T>
    where
        T: KeywordPlanCampaignService,
        B: HttpBody + Send + Sync + 'static,
        B::Error: Into<StdError> + Send + 'static,
    {
        type Response = http::Response<tonic::body::BoxBody>;
        type Error = Never;
        type Future = BoxFuture<Self::Response, Self::Error>;
        fn poll_ready(&mut self, _cx: &mut Context<'_>) -> Poll<Result<(), Self::Error>> {
            Poll::Ready(Ok(()))
        }
        fn call(&mut self, req: http::Request<B>) -> Self::Future {
            let inner = self.inner.clone();
            match req . uri ( ) . path ( ) { "/google.ads.googleads.v1.services.KeywordPlanCampaignService/GetKeywordPlanCampaign" => { # [ allow ( non_camel_case_types ) ] struct GetKeywordPlanCampaignSvc < T : KeywordPlanCampaignService > ( pub Arc < T > ) ; impl < T : KeywordPlanCampaignService > tonic :: server :: UnaryService < super :: GetKeywordPlanCampaignRequest > for GetKeywordPlanCampaignSvc < T > { type Response = super :: super :: resources :: KeywordPlanCampaign ; type Future = BoxFuture < tonic :: Response < Self :: Response > , tonic :: Status > ; fn call ( & mut self , request : tonic :: Request < super :: GetKeywordPlanCampaignRequest > ) -> Self :: Future { let inner = self . 0 . clone ( ) ; let fut = async move { inner . get_keyword_plan_campaign ( request ) . await } ; Box :: pin ( fut ) } } let inner = self . inner . clone ( ) ; let fut = async move { let interceptor = inner . 1 . clone ( ) ; let inner = inner . 0 ; let method = GetKeywordPlanCampaignSvc ( inner ) ; let codec = tonic :: codec :: ProstCodec :: default ( ) ; let mut grpc = if let Some ( interceptor ) = interceptor { tonic :: server :: Grpc :: with_interceptor ( codec , interceptor ) } else { tonic :: server :: Grpc :: new ( codec ) } ; let res = grpc . unary ( method , req ) . await ; Ok ( res ) } ; Box :: pin ( fut ) } "/google.ads.googleads.v1.services.KeywordPlanCampaignService/MutateKeywordPlanCampaigns" => { # [ allow ( non_camel_case_types ) ] struct MutateKeywordPlanCampaignsSvc < T : KeywordPlanCampaignService > ( pub Arc < T > ) ; impl < T : KeywordPlanCampaignService > tonic :: server :: UnaryService < super :: MutateKeywordPlanCampaignsRequest > for MutateKeywordPlanCampaignsSvc < T > { type Response = super :: MutateKeywordPlanCampaignsResponse ; type Future = BoxFuture < tonic :: Response < Self :: Response > , tonic :: Status > ; fn call ( & mut self , request : tonic :: Request < super :: MutateKeywordPlanCampaignsRequest > ) -> Self :: Future { let inner = self . 0 . clone ( ) ; let fut = async move { inner . mutate_keyword_plan_campaigns ( request ) . await } ; Box :: pin ( fut ) } } let inner = self . inner . clone ( ) ; let fut = async move { let interceptor = inner . 1 . clone ( ) ; let inner = inner . 0 ; let method = MutateKeywordPlanCampaignsSvc ( inner ) ; let codec = tonic :: codec :: ProstCodec :: default ( ) ; let mut grpc = if let Some ( interceptor ) = interceptor { tonic :: server :: Grpc :: with_interceptor ( codec , interceptor ) } else { tonic :: server :: Grpc :: new ( codec ) } ; let res = grpc . unary ( method , req ) . await ; Ok ( res ) } ; Box :: pin ( fut ) } _ => Box :: pin ( async move { Ok ( http :: Response :: builder ( ) . status ( 200 ) . header ( "grpc-status" , "12" ) . body ( tonic :: body :: BoxBody :: empty ( ) ) . unwrap ( ) ) } ) , }
        }
    }
    impl<T: KeywordPlanCampaignService> Clone for KeywordPlanCampaignServiceServer<T> {
        fn clone(&self) -> Self {
            let inner = self.inner.clone();
            Self { inner }
        }
    }
    impl<T: KeywordPlanCampaignService> Clone for _Inner<T> {
        fn clone(&self) -> Self {
            Self(self.0.clone(), self.1.clone())
        }
    }
    impl<T: std::fmt::Debug> std::fmt::Debug for _Inner<T> {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
            write!(f, "{:?}", self.0)
        }
    }
    impl<T: KeywordPlanCampaignService> tonic::transport::NamedService
        for KeywordPlanCampaignServiceServer<T>
    {
        const NAME: &'static str = "google.ads.googleads.v1.services.KeywordPlanCampaignService";
    }
}
/// Request message for [KeywordIdeaService.GenerateKeywordIdeas][].
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GenerateKeywordIdeasRequest {
    /// The ID of the customer with the recommendation.
    #[prost(string, tag = "1")]
    pub customer_id: std::string::String,
    /// Required. The resource name of the language to target.
    /// Required
    #[prost(message, optional, tag = "7")]
    pub language: ::std::option::Option<::std::string::String>,
    /// The resource names of the location to target.
    /// Max 10
    #[prost(message, repeated, tag = "8")]
    pub geo_target_constants: ::std::vec::Vec<::std::string::String>,
    /// Targeting network.
    #[prost(
        enumeration = "super::enums::keyword_plan_network_enum::KeywordPlanNetwork",
        tag = "9"
    )]
    pub keyword_plan_network: i32,
    /// The type of seed to generate keyword ideas.
    #[prost(oneof = "generate_keyword_ideas_request::Seed", tags = "2, 3, 5")]
    pub seed: ::std::option::Option<generate_keyword_ideas_request::Seed>,
}
pub mod generate_keyword_ideas_request {
    /// The type of seed to generate keyword ideas.
    #[derive(Clone, PartialEq, ::prost::Oneof)]
    pub enum Seed {
        /// A Keyword and a specific Url to generate ideas from
        /// e.g. cars, www.example.com/cars.
        #[prost(message, tag = "2")]
        KeywordAndUrlSeed(super::KeywordAndUrlSeed),
        /// A Keyword or phrase to generate ideas from, e.g. cars.
        #[prost(message, tag = "3")]
        KeywordSeed(super::KeywordSeed),
        /// A specific url to generate ideas from, e.g. www.example.com/cars.
        #[prost(message, tag = "5")]
        UrlSeed(super::UrlSeed),
    }
}
/// Keyword And Url Seed
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct KeywordAndUrlSeed {
    /// The URL to crawl in order to generate keyword ideas.
    #[prost(message, optional, tag = "1")]
    pub url: ::std::option::Option<::std::string::String>,
    /// Requires at least one keyword.
    #[prost(message, repeated, tag = "2")]
    pub keywords: ::std::vec::Vec<::std::string::String>,
}
/// Keyword Seed
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct KeywordSeed {
    /// Requires at least one keyword.
    #[prost(message, repeated, tag = "1")]
    pub keywords: ::std::vec::Vec<::std::string::String>,
}
/// Url Seed
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct UrlSeed {
    /// The URL to crawl in order to generate keyword ideas.
    #[prost(message, optional, tag = "1")]
    pub url: ::std::option::Option<::std::string::String>,
}
/// Response message for [KeywordIdeaService.GenerateKeywordIdeas][].
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GenerateKeywordIdeaResponse {
    /// Results of generating keyword ideas.
    #[prost(message, repeated, tag = "1")]
    pub results: ::std::vec::Vec<GenerateKeywordIdeaResult>,
}
/// The result of generating keyword ideas.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GenerateKeywordIdeaResult {
    /// Text of the keyword idea.
    /// As in Keyword Plan historical metrics, this text may not be an actual
    /// keyword, but the canonical form of multiple keywords.
    /// See KeywordPlanKeywordHistoricalMetrics message in KeywordPlanService.
    #[prost(message, optional, tag = "2")]
    pub text: ::std::option::Option<::std::string::String>,
    /// The historical metrics for the keyword
    #[prost(message, optional, tag = "3")]
    pub keyword_idea_metrics: ::std::option::Option<super::common::KeywordPlanHistoricalMetrics>,
}
#[doc = r" Generated client implementations."]
pub mod keyword_plan_idea_service_client {
    #![allow(unused_variables, dead_code, missing_docs)]
    use tonic::codegen::*;
    #[doc = " Service to generate keyword ideas."]
    pub struct KeywordPlanIdeaServiceClient<T> {
        inner: tonic::client::Grpc<T>,
    }
    impl KeywordPlanIdeaServiceClient<tonic::transport::Channel> {
        #[doc = r" Attempt to create a new client by connecting to a given endpoint."]
        pub async fn connect<D>(dst: D) -> Result<Self, tonic::transport::Error>
        where
            D: std::convert::TryInto<tonic::transport::Endpoint>,
            D::Error: Into<StdError>,
        {
            let conn = tonic::transport::Endpoint::new(dst)?.connect().await?;
            Ok(Self::new(conn))
        }
    }
    impl<T> KeywordPlanIdeaServiceClient<T>
    where
        T: tonic::client::GrpcService<tonic::body::BoxBody>,
        T::ResponseBody: Body + HttpBody + Send + 'static,
        T::Error: Into<StdError>,
        <T::ResponseBody as HttpBody>::Error: Into<StdError> + Send,
    {
        pub fn new(inner: T) -> Self {
            let inner = tonic::client::Grpc::new(inner);
            Self { inner }
        }
        pub fn with_interceptor(inner: T, interceptor: impl Into<tonic::Interceptor>) -> Self {
            let inner = tonic::client::Grpc::with_interceptor(inner, interceptor);
            Self { inner }
        }
        #[doc = " Returns a list of keyword ideas."]
        pub async fn generate_keyword_ideas(
            &mut self,
            request: impl tonic::IntoRequest<super::GenerateKeywordIdeasRequest>,
        ) -> Result<tonic::Response<super::GenerateKeywordIdeaResponse>, tonic::Status> {
            self.inner.ready().await.map_err(|e| {
                tonic::Status::new(
                    tonic::Code::Unknown,
                    format!("Service was not ready: {}", e.into()),
                )
            })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.ads.googleads.v1.services.KeywordPlanIdeaService/GenerateKeywordIdeas",
            );
            self.inner.unary(request.into_request(), path, codec).await
        }
    }
    impl<T: Clone> Clone for KeywordPlanIdeaServiceClient<T> {
        fn clone(&self) -> Self {
            Self {
                inner: self.inner.clone(),
            }
        }
    }
    impl<T> std::fmt::Debug for KeywordPlanIdeaServiceClient<T> {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
            write!(f, "KeywordPlanIdeaServiceClient {{ ... }}")
        }
    }
}
#[doc = r" Generated server implementations."]
pub mod keyword_plan_idea_service_server {
    #![allow(unused_variables, dead_code, missing_docs)]
    use tonic::codegen::*;
    #[doc = "Generated trait containing gRPC methods that should be implemented for use with KeywordPlanIdeaServiceServer."]
    #[async_trait]
    pub trait KeywordPlanIdeaService: Send + Sync + 'static {
        #[doc = " Returns a list of keyword ideas."]
        async fn generate_keyword_ideas(
            &self,
            request: tonic::Request<super::GenerateKeywordIdeasRequest>,
        ) -> Result<tonic::Response<super::GenerateKeywordIdeaResponse>, tonic::Status>;
    }
    #[doc = " Service to generate keyword ideas."]
    #[derive(Debug)]
    #[doc(hidden)]
    pub struct KeywordPlanIdeaServiceServer<T: KeywordPlanIdeaService> {
        inner: _Inner<T>,
    }
    struct _Inner<T>(Arc<T>, Option<tonic::Interceptor>);
    impl<T: KeywordPlanIdeaService> KeywordPlanIdeaServiceServer<T> {
        pub fn new(inner: T) -> Self {
            let inner = Arc::new(inner);
            let inner = _Inner(inner, None);
            Self { inner }
        }
        pub fn with_interceptor(inner: T, interceptor: impl Into<tonic::Interceptor>) -> Self {
            let inner = Arc::new(inner);
            let inner = _Inner(inner, Some(interceptor.into()));
            Self { inner }
        }
    }
    impl<T, B> Service<http::Request<B>> for KeywordPlanIdeaServiceServer<T>
    where
        T: KeywordPlanIdeaService,
        B: HttpBody + Send + Sync + 'static,
        B::Error: Into<StdError> + Send + 'static,
    {
        type Response = http::Response<tonic::body::BoxBody>;
        type Error = Never;
        type Future = BoxFuture<Self::Response, Self::Error>;
        fn poll_ready(&mut self, _cx: &mut Context<'_>) -> Poll<Result<(), Self::Error>> {
            Poll::Ready(Ok(()))
        }
        fn call(&mut self, req: http::Request<B>) -> Self::Future {
            let inner = self.inner.clone();
            match req.uri().path() {
                "/google.ads.googleads.v1.services.KeywordPlanIdeaService/GenerateKeywordIdeas" => {
                    #[allow(non_camel_case_types)]
                    struct GenerateKeywordIdeasSvc<T: KeywordPlanIdeaService>(pub Arc<T>);
                    impl<T: KeywordPlanIdeaService>
                        tonic::server::UnaryService<super::GenerateKeywordIdeasRequest>
                        for GenerateKeywordIdeasSvc<T>
                    {
                        type Response = super::GenerateKeywordIdeaResponse;
                        type Future = BoxFuture<tonic::Response<Self::Response>, tonic::Status>;
                        fn call(
                            &mut self,
                            request: tonic::Request<super::GenerateKeywordIdeasRequest>,
                        ) -> Self::Future {
                            let inner = self.0.clone();
                            let fut = async move { inner.generate_keyword_ideas(request).await };
                            Box::pin(fut)
                        }
                    }
                    let inner = self.inner.clone();
                    let fut = async move {
                        let interceptor = inner.1.clone();
                        let inner = inner.0;
                        let method = GenerateKeywordIdeasSvc(inner);
                        let codec = tonic::codec::ProstCodec::default();
                        let mut grpc = if let Some(interceptor) = interceptor {
                            tonic::server::Grpc::with_interceptor(codec, interceptor)
                        } else {
                            tonic::server::Grpc::new(codec)
                        };
                        let res = grpc.unary(method, req).await;
                        Ok(res)
                    };
                    Box::pin(fut)
                }
                _ => Box::pin(async move {
                    Ok(http::Response::builder()
                        .status(200)
                        .header("grpc-status", "12")
                        .body(tonic::body::BoxBody::empty())
                        .unwrap())
                }),
            }
        }
    }
    impl<T: KeywordPlanIdeaService> Clone for KeywordPlanIdeaServiceServer<T> {
        fn clone(&self) -> Self {
            let inner = self.inner.clone();
            Self { inner }
        }
    }
    impl<T: KeywordPlanIdeaService> Clone for _Inner<T> {
        fn clone(&self) -> Self {
            Self(self.0.clone(), self.1.clone())
        }
    }
    impl<T: std::fmt::Debug> std::fmt::Debug for _Inner<T> {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
            write!(f, "{:?}", self.0)
        }
    }
    impl<T: KeywordPlanIdeaService> tonic::transport::NamedService for KeywordPlanIdeaServiceServer<T> {
        const NAME: &'static str = "google.ads.googleads.v1.services.KeywordPlanIdeaService";
    }
}
/// Request message for [KeywordPlanKeywordService.GetKeywordPlanKeyword][google.ads.googleads.v1.services.KeywordPlanKeywordService.GetKeywordPlanKeyword].
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GetKeywordPlanKeywordRequest {
    /// Required. The resource name of the ad group keyword to fetch.
    #[prost(string, tag = "1")]
    pub resource_name: std::string::String,
}
/// Request message for [KeywordPlanKeywordService.MutateKeywordPlanKeywords][google.ads.googleads.v1.services.KeywordPlanKeywordService.MutateKeywordPlanKeywords].
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct MutateKeywordPlanKeywordsRequest {
    /// Required. The ID of the customer whose Keyword Plan keywords are being modified.
    #[prost(string, tag = "1")]
    pub customer_id: std::string::String,
    /// Required. The list of operations to perform on individual Keyword Plan keywords.
    #[prost(message, repeated, tag = "2")]
    pub operations: ::std::vec::Vec<KeywordPlanKeywordOperation>,
    /// If true, successful operations will be carried out and invalid
    /// operations will return errors. If false, all operations will be carried
    /// out in one transaction if and only if they are all valid.
    /// Default is false.
    #[prost(bool, tag = "3")]
    pub partial_failure: bool,
    /// If true, the request is validated but not executed. Only errors are
    /// returned, not results.
    #[prost(bool, tag = "4")]
    pub validate_only: bool,
}
/// A single operation (create, update, remove) on a Keyword Plan keyword.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct KeywordPlanKeywordOperation {
    /// The FieldMask that determines which resource fields are modified in an
    /// update.
    #[prost(message, optional, tag = "4")]
    pub update_mask: ::std::option::Option<::prost_types::FieldMask>,
    /// The mutate operation.
    #[prost(oneof = "keyword_plan_keyword_operation::Operation", tags = "1, 2, 3")]
    pub operation: ::std::option::Option<keyword_plan_keyword_operation::Operation>,
}
pub mod keyword_plan_keyword_operation {
    /// The mutate operation.
    #[derive(Clone, PartialEq, ::prost::Oneof)]
    pub enum Operation {
        /// Create operation: No resource name is expected for the new Keyword Plan
        /// ad group keyword.
        #[prost(message, tag = "1")]
        Create(super::super::resources::KeywordPlanKeyword),
        /// Update operation: The Keyword Plan keyword is expected to have a valid
        /// resource name.
        #[prost(message, tag = "2")]
        Update(super::super::resources::KeywordPlanKeyword),
        /// Remove operation: A resource name for the removed Keyword Plan keyword is
        /// expected, in this format:
        ///
        /// `customers/{customer_id}/keywordPlanKeywords/{kp_ad_group_keyword_id}`
        #[prost(string, tag = "3")]
        Remove(std::string::String),
    }
}
/// Response message for a Keyword Plan keyword mutate.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct MutateKeywordPlanKeywordsResponse {
    /// Errors that pertain to operation failures in the partial failure mode.
    /// Returned only when partial_failure = true and all errors occur inside the
    /// operations. If any errors occur outside the operations (e.g. auth errors),
    /// we return an RPC level error.
    #[prost(message, optional, tag = "3")]
    pub partial_failure_error: ::std::option::Option<super::super::super::super::rpc::Status>,
    /// All results for the mutate.
    #[prost(message, repeated, tag = "2")]
    pub results: ::std::vec::Vec<MutateKeywordPlanKeywordResult>,
}
/// The result for the Keyword Plan keyword mutate.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct MutateKeywordPlanKeywordResult {
    /// Returned for successful operations.
    #[prost(string, tag = "1")]
    pub resource_name: std::string::String,
}
#[doc = r" Generated client implementations."]
pub mod keyword_plan_keyword_service_client {
    #![allow(unused_variables, dead_code, missing_docs)]
    use tonic::codegen::*;
    #[doc = " Service to manage Keyword Plan ad group keywords."]
    pub struct KeywordPlanKeywordServiceClient<T> {
        inner: tonic::client::Grpc<T>,
    }
    impl KeywordPlanKeywordServiceClient<tonic::transport::Channel> {
        #[doc = r" Attempt to create a new client by connecting to a given endpoint."]
        pub async fn connect<D>(dst: D) -> Result<Self, tonic::transport::Error>
        where
            D: std::convert::TryInto<tonic::transport::Endpoint>,
            D::Error: Into<StdError>,
        {
            let conn = tonic::transport::Endpoint::new(dst)?.connect().await?;
            Ok(Self::new(conn))
        }
    }
    impl<T> KeywordPlanKeywordServiceClient<T>
    where
        T: tonic::client::GrpcService<tonic::body::BoxBody>,
        T::ResponseBody: Body + HttpBody + Send + 'static,
        T::Error: Into<StdError>,
        <T::ResponseBody as HttpBody>::Error: Into<StdError> + Send,
    {
        pub fn new(inner: T) -> Self {
            let inner = tonic::client::Grpc::new(inner);
            Self { inner }
        }
        pub fn with_interceptor(inner: T, interceptor: impl Into<tonic::Interceptor>) -> Self {
            let inner = tonic::client::Grpc::with_interceptor(inner, interceptor);
            Self { inner }
        }
        #[doc = " Returns the requested Keyword Plan keyword in full detail."]
        pub async fn get_keyword_plan_keyword(
            &mut self,
            request: impl tonic::IntoRequest<super::GetKeywordPlanKeywordRequest>,
        ) -> Result<tonic::Response<super::super::resources::KeywordPlanKeyword>, tonic::Status>
        {
            self.inner.ready().await.map_err(|e| {
                tonic::Status::new(
                    tonic::Code::Unknown,
                    format!("Service was not ready: {}", e.into()),
                )
            })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.ads.googleads.v1.services.KeywordPlanKeywordService/GetKeywordPlanKeyword",
            );
            self.inner.unary(request.into_request(), path, codec).await
        }
        #[doc = " Creates, updates, or removes Keyword Plan keywords. Operation statuses are"]
        #[doc = " returned."]
        pub async fn mutate_keyword_plan_keywords(
            &mut self,
            request: impl tonic::IntoRequest<super::MutateKeywordPlanKeywordsRequest>,
        ) -> Result<tonic::Response<super::MutateKeywordPlanKeywordsResponse>, tonic::Status>
        {
            self.inner.ready().await.map_err(|e| {
                tonic::Status::new(
                    tonic::Code::Unknown,
                    format!("Service was not ready: {}", e.into()),
                )
            })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http :: uri :: PathAndQuery :: from_static ( "/google.ads.googleads.v1.services.KeywordPlanKeywordService/MutateKeywordPlanKeywords" ) ;
            self.inner.unary(request.into_request(), path, codec).await
        }
    }
    impl<T: Clone> Clone for KeywordPlanKeywordServiceClient<T> {
        fn clone(&self) -> Self {
            Self {
                inner: self.inner.clone(),
            }
        }
    }
    impl<T> std::fmt::Debug for KeywordPlanKeywordServiceClient<T> {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
            write!(f, "KeywordPlanKeywordServiceClient {{ ... }}")
        }
    }
}
#[doc = r" Generated server implementations."]
pub mod keyword_plan_keyword_service_server {
    #![allow(unused_variables, dead_code, missing_docs)]
    use tonic::codegen::*;
    #[doc = "Generated trait containing gRPC methods that should be implemented for use with KeywordPlanKeywordServiceServer."]
    #[async_trait]
    pub trait KeywordPlanKeywordService: Send + Sync + 'static {
        #[doc = " Returns the requested Keyword Plan keyword in full detail."]
        async fn get_keyword_plan_keyword(
            &self,
            request: tonic::Request<super::GetKeywordPlanKeywordRequest>,
        ) -> Result<tonic::Response<super::super::resources::KeywordPlanKeyword>, tonic::Status>;
        #[doc = " Creates, updates, or removes Keyword Plan keywords. Operation statuses are"]
        #[doc = " returned."]
        async fn mutate_keyword_plan_keywords(
            &self,
            request: tonic::Request<super::MutateKeywordPlanKeywordsRequest>,
        ) -> Result<tonic::Response<super::MutateKeywordPlanKeywordsResponse>, tonic::Status>;
    }
    #[doc = " Service to manage Keyword Plan ad group keywords."]
    #[derive(Debug)]
    #[doc(hidden)]
    pub struct KeywordPlanKeywordServiceServer<T: KeywordPlanKeywordService> {
        inner: _Inner<T>,
    }
    struct _Inner<T>(Arc<T>, Option<tonic::Interceptor>);
    impl<T: KeywordPlanKeywordService> KeywordPlanKeywordServiceServer<T> {
        pub fn new(inner: T) -> Self {
            let inner = Arc::new(inner);
            let inner = _Inner(inner, None);
            Self { inner }
        }
        pub fn with_interceptor(inner: T, interceptor: impl Into<tonic::Interceptor>) -> Self {
            let inner = Arc::new(inner);
            let inner = _Inner(inner, Some(interceptor.into()));
            Self { inner }
        }
    }
    impl<T, B> Service<http::Request<B>> for KeywordPlanKeywordServiceServer<T>
    where
        T: KeywordPlanKeywordService,
        B: HttpBody + Send + Sync + 'static,
        B::Error: Into<StdError> + Send + 'static,
    {
        type Response = http::Response<tonic::body::BoxBody>;
        type Error = Never;
        type Future = BoxFuture<Self::Response, Self::Error>;
        fn poll_ready(&mut self, _cx: &mut Context<'_>) -> Poll<Result<(), Self::Error>> {
            Poll::Ready(Ok(()))
        }
        fn call(&mut self, req: http::Request<B>) -> Self::Future {
            let inner = self.inner.clone();
            match req . uri ( ) . path ( ) { "/google.ads.googleads.v1.services.KeywordPlanKeywordService/GetKeywordPlanKeyword" => { # [ allow ( non_camel_case_types ) ] struct GetKeywordPlanKeywordSvc < T : KeywordPlanKeywordService > ( pub Arc < T > ) ; impl < T : KeywordPlanKeywordService > tonic :: server :: UnaryService < super :: GetKeywordPlanKeywordRequest > for GetKeywordPlanKeywordSvc < T > { type Response = super :: super :: resources :: KeywordPlanKeyword ; type Future = BoxFuture < tonic :: Response < Self :: Response > , tonic :: Status > ; fn call ( & mut self , request : tonic :: Request < super :: GetKeywordPlanKeywordRequest > ) -> Self :: Future { let inner = self . 0 . clone ( ) ; let fut = async move { inner . get_keyword_plan_keyword ( request ) . await } ; Box :: pin ( fut ) } } let inner = self . inner . clone ( ) ; let fut = async move { let interceptor = inner . 1 . clone ( ) ; let inner = inner . 0 ; let method = GetKeywordPlanKeywordSvc ( inner ) ; let codec = tonic :: codec :: ProstCodec :: default ( ) ; let mut grpc = if let Some ( interceptor ) = interceptor { tonic :: server :: Grpc :: with_interceptor ( codec , interceptor ) } else { tonic :: server :: Grpc :: new ( codec ) } ; let res = grpc . unary ( method , req ) . await ; Ok ( res ) } ; Box :: pin ( fut ) } "/google.ads.googleads.v1.services.KeywordPlanKeywordService/MutateKeywordPlanKeywords" => { # [ allow ( non_camel_case_types ) ] struct MutateKeywordPlanKeywordsSvc < T : KeywordPlanKeywordService > ( pub Arc < T > ) ; impl < T : KeywordPlanKeywordService > tonic :: server :: UnaryService < super :: MutateKeywordPlanKeywordsRequest > for MutateKeywordPlanKeywordsSvc < T > { type Response = super :: MutateKeywordPlanKeywordsResponse ; type Future = BoxFuture < tonic :: Response < Self :: Response > , tonic :: Status > ; fn call ( & mut self , request : tonic :: Request < super :: MutateKeywordPlanKeywordsRequest > ) -> Self :: Future { let inner = self . 0 . clone ( ) ; let fut = async move { inner . mutate_keyword_plan_keywords ( request ) . await } ; Box :: pin ( fut ) } } let inner = self . inner . clone ( ) ; let fut = async move { let interceptor = inner . 1 . clone ( ) ; let inner = inner . 0 ; let method = MutateKeywordPlanKeywordsSvc ( inner ) ; let codec = tonic :: codec :: ProstCodec :: default ( ) ; let mut grpc = if let Some ( interceptor ) = interceptor { tonic :: server :: Grpc :: with_interceptor ( codec , interceptor ) } else { tonic :: server :: Grpc :: new ( codec ) } ; let res = grpc . unary ( method , req ) . await ; Ok ( res ) } ; Box :: pin ( fut ) } _ => Box :: pin ( async move { Ok ( http :: Response :: builder ( ) . status ( 200 ) . header ( "grpc-status" , "12" ) . body ( tonic :: body :: BoxBody :: empty ( ) ) . unwrap ( ) ) } ) , }
        }
    }
    impl<T: KeywordPlanKeywordService> Clone for KeywordPlanKeywordServiceServer<T> {
        fn clone(&self) -> Self {
            let inner = self.inner.clone();
            Self { inner }
        }
    }
    impl<T: KeywordPlanKeywordService> Clone for _Inner<T> {
        fn clone(&self) -> Self {
            Self(self.0.clone(), self.1.clone())
        }
    }
    impl<T: std::fmt::Debug> std::fmt::Debug for _Inner<T> {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
            write!(f, "{:?}", self.0)
        }
    }
    impl<T: KeywordPlanKeywordService> tonic::transport::NamedService
        for KeywordPlanKeywordServiceServer<T>
    {
        const NAME: &'static str = "google.ads.googleads.v1.services.KeywordPlanKeywordService";
    }
}
/// Request message for
/// [KeywordPlanNegativeKeywordService.GetKeywordPlanNegativeKeyword][google.ads.googleads.v1.services.KeywordPlanNegativeKeywordService.GetKeywordPlanNegativeKeyword].
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GetKeywordPlanNegativeKeywordRequest {
    /// Required. The resource name of the plan to fetch.
    #[prost(string, tag = "1")]
    pub resource_name: std::string::String,
}
/// Request message for
/// [KeywordPlanNegativeKeywordService.MutateKeywordPlanNegativeKeywords][google.ads.googleads.v1.services.KeywordPlanNegativeKeywordService.MutateKeywordPlanNegativeKeywords].
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct MutateKeywordPlanNegativeKeywordsRequest {
    /// Required. The ID of the customer whose negative keywords are being modified.
    #[prost(string, tag = "1")]
    pub customer_id: std::string::String,
    /// Required. The list of operations to perform on individual Keyword Plan negative
    /// keywords.
    #[prost(message, repeated, tag = "2")]
    pub operations: ::std::vec::Vec<KeywordPlanNegativeKeywordOperation>,
    /// If true, successful operations will be carried out and invalid
    /// operations will return errors. If false, all operations will be carried
    /// out in one transaction if and only if they are all valid.
    /// Default is false.
    #[prost(bool, tag = "3")]
    pub partial_failure: bool,
    /// If true, the request is validated but not executed. Only errors are
    /// returned, not results.
    #[prost(bool, tag = "4")]
    pub validate_only: bool,
}
/// A single operation (create, update, remove) on a Keyword Plan negative
/// keyword.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct KeywordPlanNegativeKeywordOperation {
    /// The FieldMask that determines which resource fields are modified in an
    /// update.
    #[prost(message, optional, tag = "4")]
    pub update_mask: ::std::option::Option<::prost_types::FieldMask>,
    /// The mutate operation.
    #[prost(
        oneof = "keyword_plan_negative_keyword_operation::Operation",
        tags = "1, 2, 3"
    )]
    pub operation: ::std::option::Option<keyword_plan_negative_keyword_operation::Operation>,
}
pub mod keyword_plan_negative_keyword_operation {
    /// The mutate operation.
    #[derive(Clone, PartialEq, ::prost::Oneof)]
    pub enum Operation {
        /// Create operation: No resource name is expected for the new Keyword Plan
        /// negative keyword.
        #[prost(message, tag = "1")]
        Create(super::super::resources::KeywordPlanNegativeKeyword),
        /// Update operation: The Keyword Plan negative keyword expected to have a
        /// valid resource name.
        #[prost(message, tag = "2")]
        Update(super::super::resources::KeywordPlanNegativeKeyword),
        /// Remove operation: A resource name for the removed Keyword Plan negative
        /// keywords expected in this format:
        ///
        /// `customers/{customer_id}/keywordPlanNegativeKeywords/{kp_negative_keyword_id}`
        #[prost(string, tag = "3")]
        Remove(std::string::String),
    }
}
/// Response message for a Keyword Plan negative keyword mutate.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct MutateKeywordPlanNegativeKeywordsResponse {
    /// Errors that pertain to operation failures in the partial failure mode.
    /// Returned only when partial_failure = true and all errors occur inside the
    /// operations. If any errors occur outside the operations (e.g. auth errors),
    /// we return an RPC level error.
    #[prost(message, optional, tag = "3")]
    pub partial_failure_error: ::std::option::Option<super::super::super::super::rpc::Status>,
    /// All results for the mutate.
    #[prost(message, repeated, tag = "2")]
    pub results: ::std::vec::Vec<MutateKeywordPlanNegativeKeywordResult>,
}
/// The result for the Keyword Plan negative keyword mutate.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct MutateKeywordPlanNegativeKeywordResult {
    /// Returned for successful operations.
    #[prost(string, tag = "1")]
    pub resource_name: std::string::String,
}
#[doc = r" Generated client implementations."]
pub mod keyword_plan_negative_keyword_service_client {
    #![allow(unused_variables, dead_code, missing_docs)]
    use tonic::codegen::*;
    #[doc = " Service to manage Keyword Plan negative keywords."]
    pub struct KeywordPlanNegativeKeywordServiceClient<T> {
        inner: tonic::client::Grpc<T>,
    }
    impl KeywordPlanNegativeKeywordServiceClient<tonic::transport::Channel> {
        #[doc = r" Attempt to create a new client by connecting to a given endpoint."]
        pub async fn connect<D>(dst: D) -> Result<Self, tonic::transport::Error>
        where
            D: std::convert::TryInto<tonic::transport::Endpoint>,
            D::Error: Into<StdError>,
        {
            let conn = tonic::transport::Endpoint::new(dst)?.connect().await?;
            Ok(Self::new(conn))
        }
    }
    impl<T> KeywordPlanNegativeKeywordServiceClient<T>
    where
        T: tonic::client::GrpcService<tonic::body::BoxBody>,
        T::ResponseBody: Body + HttpBody + Send + 'static,
        T::Error: Into<StdError>,
        <T::ResponseBody as HttpBody>::Error: Into<StdError> + Send,
    {
        pub fn new(inner: T) -> Self {
            let inner = tonic::client::Grpc::new(inner);
            Self { inner }
        }
        pub fn with_interceptor(inner: T, interceptor: impl Into<tonic::Interceptor>) -> Self {
            let inner = tonic::client::Grpc::with_interceptor(inner, interceptor);
            Self { inner }
        }
        #[doc = " Returns the requested plan in full detail."]
        pub async fn get_keyword_plan_negative_keyword(
            &mut self,
            request: impl tonic::IntoRequest<super::GetKeywordPlanNegativeKeywordRequest>,
        ) -> Result<
            tonic::Response<super::super::resources::KeywordPlanNegativeKeyword>,
            tonic::Status,
        > {
            self.inner.ready().await.map_err(|e| {
                tonic::Status::new(
                    tonic::Code::Unknown,
                    format!("Service was not ready: {}", e.into()),
                )
            })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http :: uri :: PathAndQuery :: from_static ( "/google.ads.googleads.v1.services.KeywordPlanNegativeKeywordService/GetKeywordPlanNegativeKeyword" ) ;
            self.inner.unary(request.into_request(), path, codec).await
        }
        #[doc = " Creates, updates, or removes Keyword Plan negative keywords. Operation"]
        #[doc = " statuses are returned."]
        pub async fn mutate_keyword_plan_negative_keywords(
            &mut self,
            request: impl tonic::IntoRequest<super::MutateKeywordPlanNegativeKeywordsRequest>,
        ) -> Result<tonic::Response<super::MutateKeywordPlanNegativeKeywordsResponse>, tonic::Status>
        {
            self.inner.ready().await.map_err(|e| {
                tonic::Status::new(
                    tonic::Code::Unknown,
                    format!("Service was not ready: {}", e.into()),
                )
            })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http :: uri :: PathAndQuery :: from_static ( "/google.ads.googleads.v1.services.KeywordPlanNegativeKeywordService/MutateKeywordPlanNegativeKeywords" ) ;
            self.inner.unary(request.into_request(), path, codec).await
        }
    }
    impl<T: Clone> Clone for KeywordPlanNegativeKeywordServiceClient<T> {
        fn clone(&self) -> Self {
            Self {
                inner: self.inner.clone(),
            }
        }
    }
    impl<T> std::fmt::Debug for KeywordPlanNegativeKeywordServiceClient<T> {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
            write!(f, "KeywordPlanNegativeKeywordServiceClient {{ ... }}")
        }
    }
}
#[doc = r" Generated server implementations."]
pub mod keyword_plan_negative_keyword_service_server {
    #![allow(unused_variables, dead_code, missing_docs)]
    use tonic::codegen::*;
    #[doc = "Generated trait containing gRPC methods that should be implemented for use with KeywordPlanNegativeKeywordServiceServer."]
    #[async_trait]
    pub trait KeywordPlanNegativeKeywordService: Send + Sync + 'static {
        #[doc = " Returns the requested plan in full detail."]
        async fn get_keyword_plan_negative_keyword(
            &self,
            request: tonic::Request<super::GetKeywordPlanNegativeKeywordRequest>,
        ) -> Result<
            tonic::Response<super::super::resources::KeywordPlanNegativeKeyword>,
            tonic::Status,
        >;
        #[doc = " Creates, updates, or removes Keyword Plan negative keywords. Operation"]
        #[doc = " statuses are returned."]
        async fn mutate_keyword_plan_negative_keywords(
            &self,
            request: tonic::Request<super::MutateKeywordPlanNegativeKeywordsRequest>,
        ) -> Result<tonic::Response<super::MutateKeywordPlanNegativeKeywordsResponse>, tonic::Status>;
    }
    #[doc = " Service to manage Keyword Plan negative keywords."]
    #[derive(Debug)]
    #[doc(hidden)]
    pub struct KeywordPlanNegativeKeywordServiceServer<T: KeywordPlanNegativeKeywordService> {
        inner: _Inner<T>,
    }
    struct _Inner<T>(Arc<T>, Option<tonic::Interceptor>);
    impl<T: KeywordPlanNegativeKeywordService> KeywordPlanNegativeKeywordServiceServer<T> {
        pub fn new(inner: T) -> Self {
            let inner = Arc::new(inner);
            let inner = _Inner(inner, None);
            Self { inner }
        }
        pub fn with_interceptor(inner: T, interceptor: impl Into<tonic::Interceptor>) -> Self {
            let inner = Arc::new(inner);
            let inner = _Inner(inner, Some(interceptor.into()));
            Self { inner }
        }
    }
    impl<T, B> Service<http::Request<B>> for KeywordPlanNegativeKeywordServiceServer<T>
    where
        T: KeywordPlanNegativeKeywordService,
        B: HttpBody + Send + Sync + 'static,
        B::Error: Into<StdError> + Send + 'static,
    {
        type Response = http::Response<tonic::body::BoxBody>;
        type Error = Never;
        type Future = BoxFuture<Self::Response, Self::Error>;
        fn poll_ready(&mut self, _cx: &mut Context<'_>) -> Poll<Result<(), Self::Error>> {
            Poll::Ready(Ok(()))
        }
        fn call(&mut self, req: http::Request<B>) -> Self::Future {
            let inner = self.inner.clone();
            match req . uri ( ) . path ( ) { "/google.ads.googleads.v1.services.KeywordPlanNegativeKeywordService/GetKeywordPlanNegativeKeyword" => { # [ allow ( non_camel_case_types ) ] struct GetKeywordPlanNegativeKeywordSvc < T : KeywordPlanNegativeKeywordService > ( pub Arc < T > ) ; impl < T : KeywordPlanNegativeKeywordService > tonic :: server :: UnaryService < super :: GetKeywordPlanNegativeKeywordRequest > for GetKeywordPlanNegativeKeywordSvc < T > { type Response = super :: super :: resources :: KeywordPlanNegativeKeyword ; type Future = BoxFuture < tonic :: Response < Self :: Response > , tonic :: Status > ; fn call ( & mut self , request : tonic :: Request < super :: GetKeywordPlanNegativeKeywordRequest > ) -> Self :: Future { let inner = self . 0 . clone ( ) ; let fut = async move { inner . get_keyword_plan_negative_keyword ( request ) . await } ; Box :: pin ( fut ) } } let inner = self . inner . clone ( ) ; let fut = async move { let interceptor = inner . 1 . clone ( ) ; let inner = inner . 0 ; let method = GetKeywordPlanNegativeKeywordSvc ( inner ) ; let codec = tonic :: codec :: ProstCodec :: default ( ) ; let mut grpc = if let Some ( interceptor ) = interceptor { tonic :: server :: Grpc :: with_interceptor ( codec , interceptor ) } else { tonic :: server :: Grpc :: new ( codec ) } ; let res = grpc . unary ( method , req ) . await ; Ok ( res ) } ; Box :: pin ( fut ) } "/google.ads.googleads.v1.services.KeywordPlanNegativeKeywordService/MutateKeywordPlanNegativeKeywords" => { # [ allow ( non_camel_case_types ) ] struct MutateKeywordPlanNegativeKeywordsSvc < T : KeywordPlanNegativeKeywordService > ( pub Arc < T > ) ; impl < T : KeywordPlanNegativeKeywordService > tonic :: server :: UnaryService < super :: MutateKeywordPlanNegativeKeywordsRequest > for MutateKeywordPlanNegativeKeywordsSvc < T > { type Response = super :: MutateKeywordPlanNegativeKeywordsResponse ; type Future = BoxFuture < tonic :: Response < Self :: Response > , tonic :: Status > ; fn call ( & mut self , request : tonic :: Request < super :: MutateKeywordPlanNegativeKeywordsRequest > ) -> Self :: Future { let inner = self . 0 . clone ( ) ; let fut = async move { inner . mutate_keyword_plan_negative_keywords ( request ) . await } ; Box :: pin ( fut ) } } let inner = self . inner . clone ( ) ; let fut = async move { let interceptor = inner . 1 . clone ( ) ; let inner = inner . 0 ; let method = MutateKeywordPlanNegativeKeywordsSvc ( inner ) ; let codec = tonic :: codec :: ProstCodec :: default ( ) ; let mut grpc = if let Some ( interceptor ) = interceptor { tonic :: server :: Grpc :: with_interceptor ( codec , interceptor ) } else { tonic :: server :: Grpc :: new ( codec ) } ; let res = grpc . unary ( method , req ) . await ; Ok ( res ) } ; Box :: pin ( fut ) } _ => Box :: pin ( async move { Ok ( http :: Response :: builder ( ) . status ( 200 ) . header ( "grpc-status" , "12" ) . body ( tonic :: body :: BoxBody :: empty ( ) ) . unwrap ( ) ) } ) , }
        }
    }
    impl<T: KeywordPlanNegativeKeywordService> Clone for KeywordPlanNegativeKeywordServiceServer<T> {
        fn clone(&self) -> Self {
            let inner = self.inner.clone();
            Self { inner }
        }
    }
    impl<T: KeywordPlanNegativeKeywordService> Clone for _Inner<T> {
        fn clone(&self) -> Self {
            Self(self.0.clone(), self.1.clone())
        }
    }
    impl<T: std::fmt::Debug> std::fmt::Debug for _Inner<T> {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
            write!(f, "{:?}", self.0)
        }
    }
    impl<T: KeywordPlanNegativeKeywordService> tonic::transport::NamedService
        for KeywordPlanNegativeKeywordServiceServer<T>
    {
        const NAME: &'static str =
            "google.ads.googleads.v1.services.KeywordPlanNegativeKeywordService";
    }
}
/// Request message for [KeywordPlanService.GetKeywordPlan][google.ads.googleads.v1.services.KeywordPlanService.GetKeywordPlan].
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GetKeywordPlanRequest {
    /// Required. The resource name of the plan to fetch.
    #[prost(string, tag = "1")]
    pub resource_name: std::string::String,
}
/// Request message for [KeywordPlanService.MutateKeywordPlans][google.ads.googleads.v1.services.KeywordPlanService.MutateKeywordPlans].
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct MutateKeywordPlansRequest {
    /// Required. The ID of the customer whose keyword plans are being modified.
    #[prost(string, tag = "1")]
    pub customer_id: std::string::String,
    /// Required. The list of operations to perform on individual keyword plans.
    #[prost(message, repeated, tag = "2")]
    pub operations: ::std::vec::Vec<KeywordPlanOperation>,
    /// If true, successful operations will be carried out and invalid
    /// operations will return errors. If false, all operations will be carried
    /// out in one transaction if and only if they are all valid.
    /// Default is false.
    #[prost(bool, tag = "3")]
    pub partial_failure: bool,
    /// If true, the request is validated but not executed. Only errors are
    /// returned, not results.
    #[prost(bool, tag = "4")]
    pub validate_only: bool,
}
/// A single operation (create, update, remove) on a keyword plan.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct KeywordPlanOperation {
    /// The FieldMask that determines which resource fields are modified in an
    /// update.
    #[prost(message, optional, tag = "4")]
    pub update_mask: ::std::option::Option<::prost_types::FieldMask>,
    /// The mutate operation.
    #[prost(oneof = "keyword_plan_operation::Operation", tags = "1, 2, 3")]
    pub operation: ::std::option::Option<keyword_plan_operation::Operation>,
}
pub mod keyword_plan_operation {
    /// The mutate operation.
    #[derive(Clone, PartialEq, ::prost::Oneof)]
    pub enum Operation {
        /// Create operation: No resource name is expected for the new keyword plan.
        #[prost(message, tag = "1")]
        Create(super::super::resources::KeywordPlan),
        /// Update operation: The keyword plan is expected to have a valid resource
        /// name.
        #[prost(message, tag = "2")]
        Update(super::super::resources::KeywordPlan),
        /// Remove operation: A resource name for the removed keyword plan is
        /// expected in this format:
        ///
        /// `customers/{customer_id}/keywordPlans/{keyword_plan_id}`
        #[prost(string, tag = "3")]
        Remove(std::string::String),
    }
}
/// Response message for a keyword plan mutate.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct MutateKeywordPlansResponse {
    /// Errors that pertain to operation failures in the partial failure mode.
    /// Returned only when partial_failure = true and all errors occur inside the
    /// operations. If any errors occur outside the operations (e.g. auth errors),
    /// we return an RPC level error.
    #[prost(message, optional, tag = "3")]
    pub partial_failure_error: ::std::option::Option<super::super::super::super::rpc::Status>,
    /// All results for the mutate.
    #[prost(message, repeated, tag = "2")]
    pub results: ::std::vec::Vec<MutateKeywordPlansResult>,
}
/// The result for the keyword plan mutate.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct MutateKeywordPlansResult {
    /// Returned for successful operations.
    #[prost(string, tag = "1")]
    pub resource_name: std::string::String,
}
/// Request message for [KeywordPlanService.GenerateForecastMetrics][google.ads.googleads.v1.services.KeywordPlanService.GenerateForecastMetrics].
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GenerateForecastMetricsRequest {
    /// Required. The resource name of the keyword plan to be forecasted.
    #[prost(string, tag = "1")]
    pub keyword_plan: std::string::String,
}
/// Response message for [KeywordPlanService.GenerateForecastMetrics][google.ads.googleads.v1.services.KeywordPlanService.GenerateForecastMetrics].
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GenerateForecastMetricsResponse {
    /// List of campaign forecasts.
    /// One maximum.
    #[prost(message, repeated, tag = "1")]
    pub campaign_forecasts: ::std::vec::Vec<KeywordPlanCampaignForecast>,
    /// List of ad group forecasts.
    #[prost(message, repeated, tag = "2")]
    pub ad_group_forecasts: ::std::vec::Vec<KeywordPlanAdGroupForecast>,
    /// List of keyword forecasts.
    #[prost(message, repeated, tag = "3")]
    pub keyword_forecasts: ::std::vec::Vec<KeywordPlanKeywordForecast>,
}
/// A campaign forecast.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct KeywordPlanCampaignForecast {
    /// The resource name of the Keyword Plan campaign related to the forecast.
    ///
    /// `customers/{customer_id}/keywordPlanCampaigns/{keyword+plan_campaign_id}`
    #[prost(message, optional, tag = "1")]
    pub keyword_plan_campaign: ::std::option::Option<::std::string::String>,
    /// The forecast for the Keyword Plan campaign.
    #[prost(message, optional, tag = "2")]
    pub campaign_forecast: ::std::option::Option<ForecastMetrics>,
}
/// An ad group forecast.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct KeywordPlanAdGroupForecast {
    /// The resource name of the Keyword Plan ad group related to the forecast.
    ///
    /// `customers/{customer_id}/keywordPlanAdGroups/{keyword_plan_ad_group_id}`
    #[prost(message, optional, tag = "1")]
    pub keyword_plan_ad_group: ::std::option::Option<::std::string::String>,
    /// The forecast for the Keyword Plan ad group.
    #[prost(message, optional, tag = "2")]
    pub ad_group_forecast: ::std::option::Option<ForecastMetrics>,
}
/// A keyword forecast.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct KeywordPlanKeywordForecast {
    /// The resource name of the Keyword Plan keyword related to the forecast.
    ///
    /// `customers/{customer_id}/keywordPlanAdGroupKeywords/{keyword_plan_ad_group_keyword_id}`
    #[prost(message, optional, tag = "1")]
    pub keyword_plan_ad_group_keyword: ::std::option::Option<::std::string::String>,
    /// The forecast for the Keyword Plan keyword.
    #[prost(message, optional, tag = "2")]
    pub keyword_forecast: ::std::option::Option<ForecastMetrics>,
}
/// Forecast metrics.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ForecastMetrics {
    /// Impressions
    #[prost(message, optional, tag = "1")]
    pub impressions: ::std::option::Option<f64>,
    /// Ctr
    #[prost(message, optional, tag = "2")]
    pub ctr: ::std::option::Option<f64>,
    /// AVG cpc
    #[prost(message, optional, tag = "3")]
    pub average_cpc: ::std::option::Option<i64>,
    /// Clicks
    #[prost(message, optional, tag = "5")]
    pub clicks: ::std::option::Option<f64>,
    /// Cost
    #[prost(message, optional, tag = "6")]
    pub cost_micros: ::std::option::Option<i64>,
}
/// Request message for [KeywordPlanService.GenerateHistoricalMetrics][google.ads.googleads.v1.services.KeywordPlanService.GenerateHistoricalMetrics].
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GenerateHistoricalMetricsRequest {
    /// Required. The resource name of the keyword plan of which historical metrics are
    /// requested.
    #[prost(string, tag = "1")]
    pub keyword_plan: std::string::String,
}
/// Response message for [KeywordPlanService.GenerateHistoricalMetrics][google.ads.googleads.v1.services.KeywordPlanService.GenerateHistoricalMetrics].
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GenerateHistoricalMetricsResponse {
    /// List of keyword historical metrics.
    #[prost(message, repeated, tag = "1")]
    pub metrics: ::std::vec::Vec<KeywordPlanKeywordHistoricalMetrics>,
}
/// A keyword historical metrics.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct KeywordPlanKeywordHistoricalMetrics {
    /// The text of the query associated with one or more ad_group_keywords in the
    /// plan.
    ///
    /// Note that we de-dupe your keywords list, eliminating close variants before
    /// returning the plan's keywords as text. For example, if your plan originally
    /// contained the keywords 'car' and 'cars', the returned search query will
    /// only contain 'car'.
    #[prost(message, optional, tag = "1")]
    pub search_query: ::std::option::Option<::std::string::String>,
    /// The historical metrics for the query associated with one or more
    /// ad_group_keywords in the plan.
    #[prost(message, optional, tag = "2")]
    pub keyword_metrics: ::std::option::Option<super::common::KeywordPlanHistoricalMetrics>,
}
#[doc = r" Generated client implementations."]
pub mod keyword_plan_service_client {
    #![allow(unused_variables, dead_code, missing_docs)]
    use tonic::codegen::*;
    #[doc = " Service to manage keyword plans."]
    pub struct KeywordPlanServiceClient<T> {
        inner: tonic::client::Grpc<T>,
    }
    impl KeywordPlanServiceClient<tonic::transport::Channel> {
        #[doc = r" Attempt to create a new client by connecting to a given endpoint."]
        pub async fn connect<D>(dst: D) -> Result<Self, tonic::transport::Error>
        where
            D: std::convert::TryInto<tonic::transport::Endpoint>,
            D::Error: Into<StdError>,
        {
            let conn = tonic::transport::Endpoint::new(dst)?.connect().await?;
            Ok(Self::new(conn))
        }
    }
    impl<T> KeywordPlanServiceClient<T>
    where
        T: tonic::client::GrpcService<tonic::body::BoxBody>,
        T::ResponseBody: Body + HttpBody + Send + 'static,
        T::Error: Into<StdError>,
        <T::ResponseBody as HttpBody>::Error: Into<StdError> + Send,
    {
        pub fn new(inner: T) -> Self {
            let inner = tonic::client::Grpc::new(inner);
            Self { inner }
        }
        pub fn with_interceptor(inner: T, interceptor: impl Into<tonic::Interceptor>) -> Self {
            let inner = tonic::client::Grpc::with_interceptor(inner, interceptor);
            Self { inner }
        }
        #[doc = " Returns the requested plan in full detail."]
        pub async fn get_keyword_plan(
            &mut self,
            request: impl tonic::IntoRequest<super::GetKeywordPlanRequest>,
        ) -> Result<tonic::Response<super::super::resources::KeywordPlan>, tonic::Status> {
            self.inner.ready().await.map_err(|e| {
                tonic::Status::new(
                    tonic::Code::Unknown,
                    format!("Service was not ready: {}", e.into()),
                )
            })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.ads.googleads.v1.services.KeywordPlanService/GetKeywordPlan",
            );
            self.inner.unary(request.into_request(), path, codec).await
        }
        #[doc = " Creates, updates, or removes keyword plans. Operation statuses are"]
        #[doc = " returned."]
        pub async fn mutate_keyword_plans(
            &mut self,
            request: impl tonic::IntoRequest<super::MutateKeywordPlansRequest>,
        ) -> Result<tonic::Response<super::MutateKeywordPlansResponse>, tonic::Status> {
            self.inner.ready().await.map_err(|e| {
                tonic::Status::new(
                    tonic::Code::Unknown,
                    format!("Service was not ready: {}", e.into()),
                )
            })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.ads.googleads.v1.services.KeywordPlanService/MutateKeywordPlans",
            );
            self.inner.unary(request.into_request(), path, codec).await
        }
        #[doc = " Returns the requested Keyword Plan forecasts."]
        pub async fn generate_forecast_metrics(
            &mut self,
            request: impl tonic::IntoRequest<super::GenerateForecastMetricsRequest>,
        ) -> Result<tonic::Response<super::GenerateForecastMetricsResponse>, tonic::Status>
        {
            self.inner.ready().await.map_err(|e| {
                tonic::Status::new(
                    tonic::Code::Unknown,
                    format!("Service was not ready: {}", e.into()),
                )
            })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.ads.googleads.v1.services.KeywordPlanService/GenerateForecastMetrics",
            );
            self.inner.unary(request.into_request(), path, codec).await
        }
        #[doc = " Returns the requested Keyword Plan historical metrics."]
        pub async fn generate_historical_metrics(
            &mut self,
            request: impl tonic::IntoRequest<super::GenerateHistoricalMetricsRequest>,
        ) -> Result<tonic::Response<super::GenerateHistoricalMetricsResponse>, tonic::Status>
        {
            self.inner.ready().await.map_err(|e| {
                tonic::Status::new(
                    tonic::Code::Unknown,
                    format!("Service was not ready: {}", e.into()),
                )
            })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.ads.googleads.v1.services.KeywordPlanService/GenerateHistoricalMetrics",
            );
            self.inner.unary(request.into_request(), path, codec).await
        }
    }
    impl<T: Clone> Clone for KeywordPlanServiceClient<T> {
        fn clone(&self) -> Self {
            Self {
                inner: self.inner.clone(),
            }
        }
    }
    impl<T> std::fmt::Debug for KeywordPlanServiceClient<T> {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
            write!(f, "KeywordPlanServiceClient {{ ... }}")
        }
    }
}
#[doc = r" Generated server implementations."]
pub mod keyword_plan_service_server {
    #![allow(unused_variables, dead_code, missing_docs)]
    use tonic::codegen::*;
    #[doc = "Generated trait containing gRPC methods that should be implemented for use with KeywordPlanServiceServer."]
    #[async_trait]
    pub trait KeywordPlanService: Send + Sync + 'static {
        #[doc = " Returns the requested plan in full detail."]
        async fn get_keyword_plan(
            &self,
            request: tonic::Request<super::GetKeywordPlanRequest>,
        ) -> Result<tonic::Response<super::super::resources::KeywordPlan>, tonic::Status>;
        #[doc = " Creates, updates, or removes keyword plans. Operation statuses are"]
        #[doc = " returned."]
        async fn mutate_keyword_plans(
            &self,
            request: tonic::Request<super::MutateKeywordPlansRequest>,
        ) -> Result<tonic::Response<super::MutateKeywordPlansResponse>, tonic::Status>;
        #[doc = " Returns the requested Keyword Plan forecasts."]
        async fn generate_forecast_metrics(
            &self,
            request: tonic::Request<super::GenerateForecastMetricsRequest>,
        ) -> Result<tonic::Response<super::GenerateForecastMetricsResponse>, tonic::Status>;
        #[doc = " Returns the requested Keyword Plan historical metrics."]
        async fn generate_historical_metrics(
            &self,
            request: tonic::Request<super::GenerateHistoricalMetricsRequest>,
        ) -> Result<tonic::Response<super::GenerateHistoricalMetricsResponse>, tonic::Status>;
    }
    #[doc = " Service to manage keyword plans."]
    #[derive(Debug)]
    #[doc(hidden)]
    pub struct KeywordPlanServiceServer<T: KeywordPlanService> {
        inner: _Inner<T>,
    }
    struct _Inner<T>(Arc<T>, Option<tonic::Interceptor>);
    impl<T: KeywordPlanService> KeywordPlanServiceServer<T> {
        pub fn new(inner: T) -> Self {
            let inner = Arc::new(inner);
            let inner = _Inner(inner, None);
            Self { inner }
        }
        pub fn with_interceptor(inner: T, interceptor: impl Into<tonic::Interceptor>) -> Self {
            let inner = Arc::new(inner);
            let inner = _Inner(inner, Some(interceptor.into()));
            Self { inner }
        }
    }
    impl<T, B> Service<http::Request<B>> for KeywordPlanServiceServer<T>
    where
        T: KeywordPlanService,
        B: HttpBody + Send + Sync + 'static,
        B::Error: Into<StdError> + Send + 'static,
    {
        type Response = http::Response<tonic::body::BoxBody>;
        type Error = Never;
        type Future = BoxFuture<Self::Response, Self::Error>;
        fn poll_ready(&mut self, _cx: &mut Context<'_>) -> Poll<Result<(), Self::Error>> {
            Poll::Ready(Ok(()))
        }
        fn call(&mut self, req: http::Request<B>) -> Self::Future {
            let inner = self.inner.clone();
            match req . uri ( ) . path ( ) { "/google.ads.googleads.v1.services.KeywordPlanService/GetKeywordPlan" => { # [ allow ( non_camel_case_types ) ] struct GetKeywordPlanSvc < T : KeywordPlanService > ( pub Arc < T > ) ; impl < T : KeywordPlanService > tonic :: server :: UnaryService < super :: GetKeywordPlanRequest > for GetKeywordPlanSvc < T > { type Response = super :: super :: resources :: KeywordPlan ; type Future = BoxFuture < tonic :: Response < Self :: Response > , tonic :: Status > ; fn call ( & mut self , request : tonic :: Request < super :: GetKeywordPlanRequest > ) -> Self :: Future { let inner = self . 0 . clone ( ) ; let fut = async move { inner . get_keyword_plan ( request ) . await } ; Box :: pin ( fut ) } } let inner = self . inner . clone ( ) ; let fut = async move { let interceptor = inner . 1 . clone ( ) ; let inner = inner . 0 ; let method = GetKeywordPlanSvc ( inner ) ; let codec = tonic :: codec :: ProstCodec :: default ( ) ; let mut grpc = if let Some ( interceptor ) = interceptor { tonic :: server :: Grpc :: with_interceptor ( codec , interceptor ) } else { tonic :: server :: Grpc :: new ( codec ) } ; let res = grpc . unary ( method , req ) . await ; Ok ( res ) } ; Box :: pin ( fut ) } "/google.ads.googleads.v1.services.KeywordPlanService/MutateKeywordPlans" => { # [ allow ( non_camel_case_types ) ] struct MutateKeywordPlansSvc < T : KeywordPlanService > ( pub Arc < T > ) ; impl < T : KeywordPlanService > tonic :: server :: UnaryService < super :: MutateKeywordPlansRequest > for MutateKeywordPlansSvc < T > { type Response = super :: MutateKeywordPlansResponse ; type Future = BoxFuture < tonic :: Response < Self :: Response > , tonic :: Status > ; fn call ( & mut self , request : tonic :: Request < super :: MutateKeywordPlansRequest > ) -> Self :: Future { let inner = self . 0 . clone ( ) ; let fut = async move { inner . mutate_keyword_plans ( request ) . await } ; Box :: pin ( fut ) } } let inner = self . inner . clone ( ) ; let fut = async move { let interceptor = inner . 1 . clone ( ) ; let inner = inner . 0 ; let method = MutateKeywordPlansSvc ( inner ) ; let codec = tonic :: codec :: ProstCodec :: default ( ) ; let mut grpc = if let Some ( interceptor ) = interceptor { tonic :: server :: Grpc :: with_interceptor ( codec , interceptor ) } else { tonic :: server :: Grpc :: new ( codec ) } ; let res = grpc . unary ( method , req ) . await ; Ok ( res ) } ; Box :: pin ( fut ) } "/google.ads.googleads.v1.services.KeywordPlanService/GenerateForecastMetrics" => { # [ allow ( non_camel_case_types ) ] struct GenerateForecastMetricsSvc < T : KeywordPlanService > ( pub Arc < T > ) ; impl < T : KeywordPlanService > tonic :: server :: UnaryService < super :: GenerateForecastMetricsRequest > for GenerateForecastMetricsSvc < T > { type Response = super :: GenerateForecastMetricsResponse ; type Future = BoxFuture < tonic :: Response < Self :: Response > , tonic :: Status > ; fn call ( & mut self , request : tonic :: Request < super :: GenerateForecastMetricsRequest > ) -> Self :: Future { let inner = self . 0 . clone ( ) ; let fut = async move { inner . generate_forecast_metrics ( request ) . await } ; Box :: pin ( fut ) } } let inner = self . inner . clone ( ) ; let fut = async move { let interceptor = inner . 1 . clone ( ) ; let inner = inner . 0 ; let method = GenerateForecastMetricsSvc ( inner ) ; let codec = tonic :: codec :: ProstCodec :: default ( ) ; let mut grpc = if let Some ( interceptor ) = interceptor { tonic :: server :: Grpc :: with_interceptor ( codec , interceptor ) } else { tonic :: server :: Grpc :: new ( codec ) } ; let res = grpc . unary ( method , req ) . await ; Ok ( res ) } ; Box :: pin ( fut ) } "/google.ads.googleads.v1.services.KeywordPlanService/GenerateHistoricalMetrics" => { # [ allow ( non_camel_case_types ) ] struct GenerateHistoricalMetricsSvc < T : KeywordPlanService > ( pub Arc < T > ) ; impl < T : KeywordPlanService > tonic :: server :: UnaryService < super :: GenerateHistoricalMetricsRequest > for GenerateHistoricalMetricsSvc < T > { type Response = super :: GenerateHistoricalMetricsResponse ; type Future = BoxFuture < tonic :: Response < Self :: Response > , tonic :: Status > ; fn call ( & mut self , request : tonic :: Request < super :: GenerateHistoricalMetricsRequest > ) -> Self :: Future { let inner = self . 0 . clone ( ) ; let fut = async move { inner . generate_historical_metrics ( request ) . await } ; Box :: pin ( fut ) } } let inner = self . inner . clone ( ) ; let fut = async move { let interceptor = inner . 1 . clone ( ) ; let inner = inner . 0 ; let method = GenerateHistoricalMetricsSvc ( inner ) ; let codec = tonic :: codec :: ProstCodec :: default ( ) ; let mut grpc = if let Some ( interceptor ) = interceptor { tonic :: server :: Grpc :: with_interceptor ( codec , interceptor ) } else { tonic :: server :: Grpc :: new ( codec ) } ; let res = grpc . unary ( method , req ) . await ; Ok ( res ) } ; Box :: pin ( fut ) } _ => Box :: pin ( async move { Ok ( http :: Response :: builder ( ) . status ( 200 ) . header ( "grpc-status" , "12" ) . body ( tonic :: body :: BoxBody :: empty ( ) ) . unwrap ( ) ) } ) , }
        }
    }
    impl<T: KeywordPlanService> Clone for KeywordPlanServiceServer<T> {
        fn clone(&self) -> Self {
            let inner = self.inner.clone();
            Self { inner }
        }
    }
    impl<T: KeywordPlanService> Clone for _Inner<T> {
        fn clone(&self) -> Self {
            Self(self.0.clone(), self.1.clone())
        }
    }
    impl<T: std::fmt::Debug> std::fmt::Debug for _Inner<T> {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
            write!(f, "{:?}", self.0)
        }
    }
    impl<T: KeywordPlanService> tonic::transport::NamedService for KeywordPlanServiceServer<T> {
        const NAME: &'static str = "google.ads.googleads.v1.services.KeywordPlanService";
    }
}
/// Request message for [KeywordViewService.GetKeywordView][google.ads.googleads.v1.services.KeywordViewService.GetKeywordView].
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GetKeywordViewRequest {
    /// Required. The resource name of the keyword view to fetch.
    #[prost(string, tag = "1")]
    pub resource_name: std::string::String,
}
#[doc = r" Generated client implementations."]
pub mod keyword_view_service_client {
    #![allow(unused_variables, dead_code, missing_docs)]
    use tonic::codegen::*;
    #[doc = " Service to manage keyword views."]
    pub struct KeywordViewServiceClient<T> {
        inner: tonic::client::Grpc<T>,
    }
    impl KeywordViewServiceClient<tonic::transport::Channel> {
        #[doc = r" Attempt to create a new client by connecting to a given endpoint."]
        pub async fn connect<D>(dst: D) -> Result<Self, tonic::transport::Error>
        where
            D: std::convert::TryInto<tonic::transport::Endpoint>,
            D::Error: Into<StdError>,
        {
            let conn = tonic::transport::Endpoint::new(dst)?.connect().await?;
            Ok(Self::new(conn))
        }
    }
    impl<T> KeywordViewServiceClient<T>
    where
        T: tonic::client::GrpcService<tonic::body::BoxBody>,
        T::ResponseBody: Body + HttpBody + Send + 'static,
        T::Error: Into<StdError>,
        <T::ResponseBody as HttpBody>::Error: Into<StdError> + Send,
    {
        pub fn new(inner: T) -> Self {
            let inner = tonic::client::Grpc::new(inner);
            Self { inner }
        }
        pub fn with_interceptor(inner: T, interceptor: impl Into<tonic::Interceptor>) -> Self {
            let inner = tonic::client::Grpc::with_interceptor(inner, interceptor);
            Self { inner }
        }
        #[doc = " Returns the requested keyword view in full detail."]
        pub async fn get_keyword_view(
            &mut self,
            request: impl tonic::IntoRequest<super::GetKeywordViewRequest>,
        ) -> Result<tonic::Response<super::super::resources::KeywordView>, tonic::Status> {
            self.inner.ready().await.map_err(|e| {
                tonic::Status::new(
                    tonic::Code::Unknown,
                    format!("Service was not ready: {}", e.into()),
                )
            })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.ads.googleads.v1.services.KeywordViewService/GetKeywordView",
            );
            self.inner.unary(request.into_request(), path, codec).await
        }
    }
    impl<T: Clone> Clone for KeywordViewServiceClient<T> {
        fn clone(&self) -> Self {
            Self {
                inner: self.inner.clone(),
            }
        }
    }
    impl<T> std::fmt::Debug for KeywordViewServiceClient<T> {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
            write!(f, "KeywordViewServiceClient {{ ... }}")
        }
    }
}
#[doc = r" Generated server implementations."]
pub mod keyword_view_service_server {
    #![allow(unused_variables, dead_code, missing_docs)]
    use tonic::codegen::*;
    #[doc = "Generated trait containing gRPC methods that should be implemented for use with KeywordViewServiceServer."]
    #[async_trait]
    pub trait KeywordViewService: Send + Sync + 'static {
        #[doc = " Returns the requested keyword view in full detail."]
        async fn get_keyword_view(
            &self,
            request: tonic::Request<super::GetKeywordViewRequest>,
        ) -> Result<tonic::Response<super::super::resources::KeywordView>, tonic::Status>;
    }
    #[doc = " Service to manage keyword views."]
    #[derive(Debug)]
    #[doc(hidden)]
    pub struct KeywordViewServiceServer<T: KeywordViewService> {
        inner: _Inner<T>,
    }
    struct _Inner<T>(Arc<T>, Option<tonic::Interceptor>);
    impl<T: KeywordViewService> KeywordViewServiceServer<T> {
        pub fn new(inner: T) -> Self {
            let inner = Arc::new(inner);
            let inner = _Inner(inner, None);
            Self { inner }
        }
        pub fn with_interceptor(inner: T, interceptor: impl Into<tonic::Interceptor>) -> Self {
            let inner = Arc::new(inner);
            let inner = _Inner(inner, Some(interceptor.into()));
            Self { inner }
        }
    }
    impl<T, B> Service<http::Request<B>> for KeywordViewServiceServer<T>
    where
        T: KeywordViewService,
        B: HttpBody + Send + Sync + 'static,
        B::Error: Into<StdError> + Send + 'static,
    {
        type Response = http::Response<tonic::body::BoxBody>;
        type Error = Never;
        type Future = BoxFuture<Self::Response, Self::Error>;
        fn poll_ready(&mut self, _cx: &mut Context<'_>) -> Poll<Result<(), Self::Error>> {
            Poll::Ready(Ok(()))
        }
        fn call(&mut self, req: http::Request<B>) -> Self::Future {
            let inner = self.inner.clone();
            match req.uri().path() {
                "/google.ads.googleads.v1.services.KeywordViewService/GetKeywordView" => {
                    #[allow(non_camel_case_types)]
                    struct GetKeywordViewSvc<T: KeywordViewService>(pub Arc<T>);
                    impl<T: KeywordViewService>
                        tonic::server::UnaryService<super::GetKeywordViewRequest>
                        for GetKeywordViewSvc<T>
                    {
                        type Response = super::super::resources::KeywordView;
                        type Future = BoxFuture<tonic::Response<Self::Response>, tonic::Status>;
                        fn call(
                            &mut self,
                            request: tonic::Request<super::GetKeywordViewRequest>,
                        ) -> Self::Future {
                            let inner = self.0.clone();
                            let fut = async move { inner.get_keyword_view(request).await };
                            Box::pin(fut)
                        }
                    }
                    let inner = self.inner.clone();
                    let fut = async move {
                        let interceptor = inner.1.clone();
                        let inner = inner.0;
                        let method = GetKeywordViewSvc(inner);
                        let codec = tonic::codec::ProstCodec::default();
                        let mut grpc = if let Some(interceptor) = interceptor {
                            tonic::server::Grpc::with_interceptor(codec, interceptor)
                        } else {
                            tonic::server::Grpc::new(codec)
                        };
                        let res = grpc.unary(method, req).await;
                        Ok(res)
                    };
                    Box::pin(fut)
                }
                _ => Box::pin(async move {
                    Ok(http::Response::builder()
                        .status(200)
                        .header("grpc-status", "12")
                        .body(tonic::body::BoxBody::empty())
                        .unwrap())
                }),
            }
        }
    }
    impl<T: KeywordViewService> Clone for KeywordViewServiceServer<T> {
        fn clone(&self) -> Self {
            let inner = self.inner.clone();
            Self { inner }
        }
    }
    impl<T: KeywordViewService> Clone for _Inner<T> {
        fn clone(&self) -> Self {
            Self(self.0.clone(), self.1.clone())
        }
    }
    impl<T: std::fmt::Debug> std::fmt::Debug for _Inner<T> {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
            write!(f, "{:?}", self.0)
        }
    }
    impl<T: KeywordViewService> tonic::transport::NamedService for KeywordViewServiceServer<T> {
        const NAME: &'static str = "google.ads.googleads.v1.services.KeywordViewService";
    }
}
/// Request message for [LandingPageViewService.GetLandingPageView][google.ads.googleads.v1.services.LandingPageViewService.GetLandingPageView].
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GetLandingPageViewRequest {
    /// Required. The resource name of the landing page view to fetch.
    #[prost(string, tag = "1")]
    pub resource_name: std::string::String,
}
#[doc = r" Generated client implementations."]
pub mod landing_page_view_service_client {
    #![allow(unused_variables, dead_code, missing_docs)]
    use tonic::codegen::*;
    #[doc = " Service to fetch landing page views."]
    pub struct LandingPageViewServiceClient<T> {
        inner: tonic::client::Grpc<T>,
    }
    impl LandingPageViewServiceClient<tonic::transport::Channel> {
        #[doc = r" Attempt to create a new client by connecting to a given endpoint."]
        pub async fn connect<D>(dst: D) -> Result<Self, tonic::transport::Error>
        where
            D: std::convert::TryInto<tonic::transport::Endpoint>,
            D::Error: Into<StdError>,
        {
            let conn = tonic::transport::Endpoint::new(dst)?.connect().await?;
            Ok(Self::new(conn))
        }
    }
    impl<T> LandingPageViewServiceClient<T>
    where
        T: tonic::client::GrpcService<tonic::body::BoxBody>,
        T::ResponseBody: Body + HttpBody + Send + 'static,
        T::Error: Into<StdError>,
        <T::ResponseBody as HttpBody>::Error: Into<StdError> + Send,
    {
        pub fn new(inner: T) -> Self {
            let inner = tonic::client::Grpc::new(inner);
            Self { inner }
        }
        pub fn with_interceptor(inner: T, interceptor: impl Into<tonic::Interceptor>) -> Self {
            let inner = tonic::client::Grpc::with_interceptor(inner, interceptor);
            Self { inner }
        }
        #[doc = " Returns the requested landing page view in full detail."]
        pub async fn get_landing_page_view(
            &mut self,
            request: impl tonic::IntoRequest<super::GetLandingPageViewRequest>,
        ) -> Result<tonic::Response<super::super::resources::LandingPageView>, tonic::Status>
        {
            self.inner.ready().await.map_err(|e| {
                tonic::Status::new(
                    tonic::Code::Unknown,
                    format!("Service was not ready: {}", e.into()),
                )
            })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.ads.googleads.v1.services.LandingPageViewService/GetLandingPageView",
            );
            self.inner.unary(request.into_request(), path, codec).await
        }
    }
    impl<T: Clone> Clone for LandingPageViewServiceClient<T> {
        fn clone(&self) -> Self {
            Self {
                inner: self.inner.clone(),
            }
        }
    }
    impl<T> std::fmt::Debug for LandingPageViewServiceClient<T> {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
            write!(f, "LandingPageViewServiceClient {{ ... }}")
        }
    }
}
#[doc = r" Generated server implementations."]
pub mod landing_page_view_service_server {
    #![allow(unused_variables, dead_code, missing_docs)]
    use tonic::codegen::*;
    #[doc = "Generated trait containing gRPC methods that should be implemented for use with LandingPageViewServiceServer."]
    #[async_trait]
    pub trait LandingPageViewService: Send + Sync + 'static {
        #[doc = " Returns the requested landing page view in full detail."]
        async fn get_landing_page_view(
            &self,
            request: tonic::Request<super::GetLandingPageViewRequest>,
        ) -> Result<tonic::Response<super::super::resources::LandingPageView>, tonic::Status>;
    }
    #[doc = " Service to fetch landing page views."]
    #[derive(Debug)]
    #[doc(hidden)]
    pub struct LandingPageViewServiceServer<T: LandingPageViewService> {
        inner: _Inner<T>,
    }
    struct _Inner<T>(Arc<T>, Option<tonic::Interceptor>);
    impl<T: LandingPageViewService> LandingPageViewServiceServer<T> {
        pub fn new(inner: T) -> Self {
            let inner = Arc::new(inner);
            let inner = _Inner(inner, None);
            Self { inner }
        }
        pub fn with_interceptor(inner: T, interceptor: impl Into<tonic::Interceptor>) -> Self {
            let inner = Arc::new(inner);
            let inner = _Inner(inner, Some(interceptor.into()));
            Self { inner }
        }
    }
    impl<T, B> Service<http::Request<B>> for LandingPageViewServiceServer<T>
    where
        T: LandingPageViewService,
        B: HttpBody + Send + Sync + 'static,
        B::Error: Into<StdError> + Send + 'static,
    {
        type Response = http::Response<tonic::body::BoxBody>;
        type Error = Never;
        type Future = BoxFuture<Self::Response, Self::Error>;
        fn poll_ready(&mut self, _cx: &mut Context<'_>) -> Poll<Result<(), Self::Error>> {
            Poll::Ready(Ok(()))
        }
        fn call(&mut self, req: http::Request<B>) -> Self::Future {
            let inner = self.inner.clone();
            match req.uri().path() {
                "/google.ads.googleads.v1.services.LandingPageViewService/GetLandingPageView" => {
                    #[allow(non_camel_case_types)]
                    struct GetLandingPageViewSvc<T: LandingPageViewService>(pub Arc<T>);
                    impl<T: LandingPageViewService>
                        tonic::server::UnaryService<super::GetLandingPageViewRequest>
                        for GetLandingPageViewSvc<T>
                    {
                        type Response = super::super::resources::LandingPageView;
                        type Future = BoxFuture<tonic::Response<Self::Response>, tonic::Status>;
                        fn call(
                            &mut self,
                            request: tonic::Request<super::GetLandingPageViewRequest>,
                        ) -> Self::Future {
                            let inner = self.0.clone();
                            let fut = async move { inner.get_landing_page_view(request).await };
                            Box::pin(fut)
                        }
                    }
                    let inner = self.inner.clone();
                    let fut = async move {
                        let interceptor = inner.1.clone();
                        let inner = inner.0;
                        let method = GetLandingPageViewSvc(inner);
                        let codec = tonic::codec::ProstCodec::default();
                        let mut grpc = if let Some(interceptor) = interceptor {
                            tonic::server::Grpc::with_interceptor(codec, interceptor)
                        } else {
                            tonic::server::Grpc::new(codec)
                        };
                        let res = grpc.unary(method, req).await;
                        Ok(res)
                    };
                    Box::pin(fut)
                }
                _ => Box::pin(async move {
                    Ok(http::Response::builder()
                        .status(200)
                        .header("grpc-status", "12")
                        .body(tonic::body::BoxBody::empty())
                        .unwrap())
                }),
            }
        }
    }
    impl<T: LandingPageViewService> Clone for LandingPageViewServiceServer<T> {
        fn clone(&self) -> Self {
            let inner = self.inner.clone();
            Self { inner }
        }
    }
    impl<T: LandingPageViewService> Clone for _Inner<T> {
        fn clone(&self) -> Self {
            Self(self.0.clone(), self.1.clone())
        }
    }
    impl<T: std::fmt::Debug> std::fmt::Debug for _Inner<T> {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
            write!(f, "{:?}", self.0)
        }
    }
    impl<T: LandingPageViewService> tonic::transport::NamedService for LandingPageViewServiceServer<T> {
        const NAME: &'static str = "google.ads.googleads.v1.services.LandingPageViewService";
    }
}
/// Request message for [LanguageConstantService.GetLanguageConstant][google.ads.googleads.v1.services.LanguageConstantService.GetLanguageConstant].
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GetLanguageConstantRequest {
    /// Required. Resource name of the language constant to fetch.
    #[prost(string, tag = "1")]
    pub resource_name: std::string::String,
}
#[doc = r" Generated client implementations."]
pub mod language_constant_service_client {
    #![allow(unused_variables, dead_code, missing_docs)]
    use tonic::codegen::*;
    #[doc = " Service to fetch language constants."]
    pub struct LanguageConstantServiceClient<T> {
        inner: tonic::client::Grpc<T>,
    }
    impl LanguageConstantServiceClient<tonic::transport::Channel> {
        #[doc = r" Attempt to create a new client by connecting to a given endpoint."]
        pub async fn connect<D>(dst: D) -> Result<Self, tonic::transport::Error>
        where
            D: std::convert::TryInto<tonic::transport::Endpoint>,
            D::Error: Into<StdError>,
        {
            let conn = tonic::transport::Endpoint::new(dst)?.connect().await?;
            Ok(Self::new(conn))
        }
    }
    impl<T> LanguageConstantServiceClient<T>
    where
        T: tonic::client::GrpcService<tonic::body::BoxBody>,
        T::ResponseBody: Body + HttpBody + Send + 'static,
        T::Error: Into<StdError>,
        <T::ResponseBody as HttpBody>::Error: Into<StdError> + Send,
    {
        pub fn new(inner: T) -> Self {
            let inner = tonic::client::Grpc::new(inner);
            Self { inner }
        }
        pub fn with_interceptor(inner: T, interceptor: impl Into<tonic::Interceptor>) -> Self {
            let inner = tonic::client::Grpc::with_interceptor(inner, interceptor);
            Self { inner }
        }
        #[doc = " Returns the requested language constant."]
        pub async fn get_language_constant(
            &mut self,
            request: impl tonic::IntoRequest<super::GetLanguageConstantRequest>,
        ) -> Result<tonic::Response<super::super::resources::LanguageConstant>, tonic::Status>
        {
            self.inner.ready().await.map_err(|e| {
                tonic::Status::new(
                    tonic::Code::Unknown,
                    format!("Service was not ready: {}", e.into()),
                )
            })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.ads.googleads.v1.services.LanguageConstantService/GetLanguageConstant",
            );
            self.inner.unary(request.into_request(), path, codec).await
        }
    }
    impl<T: Clone> Clone for LanguageConstantServiceClient<T> {
        fn clone(&self) -> Self {
            Self {
                inner: self.inner.clone(),
            }
        }
    }
    impl<T> std::fmt::Debug for LanguageConstantServiceClient<T> {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
            write!(f, "LanguageConstantServiceClient {{ ... }}")
        }
    }
}
#[doc = r" Generated server implementations."]
pub mod language_constant_service_server {
    #![allow(unused_variables, dead_code, missing_docs)]
    use tonic::codegen::*;
    #[doc = "Generated trait containing gRPC methods that should be implemented for use with LanguageConstantServiceServer."]
    #[async_trait]
    pub trait LanguageConstantService: Send + Sync + 'static {
        #[doc = " Returns the requested language constant."]
        async fn get_language_constant(
            &self,
            request: tonic::Request<super::GetLanguageConstantRequest>,
        ) -> Result<tonic::Response<super::super::resources::LanguageConstant>, tonic::Status>;
    }
    #[doc = " Service to fetch language constants."]
    #[derive(Debug)]
    #[doc(hidden)]
    pub struct LanguageConstantServiceServer<T: LanguageConstantService> {
        inner: _Inner<T>,
    }
    struct _Inner<T>(Arc<T>, Option<tonic::Interceptor>);
    impl<T: LanguageConstantService> LanguageConstantServiceServer<T> {
        pub fn new(inner: T) -> Self {
            let inner = Arc::new(inner);
            let inner = _Inner(inner, None);
            Self { inner }
        }
        pub fn with_interceptor(inner: T, interceptor: impl Into<tonic::Interceptor>) -> Self {
            let inner = Arc::new(inner);
            let inner = _Inner(inner, Some(interceptor.into()));
            Self { inner }
        }
    }
    impl<T, B> Service<http::Request<B>> for LanguageConstantServiceServer<T>
    where
        T: LanguageConstantService,
        B: HttpBody + Send + Sync + 'static,
        B::Error: Into<StdError> + Send + 'static,
    {
        type Response = http::Response<tonic::body::BoxBody>;
        type Error = Never;
        type Future = BoxFuture<Self::Response, Self::Error>;
        fn poll_ready(&mut self, _cx: &mut Context<'_>) -> Poll<Result<(), Self::Error>> {
            Poll::Ready(Ok(()))
        }
        fn call(&mut self, req: http::Request<B>) -> Self::Future {
            let inner = self.inner.clone();
            match req.uri().path() {
                "/google.ads.googleads.v1.services.LanguageConstantService/GetLanguageConstant" => {
                    #[allow(non_camel_case_types)]
                    struct GetLanguageConstantSvc<T: LanguageConstantService>(pub Arc<T>);
                    impl<T: LanguageConstantService>
                        tonic::server::UnaryService<super::GetLanguageConstantRequest>
                        for GetLanguageConstantSvc<T>
                    {
                        type Response = super::super::resources::LanguageConstant;
                        type Future = BoxFuture<tonic::Response<Self::Response>, tonic::Status>;
                        fn call(
                            &mut self,
                            request: tonic::Request<super::GetLanguageConstantRequest>,
                        ) -> Self::Future {
                            let inner = self.0.clone();
                            let fut = async move { inner.get_language_constant(request).await };
                            Box::pin(fut)
                        }
                    }
                    let inner = self.inner.clone();
                    let fut = async move {
                        let interceptor = inner.1.clone();
                        let inner = inner.0;
                        let method = GetLanguageConstantSvc(inner);
                        let codec = tonic::codec::ProstCodec::default();
                        let mut grpc = if let Some(interceptor) = interceptor {
                            tonic::server::Grpc::with_interceptor(codec, interceptor)
                        } else {
                            tonic::server::Grpc::new(codec)
                        };
                        let res = grpc.unary(method, req).await;
                        Ok(res)
                    };
                    Box::pin(fut)
                }
                _ => Box::pin(async move {
                    Ok(http::Response::builder()
                        .status(200)
                        .header("grpc-status", "12")
                        .body(tonic::body::BoxBody::empty())
                        .unwrap())
                }),
            }
        }
    }
    impl<T: LanguageConstantService> Clone for LanguageConstantServiceServer<T> {
        fn clone(&self) -> Self {
            let inner = self.inner.clone();
            Self { inner }
        }
    }
    impl<T: LanguageConstantService> Clone for _Inner<T> {
        fn clone(&self) -> Self {
            Self(self.0.clone(), self.1.clone())
        }
    }
    impl<T: std::fmt::Debug> std::fmt::Debug for _Inner<T> {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
            write!(f, "{:?}", self.0)
        }
    }
    impl<T: LanguageConstantService> tonic::transport::NamedService
        for LanguageConstantServiceServer<T>
    {
        const NAME: &'static str = "google.ads.googleads.v1.services.LanguageConstantService";
    }
}
/// Request message for [LocationViewService.GetLocationView][google.ads.googleads.v1.services.LocationViewService.GetLocationView].
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GetLocationViewRequest {
    /// Required. The resource name of the location view to fetch.
    #[prost(string, tag = "1")]
    pub resource_name: std::string::String,
}
#[doc = r" Generated client implementations."]
pub mod location_view_service_client {
    #![allow(unused_variables, dead_code, missing_docs)]
    use tonic::codegen::*;
    #[doc = " Service to fetch location views."]
    pub struct LocationViewServiceClient<T> {
        inner: tonic::client::Grpc<T>,
    }
    impl LocationViewServiceClient<tonic::transport::Channel> {
        #[doc = r" Attempt to create a new client by connecting to a given endpoint."]
        pub async fn connect<D>(dst: D) -> Result<Self, tonic::transport::Error>
        where
            D: std::convert::TryInto<tonic::transport::Endpoint>,
            D::Error: Into<StdError>,
        {
            let conn = tonic::transport::Endpoint::new(dst)?.connect().await?;
            Ok(Self::new(conn))
        }
    }
    impl<T> LocationViewServiceClient<T>
    where
        T: tonic::client::GrpcService<tonic::body::BoxBody>,
        T::ResponseBody: Body + HttpBody + Send + 'static,
        T::Error: Into<StdError>,
        <T::ResponseBody as HttpBody>::Error: Into<StdError> + Send,
    {
        pub fn new(inner: T) -> Self {
            let inner = tonic::client::Grpc::new(inner);
            Self { inner }
        }
        pub fn with_interceptor(inner: T, interceptor: impl Into<tonic::Interceptor>) -> Self {
            let inner = tonic::client::Grpc::with_interceptor(inner, interceptor);
            Self { inner }
        }
        #[doc = " Returns the requested location view in full detail."]
        pub async fn get_location_view(
            &mut self,
            request: impl tonic::IntoRequest<super::GetLocationViewRequest>,
        ) -> Result<tonic::Response<super::super::resources::LocationView>, tonic::Status> {
            self.inner.ready().await.map_err(|e| {
                tonic::Status::new(
                    tonic::Code::Unknown,
                    format!("Service was not ready: {}", e.into()),
                )
            })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.ads.googleads.v1.services.LocationViewService/GetLocationView",
            );
            self.inner.unary(request.into_request(), path, codec).await
        }
    }
    impl<T: Clone> Clone for LocationViewServiceClient<T> {
        fn clone(&self) -> Self {
            Self {
                inner: self.inner.clone(),
            }
        }
    }
    impl<T> std::fmt::Debug for LocationViewServiceClient<T> {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
            write!(f, "LocationViewServiceClient {{ ... }}")
        }
    }
}
#[doc = r" Generated server implementations."]
pub mod location_view_service_server {
    #![allow(unused_variables, dead_code, missing_docs)]
    use tonic::codegen::*;
    #[doc = "Generated trait containing gRPC methods that should be implemented for use with LocationViewServiceServer."]
    #[async_trait]
    pub trait LocationViewService: Send + Sync + 'static {
        #[doc = " Returns the requested location view in full detail."]
        async fn get_location_view(
            &self,
            request: tonic::Request<super::GetLocationViewRequest>,
        ) -> Result<tonic::Response<super::super::resources::LocationView>, tonic::Status>;
    }
    #[doc = " Service to fetch location views."]
    #[derive(Debug)]
    #[doc(hidden)]
    pub struct LocationViewServiceServer<T: LocationViewService> {
        inner: _Inner<T>,
    }
    struct _Inner<T>(Arc<T>, Option<tonic::Interceptor>);
    impl<T: LocationViewService> LocationViewServiceServer<T> {
        pub fn new(inner: T) -> Self {
            let inner = Arc::new(inner);
            let inner = _Inner(inner, None);
            Self { inner }
        }
        pub fn with_interceptor(inner: T, interceptor: impl Into<tonic::Interceptor>) -> Self {
            let inner = Arc::new(inner);
            let inner = _Inner(inner, Some(interceptor.into()));
            Self { inner }
        }
    }
    impl<T, B> Service<http::Request<B>> for LocationViewServiceServer<T>
    where
        T: LocationViewService,
        B: HttpBody + Send + Sync + 'static,
        B::Error: Into<StdError> + Send + 'static,
    {
        type Response = http::Response<tonic::body::BoxBody>;
        type Error = Never;
        type Future = BoxFuture<Self::Response, Self::Error>;
        fn poll_ready(&mut self, _cx: &mut Context<'_>) -> Poll<Result<(), Self::Error>> {
            Poll::Ready(Ok(()))
        }
        fn call(&mut self, req: http::Request<B>) -> Self::Future {
            let inner = self.inner.clone();
            match req.uri().path() {
                "/google.ads.googleads.v1.services.LocationViewService/GetLocationView" => {
                    #[allow(non_camel_case_types)]
                    struct GetLocationViewSvc<T: LocationViewService>(pub Arc<T>);
                    impl<T: LocationViewService>
                        tonic::server::UnaryService<super::GetLocationViewRequest>
                        for GetLocationViewSvc<T>
                    {
                        type Response = super::super::resources::LocationView;
                        type Future = BoxFuture<tonic::Response<Self::Response>, tonic::Status>;
                        fn call(
                            &mut self,
                            request: tonic::Request<super::GetLocationViewRequest>,
                        ) -> Self::Future {
                            let inner = self.0.clone();
                            let fut = async move { inner.get_location_view(request).await };
                            Box::pin(fut)
                        }
                    }
                    let inner = self.inner.clone();
                    let fut = async move {
                        let interceptor = inner.1.clone();
                        let inner = inner.0;
                        let method = GetLocationViewSvc(inner);
                        let codec = tonic::codec::ProstCodec::default();
                        let mut grpc = if let Some(interceptor) = interceptor {
                            tonic::server::Grpc::with_interceptor(codec, interceptor)
                        } else {
                            tonic::server::Grpc::new(codec)
                        };
                        let res = grpc.unary(method, req).await;
                        Ok(res)
                    };
                    Box::pin(fut)
                }
                _ => Box::pin(async move {
                    Ok(http::Response::builder()
                        .status(200)
                        .header("grpc-status", "12")
                        .body(tonic::body::BoxBody::empty())
                        .unwrap())
                }),
            }
        }
    }
    impl<T: LocationViewService> Clone for LocationViewServiceServer<T> {
        fn clone(&self) -> Self {
            let inner = self.inner.clone();
            Self { inner }
        }
    }
    impl<T: LocationViewService> Clone for _Inner<T> {
        fn clone(&self) -> Self {
            Self(self.0.clone(), self.1.clone())
        }
    }
    impl<T: std::fmt::Debug> std::fmt::Debug for _Inner<T> {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
            write!(f, "{:?}", self.0)
        }
    }
    impl<T: LocationViewService> tonic::transport::NamedService for LocationViewServiceServer<T> {
        const NAME: &'static str = "google.ads.googleads.v1.services.LocationViewService";
    }
}
/// Request message for [ManagedPlacementViewService.GetManagedPlacementView][google.ads.googleads.v1.services.ManagedPlacementViewService.GetManagedPlacementView].
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GetManagedPlacementViewRequest {
    /// Required. The resource name of the Managed Placement View to fetch.
    #[prost(string, tag = "1")]
    pub resource_name: std::string::String,
}
#[doc = r" Generated client implementations."]
pub mod managed_placement_view_service_client {
    #![allow(unused_variables, dead_code, missing_docs)]
    use tonic::codegen::*;
    #[doc = " Service to manage Managed Placement views."]
    pub struct ManagedPlacementViewServiceClient<T> {
        inner: tonic::client::Grpc<T>,
    }
    impl ManagedPlacementViewServiceClient<tonic::transport::Channel> {
        #[doc = r" Attempt to create a new client by connecting to a given endpoint."]
        pub async fn connect<D>(dst: D) -> Result<Self, tonic::transport::Error>
        where
            D: std::convert::TryInto<tonic::transport::Endpoint>,
            D::Error: Into<StdError>,
        {
            let conn = tonic::transport::Endpoint::new(dst)?.connect().await?;
            Ok(Self::new(conn))
        }
    }
    impl<T> ManagedPlacementViewServiceClient<T>
    where
        T: tonic::client::GrpcService<tonic::body::BoxBody>,
        T::ResponseBody: Body + HttpBody + Send + 'static,
        T::Error: Into<StdError>,
        <T::ResponseBody as HttpBody>::Error: Into<StdError> + Send,
    {
        pub fn new(inner: T) -> Self {
            let inner = tonic::client::Grpc::new(inner);
            Self { inner }
        }
        pub fn with_interceptor(inner: T, interceptor: impl Into<tonic::Interceptor>) -> Self {
            let inner = tonic::client::Grpc::with_interceptor(inner, interceptor);
            Self { inner }
        }
        #[doc = " Returns the requested Managed Placement view in full detail."]
        pub async fn get_managed_placement_view(
            &mut self,
            request: impl tonic::IntoRequest<super::GetManagedPlacementViewRequest>,
        ) -> Result<tonic::Response<super::super::resources::ManagedPlacementView>, tonic::Status>
        {
            self.inner.ready().await.map_err(|e| {
                tonic::Status::new(
                    tonic::Code::Unknown,
                    format!("Service was not ready: {}", e.into()),
                )
            })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http :: uri :: PathAndQuery :: from_static ( "/google.ads.googleads.v1.services.ManagedPlacementViewService/GetManagedPlacementView" ) ;
            self.inner.unary(request.into_request(), path, codec).await
        }
    }
    impl<T: Clone> Clone for ManagedPlacementViewServiceClient<T> {
        fn clone(&self) -> Self {
            Self {
                inner: self.inner.clone(),
            }
        }
    }
    impl<T> std::fmt::Debug for ManagedPlacementViewServiceClient<T> {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
            write!(f, "ManagedPlacementViewServiceClient {{ ... }}")
        }
    }
}
#[doc = r" Generated server implementations."]
pub mod managed_placement_view_service_server {
    #![allow(unused_variables, dead_code, missing_docs)]
    use tonic::codegen::*;
    #[doc = "Generated trait containing gRPC methods that should be implemented for use with ManagedPlacementViewServiceServer."]
    #[async_trait]
    pub trait ManagedPlacementViewService: Send + Sync + 'static {
        #[doc = " Returns the requested Managed Placement view in full detail."]
        async fn get_managed_placement_view(
            &self,
            request: tonic::Request<super::GetManagedPlacementViewRequest>,
        ) -> Result<tonic::Response<super::super::resources::ManagedPlacementView>, tonic::Status>;
    }
    #[doc = " Service to manage Managed Placement views."]
    #[derive(Debug)]
    #[doc(hidden)]
    pub struct ManagedPlacementViewServiceServer<T: ManagedPlacementViewService> {
        inner: _Inner<T>,
    }
    struct _Inner<T>(Arc<T>, Option<tonic::Interceptor>);
    impl<T: ManagedPlacementViewService> ManagedPlacementViewServiceServer<T> {
        pub fn new(inner: T) -> Self {
            let inner = Arc::new(inner);
            let inner = _Inner(inner, None);
            Self { inner }
        }
        pub fn with_interceptor(inner: T, interceptor: impl Into<tonic::Interceptor>) -> Self {
            let inner = Arc::new(inner);
            let inner = _Inner(inner, Some(interceptor.into()));
            Self { inner }
        }
    }
    impl<T, B> Service<http::Request<B>> for ManagedPlacementViewServiceServer<T>
    where
        T: ManagedPlacementViewService,
        B: HttpBody + Send + Sync + 'static,
        B::Error: Into<StdError> + Send + 'static,
    {
        type Response = http::Response<tonic::body::BoxBody>;
        type Error = Never;
        type Future = BoxFuture<Self::Response, Self::Error>;
        fn poll_ready(&mut self, _cx: &mut Context<'_>) -> Poll<Result<(), Self::Error>> {
            Poll::Ready(Ok(()))
        }
        fn call(&mut self, req: http::Request<B>) -> Self::Future {
            let inner = self.inner.clone();
            match req . uri ( ) . path ( ) { "/google.ads.googleads.v1.services.ManagedPlacementViewService/GetManagedPlacementView" => { # [ allow ( non_camel_case_types ) ] struct GetManagedPlacementViewSvc < T : ManagedPlacementViewService > ( pub Arc < T > ) ; impl < T : ManagedPlacementViewService > tonic :: server :: UnaryService < super :: GetManagedPlacementViewRequest > for GetManagedPlacementViewSvc < T > { type Response = super :: super :: resources :: ManagedPlacementView ; type Future = BoxFuture < tonic :: Response < Self :: Response > , tonic :: Status > ; fn call ( & mut self , request : tonic :: Request < super :: GetManagedPlacementViewRequest > ) -> Self :: Future { let inner = self . 0 . clone ( ) ; let fut = async move { inner . get_managed_placement_view ( request ) . await } ; Box :: pin ( fut ) } } let inner = self . inner . clone ( ) ; let fut = async move { let interceptor = inner . 1 . clone ( ) ; let inner = inner . 0 ; let method = GetManagedPlacementViewSvc ( inner ) ; let codec = tonic :: codec :: ProstCodec :: default ( ) ; let mut grpc = if let Some ( interceptor ) = interceptor { tonic :: server :: Grpc :: with_interceptor ( codec , interceptor ) } else { tonic :: server :: Grpc :: new ( codec ) } ; let res = grpc . unary ( method , req ) . await ; Ok ( res ) } ; Box :: pin ( fut ) } _ => Box :: pin ( async move { Ok ( http :: Response :: builder ( ) . status ( 200 ) . header ( "grpc-status" , "12" ) . body ( tonic :: body :: BoxBody :: empty ( ) ) . unwrap ( ) ) } ) , }
        }
    }
    impl<T: ManagedPlacementViewService> Clone for ManagedPlacementViewServiceServer<T> {
        fn clone(&self) -> Self {
            let inner = self.inner.clone();
            Self { inner }
        }
    }
    impl<T: ManagedPlacementViewService> Clone for _Inner<T> {
        fn clone(&self) -> Self {
            Self(self.0.clone(), self.1.clone())
        }
    }
    impl<T: std::fmt::Debug> std::fmt::Debug for _Inner<T> {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
            write!(f, "{:?}", self.0)
        }
    }
    impl<T: ManagedPlacementViewService> tonic::transport::NamedService
        for ManagedPlacementViewServiceServer<T>
    {
        const NAME: &'static str = "google.ads.googleads.v1.services.ManagedPlacementViewService";
    }
}
/// Request message for [MerchantCenterLinkService.ListMerchantCenterLinks][google.ads.googleads.v1.services.MerchantCenterLinkService.ListMerchantCenterLinks].
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ListMerchantCenterLinksRequest {
    /// Required. The ID of the customer onto which to apply the Merchant Center link list
    /// operation.
    #[prost(string, tag = "1")]
    pub customer_id: std::string::String,
}
/// Response message for [MerchantCenterLinkService.ListMerchantCenterLinks][google.ads.googleads.v1.services.MerchantCenterLinkService.ListMerchantCenterLinks].
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ListMerchantCenterLinksResponse {
    /// Merchant Center links available for the requested customer
    #[prost(message, repeated, tag = "1")]
    pub merchant_center_links: ::std::vec::Vec<super::resources::MerchantCenterLink>,
}
/// Request message for [MerchantCenterLinkService.GetMerchantCenterLink][google.ads.googleads.v1.services.MerchantCenterLinkService.GetMerchantCenterLink].
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GetMerchantCenterLinkRequest {
    /// Required. Resource name of the Merchant Center link.
    #[prost(string, tag = "1")]
    pub resource_name: std::string::String,
}
/// Request message for [MerchantCenterLinkService.MutateMerchantCenterLink][google.ads.googleads.v1.services.MerchantCenterLinkService.MutateMerchantCenterLink].
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct MutateMerchantCenterLinkRequest {
    /// Required. The ID of the customer being modified.
    #[prost(string, tag = "1")]
    pub customer_id: std::string::String,
    /// Required. The operation to perform on the link
    #[prost(message, optional, tag = "2")]
    pub operation: ::std::option::Option<MerchantCenterLinkOperation>,
}
/// A single update on a Merchant Center link.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct MerchantCenterLinkOperation {
    /// FieldMask that determines which resource fields are modified in an update.
    #[prost(message, optional, tag = "3")]
    pub update_mask: ::std::option::Option<::prost_types::FieldMask>,
    /// The operation to perform
    #[prost(oneof = "merchant_center_link_operation::Operation", tags = "1, 2")]
    pub operation: ::std::option::Option<merchant_center_link_operation::Operation>,
}
pub mod merchant_center_link_operation {
    /// The operation to perform
    #[derive(Clone, PartialEq, ::prost::Oneof)]
    pub enum Operation {
        /// Update operation: The merchant center link is expected to have a valid
        /// resource name.
        #[prost(message, tag = "1")]
        Update(super::super::resources::MerchantCenterLink),
        /// Remove operation: A resource name for the removed merchant center link is
        /// expected, in this format:
        ///
        /// `customers/{customer_id}/merchantCenterLinks/{merchant_center_id}`
        #[prost(string, tag = "2")]
        Remove(std::string::String),
    }
}
/// Response message for Merchant Center link mutate.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct MutateMerchantCenterLinkResponse {
    /// Result for the mutate.
    #[prost(message, optional, tag = "2")]
    pub result: ::std::option::Option<MutateMerchantCenterLinkResult>,
}
/// The result for the Merchant Center link mutate.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct MutateMerchantCenterLinkResult {
    /// Returned for successful operations.
    #[prost(string, tag = "1")]
    pub resource_name: std::string::String,
}
#[doc = r" Generated client implementations."]
pub mod merchant_center_link_service_client {
    #![allow(unused_variables, dead_code, missing_docs)]
    use tonic::codegen::*;
    #[doc = " This service allows management of links between Google Ads and Google"]
    #[doc = " Merchant Center."]
    pub struct MerchantCenterLinkServiceClient<T> {
        inner: tonic::client::Grpc<T>,
    }
    impl MerchantCenterLinkServiceClient<tonic::transport::Channel> {
        #[doc = r" Attempt to create a new client by connecting to a given endpoint."]
        pub async fn connect<D>(dst: D) -> Result<Self, tonic::transport::Error>
        where
            D: std::convert::TryInto<tonic::transport::Endpoint>,
            D::Error: Into<StdError>,
        {
            let conn = tonic::transport::Endpoint::new(dst)?.connect().await?;
            Ok(Self::new(conn))
        }
    }
    impl<T> MerchantCenterLinkServiceClient<T>
    where
        T: tonic::client::GrpcService<tonic::body::BoxBody>,
        T::ResponseBody: Body + HttpBody + Send + 'static,
        T::Error: Into<StdError>,
        <T::ResponseBody as HttpBody>::Error: Into<StdError> + Send,
    {
        pub fn new(inner: T) -> Self {
            let inner = tonic::client::Grpc::new(inner);
            Self { inner }
        }
        pub fn with_interceptor(inner: T, interceptor: impl Into<tonic::Interceptor>) -> Self {
            let inner = tonic::client::Grpc::with_interceptor(inner, interceptor);
            Self { inner }
        }
        #[doc = " Returns Merchant Center links available for this customer."]
        pub async fn list_merchant_center_links(
            &mut self,
            request: impl tonic::IntoRequest<super::ListMerchantCenterLinksRequest>,
        ) -> Result<tonic::Response<super::ListMerchantCenterLinksResponse>, tonic::Status>
        {
            self.inner.ready().await.map_err(|e| {
                tonic::Status::new(
                    tonic::Code::Unknown,
                    format!("Service was not ready: {}", e.into()),
                )
            })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http :: uri :: PathAndQuery :: from_static ( "/google.ads.googleads.v1.services.MerchantCenterLinkService/ListMerchantCenterLinks" ) ;
            self.inner.unary(request.into_request(), path, codec).await
        }
        #[doc = " Returns the Merchant Center link in full detail."]
        pub async fn get_merchant_center_link(
            &mut self,
            request: impl tonic::IntoRequest<super::GetMerchantCenterLinkRequest>,
        ) -> Result<tonic::Response<super::super::resources::MerchantCenterLink>, tonic::Status>
        {
            self.inner.ready().await.map_err(|e| {
                tonic::Status::new(
                    tonic::Code::Unknown,
                    format!("Service was not ready: {}", e.into()),
                )
            })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.ads.googleads.v1.services.MerchantCenterLinkService/GetMerchantCenterLink",
            );
            self.inner.unary(request.into_request(), path, codec).await
        }
        #[doc = " Updates status or removes a Merchant Center link."]
        pub async fn mutate_merchant_center_link(
            &mut self,
            request: impl tonic::IntoRequest<super::MutateMerchantCenterLinkRequest>,
        ) -> Result<tonic::Response<super::MutateMerchantCenterLinkResponse>, tonic::Status>
        {
            self.inner.ready().await.map_err(|e| {
                tonic::Status::new(
                    tonic::Code::Unknown,
                    format!("Service was not ready: {}", e.into()),
                )
            })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http :: uri :: PathAndQuery :: from_static ( "/google.ads.googleads.v1.services.MerchantCenterLinkService/MutateMerchantCenterLink" ) ;
            self.inner.unary(request.into_request(), path, codec).await
        }
    }
    impl<T: Clone> Clone for MerchantCenterLinkServiceClient<T> {
        fn clone(&self) -> Self {
            Self {
                inner: self.inner.clone(),
            }
        }
    }
    impl<T> std::fmt::Debug for MerchantCenterLinkServiceClient<T> {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
            write!(f, "MerchantCenterLinkServiceClient {{ ... }}")
        }
    }
}
#[doc = r" Generated server implementations."]
pub mod merchant_center_link_service_server {
    #![allow(unused_variables, dead_code, missing_docs)]
    use tonic::codegen::*;
    #[doc = "Generated trait containing gRPC methods that should be implemented for use with MerchantCenterLinkServiceServer."]
    #[async_trait]
    pub trait MerchantCenterLinkService: Send + Sync + 'static {
        #[doc = " Returns Merchant Center links available for this customer."]
        async fn list_merchant_center_links(
            &self,
            request: tonic::Request<super::ListMerchantCenterLinksRequest>,
        ) -> Result<tonic::Response<super::ListMerchantCenterLinksResponse>, tonic::Status>;
        #[doc = " Returns the Merchant Center link in full detail."]
        async fn get_merchant_center_link(
            &self,
            request: tonic::Request<super::GetMerchantCenterLinkRequest>,
        ) -> Result<tonic::Response<super::super::resources::MerchantCenterLink>, tonic::Status>;
        #[doc = " Updates status or removes a Merchant Center link."]
        async fn mutate_merchant_center_link(
            &self,
            request: tonic::Request<super::MutateMerchantCenterLinkRequest>,
        ) -> Result<tonic::Response<super::MutateMerchantCenterLinkResponse>, tonic::Status>;
    }
    #[doc = " This service allows management of links between Google Ads and Google"]
    #[doc = " Merchant Center."]
    #[derive(Debug)]
    #[doc(hidden)]
    pub struct MerchantCenterLinkServiceServer<T: MerchantCenterLinkService> {
        inner: _Inner<T>,
    }
    struct _Inner<T>(Arc<T>, Option<tonic::Interceptor>);
    impl<T: MerchantCenterLinkService> MerchantCenterLinkServiceServer<T> {
        pub fn new(inner: T) -> Self {
            let inner = Arc::new(inner);
            let inner = _Inner(inner, None);
            Self { inner }
        }
        pub fn with_interceptor(inner: T, interceptor: impl Into<tonic::Interceptor>) -> Self {
            let inner = Arc::new(inner);
            let inner = _Inner(inner, Some(interceptor.into()));
            Self { inner }
        }
    }
    impl<T, B> Service<http::Request<B>> for MerchantCenterLinkServiceServer<T>
    where
        T: MerchantCenterLinkService,
        B: HttpBody + Send + Sync + 'static,
        B::Error: Into<StdError> + Send + 'static,
    {
        type Response = http::Response<tonic::body::BoxBody>;
        type Error = Never;
        type Future = BoxFuture<Self::Response, Self::Error>;
        fn poll_ready(&mut self, _cx: &mut Context<'_>) -> Poll<Result<(), Self::Error>> {
            Poll::Ready(Ok(()))
        }
        fn call(&mut self, req: http::Request<B>) -> Self::Future {
            let inner = self.inner.clone();
            match req . uri ( ) . path ( ) { "/google.ads.googleads.v1.services.MerchantCenterLinkService/ListMerchantCenterLinks" => { # [ allow ( non_camel_case_types ) ] struct ListMerchantCenterLinksSvc < T : MerchantCenterLinkService > ( pub Arc < T > ) ; impl < T : MerchantCenterLinkService > tonic :: server :: UnaryService < super :: ListMerchantCenterLinksRequest > for ListMerchantCenterLinksSvc < T > { type Response = super :: ListMerchantCenterLinksResponse ; type Future = BoxFuture < tonic :: Response < Self :: Response > , tonic :: Status > ; fn call ( & mut self , request : tonic :: Request < super :: ListMerchantCenterLinksRequest > ) -> Self :: Future { let inner = self . 0 . clone ( ) ; let fut = async move { inner . list_merchant_center_links ( request ) . await } ; Box :: pin ( fut ) } } let inner = self . inner . clone ( ) ; let fut = async move { let interceptor = inner . 1 . clone ( ) ; let inner = inner . 0 ; let method = ListMerchantCenterLinksSvc ( inner ) ; let codec = tonic :: codec :: ProstCodec :: default ( ) ; let mut grpc = if let Some ( interceptor ) = interceptor { tonic :: server :: Grpc :: with_interceptor ( codec , interceptor ) } else { tonic :: server :: Grpc :: new ( codec ) } ; let res = grpc . unary ( method , req ) . await ; Ok ( res ) } ; Box :: pin ( fut ) } "/google.ads.googleads.v1.services.MerchantCenterLinkService/GetMerchantCenterLink" => { # [ allow ( non_camel_case_types ) ] struct GetMerchantCenterLinkSvc < T : MerchantCenterLinkService > ( pub Arc < T > ) ; impl < T : MerchantCenterLinkService > tonic :: server :: UnaryService < super :: GetMerchantCenterLinkRequest > for GetMerchantCenterLinkSvc < T > { type Response = super :: super :: resources :: MerchantCenterLink ; type Future = BoxFuture < tonic :: Response < Self :: Response > , tonic :: Status > ; fn call ( & mut self , request : tonic :: Request < super :: GetMerchantCenterLinkRequest > ) -> Self :: Future { let inner = self . 0 . clone ( ) ; let fut = async move { inner . get_merchant_center_link ( request ) . await } ; Box :: pin ( fut ) } } let inner = self . inner . clone ( ) ; let fut = async move { let interceptor = inner . 1 . clone ( ) ; let inner = inner . 0 ; let method = GetMerchantCenterLinkSvc ( inner ) ; let codec = tonic :: codec :: ProstCodec :: default ( ) ; let mut grpc = if let Some ( interceptor ) = interceptor { tonic :: server :: Grpc :: with_interceptor ( codec , interceptor ) } else { tonic :: server :: Grpc :: new ( codec ) } ; let res = grpc . unary ( method , req ) . await ; Ok ( res ) } ; Box :: pin ( fut ) } "/google.ads.googleads.v1.services.MerchantCenterLinkService/MutateMerchantCenterLink" => { # [ allow ( non_camel_case_types ) ] struct MutateMerchantCenterLinkSvc < T : MerchantCenterLinkService > ( pub Arc < T > ) ; impl < T : MerchantCenterLinkService > tonic :: server :: UnaryService < super :: MutateMerchantCenterLinkRequest > for MutateMerchantCenterLinkSvc < T > { type Response = super :: MutateMerchantCenterLinkResponse ; type Future = BoxFuture < tonic :: Response < Self :: Response > , tonic :: Status > ; fn call ( & mut self , request : tonic :: Request < super :: MutateMerchantCenterLinkRequest > ) -> Self :: Future { let inner = self . 0 . clone ( ) ; let fut = async move { inner . mutate_merchant_center_link ( request ) . await } ; Box :: pin ( fut ) } } let inner = self . inner . clone ( ) ; let fut = async move { let interceptor = inner . 1 . clone ( ) ; let inner = inner . 0 ; let method = MutateMerchantCenterLinkSvc ( inner ) ; let codec = tonic :: codec :: ProstCodec :: default ( ) ; let mut grpc = if let Some ( interceptor ) = interceptor { tonic :: server :: Grpc :: with_interceptor ( codec , interceptor ) } else { tonic :: server :: Grpc :: new ( codec ) } ; let res = grpc . unary ( method , req ) . await ; Ok ( res ) } ; Box :: pin ( fut ) } _ => Box :: pin ( async move { Ok ( http :: Response :: builder ( ) . status ( 200 ) . header ( "grpc-status" , "12" ) . body ( tonic :: body :: BoxBody :: empty ( ) ) . unwrap ( ) ) } ) , }
        }
    }
    impl<T: MerchantCenterLinkService> Clone for MerchantCenterLinkServiceServer<T> {
        fn clone(&self) -> Self {
            let inner = self.inner.clone();
            Self { inner }
        }
    }
    impl<T: MerchantCenterLinkService> Clone for _Inner<T> {
        fn clone(&self) -> Self {
            Self(self.0.clone(), self.1.clone())
        }
    }
    impl<T: std::fmt::Debug> std::fmt::Debug for _Inner<T> {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
            write!(f, "{:?}", self.0)
        }
    }
    impl<T: MerchantCenterLinkService> tonic::transport::NamedService
        for MerchantCenterLinkServiceServer<T>
    {
        const NAME: &'static str = "google.ads.googleads.v1.services.MerchantCenterLinkService";
    }
}
/// Request message for
/// [MobileAppCategoryConstantService.GetMobileAppCategoryConstant][google.ads.googleads.v1.services.MobileAppCategoryConstantService.GetMobileAppCategoryConstant].
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GetMobileAppCategoryConstantRequest {
    /// Required. Resource name of the mobile app category constant to fetch.
    #[prost(string, tag = "1")]
    pub resource_name: std::string::String,
}
#[doc = r" Generated client implementations."]
pub mod mobile_app_category_constant_service_client {
    #![allow(unused_variables, dead_code, missing_docs)]
    use tonic::codegen::*;
    #[doc = " Service to fetch mobile app category constants."]
    pub struct MobileAppCategoryConstantServiceClient<T> {
        inner: tonic::client::Grpc<T>,
    }
    impl MobileAppCategoryConstantServiceClient<tonic::transport::Channel> {
        #[doc = r" Attempt to create a new client by connecting to a given endpoint."]
        pub async fn connect<D>(dst: D) -> Result<Self, tonic::transport::Error>
        where
            D: std::convert::TryInto<tonic::transport::Endpoint>,
            D::Error: Into<StdError>,
        {
            let conn = tonic::transport::Endpoint::new(dst)?.connect().await?;
            Ok(Self::new(conn))
        }
    }
    impl<T> MobileAppCategoryConstantServiceClient<T>
    where
        T: tonic::client::GrpcService<tonic::body::BoxBody>,
        T::ResponseBody: Body + HttpBody + Send + 'static,
        T::Error: Into<StdError>,
        <T::ResponseBody as HttpBody>::Error: Into<StdError> + Send,
    {
        pub fn new(inner: T) -> Self {
            let inner = tonic::client::Grpc::new(inner);
            Self { inner }
        }
        pub fn with_interceptor(inner: T, interceptor: impl Into<tonic::Interceptor>) -> Self {
            let inner = tonic::client::Grpc::with_interceptor(inner, interceptor);
            Self { inner }
        }
        #[doc = " Returns the requested mobile app category constant."]
        pub async fn get_mobile_app_category_constant(
            &mut self,
            request: impl tonic::IntoRequest<super::GetMobileAppCategoryConstantRequest>,
        ) -> Result<
            tonic::Response<super::super::resources::MobileAppCategoryConstant>,
            tonic::Status,
        > {
            self.inner.ready().await.map_err(|e| {
                tonic::Status::new(
                    tonic::Code::Unknown,
                    format!("Service was not ready: {}", e.into()),
                )
            })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http :: uri :: PathAndQuery :: from_static ( "/google.ads.googleads.v1.services.MobileAppCategoryConstantService/GetMobileAppCategoryConstant" ) ;
            self.inner.unary(request.into_request(), path, codec).await
        }
    }
    impl<T: Clone> Clone for MobileAppCategoryConstantServiceClient<T> {
        fn clone(&self) -> Self {
            Self {
                inner: self.inner.clone(),
            }
        }
    }
    impl<T> std::fmt::Debug for MobileAppCategoryConstantServiceClient<T> {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
            write!(f, "MobileAppCategoryConstantServiceClient {{ ... }}")
        }
    }
}
#[doc = r" Generated server implementations."]
pub mod mobile_app_category_constant_service_server {
    #![allow(unused_variables, dead_code, missing_docs)]
    use tonic::codegen::*;
    #[doc = "Generated trait containing gRPC methods that should be implemented for use with MobileAppCategoryConstantServiceServer."]
    #[async_trait]
    pub trait MobileAppCategoryConstantService: Send + Sync + 'static {
        #[doc = " Returns the requested mobile app category constant."]
        async fn get_mobile_app_category_constant(
            &self,
            request: tonic::Request<super::GetMobileAppCategoryConstantRequest>,
        ) -> Result<
            tonic::Response<super::super::resources::MobileAppCategoryConstant>,
            tonic::Status,
        >;
    }
    #[doc = " Service to fetch mobile app category constants."]
    #[derive(Debug)]
    #[doc(hidden)]
    pub struct MobileAppCategoryConstantServiceServer<T: MobileAppCategoryConstantService> {
        inner: _Inner<T>,
    }
    struct _Inner<T>(Arc<T>, Option<tonic::Interceptor>);
    impl<T: MobileAppCategoryConstantService> MobileAppCategoryConstantServiceServer<T> {
        pub fn new(inner: T) -> Self {
            let inner = Arc::new(inner);
            let inner = _Inner(inner, None);
            Self { inner }
        }
        pub fn with_interceptor(inner: T, interceptor: impl Into<tonic::Interceptor>) -> Self {
            let inner = Arc::new(inner);
            let inner = _Inner(inner, Some(interceptor.into()));
            Self { inner }
        }
    }
    impl<T, B> Service<http::Request<B>> for MobileAppCategoryConstantServiceServer<T>
    where
        T: MobileAppCategoryConstantService,
        B: HttpBody + Send + Sync + 'static,
        B::Error: Into<StdError> + Send + 'static,
    {
        type Response = http::Response<tonic::body::BoxBody>;
        type Error = Never;
        type Future = BoxFuture<Self::Response, Self::Error>;
        fn poll_ready(&mut self, _cx: &mut Context<'_>) -> Poll<Result<(), Self::Error>> {
            Poll::Ready(Ok(()))
        }
        fn call(&mut self, req: http::Request<B>) -> Self::Future {
            let inner = self.inner.clone();
            match req . uri ( ) . path ( ) { "/google.ads.googleads.v1.services.MobileAppCategoryConstantService/GetMobileAppCategoryConstant" => { # [ allow ( non_camel_case_types ) ] struct GetMobileAppCategoryConstantSvc < T : MobileAppCategoryConstantService > ( pub Arc < T > ) ; impl < T : MobileAppCategoryConstantService > tonic :: server :: UnaryService < super :: GetMobileAppCategoryConstantRequest > for GetMobileAppCategoryConstantSvc < T > { type Response = super :: super :: resources :: MobileAppCategoryConstant ; type Future = BoxFuture < tonic :: Response < Self :: Response > , tonic :: Status > ; fn call ( & mut self , request : tonic :: Request < super :: GetMobileAppCategoryConstantRequest > ) -> Self :: Future { let inner = self . 0 . clone ( ) ; let fut = async move { inner . get_mobile_app_category_constant ( request ) . await } ; Box :: pin ( fut ) } } let inner = self . inner . clone ( ) ; let fut = async move { let interceptor = inner . 1 . clone ( ) ; let inner = inner . 0 ; let method = GetMobileAppCategoryConstantSvc ( inner ) ; let codec = tonic :: codec :: ProstCodec :: default ( ) ; let mut grpc = if let Some ( interceptor ) = interceptor { tonic :: server :: Grpc :: with_interceptor ( codec , interceptor ) } else { tonic :: server :: Grpc :: new ( codec ) } ; let res = grpc . unary ( method , req ) . await ; Ok ( res ) } ; Box :: pin ( fut ) } _ => Box :: pin ( async move { Ok ( http :: Response :: builder ( ) . status ( 200 ) . header ( "grpc-status" , "12" ) . body ( tonic :: body :: BoxBody :: empty ( ) ) . unwrap ( ) ) } ) , }
        }
    }
    impl<T: MobileAppCategoryConstantService> Clone for MobileAppCategoryConstantServiceServer<T> {
        fn clone(&self) -> Self {
            let inner = self.inner.clone();
            Self { inner }
        }
    }
    impl<T: MobileAppCategoryConstantService> Clone for _Inner<T> {
        fn clone(&self) -> Self {
            Self(self.0.clone(), self.1.clone())
        }
    }
    impl<T: std::fmt::Debug> std::fmt::Debug for _Inner<T> {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
            write!(f, "{:?}", self.0)
        }
    }
    impl<T: MobileAppCategoryConstantService> tonic::transport::NamedService
        for MobileAppCategoryConstantServiceServer<T>
    {
        const NAME: &'static str =
            "google.ads.googleads.v1.services.MobileAppCategoryConstantService";
    }
}
/// Request message for [MobileDeviceConstantService.GetMobileDeviceConstant][google.ads.googleads.v1.services.MobileDeviceConstantService.GetMobileDeviceConstant].
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GetMobileDeviceConstantRequest {
    /// Required. Resource name of the mobile device to fetch.
    #[prost(string, tag = "1")]
    pub resource_name: std::string::String,
}
#[doc = r" Generated client implementations."]
pub mod mobile_device_constant_service_client {
    #![allow(unused_variables, dead_code, missing_docs)]
    use tonic::codegen::*;
    #[doc = " Service to fetch mobile device constants."]
    pub struct MobileDeviceConstantServiceClient<T> {
        inner: tonic::client::Grpc<T>,
    }
    impl MobileDeviceConstantServiceClient<tonic::transport::Channel> {
        #[doc = r" Attempt to create a new client by connecting to a given endpoint."]
        pub async fn connect<D>(dst: D) -> Result<Self, tonic::transport::Error>
        where
            D: std::convert::TryInto<tonic::transport::Endpoint>,
            D::Error: Into<StdError>,
        {
            let conn = tonic::transport::Endpoint::new(dst)?.connect().await?;
            Ok(Self::new(conn))
        }
    }
    impl<T> MobileDeviceConstantServiceClient<T>
    where
        T: tonic::client::GrpcService<tonic::body::BoxBody>,
        T::ResponseBody: Body + HttpBody + Send + 'static,
        T::Error: Into<StdError>,
        <T::ResponseBody as HttpBody>::Error: Into<StdError> + Send,
    {
        pub fn new(inner: T) -> Self {
            let inner = tonic::client::Grpc::new(inner);
            Self { inner }
        }
        pub fn with_interceptor(inner: T, interceptor: impl Into<tonic::Interceptor>) -> Self {
            let inner = tonic::client::Grpc::with_interceptor(inner, interceptor);
            Self { inner }
        }
        #[doc = " Returns the requested mobile device constant in full detail."]
        pub async fn get_mobile_device_constant(
            &mut self,
            request: impl tonic::IntoRequest<super::GetMobileDeviceConstantRequest>,
        ) -> Result<tonic::Response<super::super::resources::MobileDeviceConstant>, tonic::Status>
        {
            self.inner.ready().await.map_err(|e| {
                tonic::Status::new(
                    tonic::Code::Unknown,
                    format!("Service was not ready: {}", e.into()),
                )
            })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http :: uri :: PathAndQuery :: from_static ( "/google.ads.googleads.v1.services.MobileDeviceConstantService/GetMobileDeviceConstant" ) ;
            self.inner.unary(request.into_request(), path, codec).await
        }
    }
    impl<T: Clone> Clone for MobileDeviceConstantServiceClient<T> {
        fn clone(&self) -> Self {
            Self {
                inner: self.inner.clone(),
            }
        }
    }
    impl<T> std::fmt::Debug for MobileDeviceConstantServiceClient<T> {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
            write!(f, "MobileDeviceConstantServiceClient {{ ... }}")
        }
    }
}
#[doc = r" Generated server implementations."]
pub mod mobile_device_constant_service_server {
    #![allow(unused_variables, dead_code, missing_docs)]
    use tonic::codegen::*;
    #[doc = "Generated trait containing gRPC methods that should be implemented for use with MobileDeviceConstantServiceServer."]
    #[async_trait]
    pub trait MobileDeviceConstantService: Send + Sync + 'static {
        #[doc = " Returns the requested mobile device constant in full detail."]
        async fn get_mobile_device_constant(
            &self,
            request: tonic::Request<super::GetMobileDeviceConstantRequest>,
        ) -> Result<tonic::Response<super::super::resources::MobileDeviceConstant>, tonic::Status>;
    }
    #[doc = " Service to fetch mobile device constants."]
    #[derive(Debug)]
    #[doc(hidden)]
    pub struct MobileDeviceConstantServiceServer<T: MobileDeviceConstantService> {
        inner: _Inner<T>,
    }
    struct _Inner<T>(Arc<T>, Option<tonic::Interceptor>);
    impl<T: MobileDeviceConstantService> MobileDeviceConstantServiceServer<T> {
        pub fn new(inner: T) -> Self {
            let inner = Arc::new(inner);
            let inner = _Inner(inner, None);
            Self { inner }
        }
        pub fn with_interceptor(inner: T, interceptor: impl Into<tonic::Interceptor>) -> Self {
            let inner = Arc::new(inner);
            let inner = _Inner(inner, Some(interceptor.into()));
            Self { inner }
        }
    }
    impl<T, B> Service<http::Request<B>> for MobileDeviceConstantServiceServer<T>
    where
        T: MobileDeviceConstantService,
        B: HttpBody + Send + Sync + 'static,
        B::Error: Into<StdError> + Send + 'static,
    {
        type Response = http::Response<tonic::body::BoxBody>;
        type Error = Never;
        type Future = BoxFuture<Self::Response, Self::Error>;
        fn poll_ready(&mut self, _cx: &mut Context<'_>) -> Poll<Result<(), Self::Error>> {
            Poll::Ready(Ok(()))
        }
        fn call(&mut self, req: http::Request<B>) -> Self::Future {
            let inner = self.inner.clone();
            match req . uri ( ) . path ( ) { "/google.ads.googleads.v1.services.MobileDeviceConstantService/GetMobileDeviceConstant" => { # [ allow ( non_camel_case_types ) ] struct GetMobileDeviceConstantSvc < T : MobileDeviceConstantService > ( pub Arc < T > ) ; impl < T : MobileDeviceConstantService > tonic :: server :: UnaryService < super :: GetMobileDeviceConstantRequest > for GetMobileDeviceConstantSvc < T > { type Response = super :: super :: resources :: MobileDeviceConstant ; type Future = BoxFuture < tonic :: Response < Self :: Response > , tonic :: Status > ; fn call ( & mut self , request : tonic :: Request < super :: GetMobileDeviceConstantRequest > ) -> Self :: Future { let inner = self . 0 . clone ( ) ; let fut = async move { inner . get_mobile_device_constant ( request ) . await } ; Box :: pin ( fut ) } } let inner = self . inner . clone ( ) ; let fut = async move { let interceptor = inner . 1 . clone ( ) ; let inner = inner . 0 ; let method = GetMobileDeviceConstantSvc ( inner ) ; let codec = tonic :: codec :: ProstCodec :: default ( ) ; let mut grpc = if let Some ( interceptor ) = interceptor { tonic :: server :: Grpc :: with_interceptor ( codec , interceptor ) } else { tonic :: server :: Grpc :: new ( codec ) } ; let res = grpc . unary ( method , req ) . await ; Ok ( res ) } ; Box :: pin ( fut ) } _ => Box :: pin ( async move { Ok ( http :: Response :: builder ( ) . status ( 200 ) . header ( "grpc-status" , "12" ) . body ( tonic :: body :: BoxBody :: empty ( ) ) . unwrap ( ) ) } ) , }
        }
    }
    impl<T: MobileDeviceConstantService> Clone for MobileDeviceConstantServiceServer<T> {
        fn clone(&self) -> Self {
            let inner = self.inner.clone();
            Self { inner }
        }
    }
    impl<T: MobileDeviceConstantService> Clone for _Inner<T> {
        fn clone(&self) -> Self {
            Self(self.0.clone(), self.1.clone())
        }
    }
    impl<T: std::fmt::Debug> std::fmt::Debug for _Inner<T> {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
            write!(f, "{:?}", self.0)
        }
    }
    impl<T: MobileDeviceConstantService> tonic::transport::NamedService
        for MobileDeviceConstantServiceServer<T>
    {
        const NAME: &'static str = "google.ads.googleads.v1.services.MobileDeviceConstantService";
    }
}
/// Request message for [MutateJobService.CreateMutateJobRequest][]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CreateMutateJobRequest {
    /// Required. The ID of the customer for which to create a mutate job.
    #[prost(string, tag = "1")]
    pub customer_id: std::string::String,
}
/// Response message for [MutateJobService.CreateMutateJobResponse][]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CreateMutateJobResponse {
    /// The resource name of the MutateJob.
    #[prost(string, tag = "1")]
    pub resource_name: std::string::String,
}
/// Request message for [MutateJobService.GetMutateJob][google.ads.googleads.v1.services.MutateJobService.GetMutateJob]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GetMutateJobRequest {
    /// Required. The resource name of the MutateJob to get.
    #[prost(string, tag = "1")]
    pub resource_name: std::string::String,
}
/// Request message for [MutateJobService.RunMutateJob][google.ads.googleads.v1.services.MutateJobService.RunMutateJob]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct RunMutateJobRequest {
    /// Required. The resource name of the MutateJob to run.
    #[prost(string, tag = "1")]
    pub resource_name: std::string::String,
}
/// Request message for [MutateJobService.AddMutateJobOperations][google.ads.googleads.v1.services.MutateJobService.AddMutateJobOperations]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct AddMutateJobOperationsRequest {
    /// Required. The resource name of the MutateJob.
    #[prost(string, tag = "1")]
    pub resource_name: std::string::String,
    /// A token used to enforce sequencing.
    ///
    /// The first AddMutateJobOperations request for a MutateJob should not set
    /// sequence_token. Subsequent requests must set sequence_token to the value of
    /// next_sequence_token received in the previous AddMutateJobOperations
    /// response.
    #[prost(string, tag = "2")]
    pub sequence_token: std::string::String,
    /// Required. The list of mutates being added.
    ///
    /// Operations can use negative integers as temp ids to signify dependencies
    /// between entities created in this MutateJob. For example, a customer with
    /// id = 1234 can create a campaign and an ad group in that same campaign by
    /// creating a campaign in the first operation with the resource name
    /// explicitly set to "customers/1234/campaigns/-1", and creating an ad group
    /// in the second operation with the campaign field also set to
    /// "customers/1234/campaigns/-1".
    #[prost(message, repeated, tag = "3")]
    pub mutate_operations: ::std::vec::Vec<MutateOperation>,
}
/// Response message for [MutateJobService.AddMutateJobOperations][google.ads.googleads.v1.services.MutateJobService.AddMutateJobOperations]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct AddMutateJobOperationsResponse {
    /// The total number of operations added so far for this job.
    #[prost(int64, tag = "1")]
    pub total_operations: i64,
    /// The sequence token to be used when calling AddMutateJobOperations again if
    /// more operations need to be added. The next AddMutateJobOperations request
    /// must set the sequence_token field to the value of this field.
    #[prost(string, tag = "2")]
    pub next_sequence_token: std::string::String,
}
/// Request message for [MutateJobService.ListMutateJobResults][google.ads.googleads.v1.services.MutateJobService.ListMutateJobResults].
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ListMutateJobResultsRequest {
    /// Required. The resource name of the MutateJob whose results are being listed.
    #[prost(string, tag = "1")]
    pub resource_name: std::string::String,
    /// Token of the page to retrieve. If not specified, the first
    /// page of results will be returned. Use the value obtained from
    /// `next_page_token` in the previous response in order to request
    /// the next page of results.
    #[prost(string, tag = "2")]
    pub page_token: std::string::String,
    /// Number of elements to retrieve in a single page.
    /// When a page request is too large, the server may decide to
    /// further limit the number of returned resources.
    #[prost(int32, tag = "3")]
    pub page_size: i32,
}
/// Response message for [MutateJobService.ListMutateJobResults][google.ads.googleads.v1.services.MutateJobService.ListMutateJobResults].
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ListMutateJobResultsResponse {
    /// The list of rows that matched the query.
    #[prost(message, repeated, tag = "1")]
    pub results: ::std::vec::Vec<MutateJobResult>,
    /// Pagination token used to retrieve the next page of results.
    /// Pass the content of this string as the `page_token` attribute of
    /// the next request. `next_page_token` is not returned for the last
    /// page.
    #[prost(string, tag = "2")]
    pub next_page_token: std::string::String,
}
/// MutateJob result.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct MutateJobResult {
    /// Index of the mutate operation.
    #[prost(int64, tag = "1")]
    pub operation_index: i64,
    /// Response for the mutate.
    /// May be empty if errors occurred.
    #[prost(message, optional, tag = "2")]
    pub mutate_operation_response: ::std::option::Option<MutateOperationResponse>,
    /// Details of the errors when processing the operation.
    #[prost(message, optional, tag = "3")]
    pub status: ::std::option::Option<super::super::super::super::rpc::Status>,
}
#[doc = r" Generated client implementations."]
pub mod mutate_job_service_client {
    #![allow(unused_variables, dead_code, missing_docs)]
    use tonic::codegen::*;
    #[doc = " Service to manage mutate jobs."]
    pub struct MutateJobServiceClient<T> {
        inner: tonic::client::Grpc<T>,
    }
    impl MutateJobServiceClient<tonic::transport::Channel> {
        #[doc = r" Attempt to create a new client by connecting to a given endpoint."]
        pub async fn connect<D>(dst: D) -> Result<Self, tonic::transport::Error>
        where
            D: std::convert::TryInto<tonic::transport::Endpoint>,
            D::Error: Into<StdError>,
        {
            let conn = tonic::transport::Endpoint::new(dst)?.connect().await?;
            Ok(Self::new(conn))
        }
    }
    impl<T> MutateJobServiceClient<T>
    where
        T: tonic::client::GrpcService<tonic::body::BoxBody>,
        T::ResponseBody: Body + HttpBody + Send + 'static,
        T::Error: Into<StdError>,
        <T::ResponseBody as HttpBody>::Error: Into<StdError> + Send,
    {
        pub fn new(inner: T) -> Self {
            let inner = tonic::client::Grpc::new(inner);
            Self { inner }
        }
        pub fn with_interceptor(inner: T, interceptor: impl Into<tonic::Interceptor>) -> Self {
            let inner = tonic::client::Grpc::with_interceptor(inner, interceptor);
            Self { inner }
        }
        #[doc = " Creates a mutate job."]
        pub async fn create_mutate_job(
            &mut self,
            request: impl tonic::IntoRequest<super::CreateMutateJobRequest>,
        ) -> Result<tonic::Response<super::CreateMutateJobResponse>, tonic::Status> {
            self.inner.ready().await.map_err(|e| {
                tonic::Status::new(
                    tonic::Code::Unknown,
                    format!("Service was not ready: {}", e.into()),
                )
            })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.ads.googleads.v1.services.MutateJobService/CreateMutateJob",
            );
            self.inner.unary(request.into_request(), path, codec).await
        }
        #[doc = " Returns the mutate job."]
        pub async fn get_mutate_job(
            &mut self,
            request: impl tonic::IntoRequest<super::GetMutateJobRequest>,
        ) -> Result<tonic::Response<super::super::resources::MutateJob>, tonic::Status> {
            self.inner.ready().await.map_err(|e| {
                tonic::Status::new(
                    tonic::Code::Unknown,
                    format!("Service was not ready: {}", e.into()),
                )
            })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.ads.googleads.v1.services.MutateJobService/GetMutateJob",
            );
            self.inner.unary(request.into_request(), path, codec).await
        }
        #[doc = " Returns the results of the mutate job. The job must be done."]
        #[doc = " Supports standard list paging."]
        pub async fn list_mutate_job_results(
            &mut self,
            request: impl tonic::IntoRequest<super::ListMutateJobResultsRequest>,
        ) -> Result<tonic::Response<super::ListMutateJobResultsResponse>, tonic::Status> {
            self.inner.ready().await.map_err(|e| {
                tonic::Status::new(
                    tonic::Code::Unknown,
                    format!("Service was not ready: {}", e.into()),
                )
            })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.ads.googleads.v1.services.MutateJobService/ListMutateJobResults",
            );
            self.inner.unary(request.into_request(), path, codec).await
        }
        #[doc = " Runs the mutate job."]
        #[doc = ""]
        #[doc = " The Operation.metadata field type is MutateJobMetadata. When finished, the"]
        #[doc = " long running operation will not contain errors or a response. Instead, use"]
        #[doc = " ListMutateJobResults to get the results of the job."]
        pub async fn run_mutate_job(
            &mut self,
            request: impl tonic::IntoRequest<super::RunMutateJobRequest>,
        ) -> Result<
            tonic::Response<super::super::super::super::super::longrunning::Operation>,
            tonic::Status,
        > {
            self.inner.ready().await.map_err(|e| {
                tonic::Status::new(
                    tonic::Code::Unknown,
                    format!("Service was not ready: {}", e.into()),
                )
            })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.ads.googleads.v1.services.MutateJobService/RunMutateJob",
            );
            self.inner.unary(request.into_request(), path, codec).await
        }
        #[doc = " Add operations to the mutate job."]
        pub async fn add_mutate_job_operations(
            &mut self,
            request: impl tonic::IntoRequest<super::AddMutateJobOperationsRequest>,
        ) -> Result<tonic::Response<super::AddMutateJobOperationsResponse>, tonic::Status> {
            self.inner.ready().await.map_err(|e| {
                tonic::Status::new(
                    tonic::Code::Unknown,
                    format!("Service was not ready: {}", e.into()),
                )
            })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.ads.googleads.v1.services.MutateJobService/AddMutateJobOperations",
            );
            self.inner.unary(request.into_request(), path, codec).await
        }
    }
    impl<T: Clone> Clone for MutateJobServiceClient<T> {
        fn clone(&self) -> Self {
            Self {
                inner: self.inner.clone(),
            }
        }
    }
    impl<T> std::fmt::Debug for MutateJobServiceClient<T> {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
            write!(f, "MutateJobServiceClient {{ ... }}")
        }
    }
}
#[doc = r" Generated server implementations."]
pub mod mutate_job_service_server {
    #![allow(unused_variables, dead_code, missing_docs)]
    use tonic::codegen::*;
    #[doc = "Generated trait containing gRPC methods that should be implemented for use with MutateJobServiceServer."]
    #[async_trait]
    pub trait MutateJobService: Send + Sync + 'static {
        #[doc = " Creates a mutate job."]
        async fn create_mutate_job(
            &self,
            request: tonic::Request<super::CreateMutateJobRequest>,
        ) -> Result<tonic::Response<super::CreateMutateJobResponse>, tonic::Status>;
        #[doc = " Returns the mutate job."]
        async fn get_mutate_job(
            &self,
            request: tonic::Request<super::GetMutateJobRequest>,
        ) -> Result<tonic::Response<super::super::resources::MutateJob>, tonic::Status>;
        #[doc = " Returns the results of the mutate job. The job must be done."]
        #[doc = " Supports standard list paging."]
        async fn list_mutate_job_results(
            &self,
            request: tonic::Request<super::ListMutateJobResultsRequest>,
        ) -> Result<tonic::Response<super::ListMutateJobResultsResponse>, tonic::Status>;
        #[doc = " Runs the mutate job."]
        #[doc = ""]
        #[doc = " The Operation.metadata field type is MutateJobMetadata. When finished, the"]
        #[doc = " long running operation will not contain errors or a response. Instead, use"]
        #[doc = " ListMutateJobResults to get the results of the job."]
        async fn run_mutate_job(
            &self,
            request: tonic::Request<super::RunMutateJobRequest>,
        ) -> Result<
            tonic::Response<super::super::super::super::super::longrunning::Operation>,
            tonic::Status,
        >;
        #[doc = " Add operations to the mutate job."]
        async fn add_mutate_job_operations(
            &self,
            request: tonic::Request<super::AddMutateJobOperationsRequest>,
        ) -> Result<tonic::Response<super::AddMutateJobOperationsResponse>, tonic::Status>;
    }
    #[doc = " Service to manage mutate jobs."]
    #[derive(Debug)]
    #[doc(hidden)]
    pub struct MutateJobServiceServer<T: MutateJobService> {
        inner: _Inner<T>,
    }
    struct _Inner<T>(Arc<T>, Option<tonic::Interceptor>);
    impl<T: MutateJobService> MutateJobServiceServer<T> {
        pub fn new(inner: T) -> Self {
            let inner = Arc::new(inner);
            let inner = _Inner(inner, None);
            Self { inner }
        }
        pub fn with_interceptor(inner: T, interceptor: impl Into<tonic::Interceptor>) -> Self {
            let inner = Arc::new(inner);
            let inner = _Inner(inner, Some(interceptor.into()));
            Self { inner }
        }
    }
    impl<T, B> Service<http::Request<B>> for MutateJobServiceServer<T>
    where
        T: MutateJobService,
        B: HttpBody + Send + Sync + 'static,
        B::Error: Into<StdError> + Send + 'static,
    {
        type Response = http::Response<tonic::body::BoxBody>;
        type Error = Never;
        type Future = BoxFuture<Self::Response, Self::Error>;
        fn poll_ready(&mut self, _cx: &mut Context<'_>) -> Poll<Result<(), Self::Error>> {
            Poll::Ready(Ok(()))
        }
        fn call(&mut self, req: http::Request<B>) -> Self::Future {
            let inner = self.inner.clone();
            match req.uri().path() {
                "/google.ads.googleads.v1.services.MutateJobService/CreateMutateJob" => {
                    #[allow(non_camel_case_types)]
                    struct CreateMutateJobSvc<T: MutateJobService>(pub Arc<T>);
                    impl<T: MutateJobService>
                        tonic::server::UnaryService<super::CreateMutateJobRequest>
                        for CreateMutateJobSvc<T>
                    {
                        type Response = super::CreateMutateJobResponse;
                        type Future = BoxFuture<tonic::Response<Self::Response>, tonic::Status>;
                        fn call(
                            &mut self,
                            request: tonic::Request<super::CreateMutateJobRequest>,
                        ) -> Self::Future {
                            let inner = self.0.clone();
                            let fut = async move { inner.create_mutate_job(request).await };
                            Box::pin(fut)
                        }
                    }
                    let inner = self.inner.clone();
                    let fut = async move {
                        let interceptor = inner.1.clone();
                        let inner = inner.0;
                        let method = CreateMutateJobSvc(inner);
                        let codec = tonic::codec::ProstCodec::default();
                        let mut grpc = if let Some(interceptor) = interceptor {
                            tonic::server::Grpc::with_interceptor(codec, interceptor)
                        } else {
                            tonic::server::Grpc::new(codec)
                        };
                        let res = grpc.unary(method, req).await;
                        Ok(res)
                    };
                    Box::pin(fut)
                }
                "/google.ads.googleads.v1.services.MutateJobService/GetMutateJob" => {
                    #[allow(non_camel_case_types)]
                    struct GetMutateJobSvc<T: MutateJobService>(pub Arc<T>);
                    impl<T: MutateJobService>
                        tonic::server::UnaryService<super::GetMutateJobRequest>
                        for GetMutateJobSvc<T>
                    {
                        type Response = super::super::resources::MutateJob;
                        type Future = BoxFuture<tonic::Response<Self::Response>, tonic::Status>;
                        fn call(
                            &mut self,
                            request: tonic::Request<super::GetMutateJobRequest>,
                        ) -> Self::Future {
                            let inner = self.0.clone();
                            let fut = async move { inner.get_mutate_job(request).await };
                            Box::pin(fut)
                        }
                    }
                    let inner = self.inner.clone();
                    let fut = async move {
                        let interceptor = inner.1.clone();
                        let inner = inner.0;
                        let method = GetMutateJobSvc(inner);
                        let codec = tonic::codec::ProstCodec::default();
                        let mut grpc = if let Some(interceptor) = interceptor {
                            tonic::server::Grpc::with_interceptor(codec, interceptor)
                        } else {
                            tonic::server::Grpc::new(codec)
                        };
                        let res = grpc.unary(method, req).await;
                        Ok(res)
                    };
                    Box::pin(fut)
                }
                "/google.ads.googleads.v1.services.MutateJobService/ListMutateJobResults" => {
                    #[allow(non_camel_case_types)]
                    struct ListMutateJobResultsSvc<T: MutateJobService>(pub Arc<T>);
                    impl<T: MutateJobService>
                        tonic::server::UnaryService<super::ListMutateJobResultsRequest>
                        for ListMutateJobResultsSvc<T>
                    {
                        type Response = super::ListMutateJobResultsResponse;
                        type Future = BoxFuture<tonic::Response<Self::Response>, tonic::Status>;
                        fn call(
                            &mut self,
                            request: tonic::Request<super::ListMutateJobResultsRequest>,
                        ) -> Self::Future {
                            let inner = self.0.clone();
                            let fut = async move { inner.list_mutate_job_results(request).await };
                            Box::pin(fut)
                        }
                    }
                    let inner = self.inner.clone();
                    let fut = async move {
                        let interceptor = inner.1.clone();
                        let inner = inner.0;
                        let method = ListMutateJobResultsSvc(inner);
                        let codec = tonic::codec::ProstCodec::default();
                        let mut grpc = if let Some(interceptor) = interceptor {
                            tonic::server::Grpc::with_interceptor(codec, interceptor)
                        } else {
                            tonic::server::Grpc::new(codec)
                        };
                        let res = grpc.unary(method, req).await;
                        Ok(res)
                    };
                    Box::pin(fut)
                }
                "/google.ads.googleads.v1.services.MutateJobService/RunMutateJob" => {
                    #[allow(non_camel_case_types)]
                    struct RunMutateJobSvc<T: MutateJobService>(pub Arc<T>);
                    impl<T: MutateJobService>
                        tonic::server::UnaryService<super::RunMutateJobRequest>
                        for RunMutateJobSvc<T>
                    {
                        type Response = super::super::super::super::super::longrunning::Operation;
                        type Future = BoxFuture<tonic::Response<Self::Response>, tonic::Status>;
                        fn call(
                            &mut self,
                            request: tonic::Request<super::RunMutateJobRequest>,
                        ) -> Self::Future {
                            let inner = self.0.clone();
                            let fut = async move { inner.run_mutate_job(request).await };
                            Box::pin(fut)
                        }
                    }
                    let inner = self.inner.clone();
                    let fut = async move {
                        let interceptor = inner.1.clone();
                        let inner = inner.0;
                        let method = RunMutateJobSvc(inner);
                        let codec = tonic::codec::ProstCodec::default();
                        let mut grpc = if let Some(interceptor) = interceptor {
                            tonic::server::Grpc::with_interceptor(codec, interceptor)
                        } else {
                            tonic::server::Grpc::new(codec)
                        };
                        let res = grpc.unary(method, req).await;
                        Ok(res)
                    };
                    Box::pin(fut)
                }
                "/google.ads.googleads.v1.services.MutateJobService/AddMutateJobOperations" => {
                    #[allow(non_camel_case_types)]
                    struct AddMutateJobOperationsSvc<T: MutateJobService>(pub Arc<T>);
                    impl<T: MutateJobService>
                        tonic::server::UnaryService<super::AddMutateJobOperationsRequest>
                        for AddMutateJobOperationsSvc<T>
                    {
                        type Response = super::AddMutateJobOperationsResponse;
                        type Future = BoxFuture<tonic::Response<Self::Response>, tonic::Status>;
                        fn call(
                            &mut self,
                            request: tonic::Request<super::AddMutateJobOperationsRequest>,
                        ) -> Self::Future {
                            let inner = self.0.clone();
                            let fut = async move { inner.add_mutate_job_operations(request).await };
                            Box::pin(fut)
                        }
                    }
                    let inner = self.inner.clone();
                    let fut = async move {
                        let interceptor = inner.1.clone();
                        let inner = inner.0;
                        let method = AddMutateJobOperationsSvc(inner);
                        let codec = tonic::codec::ProstCodec::default();
                        let mut grpc = if let Some(interceptor) = interceptor {
                            tonic::server::Grpc::with_interceptor(codec, interceptor)
                        } else {
                            tonic::server::Grpc::new(codec)
                        };
                        let res = grpc.unary(method, req).await;
                        Ok(res)
                    };
                    Box::pin(fut)
                }
                _ => Box::pin(async move {
                    Ok(http::Response::builder()
                        .status(200)
                        .header("grpc-status", "12")
                        .body(tonic::body::BoxBody::empty())
                        .unwrap())
                }),
            }
        }
    }
    impl<T: MutateJobService> Clone for MutateJobServiceServer<T> {
        fn clone(&self) -> Self {
            let inner = self.inner.clone();
            Self { inner }
        }
    }
    impl<T: MutateJobService> Clone for _Inner<T> {
        fn clone(&self) -> Self {
            Self(self.0.clone(), self.1.clone())
        }
    }
    impl<T: std::fmt::Debug> std::fmt::Debug for _Inner<T> {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
            write!(f, "{:?}", self.0)
        }
    }
    impl<T: MutateJobService> tonic::transport::NamedService for MutateJobServiceServer<T> {
        const NAME: &'static str = "google.ads.googleads.v1.services.MutateJobService";
    }
}
/// Request message for
/// [OperatingSystemVersionConstantService.GetOperatingSystemVersionConstant][google.ads.googleads.v1.services.OperatingSystemVersionConstantService.GetOperatingSystemVersionConstant].
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GetOperatingSystemVersionConstantRequest {
    /// Required. Resource name of the OS version to fetch.
    #[prost(string, tag = "1")]
    pub resource_name: std::string::String,
}
#[doc = r" Generated client implementations."]
pub mod operating_system_version_constant_service_client {
    #![allow(unused_variables, dead_code, missing_docs)]
    use tonic::codegen::*;
    #[doc = " Service to fetch Operating System Version constants."]
    pub struct OperatingSystemVersionConstantServiceClient<T> {
        inner: tonic::client::Grpc<T>,
    }
    impl OperatingSystemVersionConstantServiceClient<tonic::transport::Channel> {
        #[doc = r" Attempt to create a new client by connecting to a given endpoint."]
        pub async fn connect<D>(dst: D) -> Result<Self, tonic::transport::Error>
        where
            D: std::convert::TryInto<tonic::transport::Endpoint>,
            D::Error: Into<StdError>,
        {
            let conn = tonic::transport::Endpoint::new(dst)?.connect().await?;
            Ok(Self::new(conn))
        }
    }
    impl<T> OperatingSystemVersionConstantServiceClient<T>
    where
        T: tonic::client::GrpcService<tonic::body::BoxBody>,
        T::ResponseBody: Body + HttpBody + Send + 'static,
        T::Error: Into<StdError>,
        <T::ResponseBody as HttpBody>::Error: Into<StdError> + Send,
    {
        pub fn new(inner: T) -> Self {
            let inner = tonic::client::Grpc::new(inner);
            Self { inner }
        }
        pub fn with_interceptor(inner: T, interceptor: impl Into<tonic::Interceptor>) -> Self {
            let inner = tonic::client::Grpc::with_interceptor(inner, interceptor);
            Self { inner }
        }
        #[doc = " Returns the requested OS version constant in full detail."]
        pub async fn get_operating_system_version_constant(
            &mut self,
            request: impl tonic::IntoRequest<super::GetOperatingSystemVersionConstantRequest>,
        ) -> Result<
            tonic::Response<super::super::resources::OperatingSystemVersionConstant>,
            tonic::Status,
        > {
            self.inner.ready().await.map_err(|e| {
                tonic::Status::new(
                    tonic::Code::Unknown,
                    format!("Service was not ready: {}", e.into()),
                )
            })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http :: uri :: PathAndQuery :: from_static ( "/google.ads.googleads.v1.services.OperatingSystemVersionConstantService/GetOperatingSystemVersionConstant" ) ;
            self.inner.unary(request.into_request(), path, codec).await
        }
    }
    impl<T: Clone> Clone for OperatingSystemVersionConstantServiceClient<T> {
        fn clone(&self) -> Self {
            Self {
                inner: self.inner.clone(),
            }
        }
    }
    impl<T> std::fmt::Debug for OperatingSystemVersionConstantServiceClient<T> {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
            write!(f, "OperatingSystemVersionConstantServiceClient {{ ... }}")
        }
    }
}
#[doc = r" Generated server implementations."]
pub mod operating_system_version_constant_service_server {
    #![allow(unused_variables, dead_code, missing_docs)]
    use tonic::codegen::*;
    #[doc = "Generated trait containing gRPC methods that should be implemented for use with OperatingSystemVersionConstantServiceServer."]
    #[async_trait]
    pub trait OperatingSystemVersionConstantService: Send + Sync + 'static {
        #[doc = " Returns the requested OS version constant in full detail."]
        async fn get_operating_system_version_constant(
            &self,
            request: tonic::Request<super::GetOperatingSystemVersionConstantRequest>,
        ) -> Result<
            tonic::Response<super::super::resources::OperatingSystemVersionConstant>,
            tonic::Status,
        >;
    }
    #[doc = " Service to fetch Operating System Version constants."]
    #[derive(Debug)]
    #[doc(hidden)]
    pub struct OperatingSystemVersionConstantServiceServer<T: OperatingSystemVersionConstantService> {
        inner: _Inner<T>,
    }
    struct _Inner<T>(Arc<T>, Option<tonic::Interceptor>);
    impl<T: OperatingSystemVersionConstantService> OperatingSystemVersionConstantServiceServer<T> {
        pub fn new(inner: T) -> Self {
            let inner = Arc::new(inner);
            let inner = _Inner(inner, None);
            Self { inner }
        }
        pub fn with_interceptor(inner: T, interceptor: impl Into<tonic::Interceptor>) -> Self {
            let inner = Arc::new(inner);
            let inner = _Inner(inner, Some(interceptor.into()));
            Self { inner }
        }
    }
    impl<T, B> Service<http::Request<B>> for OperatingSystemVersionConstantServiceServer<T>
    where
        T: OperatingSystemVersionConstantService,
        B: HttpBody + Send + Sync + 'static,
        B::Error: Into<StdError> + Send + 'static,
    {
        type Response = http::Response<tonic::body::BoxBody>;
        type Error = Never;
        type Future = BoxFuture<Self::Response, Self::Error>;
        fn poll_ready(&mut self, _cx: &mut Context<'_>) -> Poll<Result<(), Self::Error>> {
            Poll::Ready(Ok(()))
        }
        fn call(&mut self, req: http::Request<B>) -> Self::Future {
            let inner = self.inner.clone();
            match req . uri ( ) . path ( ) { "/google.ads.googleads.v1.services.OperatingSystemVersionConstantService/GetOperatingSystemVersionConstant" => { # [ allow ( non_camel_case_types ) ] struct GetOperatingSystemVersionConstantSvc < T : OperatingSystemVersionConstantService > ( pub Arc < T > ) ; impl < T : OperatingSystemVersionConstantService > tonic :: server :: UnaryService < super :: GetOperatingSystemVersionConstantRequest > for GetOperatingSystemVersionConstantSvc < T > { type Response = super :: super :: resources :: OperatingSystemVersionConstant ; type Future = BoxFuture < tonic :: Response < Self :: Response > , tonic :: Status > ; fn call ( & mut self , request : tonic :: Request < super :: GetOperatingSystemVersionConstantRequest > ) -> Self :: Future { let inner = self . 0 . clone ( ) ; let fut = async move { inner . get_operating_system_version_constant ( request ) . await } ; Box :: pin ( fut ) } } let inner = self . inner . clone ( ) ; let fut = async move { let interceptor = inner . 1 . clone ( ) ; let inner = inner . 0 ; let method = GetOperatingSystemVersionConstantSvc ( inner ) ; let codec = tonic :: codec :: ProstCodec :: default ( ) ; let mut grpc = if let Some ( interceptor ) = interceptor { tonic :: server :: Grpc :: with_interceptor ( codec , interceptor ) } else { tonic :: server :: Grpc :: new ( codec ) } ; let res = grpc . unary ( method , req ) . await ; Ok ( res ) } ; Box :: pin ( fut ) } _ => Box :: pin ( async move { Ok ( http :: Response :: builder ( ) . status ( 200 ) . header ( "grpc-status" , "12" ) . body ( tonic :: body :: BoxBody :: empty ( ) ) . unwrap ( ) ) } ) , }
        }
    }
    impl<T: OperatingSystemVersionConstantService> Clone
        for OperatingSystemVersionConstantServiceServer<T>
    {
        fn clone(&self) -> Self {
            let inner = self.inner.clone();
            Self { inner }
        }
    }
    impl<T: OperatingSystemVersionConstantService> Clone for _Inner<T> {
        fn clone(&self) -> Self {
            Self(self.0.clone(), self.1.clone())
        }
    }
    impl<T: std::fmt::Debug> std::fmt::Debug for _Inner<T> {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
            write!(f, "{:?}", self.0)
        }
    }
    impl<T: OperatingSystemVersionConstantService> tonic::transport::NamedService
        for OperatingSystemVersionConstantServiceServer<T>
    {
        const NAME: &'static str =
            "google.ads.googleads.v1.services.OperatingSystemVersionConstantService";
    }
}
/// Request message for
/// [PaidOrganicSearchTermViewService.GetPaidOrganicSearchTermView][google.ads.googleads.v1.services.PaidOrganicSearchTermViewService.GetPaidOrganicSearchTermView].
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GetPaidOrganicSearchTermViewRequest {
    /// Required. The resource name of the paid organic search term view to fetch.
    #[prost(string, tag = "1")]
    pub resource_name: std::string::String,
}
#[doc = r" Generated client implementations."]
pub mod paid_organic_search_term_view_service_client {
    #![allow(unused_variables, dead_code, missing_docs)]
    use tonic::codegen::*;
    #[doc = " Service to fetch paid organic search term views."]
    pub struct PaidOrganicSearchTermViewServiceClient<T> {
        inner: tonic::client::Grpc<T>,
    }
    impl PaidOrganicSearchTermViewServiceClient<tonic::transport::Channel> {
        #[doc = r" Attempt to create a new client by connecting to a given endpoint."]
        pub async fn connect<D>(dst: D) -> Result<Self, tonic::transport::Error>
        where
            D: std::convert::TryInto<tonic::transport::Endpoint>,
            D::Error: Into<StdError>,
        {
            let conn = tonic::transport::Endpoint::new(dst)?.connect().await?;
            Ok(Self::new(conn))
        }
    }
    impl<T> PaidOrganicSearchTermViewServiceClient<T>
    where
        T: tonic::client::GrpcService<tonic::body::BoxBody>,
        T::ResponseBody: Body + HttpBody + Send + 'static,
        T::Error: Into<StdError>,
        <T::ResponseBody as HttpBody>::Error: Into<StdError> + Send,
    {
        pub fn new(inner: T) -> Self {
            let inner = tonic::client::Grpc::new(inner);
            Self { inner }
        }
        pub fn with_interceptor(inner: T, interceptor: impl Into<tonic::Interceptor>) -> Self {
            let inner = tonic::client::Grpc::with_interceptor(inner, interceptor);
            Self { inner }
        }
        #[doc = " Returns the requested paid organic search term view in full detail."]
        pub async fn get_paid_organic_search_term_view(
            &mut self,
            request: impl tonic::IntoRequest<super::GetPaidOrganicSearchTermViewRequest>,
        ) -> Result<
            tonic::Response<super::super::resources::PaidOrganicSearchTermView>,
            tonic::Status,
        > {
            self.inner.ready().await.map_err(|e| {
                tonic::Status::new(
                    tonic::Code::Unknown,
                    format!("Service was not ready: {}", e.into()),
                )
            })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http :: uri :: PathAndQuery :: from_static ( "/google.ads.googleads.v1.services.PaidOrganicSearchTermViewService/GetPaidOrganicSearchTermView" ) ;
            self.inner.unary(request.into_request(), path, codec).await
        }
    }
    impl<T: Clone> Clone for PaidOrganicSearchTermViewServiceClient<T> {
        fn clone(&self) -> Self {
            Self {
                inner: self.inner.clone(),
            }
        }
    }
    impl<T> std::fmt::Debug for PaidOrganicSearchTermViewServiceClient<T> {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
            write!(f, "PaidOrganicSearchTermViewServiceClient {{ ... }}")
        }
    }
}
#[doc = r" Generated server implementations."]
pub mod paid_organic_search_term_view_service_server {
    #![allow(unused_variables, dead_code, missing_docs)]
    use tonic::codegen::*;
    #[doc = "Generated trait containing gRPC methods that should be implemented for use with PaidOrganicSearchTermViewServiceServer."]
    #[async_trait]
    pub trait PaidOrganicSearchTermViewService: Send + Sync + 'static {
        #[doc = " Returns the requested paid organic search term view in full detail."]
        async fn get_paid_organic_search_term_view(
            &self,
            request: tonic::Request<super::GetPaidOrganicSearchTermViewRequest>,
        ) -> Result<
            tonic::Response<super::super::resources::PaidOrganicSearchTermView>,
            tonic::Status,
        >;
    }
    #[doc = " Service to fetch paid organic search term views."]
    #[derive(Debug)]
    #[doc(hidden)]
    pub struct PaidOrganicSearchTermViewServiceServer<T: PaidOrganicSearchTermViewService> {
        inner: _Inner<T>,
    }
    struct _Inner<T>(Arc<T>, Option<tonic::Interceptor>);
    impl<T: PaidOrganicSearchTermViewService> PaidOrganicSearchTermViewServiceServer<T> {
        pub fn new(inner: T) -> Self {
            let inner = Arc::new(inner);
            let inner = _Inner(inner, None);
            Self { inner }
        }
        pub fn with_interceptor(inner: T, interceptor: impl Into<tonic::Interceptor>) -> Self {
            let inner = Arc::new(inner);
            let inner = _Inner(inner, Some(interceptor.into()));
            Self { inner }
        }
    }
    impl<T, B> Service<http::Request<B>> for PaidOrganicSearchTermViewServiceServer<T>
    where
        T: PaidOrganicSearchTermViewService,
        B: HttpBody + Send + Sync + 'static,
        B::Error: Into<StdError> + Send + 'static,
    {
        type Response = http::Response<tonic::body::BoxBody>;
        type Error = Never;
        type Future = BoxFuture<Self::Response, Self::Error>;
        fn poll_ready(&mut self, _cx: &mut Context<'_>) -> Poll<Result<(), Self::Error>> {
            Poll::Ready(Ok(()))
        }
        fn call(&mut self, req: http::Request<B>) -> Self::Future {
            let inner = self.inner.clone();
            match req . uri ( ) . path ( ) { "/google.ads.googleads.v1.services.PaidOrganicSearchTermViewService/GetPaidOrganicSearchTermView" => { # [ allow ( non_camel_case_types ) ] struct GetPaidOrganicSearchTermViewSvc < T : PaidOrganicSearchTermViewService > ( pub Arc < T > ) ; impl < T : PaidOrganicSearchTermViewService > tonic :: server :: UnaryService < super :: GetPaidOrganicSearchTermViewRequest > for GetPaidOrganicSearchTermViewSvc < T > { type Response = super :: super :: resources :: PaidOrganicSearchTermView ; type Future = BoxFuture < tonic :: Response < Self :: Response > , tonic :: Status > ; fn call ( & mut self , request : tonic :: Request < super :: GetPaidOrganicSearchTermViewRequest > ) -> Self :: Future { let inner = self . 0 . clone ( ) ; let fut = async move { inner . get_paid_organic_search_term_view ( request ) . await } ; Box :: pin ( fut ) } } let inner = self . inner . clone ( ) ; let fut = async move { let interceptor = inner . 1 . clone ( ) ; let inner = inner . 0 ; let method = GetPaidOrganicSearchTermViewSvc ( inner ) ; let codec = tonic :: codec :: ProstCodec :: default ( ) ; let mut grpc = if let Some ( interceptor ) = interceptor { tonic :: server :: Grpc :: with_interceptor ( codec , interceptor ) } else { tonic :: server :: Grpc :: new ( codec ) } ; let res = grpc . unary ( method , req ) . await ; Ok ( res ) } ; Box :: pin ( fut ) } _ => Box :: pin ( async move { Ok ( http :: Response :: builder ( ) . status ( 200 ) . header ( "grpc-status" , "12" ) . body ( tonic :: body :: BoxBody :: empty ( ) ) . unwrap ( ) ) } ) , }
        }
    }
    impl<T: PaidOrganicSearchTermViewService> Clone for PaidOrganicSearchTermViewServiceServer<T> {
        fn clone(&self) -> Self {
            let inner = self.inner.clone();
            Self { inner }
        }
    }
    impl<T: PaidOrganicSearchTermViewService> Clone for _Inner<T> {
        fn clone(&self) -> Self {
            Self(self.0.clone(), self.1.clone())
        }
    }
    impl<T: std::fmt::Debug> std::fmt::Debug for _Inner<T> {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
            write!(f, "{:?}", self.0)
        }
    }
    impl<T: PaidOrganicSearchTermViewService> tonic::transport::NamedService
        for PaidOrganicSearchTermViewServiceServer<T>
    {
        const NAME: &'static str =
            "google.ads.googleads.v1.services.PaidOrganicSearchTermViewService";
    }
}
/// Request message for [ParentalStatusViewService.GetParentalStatusView][google.ads.googleads.v1.services.ParentalStatusViewService.GetParentalStatusView].
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GetParentalStatusViewRequest {
    /// Required. The resource name of the parental status view to fetch.
    #[prost(string, tag = "1")]
    pub resource_name: std::string::String,
}
#[doc = r" Generated client implementations."]
pub mod parental_status_view_service_client {
    #![allow(unused_variables, dead_code, missing_docs)]
    use tonic::codegen::*;
    #[doc = " Service to manage parental status views."]
    pub struct ParentalStatusViewServiceClient<T> {
        inner: tonic::client::Grpc<T>,
    }
    impl ParentalStatusViewServiceClient<tonic::transport::Channel> {
        #[doc = r" Attempt to create a new client by connecting to a given endpoint."]
        pub async fn connect<D>(dst: D) -> Result<Self, tonic::transport::Error>
        where
            D: std::convert::TryInto<tonic::transport::Endpoint>,
            D::Error: Into<StdError>,
        {
            let conn = tonic::transport::Endpoint::new(dst)?.connect().await?;
            Ok(Self::new(conn))
        }
    }
    impl<T> ParentalStatusViewServiceClient<T>
    where
        T: tonic::client::GrpcService<tonic::body::BoxBody>,
        T::ResponseBody: Body + HttpBody + Send + 'static,
        T::Error: Into<StdError>,
        <T::ResponseBody as HttpBody>::Error: Into<StdError> + Send,
    {
        pub fn new(inner: T) -> Self {
            let inner = tonic::client::Grpc::new(inner);
            Self { inner }
        }
        pub fn with_interceptor(inner: T, interceptor: impl Into<tonic::Interceptor>) -> Self {
            let inner = tonic::client::Grpc::with_interceptor(inner, interceptor);
            Self { inner }
        }
        #[doc = " Returns the requested parental status view in full detail."]
        pub async fn get_parental_status_view(
            &mut self,
            request: impl tonic::IntoRequest<super::GetParentalStatusViewRequest>,
        ) -> Result<tonic::Response<super::super::resources::ParentalStatusView>, tonic::Status>
        {
            self.inner.ready().await.map_err(|e| {
                tonic::Status::new(
                    tonic::Code::Unknown,
                    format!("Service was not ready: {}", e.into()),
                )
            })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.ads.googleads.v1.services.ParentalStatusViewService/GetParentalStatusView",
            );
            self.inner.unary(request.into_request(), path, codec).await
        }
    }
    impl<T: Clone> Clone for ParentalStatusViewServiceClient<T> {
        fn clone(&self) -> Self {
            Self {
                inner: self.inner.clone(),
            }
        }
    }
    impl<T> std::fmt::Debug for ParentalStatusViewServiceClient<T> {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
            write!(f, "ParentalStatusViewServiceClient {{ ... }}")
        }
    }
}
#[doc = r" Generated server implementations."]
pub mod parental_status_view_service_server {
    #![allow(unused_variables, dead_code, missing_docs)]
    use tonic::codegen::*;
    #[doc = "Generated trait containing gRPC methods that should be implemented for use with ParentalStatusViewServiceServer."]
    #[async_trait]
    pub trait ParentalStatusViewService: Send + Sync + 'static {
        #[doc = " Returns the requested parental status view in full detail."]
        async fn get_parental_status_view(
            &self,
            request: tonic::Request<super::GetParentalStatusViewRequest>,
        ) -> Result<tonic::Response<super::super::resources::ParentalStatusView>, tonic::Status>;
    }
    #[doc = " Service to manage parental status views."]
    #[derive(Debug)]
    #[doc(hidden)]
    pub struct ParentalStatusViewServiceServer<T: ParentalStatusViewService> {
        inner: _Inner<T>,
    }
    struct _Inner<T>(Arc<T>, Option<tonic::Interceptor>);
    impl<T: ParentalStatusViewService> ParentalStatusViewServiceServer<T> {
        pub fn new(inner: T) -> Self {
            let inner = Arc::new(inner);
            let inner = _Inner(inner, None);
            Self { inner }
        }
        pub fn with_interceptor(inner: T, interceptor: impl Into<tonic::Interceptor>) -> Self {
            let inner = Arc::new(inner);
            let inner = _Inner(inner, Some(interceptor.into()));
            Self { inner }
        }
    }
    impl<T, B> Service<http::Request<B>> for ParentalStatusViewServiceServer<T>
    where
        T: ParentalStatusViewService,
        B: HttpBody + Send + Sync + 'static,
        B::Error: Into<StdError> + Send + 'static,
    {
        type Response = http::Response<tonic::body::BoxBody>;
        type Error = Never;
        type Future = BoxFuture<Self::Response, Self::Error>;
        fn poll_ready(&mut self, _cx: &mut Context<'_>) -> Poll<Result<(), Self::Error>> {
            Poll::Ready(Ok(()))
        }
        fn call(&mut self, req: http::Request<B>) -> Self::Future {
            let inner = self.inner.clone();
            match req . uri ( ) . path ( ) { "/google.ads.googleads.v1.services.ParentalStatusViewService/GetParentalStatusView" => { # [ allow ( non_camel_case_types ) ] struct GetParentalStatusViewSvc < T : ParentalStatusViewService > ( pub Arc < T > ) ; impl < T : ParentalStatusViewService > tonic :: server :: UnaryService < super :: GetParentalStatusViewRequest > for GetParentalStatusViewSvc < T > { type Response = super :: super :: resources :: ParentalStatusView ; type Future = BoxFuture < tonic :: Response < Self :: Response > , tonic :: Status > ; fn call ( & mut self , request : tonic :: Request < super :: GetParentalStatusViewRequest > ) -> Self :: Future { let inner = self . 0 . clone ( ) ; let fut = async move { inner . get_parental_status_view ( request ) . await } ; Box :: pin ( fut ) } } let inner = self . inner . clone ( ) ; let fut = async move { let interceptor = inner . 1 . clone ( ) ; let inner = inner . 0 ; let method = GetParentalStatusViewSvc ( inner ) ; let codec = tonic :: codec :: ProstCodec :: default ( ) ; let mut grpc = if let Some ( interceptor ) = interceptor { tonic :: server :: Grpc :: with_interceptor ( codec , interceptor ) } else { tonic :: server :: Grpc :: new ( codec ) } ; let res = grpc . unary ( method , req ) . await ; Ok ( res ) } ; Box :: pin ( fut ) } _ => Box :: pin ( async move { Ok ( http :: Response :: builder ( ) . status ( 200 ) . header ( "grpc-status" , "12" ) . body ( tonic :: body :: BoxBody :: empty ( ) ) . unwrap ( ) ) } ) , }
        }
    }
    impl<T: ParentalStatusViewService> Clone for ParentalStatusViewServiceServer<T> {
        fn clone(&self) -> Self {
            let inner = self.inner.clone();
            Self { inner }
        }
    }
    impl<T: ParentalStatusViewService> Clone for _Inner<T> {
        fn clone(&self) -> Self {
            Self(self.0.clone(), self.1.clone())
        }
    }
    impl<T: std::fmt::Debug> std::fmt::Debug for _Inner<T> {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
            write!(f, "{:?}", self.0)
        }
    }
    impl<T: ParentalStatusViewService> tonic::transport::NamedService
        for ParentalStatusViewServiceServer<T>
    {
        const NAME: &'static str = "google.ads.googleads.v1.services.ParentalStatusViewService";
    }
}
/// Request message for fetching all accessible payments accounts.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ListPaymentsAccountsRequest {
    /// Required. The ID of the customer to apply the PaymentsAccount list operation to.
    #[prost(string, tag = "1")]
    pub customer_id: std::string::String,
}
/// Response message for [PaymentsAccountService.ListPaymentsAccounts][google.ads.googleads.v1.services.PaymentsAccountService.ListPaymentsAccounts].
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ListPaymentsAccountsResponse {
    /// The list of accessible payments accounts.
    #[prost(message, repeated, tag = "1")]
    pub payments_accounts: ::std::vec::Vec<super::resources::PaymentsAccount>,
}
#[doc = r" Generated client implementations."]
pub mod payments_account_service_client {
    #![allow(unused_variables, dead_code, missing_docs)]
    use tonic::codegen::*;
    #[doc = " Service to provide payments accounts that can be used to set up consolidated"]
    #[doc = " billing."]
    pub struct PaymentsAccountServiceClient<T> {
        inner: tonic::client::Grpc<T>,
    }
    impl PaymentsAccountServiceClient<tonic::transport::Channel> {
        #[doc = r" Attempt to create a new client by connecting to a given endpoint."]
        pub async fn connect<D>(dst: D) -> Result<Self, tonic::transport::Error>
        where
            D: std::convert::TryInto<tonic::transport::Endpoint>,
            D::Error: Into<StdError>,
        {
            let conn = tonic::transport::Endpoint::new(dst)?.connect().await?;
            Ok(Self::new(conn))
        }
    }
    impl<T> PaymentsAccountServiceClient<T>
    where
        T: tonic::client::GrpcService<tonic::body::BoxBody>,
        T::ResponseBody: Body + HttpBody + Send + 'static,
        T::Error: Into<StdError>,
        <T::ResponseBody as HttpBody>::Error: Into<StdError> + Send,
    {
        pub fn new(inner: T) -> Self {
            let inner = tonic::client::Grpc::new(inner);
            Self { inner }
        }
        pub fn with_interceptor(inner: T, interceptor: impl Into<tonic::Interceptor>) -> Self {
            let inner = tonic::client::Grpc::with_interceptor(inner, interceptor);
            Self { inner }
        }
        #[doc = " Returns all payments accounts associated with all managers"]
        #[doc = " between the login customer ID and specified serving customer in the"]
        #[doc = " hierarchy, inclusive."]
        pub async fn list_payments_accounts(
            &mut self,
            request: impl tonic::IntoRequest<super::ListPaymentsAccountsRequest>,
        ) -> Result<tonic::Response<super::ListPaymentsAccountsResponse>, tonic::Status> {
            self.inner.ready().await.map_err(|e| {
                tonic::Status::new(
                    tonic::Code::Unknown,
                    format!("Service was not ready: {}", e.into()),
                )
            })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.ads.googleads.v1.services.PaymentsAccountService/ListPaymentsAccounts",
            );
            self.inner.unary(request.into_request(), path, codec).await
        }
    }
    impl<T: Clone> Clone for PaymentsAccountServiceClient<T> {
        fn clone(&self) -> Self {
            Self {
                inner: self.inner.clone(),
            }
        }
    }
    impl<T> std::fmt::Debug for PaymentsAccountServiceClient<T> {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
            write!(f, "PaymentsAccountServiceClient {{ ... }}")
        }
    }
}
#[doc = r" Generated server implementations."]
pub mod payments_account_service_server {
    #![allow(unused_variables, dead_code, missing_docs)]
    use tonic::codegen::*;
    #[doc = "Generated trait containing gRPC methods that should be implemented for use with PaymentsAccountServiceServer."]
    #[async_trait]
    pub trait PaymentsAccountService: Send + Sync + 'static {
        #[doc = " Returns all payments accounts associated with all managers"]
        #[doc = " between the login customer ID and specified serving customer in the"]
        #[doc = " hierarchy, inclusive."]
        async fn list_payments_accounts(
            &self,
            request: tonic::Request<super::ListPaymentsAccountsRequest>,
        ) -> Result<tonic::Response<super::ListPaymentsAccountsResponse>, tonic::Status>;
    }
    #[doc = " Service to provide payments accounts that can be used to set up consolidated"]
    #[doc = " billing."]
    #[derive(Debug)]
    #[doc(hidden)]
    pub struct PaymentsAccountServiceServer<T: PaymentsAccountService> {
        inner: _Inner<T>,
    }
    struct _Inner<T>(Arc<T>, Option<tonic::Interceptor>);
    impl<T: PaymentsAccountService> PaymentsAccountServiceServer<T> {
        pub fn new(inner: T) -> Self {
            let inner = Arc::new(inner);
            let inner = _Inner(inner, None);
            Self { inner }
        }
        pub fn with_interceptor(inner: T, interceptor: impl Into<tonic::Interceptor>) -> Self {
            let inner = Arc::new(inner);
            let inner = _Inner(inner, Some(interceptor.into()));
            Self { inner }
        }
    }
    impl<T, B> Service<http::Request<B>> for PaymentsAccountServiceServer<T>
    where
        T: PaymentsAccountService,
        B: HttpBody + Send + Sync + 'static,
        B::Error: Into<StdError> + Send + 'static,
    {
        type Response = http::Response<tonic::body::BoxBody>;
        type Error = Never;
        type Future = BoxFuture<Self::Response, Self::Error>;
        fn poll_ready(&mut self, _cx: &mut Context<'_>) -> Poll<Result<(), Self::Error>> {
            Poll::Ready(Ok(()))
        }
        fn call(&mut self, req: http::Request<B>) -> Self::Future {
            let inner = self.inner.clone();
            match req.uri().path() {
                "/google.ads.googleads.v1.services.PaymentsAccountService/ListPaymentsAccounts" => {
                    #[allow(non_camel_case_types)]
                    struct ListPaymentsAccountsSvc<T: PaymentsAccountService>(pub Arc<T>);
                    impl<T: PaymentsAccountService>
                        tonic::server::UnaryService<super::ListPaymentsAccountsRequest>
                        for ListPaymentsAccountsSvc<T>
                    {
                        type Response = super::ListPaymentsAccountsResponse;
                        type Future = BoxFuture<tonic::Response<Self::Response>, tonic::Status>;
                        fn call(
                            &mut self,
                            request: tonic::Request<super::ListPaymentsAccountsRequest>,
                        ) -> Self::Future {
                            let inner = self.0.clone();
                            let fut = async move { inner.list_payments_accounts(request).await };
                            Box::pin(fut)
                        }
                    }
                    let inner = self.inner.clone();
                    let fut = async move {
                        let interceptor = inner.1.clone();
                        let inner = inner.0;
                        let method = ListPaymentsAccountsSvc(inner);
                        let codec = tonic::codec::ProstCodec::default();
                        let mut grpc = if let Some(interceptor) = interceptor {
                            tonic::server::Grpc::with_interceptor(codec, interceptor)
                        } else {
                            tonic::server::Grpc::new(codec)
                        };
                        let res = grpc.unary(method, req).await;
                        Ok(res)
                    };
                    Box::pin(fut)
                }
                _ => Box::pin(async move {
                    Ok(http::Response::builder()
                        .status(200)
                        .header("grpc-status", "12")
                        .body(tonic::body::BoxBody::empty())
                        .unwrap())
                }),
            }
        }
    }
    impl<T: PaymentsAccountService> Clone for PaymentsAccountServiceServer<T> {
        fn clone(&self) -> Self {
            let inner = self.inner.clone();
            Self { inner }
        }
    }
    impl<T: PaymentsAccountService> Clone for _Inner<T> {
        fn clone(&self) -> Self {
            Self(self.0.clone(), self.1.clone())
        }
    }
    impl<T: std::fmt::Debug> std::fmt::Debug for _Inner<T> {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
            write!(f, "{:?}", self.0)
        }
    }
    impl<T: PaymentsAccountService> tonic::transport::NamedService for PaymentsAccountServiceServer<T> {
        const NAME: &'static str = "google.ads.googleads.v1.services.PaymentsAccountService";
    }
}
/// Request message for
/// [ProductBiddingCategoryService.GetProductBiddingCategory][].
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GetProductBiddingCategoryConstantRequest {
    /// Required. Resource name of the Product Bidding Category to fetch.
    #[prost(string, tag = "1")]
    pub resource_name: std::string::String,
}
#[doc = r" Generated client implementations."]
pub mod product_bidding_category_constant_service_client {
    #![allow(unused_variables, dead_code, missing_docs)]
    use tonic::codegen::*;
    #[doc = " Service to fetch Product Bidding Categories."]
    pub struct ProductBiddingCategoryConstantServiceClient<T> {
        inner: tonic::client::Grpc<T>,
    }
    impl ProductBiddingCategoryConstantServiceClient<tonic::transport::Channel> {
        #[doc = r" Attempt to create a new client by connecting to a given endpoint."]
        pub async fn connect<D>(dst: D) -> Result<Self, tonic::transport::Error>
        where
            D: std::convert::TryInto<tonic::transport::Endpoint>,
            D::Error: Into<StdError>,
        {
            let conn = tonic::transport::Endpoint::new(dst)?.connect().await?;
            Ok(Self::new(conn))
        }
    }
    impl<T> ProductBiddingCategoryConstantServiceClient<T>
    where
        T: tonic::client::GrpcService<tonic::body::BoxBody>,
        T::ResponseBody: Body + HttpBody + Send + 'static,
        T::Error: Into<StdError>,
        <T::ResponseBody as HttpBody>::Error: Into<StdError> + Send,
    {
        pub fn new(inner: T) -> Self {
            let inner = tonic::client::Grpc::new(inner);
            Self { inner }
        }
        pub fn with_interceptor(inner: T, interceptor: impl Into<tonic::Interceptor>) -> Self {
            let inner = tonic::client::Grpc::with_interceptor(inner, interceptor);
            Self { inner }
        }
        #[doc = " Returns the requested Product Bidding Category in full detail."]
        pub async fn get_product_bidding_category_constant(
            &mut self,
            request: impl tonic::IntoRequest<super::GetProductBiddingCategoryConstantRequest>,
        ) -> Result<
            tonic::Response<super::super::resources::ProductBiddingCategoryConstant>,
            tonic::Status,
        > {
            self.inner.ready().await.map_err(|e| {
                tonic::Status::new(
                    tonic::Code::Unknown,
                    format!("Service was not ready: {}", e.into()),
                )
            })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http :: uri :: PathAndQuery :: from_static ( "/google.ads.googleads.v1.services.ProductBiddingCategoryConstantService/GetProductBiddingCategoryConstant" ) ;
            self.inner.unary(request.into_request(), path, codec).await
        }
    }
    impl<T: Clone> Clone for ProductBiddingCategoryConstantServiceClient<T> {
        fn clone(&self) -> Self {
            Self {
                inner: self.inner.clone(),
            }
        }
    }
    impl<T> std::fmt::Debug for ProductBiddingCategoryConstantServiceClient<T> {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
            write!(f, "ProductBiddingCategoryConstantServiceClient {{ ... }}")
        }
    }
}
#[doc = r" Generated server implementations."]
pub mod product_bidding_category_constant_service_server {
    #![allow(unused_variables, dead_code, missing_docs)]
    use tonic::codegen::*;
    #[doc = "Generated trait containing gRPC methods that should be implemented for use with ProductBiddingCategoryConstantServiceServer."]
    #[async_trait]
    pub trait ProductBiddingCategoryConstantService: Send + Sync + 'static {
        #[doc = " Returns the requested Product Bidding Category in full detail."]
        async fn get_product_bidding_category_constant(
            &self,
            request: tonic::Request<super::GetProductBiddingCategoryConstantRequest>,
        ) -> Result<
            tonic::Response<super::super::resources::ProductBiddingCategoryConstant>,
            tonic::Status,
        >;
    }
    #[doc = " Service to fetch Product Bidding Categories."]
    #[derive(Debug)]
    #[doc(hidden)]
    pub struct ProductBiddingCategoryConstantServiceServer<T: ProductBiddingCategoryConstantService> {
        inner: _Inner<T>,
    }
    struct _Inner<T>(Arc<T>, Option<tonic::Interceptor>);
    impl<T: ProductBiddingCategoryConstantService> ProductBiddingCategoryConstantServiceServer<T> {
        pub fn new(inner: T) -> Self {
            let inner = Arc::new(inner);
            let inner = _Inner(inner, None);
            Self { inner }
        }
        pub fn with_interceptor(inner: T, interceptor: impl Into<tonic::Interceptor>) -> Self {
            let inner = Arc::new(inner);
            let inner = _Inner(inner, Some(interceptor.into()));
            Self { inner }
        }
    }
    impl<T, B> Service<http::Request<B>> for ProductBiddingCategoryConstantServiceServer<T>
    where
        T: ProductBiddingCategoryConstantService,
        B: HttpBody + Send + Sync + 'static,
        B::Error: Into<StdError> + Send + 'static,
    {
        type Response = http::Response<tonic::body::BoxBody>;
        type Error = Never;
        type Future = BoxFuture<Self::Response, Self::Error>;
        fn poll_ready(&mut self, _cx: &mut Context<'_>) -> Poll<Result<(), Self::Error>> {
            Poll::Ready(Ok(()))
        }
        fn call(&mut self, req: http::Request<B>) -> Self::Future {
            let inner = self.inner.clone();
            match req . uri ( ) . path ( ) { "/google.ads.googleads.v1.services.ProductBiddingCategoryConstantService/GetProductBiddingCategoryConstant" => { # [ allow ( non_camel_case_types ) ] struct GetProductBiddingCategoryConstantSvc < T : ProductBiddingCategoryConstantService > ( pub Arc < T > ) ; impl < T : ProductBiddingCategoryConstantService > tonic :: server :: UnaryService < super :: GetProductBiddingCategoryConstantRequest > for GetProductBiddingCategoryConstantSvc < T > { type Response = super :: super :: resources :: ProductBiddingCategoryConstant ; type Future = BoxFuture < tonic :: Response < Self :: Response > , tonic :: Status > ; fn call ( & mut self , request : tonic :: Request < super :: GetProductBiddingCategoryConstantRequest > ) -> Self :: Future { let inner = self . 0 . clone ( ) ; let fut = async move { inner . get_product_bidding_category_constant ( request ) . await } ; Box :: pin ( fut ) } } let inner = self . inner . clone ( ) ; let fut = async move { let interceptor = inner . 1 . clone ( ) ; let inner = inner . 0 ; let method = GetProductBiddingCategoryConstantSvc ( inner ) ; let codec = tonic :: codec :: ProstCodec :: default ( ) ; let mut grpc = if let Some ( interceptor ) = interceptor { tonic :: server :: Grpc :: with_interceptor ( codec , interceptor ) } else { tonic :: server :: Grpc :: new ( codec ) } ; let res = grpc . unary ( method , req ) . await ; Ok ( res ) } ; Box :: pin ( fut ) } _ => Box :: pin ( async move { Ok ( http :: Response :: builder ( ) . status ( 200 ) . header ( "grpc-status" , "12" ) . body ( tonic :: body :: BoxBody :: empty ( ) ) . unwrap ( ) ) } ) , }
        }
    }
    impl<T: ProductBiddingCategoryConstantService> Clone
        for ProductBiddingCategoryConstantServiceServer<T>
    {
        fn clone(&self) -> Self {
            let inner = self.inner.clone();
            Self { inner }
        }
    }
    impl<T: ProductBiddingCategoryConstantService> Clone for _Inner<T> {
        fn clone(&self) -> Self {
            Self(self.0.clone(), self.1.clone())
        }
    }
    impl<T: std::fmt::Debug> std::fmt::Debug for _Inner<T> {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
            write!(f, "{:?}", self.0)
        }
    }
    impl<T: ProductBiddingCategoryConstantService> tonic::transport::NamedService
        for ProductBiddingCategoryConstantServiceServer<T>
    {
        const NAME: &'static str =
            "google.ads.googleads.v1.services.ProductBiddingCategoryConstantService";
    }
}
/// Request message for [ProductGroupViewService.GetProductGroupView][google.ads.googleads.v1.services.ProductGroupViewService.GetProductGroupView].
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GetProductGroupViewRequest {
    /// Required. The resource name of the product group view to fetch.
    #[prost(string, tag = "1")]
    pub resource_name: std::string::String,
}
#[doc = r" Generated client implementations."]
pub mod product_group_view_service_client {
    #![allow(unused_variables, dead_code, missing_docs)]
    use tonic::codegen::*;
    #[doc = " Service to manage product group views."]
    pub struct ProductGroupViewServiceClient<T> {
        inner: tonic::client::Grpc<T>,
    }
    impl ProductGroupViewServiceClient<tonic::transport::Channel> {
        #[doc = r" Attempt to create a new client by connecting to a given endpoint."]
        pub async fn connect<D>(dst: D) -> Result<Self, tonic::transport::Error>
        where
            D: std::convert::TryInto<tonic::transport::Endpoint>,
            D::Error: Into<StdError>,
        {
            let conn = tonic::transport::Endpoint::new(dst)?.connect().await?;
            Ok(Self::new(conn))
        }
    }
    impl<T> ProductGroupViewServiceClient<T>
    where
        T: tonic::client::GrpcService<tonic::body::BoxBody>,
        T::ResponseBody: Body + HttpBody + Send + 'static,
        T::Error: Into<StdError>,
        <T::ResponseBody as HttpBody>::Error: Into<StdError> + Send,
    {
        pub fn new(inner: T) -> Self {
            let inner = tonic::client::Grpc::new(inner);
            Self { inner }
        }
        pub fn with_interceptor(inner: T, interceptor: impl Into<tonic::Interceptor>) -> Self {
            let inner = tonic::client::Grpc::with_interceptor(inner, interceptor);
            Self { inner }
        }
        #[doc = " Returns the requested product group view in full detail."]
        pub async fn get_product_group_view(
            &mut self,
            request: impl tonic::IntoRequest<super::GetProductGroupViewRequest>,
        ) -> Result<tonic::Response<super::super::resources::ProductGroupView>, tonic::Status>
        {
            self.inner.ready().await.map_err(|e| {
                tonic::Status::new(
                    tonic::Code::Unknown,
                    format!("Service was not ready: {}", e.into()),
                )
            })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.ads.googleads.v1.services.ProductGroupViewService/GetProductGroupView",
            );
            self.inner.unary(request.into_request(), path, codec).await
        }
    }
    impl<T: Clone> Clone for ProductGroupViewServiceClient<T> {
        fn clone(&self) -> Self {
            Self {
                inner: self.inner.clone(),
            }
        }
    }
    impl<T> std::fmt::Debug for ProductGroupViewServiceClient<T> {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
            write!(f, "ProductGroupViewServiceClient {{ ... }}")
        }
    }
}
#[doc = r" Generated server implementations."]
pub mod product_group_view_service_server {
    #![allow(unused_variables, dead_code, missing_docs)]
    use tonic::codegen::*;
    #[doc = "Generated trait containing gRPC methods that should be implemented for use with ProductGroupViewServiceServer."]
    #[async_trait]
    pub trait ProductGroupViewService: Send + Sync + 'static {
        #[doc = " Returns the requested product group view in full detail."]
        async fn get_product_group_view(
            &self,
            request: tonic::Request<super::GetProductGroupViewRequest>,
        ) -> Result<tonic::Response<super::super::resources::ProductGroupView>, tonic::Status>;
    }
    #[doc = " Service to manage product group views."]
    #[derive(Debug)]
    #[doc(hidden)]
    pub struct ProductGroupViewServiceServer<T: ProductGroupViewService> {
        inner: _Inner<T>,
    }
    struct _Inner<T>(Arc<T>, Option<tonic::Interceptor>);
    impl<T: ProductGroupViewService> ProductGroupViewServiceServer<T> {
        pub fn new(inner: T) -> Self {
            let inner = Arc::new(inner);
            let inner = _Inner(inner, None);
            Self { inner }
        }
        pub fn with_interceptor(inner: T, interceptor: impl Into<tonic::Interceptor>) -> Self {
            let inner = Arc::new(inner);
            let inner = _Inner(inner, Some(interceptor.into()));
            Self { inner }
        }
    }
    impl<T, B> Service<http::Request<B>> for ProductGroupViewServiceServer<T>
    where
        T: ProductGroupViewService,
        B: HttpBody + Send + Sync + 'static,
        B::Error: Into<StdError> + Send + 'static,
    {
        type Response = http::Response<tonic::body::BoxBody>;
        type Error = Never;
        type Future = BoxFuture<Self::Response, Self::Error>;
        fn poll_ready(&mut self, _cx: &mut Context<'_>) -> Poll<Result<(), Self::Error>> {
            Poll::Ready(Ok(()))
        }
        fn call(&mut self, req: http::Request<B>) -> Self::Future {
            let inner = self.inner.clone();
            match req.uri().path() {
                "/google.ads.googleads.v1.services.ProductGroupViewService/GetProductGroupView" => {
                    #[allow(non_camel_case_types)]
                    struct GetProductGroupViewSvc<T: ProductGroupViewService>(pub Arc<T>);
                    impl<T: ProductGroupViewService>
                        tonic::server::UnaryService<super::GetProductGroupViewRequest>
                        for GetProductGroupViewSvc<T>
                    {
                        type Response = super::super::resources::ProductGroupView;
                        type Future = BoxFuture<tonic::Response<Self::Response>, tonic::Status>;
                        fn call(
                            &mut self,
                            request: tonic::Request<super::GetProductGroupViewRequest>,
                        ) -> Self::Future {
                            let inner = self.0.clone();
                            let fut = async move { inner.get_product_group_view(request).await };
                            Box::pin(fut)
                        }
                    }
                    let inner = self.inner.clone();
                    let fut = async move {
                        let interceptor = inner.1.clone();
                        let inner = inner.0;
                        let method = GetProductGroupViewSvc(inner);
                        let codec = tonic::codec::ProstCodec::default();
                        let mut grpc = if let Some(interceptor) = interceptor {
                            tonic::server::Grpc::with_interceptor(codec, interceptor)
                        } else {
                            tonic::server::Grpc::new(codec)
                        };
                        let res = grpc.unary(method, req).await;
                        Ok(res)
                    };
                    Box::pin(fut)
                }
                _ => Box::pin(async move {
                    Ok(http::Response::builder()
                        .status(200)
                        .header("grpc-status", "12")
                        .body(tonic::body::BoxBody::empty())
                        .unwrap())
                }),
            }
        }
    }
    impl<T: ProductGroupViewService> Clone for ProductGroupViewServiceServer<T> {
        fn clone(&self) -> Self {
            let inner = self.inner.clone();
            Self { inner }
        }
    }
    impl<T: ProductGroupViewService> Clone for _Inner<T> {
        fn clone(&self) -> Self {
            Self(self.0.clone(), self.1.clone())
        }
    }
    impl<T: std::fmt::Debug> std::fmt::Debug for _Inner<T> {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
            write!(f, "{:?}", self.0)
        }
    }
    impl<T: ProductGroupViewService> tonic::transport::NamedService
        for ProductGroupViewServiceServer<T>
    {
        const NAME: &'static str = "google.ads.googleads.v1.services.ProductGroupViewService";
    }
}
/// Request message for [RecommendationService.GetRecommendation][google.ads.googleads.v1.services.RecommendationService.GetRecommendation].
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GetRecommendationRequest {
    /// Required. The resource name of the recommendation to fetch.
    #[prost(string, tag = "1")]
    pub resource_name: std::string::String,
}
/// Request message for [RecommendationService.ApplyRecommendation][google.ads.googleads.v1.services.RecommendationService.ApplyRecommendation].
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ApplyRecommendationRequest {
    /// Required. The ID of the customer with the recommendation.
    #[prost(string, tag = "1")]
    pub customer_id: std::string::String,
    /// Required. The list of operations to apply recommendations.
    /// If partial_failure=false all recommendations should be of the same type
    /// There is a limit of 100 operations per request.
    #[prost(message, repeated, tag = "2")]
    pub operations: ::std::vec::Vec<ApplyRecommendationOperation>,
    /// If true, successful operations will be carried out and invalid
    /// operations will return errors. If false, operations will be carried
    /// out as a transaction if and only if they are all valid.
    /// Default is false.
    #[prost(bool, tag = "3")]
    pub partial_failure: bool,
}
/// Information about the operation to apply a recommendation and any parameters
/// to customize it.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ApplyRecommendationOperation {
    /// The resource name of the recommendation to apply.
    #[prost(string, tag = "1")]
    pub resource_name: std::string::String,
    /// Parameters to use when applying the recommendation.
    #[prost(
        oneof = "apply_recommendation_operation::ApplyParameters",
        tags = "2, 3, 4, 5, 6, 7, 8, 9"
    )]
    pub apply_parameters: ::std::option::Option<apply_recommendation_operation::ApplyParameters>,
}
pub mod apply_recommendation_operation {
    /// Parameters to use when applying a campaign budget recommendation.
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct CampaignBudgetParameters {
        /// New budget amount to set for target budget resource. This is a required
        /// field.
        #[prost(message, optional, tag = "1")]
        pub new_budget_amount_micros: ::std::option::Option<i64>,
    }
    /// Parameters to use when applying a text ad recommendation.
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct TextAdParameters {
        /// New ad to add to recommended ad group. All necessary fields need to be
        /// set in this message. This is a required field.
        #[prost(message, optional, tag = "1")]
        pub ad: ::std::option::Option<super::super::resources::Ad>,
    }
    /// Parameters to use when applying keyword recommendation.
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct KeywordParameters {
        /// The ad group resource to add keyword to. This is a required field.
        #[prost(message, optional, tag = "1")]
        pub ad_group: ::std::option::Option<::std::string::String>,
        /// The match type of the keyword. This is a required field.
        #[prost(
            enumeration = "super::super::enums::keyword_match_type_enum::KeywordMatchType",
            tag = "2"
        )]
        pub match_type: i32,
        /// Optional, CPC bid to set for the keyword. If not set, keyword will use
        /// bid based on bidding strategy used by target ad group.
        #[prost(message, optional, tag = "3")]
        pub cpc_bid_micros: ::std::option::Option<i64>,
    }
    /// Parameters to use when applying Target CPA recommendation.
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct TargetCpaOptInParameters {
        /// Average CPA to use for Target CPA bidding strategy. This is a required
        /// field.
        #[prost(message, optional, tag = "1")]
        pub target_cpa_micros: ::std::option::Option<i64>,
        /// Optional, budget amount to set for the campaign.
        #[prost(message, optional, tag = "2")]
        pub new_campaign_budget_amount_micros: ::std::option::Option<i64>,
    }
    /// Parameters to use when applying callout extension recommendation.
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct CalloutExtensionParameters {
        /// Callout extensions to be added. This is a required field.
        #[prost(message, repeated, tag = "1")]
        pub callout_extensions: ::std::vec::Vec<super::super::common::CalloutFeedItem>,
    }
    /// Parameters to use when applying call extension recommendation.
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct CallExtensionParameters {
        /// Call extensions to be added. This is a required field.
        #[prost(message, repeated, tag = "1")]
        pub call_extensions: ::std::vec::Vec<super::super::common::CallFeedItem>,
    }
    /// Parameters to use when applying sitelink extension recommendation.
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct SitelinkExtensionParameters {
        /// Sitelink extensions to be added. This is a required field.
        #[prost(message, repeated, tag = "1")]
        pub sitelink_extensions: ::std::vec::Vec<super::super::common::SitelinkFeedItem>,
    }
    /// Parameters to use when applying move unused budget recommendation.
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct MoveUnusedBudgetParameters {
        /// Budget amount to move from excess budget to constrained budget. This is
        /// a required field.
        #[prost(message, optional, tag = "1")]
        pub budget_micros_to_move: ::std::option::Option<i64>,
    }
    /// Parameters to use when applying the recommendation.
    #[derive(Clone, PartialEq, ::prost::Oneof)]
    pub enum ApplyParameters {
        /// Optional parameters to use when applying a campaign budget
        /// recommendation.
        #[prost(message, tag = "2")]
        CampaignBudget(CampaignBudgetParameters),
        /// Optional parameters to use when applying a text ad recommendation.
        #[prost(message, tag = "3")]
        TextAd(TextAdParameters),
        /// Optional parameters to use when applying keyword recommendation.
        #[prost(message, tag = "4")]
        Keyword(KeywordParameters),
        /// Optional parameters to use when applying target CPA opt-in
        /// recommendation.
        #[prost(message, tag = "5")]
        TargetCpaOptIn(TargetCpaOptInParameters),
        /// Parameters to use when applying callout extension recommendation.
        #[prost(message, tag = "6")]
        CalloutExtension(CalloutExtensionParameters),
        /// Parameters to use when applying call extension recommendation.
        #[prost(message, tag = "7")]
        CallExtension(CallExtensionParameters),
        /// Parameters to use when applying sitelink extension recommendation.
        #[prost(message, tag = "8")]
        SitelinkExtension(SitelinkExtensionParameters),
        /// Parameters to use when applying move unused budget recommendation.
        #[prost(message, tag = "9")]
        MoveUnusedBudget(MoveUnusedBudgetParameters),
    }
}
/// Response message for [RecommendationService.ApplyRecommendation][google.ads.googleads.v1.services.RecommendationService.ApplyRecommendation].
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ApplyRecommendationResponse {
    /// Results of operations to apply recommendations.
    #[prost(message, repeated, tag = "1")]
    pub results: ::std::vec::Vec<ApplyRecommendationResult>,
    /// Errors that pertain to operation failures in the partial failure mode.
    /// Returned only when partial_failure = true and all errors occur inside the
    /// operations. If any errors occur outside the operations (e.g. auth errors)
    /// we return the RPC level error.
    #[prost(message, optional, tag = "2")]
    pub partial_failure_error: ::std::option::Option<super::super::super::super::rpc::Status>,
}
/// The result of applying a recommendation.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ApplyRecommendationResult {
    /// Returned for successful applies.
    #[prost(string, tag = "1")]
    pub resource_name: std::string::String,
}
/// Request message for [RecommendationService.DismissRecommendation][google.ads.googleads.v1.services.RecommendationService.DismissRecommendation].
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct DismissRecommendationRequest {
    /// Required. The ID of the customer with the recommendation.
    #[prost(string, tag = "1")]
    pub customer_id: std::string::String,
    /// Required. The list of operations to dismiss recommendations.
    /// If partial_failure=false all recommendations should be of the same type
    /// There is a limit of 100 operations per request.
    #[prost(message, repeated, tag = "3")]
    pub operations: ::std::vec::Vec<dismiss_recommendation_request::DismissRecommendationOperation>,
    /// If true, successful operations will be carried out and invalid
    /// operations will return errors. If false, operations will be carried in a
    /// single transaction if and only if they are all valid.
    /// Default is false.
    #[prost(bool, tag = "2")]
    pub partial_failure: bool,
}
pub mod dismiss_recommendation_request {
    /// Operation to dismiss a single recommendation identified by resource_name.
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct DismissRecommendationOperation {
        /// The resource name of the recommendation to dismiss.
        #[prost(string, tag = "1")]
        pub resource_name: std::string::String,
    }
}
/// Response message for [RecommendationService.DismissRecommendation][google.ads.googleads.v1.services.RecommendationService.DismissRecommendation].
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct DismissRecommendationResponse {
    /// Results of operations to dismiss recommendations.
    #[prost(message, repeated, tag = "1")]
    pub results: ::std::vec::Vec<dismiss_recommendation_response::DismissRecommendationResult>,
    /// Errors that pertain to operation failures in the partial failure mode.
    /// Returned only when partial_failure = true and all errors occur inside the
    /// operations. If any errors occur outside the operations (e.g. auth errors)
    /// we return the RPC level error.
    #[prost(message, optional, tag = "2")]
    pub partial_failure_error: ::std::option::Option<super::super::super::super::rpc::Status>,
}
pub mod dismiss_recommendation_response {
    /// The result of dismissing a recommendation.
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct DismissRecommendationResult {
        /// Returned for successful dismissals.
        #[prost(string, tag = "1")]
        pub resource_name: std::string::String,
    }
}
#[doc = r" Generated client implementations."]
pub mod recommendation_service_client {
    #![allow(unused_variables, dead_code, missing_docs)]
    use tonic::codegen::*;
    #[doc = " Service to manage recommendations."]
    pub struct RecommendationServiceClient<T> {
        inner: tonic::client::Grpc<T>,
    }
    impl RecommendationServiceClient<tonic::transport::Channel> {
        #[doc = r" Attempt to create a new client by connecting to a given endpoint."]
        pub async fn connect<D>(dst: D) -> Result<Self, tonic::transport::Error>
        where
            D: std::convert::TryInto<tonic::transport::Endpoint>,
            D::Error: Into<StdError>,
        {
            let conn = tonic::transport::Endpoint::new(dst)?.connect().await?;
            Ok(Self::new(conn))
        }
    }
    impl<T> RecommendationServiceClient<T>
    where
        T: tonic::client::GrpcService<tonic::body::BoxBody>,
        T::ResponseBody: Body + HttpBody + Send + 'static,
        T::Error: Into<StdError>,
        <T::ResponseBody as HttpBody>::Error: Into<StdError> + Send,
    {
        pub fn new(inner: T) -> Self {
            let inner = tonic::client::Grpc::new(inner);
            Self { inner }
        }
        pub fn with_interceptor(inner: T, interceptor: impl Into<tonic::Interceptor>) -> Self {
            let inner = tonic::client::Grpc::with_interceptor(inner, interceptor);
            Self { inner }
        }
        #[doc = " Returns the requested recommendation in full detail."]
        pub async fn get_recommendation(
            &mut self,
            request: impl tonic::IntoRequest<super::GetRecommendationRequest>,
        ) -> Result<tonic::Response<super::super::resources::Recommendation>, tonic::Status>
        {
            self.inner.ready().await.map_err(|e| {
                tonic::Status::new(
                    tonic::Code::Unknown,
                    format!("Service was not ready: {}", e.into()),
                )
            })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.ads.googleads.v1.services.RecommendationService/GetRecommendation",
            );
            self.inner.unary(request.into_request(), path, codec).await
        }
        #[doc = " Applies given recommendations with corresponding apply parameters."]
        pub async fn apply_recommendation(
            &mut self,
            request: impl tonic::IntoRequest<super::ApplyRecommendationRequest>,
        ) -> Result<tonic::Response<super::ApplyRecommendationResponse>, tonic::Status> {
            self.inner.ready().await.map_err(|e| {
                tonic::Status::new(
                    tonic::Code::Unknown,
                    format!("Service was not ready: {}", e.into()),
                )
            })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.ads.googleads.v1.services.RecommendationService/ApplyRecommendation",
            );
            self.inner.unary(request.into_request(), path, codec).await
        }
        #[doc = " Dismisses given recommendations."]
        pub async fn dismiss_recommendation(
            &mut self,
            request: impl tonic::IntoRequest<super::DismissRecommendationRequest>,
        ) -> Result<tonic::Response<super::DismissRecommendationResponse>, tonic::Status> {
            self.inner.ready().await.map_err(|e| {
                tonic::Status::new(
                    tonic::Code::Unknown,
                    format!("Service was not ready: {}", e.into()),
                )
            })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.ads.googleads.v1.services.RecommendationService/DismissRecommendation",
            );
            self.inner.unary(request.into_request(), path, codec).await
        }
    }
    impl<T: Clone> Clone for RecommendationServiceClient<T> {
        fn clone(&self) -> Self {
            Self {
                inner: self.inner.clone(),
            }
        }
    }
    impl<T> std::fmt::Debug for RecommendationServiceClient<T> {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
            write!(f, "RecommendationServiceClient {{ ... }}")
        }
    }
}
#[doc = r" Generated server implementations."]
pub mod recommendation_service_server {
    #![allow(unused_variables, dead_code, missing_docs)]
    use tonic::codegen::*;
    #[doc = "Generated trait containing gRPC methods that should be implemented for use with RecommendationServiceServer."]
    #[async_trait]
    pub trait RecommendationService: Send + Sync + 'static {
        #[doc = " Returns the requested recommendation in full detail."]
        async fn get_recommendation(
            &self,
            request: tonic::Request<super::GetRecommendationRequest>,
        ) -> Result<tonic::Response<super::super::resources::Recommendation>, tonic::Status>;
        #[doc = " Applies given recommendations with corresponding apply parameters."]
        async fn apply_recommendation(
            &self,
            request: tonic::Request<super::ApplyRecommendationRequest>,
        ) -> Result<tonic::Response<super::ApplyRecommendationResponse>, tonic::Status>;
        #[doc = " Dismisses given recommendations."]
        async fn dismiss_recommendation(
            &self,
            request: tonic::Request<super::DismissRecommendationRequest>,
        ) -> Result<tonic::Response<super::DismissRecommendationResponse>, tonic::Status>;
    }
    #[doc = " Service to manage recommendations."]
    #[derive(Debug)]
    #[doc(hidden)]
    pub struct RecommendationServiceServer<T: RecommendationService> {
        inner: _Inner<T>,
    }
    struct _Inner<T>(Arc<T>, Option<tonic::Interceptor>);
    impl<T: RecommendationService> RecommendationServiceServer<T> {
        pub fn new(inner: T) -> Self {
            let inner = Arc::new(inner);
            let inner = _Inner(inner, None);
            Self { inner }
        }
        pub fn with_interceptor(inner: T, interceptor: impl Into<tonic::Interceptor>) -> Self {
            let inner = Arc::new(inner);
            let inner = _Inner(inner, Some(interceptor.into()));
            Self { inner }
        }
    }
    impl<T, B> Service<http::Request<B>> for RecommendationServiceServer<T>
    where
        T: RecommendationService,
        B: HttpBody + Send + Sync + 'static,
        B::Error: Into<StdError> + Send + 'static,
    {
        type Response = http::Response<tonic::body::BoxBody>;
        type Error = Never;
        type Future = BoxFuture<Self::Response, Self::Error>;
        fn poll_ready(&mut self, _cx: &mut Context<'_>) -> Poll<Result<(), Self::Error>> {
            Poll::Ready(Ok(()))
        }
        fn call(&mut self, req: http::Request<B>) -> Self::Future {
            let inner = self.inner.clone();
            match req.uri().path() {
                "/google.ads.googleads.v1.services.RecommendationService/GetRecommendation" => {
                    #[allow(non_camel_case_types)]
                    struct GetRecommendationSvc<T: RecommendationService>(pub Arc<T>);
                    impl<T: RecommendationService>
                        tonic::server::UnaryService<super::GetRecommendationRequest>
                        for GetRecommendationSvc<T>
                    {
                        type Response = super::super::resources::Recommendation;
                        type Future = BoxFuture<tonic::Response<Self::Response>, tonic::Status>;
                        fn call(
                            &mut self,
                            request: tonic::Request<super::GetRecommendationRequest>,
                        ) -> Self::Future {
                            let inner = self.0.clone();
                            let fut = async move { inner.get_recommendation(request).await };
                            Box::pin(fut)
                        }
                    }
                    let inner = self.inner.clone();
                    let fut = async move {
                        let interceptor = inner.1.clone();
                        let inner = inner.0;
                        let method = GetRecommendationSvc(inner);
                        let codec = tonic::codec::ProstCodec::default();
                        let mut grpc = if let Some(interceptor) = interceptor {
                            tonic::server::Grpc::with_interceptor(codec, interceptor)
                        } else {
                            tonic::server::Grpc::new(codec)
                        };
                        let res = grpc.unary(method, req).await;
                        Ok(res)
                    };
                    Box::pin(fut)
                }
                "/google.ads.googleads.v1.services.RecommendationService/ApplyRecommendation" => {
                    #[allow(non_camel_case_types)]
                    struct ApplyRecommendationSvc<T: RecommendationService>(pub Arc<T>);
                    impl<T: RecommendationService>
                        tonic::server::UnaryService<super::ApplyRecommendationRequest>
                        for ApplyRecommendationSvc<T>
                    {
                        type Response = super::ApplyRecommendationResponse;
                        type Future = BoxFuture<tonic::Response<Self::Response>, tonic::Status>;
                        fn call(
                            &mut self,
                            request: tonic::Request<super::ApplyRecommendationRequest>,
                        ) -> Self::Future {
                            let inner = self.0.clone();
                            let fut = async move { inner.apply_recommendation(request).await };
                            Box::pin(fut)
                        }
                    }
                    let inner = self.inner.clone();
                    let fut = async move {
                        let interceptor = inner.1.clone();
                        let inner = inner.0;
                        let method = ApplyRecommendationSvc(inner);
                        let codec = tonic::codec::ProstCodec::default();
                        let mut grpc = if let Some(interceptor) = interceptor {
                            tonic::server::Grpc::with_interceptor(codec, interceptor)
                        } else {
                            tonic::server::Grpc::new(codec)
                        };
                        let res = grpc.unary(method, req).await;
                        Ok(res)
                    };
                    Box::pin(fut)
                }
                "/google.ads.googleads.v1.services.RecommendationService/DismissRecommendation" => {
                    #[allow(non_camel_case_types)]
                    struct DismissRecommendationSvc<T: RecommendationService>(pub Arc<T>);
                    impl<T: RecommendationService>
                        tonic::server::UnaryService<super::DismissRecommendationRequest>
                        for DismissRecommendationSvc<T>
                    {
                        type Response = super::DismissRecommendationResponse;
                        type Future = BoxFuture<tonic::Response<Self::Response>, tonic::Status>;
                        fn call(
                            &mut self,
                            request: tonic::Request<super::DismissRecommendationRequest>,
                        ) -> Self::Future {
                            let inner = self.0.clone();
                            let fut = async move { inner.dismiss_recommendation(request).await };
                            Box::pin(fut)
                        }
                    }
                    let inner = self.inner.clone();
                    let fut = async move {
                        let interceptor = inner.1.clone();
                        let inner = inner.0;
                        let method = DismissRecommendationSvc(inner);
                        let codec = tonic::codec::ProstCodec::default();
                        let mut grpc = if let Some(interceptor) = interceptor {
                            tonic::server::Grpc::with_interceptor(codec, interceptor)
                        } else {
                            tonic::server::Grpc::new(codec)
                        };
                        let res = grpc.unary(method, req).await;
                        Ok(res)
                    };
                    Box::pin(fut)
                }
                _ => Box::pin(async move {
                    Ok(http::Response::builder()
                        .status(200)
                        .header("grpc-status", "12")
                        .body(tonic::body::BoxBody::empty())
                        .unwrap())
                }),
            }
        }
    }
    impl<T: RecommendationService> Clone for RecommendationServiceServer<T> {
        fn clone(&self) -> Self {
            let inner = self.inner.clone();
            Self { inner }
        }
    }
    impl<T: RecommendationService> Clone for _Inner<T> {
        fn clone(&self) -> Self {
            Self(self.0.clone(), self.1.clone())
        }
    }
    impl<T: std::fmt::Debug> std::fmt::Debug for _Inner<T> {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
            write!(f, "{:?}", self.0)
        }
    }
    impl<T: RecommendationService> tonic::transport::NamedService for RecommendationServiceServer<T> {
        const NAME: &'static str = "google.ads.googleads.v1.services.RecommendationService";
    }
}
/// Request message for [SearchTermViewService.GetSearchTermView][google.ads.googleads.v1.services.SearchTermViewService.GetSearchTermView].
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GetSearchTermViewRequest {
    /// Required. The resource name of the search term view to fetch.
    #[prost(string, tag = "1")]
    pub resource_name: std::string::String,
}
#[doc = r" Generated client implementations."]
pub mod search_term_view_service_client {
    #![allow(unused_variables, dead_code, missing_docs)]
    use tonic::codegen::*;
    #[doc = " Service to manage search term views."]
    pub struct SearchTermViewServiceClient<T> {
        inner: tonic::client::Grpc<T>,
    }
    impl SearchTermViewServiceClient<tonic::transport::Channel> {
        #[doc = r" Attempt to create a new client by connecting to a given endpoint."]
        pub async fn connect<D>(dst: D) -> Result<Self, tonic::transport::Error>
        where
            D: std::convert::TryInto<tonic::transport::Endpoint>,
            D::Error: Into<StdError>,
        {
            let conn = tonic::transport::Endpoint::new(dst)?.connect().await?;
            Ok(Self::new(conn))
        }
    }
    impl<T> SearchTermViewServiceClient<T>
    where
        T: tonic::client::GrpcService<tonic::body::BoxBody>,
        T::ResponseBody: Body + HttpBody + Send + 'static,
        T::Error: Into<StdError>,
        <T::ResponseBody as HttpBody>::Error: Into<StdError> + Send,
    {
        pub fn new(inner: T) -> Self {
            let inner = tonic::client::Grpc::new(inner);
            Self { inner }
        }
        pub fn with_interceptor(inner: T, interceptor: impl Into<tonic::Interceptor>) -> Self {
            let inner = tonic::client::Grpc::with_interceptor(inner, interceptor);
            Self { inner }
        }
        #[doc = " Returns the attributes of the requested search term view."]
        pub async fn get_search_term_view(
            &mut self,
            request: impl tonic::IntoRequest<super::GetSearchTermViewRequest>,
        ) -> Result<tonic::Response<super::super::resources::SearchTermView>, tonic::Status>
        {
            self.inner.ready().await.map_err(|e| {
                tonic::Status::new(
                    tonic::Code::Unknown,
                    format!("Service was not ready: {}", e.into()),
                )
            })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.ads.googleads.v1.services.SearchTermViewService/GetSearchTermView",
            );
            self.inner.unary(request.into_request(), path, codec).await
        }
    }
    impl<T: Clone> Clone for SearchTermViewServiceClient<T> {
        fn clone(&self) -> Self {
            Self {
                inner: self.inner.clone(),
            }
        }
    }
    impl<T> std::fmt::Debug for SearchTermViewServiceClient<T> {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
            write!(f, "SearchTermViewServiceClient {{ ... }}")
        }
    }
}
#[doc = r" Generated server implementations."]
pub mod search_term_view_service_server {
    #![allow(unused_variables, dead_code, missing_docs)]
    use tonic::codegen::*;
    #[doc = "Generated trait containing gRPC methods that should be implemented for use with SearchTermViewServiceServer."]
    #[async_trait]
    pub trait SearchTermViewService: Send + Sync + 'static {
        #[doc = " Returns the attributes of the requested search term view."]
        async fn get_search_term_view(
            &self,
            request: tonic::Request<super::GetSearchTermViewRequest>,
        ) -> Result<tonic::Response<super::super::resources::SearchTermView>, tonic::Status>;
    }
    #[doc = " Service to manage search term views."]
    #[derive(Debug)]
    #[doc(hidden)]
    pub struct SearchTermViewServiceServer<T: SearchTermViewService> {
        inner: _Inner<T>,
    }
    struct _Inner<T>(Arc<T>, Option<tonic::Interceptor>);
    impl<T: SearchTermViewService> SearchTermViewServiceServer<T> {
        pub fn new(inner: T) -> Self {
            let inner = Arc::new(inner);
            let inner = _Inner(inner, None);
            Self { inner }
        }
        pub fn with_interceptor(inner: T, interceptor: impl Into<tonic::Interceptor>) -> Self {
            let inner = Arc::new(inner);
            let inner = _Inner(inner, Some(interceptor.into()));
            Self { inner }
        }
    }
    impl<T, B> Service<http::Request<B>> for SearchTermViewServiceServer<T>
    where
        T: SearchTermViewService,
        B: HttpBody + Send + Sync + 'static,
        B::Error: Into<StdError> + Send + 'static,
    {
        type Response = http::Response<tonic::body::BoxBody>;
        type Error = Never;
        type Future = BoxFuture<Self::Response, Self::Error>;
        fn poll_ready(&mut self, _cx: &mut Context<'_>) -> Poll<Result<(), Self::Error>> {
            Poll::Ready(Ok(()))
        }
        fn call(&mut self, req: http::Request<B>) -> Self::Future {
            let inner = self.inner.clone();
            match req.uri().path() {
                "/google.ads.googleads.v1.services.SearchTermViewService/GetSearchTermView" => {
                    #[allow(non_camel_case_types)]
                    struct GetSearchTermViewSvc<T: SearchTermViewService>(pub Arc<T>);
                    impl<T: SearchTermViewService>
                        tonic::server::UnaryService<super::GetSearchTermViewRequest>
                        for GetSearchTermViewSvc<T>
                    {
                        type Response = super::super::resources::SearchTermView;
                        type Future = BoxFuture<tonic::Response<Self::Response>, tonic::Status>;
                        fn call(
                            &mut self,
                            request: tonic::Request<super::GetSearchTermViewRequest>,
                        ) -> Self::Future {
                            let inner = self.0.clone();
                            let fut = async move { inner.get_search_term_view(request).await };
                            Box::pin(fut)
                        }
                    }
                    let inner = self.inner.clone();
                    let fut = async move {
                        let interceptor = inner.1.clone();
                        let inner = inner.0;
                        let method = GetSearchTermViewSvc(inner);
                        let codec = tonic::codec::ProstCodec::default();
                        let mut grpc = if let Some(interceptor) = interceptor {
                            tonic::server::Grpc::with_interceptor(codec, interceptor)
                        } else {
                            tonic::server::Grpc::new(codec)
                        };
                        let res = grpc.unary(method, req).await;
                        Ok(res)
                    };
                    Box::pin(fut)
                }
                _ => Box::pin(async move {
                    Ok(http::Response::builder()
                        .status(200)
                        .header("grpc-status", "12")
                        .body(tonic::body::BoxBody::empty())
                        .unwrap())
                }),
            }
        }
    }
    impl<T: SearchTermViewService> Clone for SearchTermViewServiceServer<T> {
        fn clone(&self) -> Self {
            let inner = self.inner.clone();
            Self { inner }
        }
    }
    impl<T: SearchTermViewService> Clone for _Inner<T> {
        fn clone(&self) -> Self {
            Self(self.0.clone(), self.1.clone())
        }
    }
    impl<T: std::fmt::Debug> std::fmt::Debug for _Inner<T> {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
            write!(f, "{:?}", self.0)
        }
    }
    impl<T: SearchTermViewService> tonic::transport::NamedService for SearchTermViewServiceServer<T> {
        const NAME: &'static str = "google.ads.googleads.v1.services.SearchTermViewService";
    }
}
/// Request message for
/// [ShoppingPerformanceViewService.GetShoppingPerformanceView][google.ads.googleads.v1.services.ShoppingPerformanceViewService.GetShoppingPerformanceView].
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GetShoppingPerformanceViewRequest {
    /// Required. The resource name of the Shopping performance view to fetch.
    #[prost(string, tag = "1")]
    pub resource_name: std::string::String,
}
#[doc = r" Generated client implementations."]
pub mod shopping_performance_view_service_client {
    #![allow(unused_variables, dead_code, missing_docs)]
    use tonic::codegen::*;
    #[doc = " Service to fetch Shopping performance views."]
    pub struct ShoppingPerformanceViewServiceClient<T> {
        inner: tonic::client::Grpc<T>,
    }
    impl ShoppingPerformanceViewServiceClient<tonic::transport::Channel> {
        #[doc = r" Attempt to create a new client by connecting to a given endpoint."]
        pub async fn connect<D>(dst: D) -> Result<Self, tonic::transport::Error>
        where
            D: std::convert::TryInto<tonic::transport::Endpoint>,
            D::Error: Into<StdError>,
        {
            let conn = tonic::transport::Endpoint::new(dst)?.connect().await?;
            Ok(Self::new(conn))
        }
    }
    impl<T> ShoppingPerformanceViewServiceClient<T>
    where
        T: tonic::client::GrpcService<tonic::body::BoxBody>,
        T::ResponseBody: Body + HttpBody + Send + 'static,
        T::Error: Into<StdError>,
        <T::ResponseBody as HttpBody>::Error: Into<StdError> + Send,
    {
        pub fn new(inner: T) -> Self {
            let inner = tonic::client::Grpc::new(inner);
            Self { inner }
        }
        pub fn with_interceptor(inner: T, interceptor: impl Into<tonic::Interceptor>) -> Self {
            let inner = tonic::client::Grpc::with_interceptor(inner, interceptor);
            Self { inner }
        }
        #[doc = " Returns the requested Shopping performance view in full detail."]
        pub async fn get_shopping_performance_view(
            &mut self,
            request: impl tonic::IntoRequest<super::GetShoppingPerformanceViewRequest>,
        ) -> Result<tonic::Response<super::super::resources::ShoppingPerformanceView>, tonic::Status>
        {
            self.inner.ready().await.map_err(|e| {
                tonic::Status::new(
                    tonic::Code::Unknown,
                    format!("Service was not ready: {}", e.into()),
                )
            })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http :: uri :: PathAndQuery :: from_static ( "/google.ads.googleads.v1.services.ShoppingPerformanceViewService/GetShoppingPerformanceView" ) ;
            self.inner.unary(request.into_request(), path, codec).await
        }
    }
    impl<T: Clone> Clone for ShoppingPerformanceViewServiceClient<T> {
        fn clone(&self) -> Self {
            Self {
                inner: self.inner.clone(),
            }
        }
    }
    impl<T> std::fmt::Debug for ShoppingPerformanceViewServiceClient<T> {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
            write!(f, "ShoppingPerformanceViewServiceClient {{ ... }}")
        }
    }
}
#[doc = r" Generated server implementations."]
pub mod shopping_performance_view_service_server {
    #![allow(unused_variables, dead_code, missing_docs)]
    use tonic::codegen::*;
    #[doc = "Generated trait containing gRPC methods that should be implemented for use with ShoppingPerformanceViewServiceServer."]
    #[async_trait]
    pub trait ShoppingPerformanceViewService: Send + Sync + 'static {
        #[doc = " Returns the requested Shopping performance view in full detail."]
        async fn get_shopping_performance_view(
            &self,
            request: tonic::Request<super::GetShoppingPerformanceViewRequest>,
        ) -> Result<tonic::Response<super::super::resources::ShoppingPerformanceView>, tonic::Status>;
    }
    #[doc = " Service to fetch Shopping performance views."]
    #[derive(Debug)]
    #[doc(hidden)]
    pub struct ShoppingPerformanceViewServiceServer<T: ShoppingPerformanceViewService> {
        inner: _Inner<T>,
    }
    struct _Inner<T>(Arc<T>, Option<tonic::Interceptor>);
    impl<T: ShoppingPerformanceViewService> ShoppingPerformanceViewServiceServer<T> {
        pub fn new(inner: T) -> Self {
            let inner = Arc::new(inner);
            let inner = _Inner(inner, None);
            Self { inner }
        }
        pub fn with_interceptor(inner: T, interceptor: impl Into<tonic::Interceptor>) -> Self {
            let inner = Arc::new(inner);
            let inner = _Inner(inner, Some(interceptor.into()));
            Self { inner }
        }
    }
    impl<T, B> Service<http::Request<B>> for ShoppingPerformanceViewServiceServer<T>
    where
        T: ShoppingPerformanceViewService,
        B: HttpBody + Send + Sync + 'static,
        B::Error: Into<StdError> + Send + 'static,
    {
        type Response = http::Response<tonic::body::BoxBody>;
        type Error = Never;
        type Future = BoxFuture<Self::Response, Self::Error>;
        fn poll_ready(&mut self, _cx: &mut Context<'_>) -> Poll<Result<(), Self::Error>> {
            Poll::Ready(Ok(()))
        }
        fn call(&mut self, req: http::Request<B>) -> Self::Future {
            let inner = self.inner.clone();
            match req . uri ( ) . path ( ) { "/google.ads.googleads.v1.services.ShoppingPerformanceViewService/GetShoppingPerformanceView" => { # [ allow ( non_camel_case_types ) ] struct GetShoppingPerformanceViewSvc < T : ShoppingPerformanceViewService > ( pub Arc < T > ) ; impl < T : ShoppingPerformanceViewService > tonic :: server :: UnaryService < super :: GetShoppingPerformanceViewRequest > for GetShoppingPerformanceViewSvc < T > { type Response = super :: super :: resources :: ShoppingPerformanceView ; type Future = BoxFuture < tonic :: Response < Self :: Response > , tonic :: Status > ; fn call ( & mut self , request : tonic :: Request < super :: GetShoppingPerformanceViewRequest > ) -> Self :: Future { let inner = self . 0 . clone ( ) ; let fut = async move { inner . get_shopping_performance_view ( request ) . await } ; Box :: pin ( fut ) } } let inner = self . inner . clone ( ) ; let fut = async move { let interceptor = inner . 1 . clone ( ) ; let inner = inner . 0 ; let method = GetShoppingPerformanceViewSvc ( inner ) ; let codec = tonic :: codec :: ProstCodec :: default ( ) ; let mut grpc = if let Some ( interceptor ) = interceptor { tonic :: server :: Grpc :: with_interceptor ( codec , interceptor ) } else { tonic :: server :: Grpc :: new ( codec ) } ; let res = grpc . unary ( method , req ) . await ; Ok ( res ) } ; Box :: pin ( fut ) } _ => Box :: pin ( async move { Ok ( http :: Response :: builder ( ) . status ( 200 ) . header ( "grpc-status" , "12" ) . body ( tonic :: body :: BoxBody :: empty ( ) ) . unwrap ( ) ) } ) , }
        }
    }
    impl<T: ShoppingPerformanceViewService> Clone for ShoppingPerformanceViewServiceServer<T> {
        fn clone(&self) -> Self {
            let inner = self.inner.clone();
            Self { inner }
        }
    }
    impl<T: ShoppingPerformanceViewService> Clone for _Inner<T> {
        fn clone(&self) -> Self {
            Self(self.0.clone(), self.1.clone())
        }
    }
    impl<T: std::fmt::Debug> std::fmt::Debug for _Inner<T> {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
            write!(f, "{:?}", self.0)
        }
    }
    impl<T: ShoppingPerformanceViewService> tonic::transport::NamedService
        for ShoppingPerformanceViewServiceServer<T>
    {
        const NAME: &'static str =
            "google.ads.googleads.v1.services.ShoppingPerformanceViewService";
    }
}
/// Request message for [TopicConstantService.GetTopicConstant][google.ads.googleads.v1.services.TopicConstantService.GetTopicConstant].
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GetTopicConstantRequest {
    /// Required. Resource name of the Topic to fetch.
    #[prost(string, tag = "1")]
    pub resource_name: std::string::String,
}
#[doc = r" Generated client implementations."]
pub mod topic_constant_service_client {
    #![allow(unused_variables, dead_code, missing_docs)]
    use tonic::codegen::*;
    #[doc = " Service to fetch topic constants."]
    pub struct TopicConstantServiceClient<T> {
        inner: tonic::client::Grpc<T>,
    }
    impl TopicConstantServiceClient<tonic::transport::Channel> {
        #[doc = r" Attempt to create a new client by connecting to a given endpoint."]
        pub async fn connect<D>(dst: D) -> Result<Self, tonic::transport::Error>
        where
            D: std::convert::TryInto<tonic::transport::Endpoint>,
            D::Error: Into<StdError>,
        {
            let conn = tonic::transport::Endpoint::new(dst)?.connect().await?;
            Ok(Self::new(conn))
        }
    }
    impl<T> TopicConstantServiceClient<T>
    where
        T: tonic::client::GrpcService<tonic::body::BoxBody>,
        T::ResponseBody: Body + HttpBody + Send + 'static,
        T::Error: Into<StdError>,
        <T::ResponseBody as HttpBody>::Error: Into<StdError> + Send,
    {
        pub fn new(inner: T) -> Self {
            let inner = tonic::client::Grpc::new(inner);
            Self { inner }
        }
        pub fn with_interceptor(inner: T, interceptor: impl Into<tonic::Interceptor>) -> Self {
            let inner = tonic::client::Grpc::with_interceptor(inner, interceptor);
            Self { inner }
        }
        #[doc = " Returns the requested topic constant in full detail."]
        pub async fn get_topic_constant(
            &mut self,
            request: impl tonic::IntoRequest<super::GetTopicConstantRequest>,
        ) -> Result<tonic::Response<super::super::resources::TopicConstant>, tonic::Status>
        {
            self.inner.ready().await.map_err(|e| {
                tonic::Status::new(
                    tonic::Code::Unknown,
                    format!("Service was not ready: {}", e.into()),
                )
            })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.ads.googleads.v1.services.TopicConstantService/GetTopicConstant",
            );
            self.inner.unary(request.into_request(), path, codec).await
        }
    }
    impl<T: Clone> Clone for TopicConstantServiceClient<T> {
        fn clone(&self) -> Self {
            Self {
                inner: self.inner.clone(),
            }
        }
    }
    impl<T> std::fmt::Debug for TopicConstantServiceClient<T> {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
            write!(f, "TopicConstantServiceClient {{ ... }}")
        }
    }
}
#[doc = r" Generated server implementations."]
pub mod topic_constant_service_server {
    #![allow(unused_variables, dead_code, missing_docs)]
    use tonic::codegen::*;
    #[doc = "Generated trait containing gRPC methods that should be implemented for use with TopicConstantServiceServer."]
    #[async_trait]
    pub trait TopicConstantService: Send + Sync + 'static {
        #[doc = " Returns the requested topic constant in full detail."]
        async fn get_topic_constant(
            &self,
            request: tonic::Request<super::GetTopicConstantRequest>,
        ) -> Result<tonic::Response<super::super::resources::TopicConstant>, tonic::Status>;
    }
    #[doc = " Service to fetch topic constants."]
    #[derive(Debug)]
    #[doc(hidden)]
    pub struct TopicConstantServiceServer<T: TopicConstantService> {
        inner: _Inner<T>,
    }
    struct _Inner<T>(Arc<T>, Option<tonic::Interceptor>);
    impl<T: TopicConstantService> TopicConstantServiceServer<T> {
        pub fn new(inner: T) -> Self {
            let inner = Arc::new(inner);
            let inner = _Inner(inner, None);
            Self { inner }
        }
        pub fn with_interceptor(inner: T, interceptor: impl Into<tonic::Interceptor>) -> Self {
            let inner = Arc::new(inner);
            let inner = _Inner(inner, Some(interceptor.into()));
            Self { inner }
        }
    }
    impl<T, B> Service<http::Request<B>> for TopicConstantServiceServer<T>
    where
        T: TopicConstantService,
        B: HttpBody + Send + Sync + 'static,
        B::Error: Into<StdError> + Send + 'static,
    {
        type Response = http::Response<tonic::body::BoxBody>;
        type Error = Never;
        type Future = BoxFuture<Self::Response, Self::Error>;
        fn poll_ready(&mut self, _cx: &mut Context<'_>) -> Poll<Result<(), Self::Error>> {
            Poll::Ready(Ok(()))
        }
        fn call(&mut self, req: http::Request<B>) -> Self::Future {
            let inner = self.inner.clone();
            match req.uri().path() {
                "/google.ads.googleads.v1.services.TopicConstantService/GetTopicConstant" => {
                    #[allow(non_camel_case_types)]
                    struct GetTopicConstantSvc<T: TopicConstantService>(pub Arc<T>);
                    impl<T: TopicConstantService>
                        tonic::server::UnaryService<super::GetTopicConstantRequest>
                        for GetTopicConstantSvc<T>
                    {
                        type Response = super::super::resources::TopicConstant;
                        type Future = BoxFuture<tonic::Response<Self::Response>, tonic::Status>;
                        fn call(
                            &mut self,
                            request: tonic::Request<super::GetTopicConstantRequest>,
                        ) -> Self::Future {
                            let inner = self.0.clone();
                            let fut = async move { inner.get_topic_constant(request).await };
                            Box::pin(fut)
                        }
                    }
                    let inner = self.inner.clone();
                    let fut = async move {
                        let interceptor = inner.1.clone();
                        let inner = inner.0;
                        let method = GetTopicConstantSvc(inner);
                        let codec = tonic::codec::ProstCodec::default();
                        let mut grpc = if let Some(interceptor) = interceptor {
                            tonic::server::Grpc::with_interceptor(codec, interceptor)
                        } else {
                            tonic::server::Grpc::new(codec)
                        };
                        let res = grpc.unary(method, req).await;
                        Ok(res)
                    };
                    Box::pin(fut)
                }
                _ => Box::pin(async move {
                    Ok(http::Response::builder()
                        .status(200)
                        .header("grpc-status", "12")
                        .body(tonic::body::BoxBody::empty())
                        .unwrap())
                }),
            }
        }
    }
    impl<T: TopicConstantService> Clone for TopicConstantServiceServer<T> {
        fn clone(&self) -> Self {
            let inner = self.inner.clone();
            Self { inner }
        }
    }
    impl<T: TopicConstantService> Clone for _Inner<T> {
        fn clone(&self) -> Self {
            Self(self.0.clone(), self.1.clone())
        }
    }
    impl<T: std::fmt::Debug> std::fmt::Debug for _Inner<T> {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
            write!(f, "{:?}", self.0)
        }
    }
    impl<T: TopicConstantService> tonic::transport::NamedService for TopicConstantServiceServer<T> {
        const NAME: &'static str = "google.ads.googleads.v1.services.TopicConstantService";
    }
}
/// Request message for [TopicViewService.GetTopicView][google.ads.googleads.v1.services.TopicViewService.GetTopicView].
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GetTopicViewRequest {
    /// Required. The resource name of the topic view to fetch.
    #[prost(string, tag = "1")]
    pub resource_name: std::string::String,
}
#[doc = r" Generated client implementations."]
pub mod topic_view_service_client {
    #![allow(unused_variables, dead_code, missing_docs)]
    use tonic::codegen::*;
    #[doc = " Service to manage topic views."]
    pub struct TopicViewServiceClient<T> {
        inner: tonic::client::Grpc<T>,
    }
    impl TopicViewServiceClient<tonic::transport::Channel> {
        #[doc = r" Attempt to create a new client by connecting to a given endpoint."]
        pub async fn connect<D>(dst: D) -> Result<Self, tonic::transport::Error>
        where
            D: std::convert::TryInto<tonic::transport::Endpoint>,
            D::Error: Into<StdError>,
        {
            let conn = tonic::transport::Endpoint::new(dst)?.connect().await?;
            Ok(Self::new(conn))
        }
    }
    impl<T> TopicViewServiceClient<T>
    where
        T: tonic::client::GrpcService<tonic::body::BoxBody>,
        T::ResponseBody: Body + HttpBody + Send + 'static,
        T::Error: Into<StdError>,
        <T::ResponseBody as HttpBody>::Error: Into<StdError> + Send,
    {
        pub fn new(inner: T) -> Self {
            let inner = tonic::client::Grpc::new(inner);
            Self { inner }
        }
        pub fn with_interceptor(inner: T, interceptor: impl Into<tonic::Interceptor>) -> Self {
            let inner = tonic::client::Grpc::with_interceptor(inner, interceptor);
            Self { inner }
        }
        #[doc = " Returns the requested topic view in full detail."]
        pub async fn get_topic_view(
            &mut self,
            request: impl tonic::IntoRequest<super::GetTopicViewRequest>,
        ) -> Result<tonic::Response<super::super::resources::TopicView>, tonic::Status> {
            self.inner.ready().await.map_err(|e| {
                tonic::Status::new(
                    tonic::Code::Unknown,
                    format!("Service was not ready: {}", e.into()),
                )
            })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.ads.googleads.v1.services.TopicViewService/GetTopicView",
            );
            self.inner.unary(request.into_request(), path, codec).await
        }
    }
    impl<T: Clone> Clone for TopicViewServiceClient<T> {
        fn clone(&self) -> Self {
            Self {
                inner: self.inner.clone(),
            }
        }
    }
    impl<T> std::fmt::Debug for TopicViewServiceClient<T> {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
            write!(f, "TopicViewServiceClient {{ ... }}")
        }
    }
}
#[doc = r" Generated server implementations."]
pub mod topic_view_service_server {
    #![allow(unused_variables, dead_code, missing_docs)]
    use tonic::codegen::*;
    #[doc = "Generated trait containing gRPC methods that should be implemented for use with TopicViewServiceServer."]
    #[async_trait]
    pub trait TopicViewService: Send + Sync + 'static {
        #[doc = " Returns the requested topic view in full detail."]
        async fn get_topic_view(
            &self,
            request: tonic::Request<super::GetTopicViewRequest>,
        ) -> Result<tonic::Response<super::super::resources::TopicView>, tonic::Status>;
    }
    #[doc = " Service to manage topic views."]
    #[derive(Debug)]
    #[doc(hidden)]
    pub struct TopicViewServiceServer<T: TopicViewService> {
        inner: _Inner<T>,
    }
    struct _Inner<T>(Arc<T>, Option<tonic::Interceptor>);
    impl<T: TopicViewService> TopicViewServiceServer<T> {
        pub fn new(inner: T) -> Self {
            let inner = Arc::new(inner);
            let inner = _Inner(inner, None);
            Self { inner }
        }
        pub fn with_interceptor(inner: T, interceptor: impl Into<tonic::Interceptor>) -> Self {
            let inner = Arc::new(inner);
            let inner = _Inner(inner, Some(interceptor.into()));
            Self { inner }
        }
    }
    impl<T, B> Service<http::Request<B>> for TopicViewServiceServer<T>
    where
        T: TopicViewService,
        B: HttpBody + Send + Sync + 'static,
        B::Error: Into<StdError> + Send + 'static,
    {
        type Response = http::Response<tonic::body::BoxBody>;
        type Error = Never;
        type Future = BoxFuture<Self::Response, Self::Error>;
        fn poll_ready(&mut self, _cx: &mut Context<'_>) -> Poll<Result<(), Self::Error>> {
            Poll::Ready(Ok(()))
        }
        fn call(&mut self, req: http::Request<B>) -> Self::Future {
            let inner = self.inner.clone();
            match req.uri().path() {
                "/google.ads.googleads.v1.services.TopicViewService/GetTopicView" => {
                    #[allow(non_camel_case_types)]
                    struct GetTopicViewSvc<T: TopicViewService>(pub Arc<T>);
                    impl<T: TopicViewService>
                        tonic::server::UnaryService<super::GetTopicViewRequest>
                        for GetTopicViewSvc<T>
                    {
                        type Response = super::super::resources::TopicView;
                        type Future = BoxFuture<tonic::Response<Self::Response>, tonic::Status>;
                        fn call(
                            &mut self,
                            request: tonic::Request<super::GetTopicViewRequest>,
                        ) -> Self::Future {
                            let inner = self.0.clone();
                            let fut = async move { inner.get_topic_view(request).await };
                            Box::pin(fut)
                        }
                    }
                    let inner = self.inner.clone();
                    let fut = async move {
                        let interceptor = inner.1.clone();
                        let inner = inner.0;
                        let method = GetTopicViewSvc(inner);
                        let codec = tonic::codec::ProstCodec::default();
                        let mut grpc = if let Some(interceptor) = interceptor {
                            tonic::server::Grpc::with_interceptor(codec, interceptor)
                        } else {
                            tonic::server::Grpc::new(codec)
                        };
                        let res = grpc.unary(method, req).await;
                        Ok(res)
                    };
                    Box::pin(fut)
                }
                _ => Box::pin(async move {
                    Ok(http::Response::builder()
                        .status(200)
                        .header("grpc-status", "12")
                        .body(tonic::body::BoxBody::empty())
                        .unwrap())
                }),
            }
        }
    }
    impl<T: TopicViewService> Clone for TopicViewServiceServer<T> {
        fn clone(&self) -> Self {
            let inner = self.inner.clone();
            Self { inner }
        }
    }
    impl<T: TopicViewService> Clone for _Inner<T> {
        fn clone(&self) -> Self {
            Self(self.0.clone(), self.1.clone())
        }
    }
    impl<T: std::fmt::Debug> std::fmt::Debug for _Inner<T> {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
            write!(f, "{:?}", self.0)
        }
    }
    impl<T: TopicViewService> tonic::transport::NamedService for TopicViewServiceServer<T> {
        const NAME: &'static str = "google.ads.googleads.v1.services.TopicViewService";
    }
}
/// Request message for [UserInterestService.GetUserInterest][google.ads.googleads.v1.services.UserInterestService.GetUserInterest].
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GetUserInterestRequest {
    /// Required. Resource name of the UserInterest to fetch.
    #[prost(string, tag = "1")]
    pub resource_name: std::string::String,
}
#[doc = r" Generated client implementations."]
pub mod user_interest_service_client {
    #![allow(unused_variables, dead_code, missing_docs)]
    use tonic::codegen::*;
    #[doc = " Service to fetch Google Ads User Interest."]
    pub struct UserInterestServiceClient<T> {
        inner: tonic::client::Grpc<T>,
    }
    impl UserInterestServiceClient<tonic::transport::Channel> {
        #[doc = r" Attempt to create a new client by connecting to a given endpoint."]
        pub async fn connect<D>(dst: D) -> Result<Self, tonic::transport::Error>
        where
            D: std::convert::TryInto<tonic::transport::Endpoint>,
            D::Error: Into<StdError>,
        {
            let conn = tonic::transport::Endpoint::new(dst)?.connect().await?;
            Ok(Self::new(conn))
        }
    }
    impl<T> UserInterestServiceClient<T>
    where
        T: tonic::client::GrpcService<tonic::body::BoxBody>,
        T::ResponseBody: Body + HttpBody + Send + 'static,
        T::Error: Into<StdError>,
        <T::ResponseBody as HttpBody>::Error: Into<StdError> + Send,
    {
        pub fn new(inner: T) -> Self {
            let inner = tonic::client::Grpc::new(inner);
            Self { inner }
        }
        pub fn with_interceptor(inner: T, interceptor: impl Into<tonic::Interceptor>) -> Self {
            let inner = tonic::client::Grpc::with_interceptor(inner, interceptor);
            Self { inner }
        }
        #[doc = " Returns the requested user interest in full detail"]
        pub async fn get_user_interest(
            &mut self,
            request: impl tonic::IntoRequest<super::GetUserInterestRequest>,
        ) -> Result<tonic::Response<super::super::resources::UserInterest>, tonic::Status> {
            self.inner.ready().await.map_err(|e| {
                tonic::Status::new(
                    tonic::Code::Unknown,
                    format!("Service was not ready: {}", e.into()),
                )
            })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.ads.googleads.v1.services.UserInterestService/GetUserInterest",
            );
            self.inner.unary(request.into_request(), path, codec).await
        }
    }
    impl<T: Clone> Clone for UserInterestServiceClient<T> {
        fn clone(&self) -> Self {
            Self {
                inner: self.inner.clone(),
            }
        }
    }
    impl<T> std::fmt::Debug for UserInterestServiceClient<T> {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
            write!(f, "UserInterestServiceClient {{ ... }}")
        }
    }
}
#[doc = r" Generated server implementations."]
pub mod user_interest_service_server {
    #![allow(unused_variables, dead_code, missing_docs)]
    use tonic::codegen::*;
    #[doc = "Generated trait containing gRPC methods that should be implemented for use with UserInterestServiceServer."]
    #[async_trait]
    pub trait UserInterestService: Send + Sync + 'static {
        #[doc = " Returns the requested user interest in full detail"]
        async fn get_user_interest(
            &self,
            request: tonic::Request<super::GetUserInterestRequest>,
        ) -> Result<tonic::Response<super::super::resources::UserInterest>, tonic::Status>;
    }
    #[doc = " Service to fetch Google Ads User Interest."]
    #[derive(Debug)]
    #[doc(hidden)]
    pub struct UserInterestServiceServer<T: UserInterestService> {
        inner: _Inner<T>,
    }
    struct _Inner<T>(Arc<T>, Option<tonic::Interceptor>);
    impl<T: UserInterestService> UserInterestServiceServer<T> {
        pub fn new(inner: T) -> Self {
            let inner = Arc::new(inner);
            let inner = _Inner(inner, None);
            Self { inner }
        }
        pub fn with_interceptor(inner: T, interceptor: impl Into<tonic::Interceptor>) -> Self {
            let inner = Arc::new(inner);
            let inner = _Inner(inner, Some(interceptor.into()));
            Self { inner }
        }
    }
    impl<T, B> Service<http::Request<B>> for UserInterestServiceServer<T>
    where
        T: UserInterestService,
        B: HttpBody + Send + Sync + 'static,
        B::Error: Into<StdError> + Send + 'static,
    {
        type Response = http::Response<tonic::body::BoxBody>;
        type Error = Never;
        type Future = BoxFuture<Self::Response, Self::Error>;
        fn poll_ready(&mut self, _cx: &mut Context<'_>) -> Poll<Result<(), Self::Error>> {
            Poll::Ready(Ok(()))
        }
        fn call(&mut self, req: http::Request<B>) -> Self::Future {
            let inner = self.inner.clone();
            match req.uri().path() {
                "/google.ads.googleads.v1.services.UserInterestService/GetUserInterest" => {
                    #[allow(non_camel_case_types)]
                    struct GetUserInterestSvc<T: UserInterestService>(pub Arc<T>);
                    impl<T: UserInterestService>
                        tonic::server::UnaryService<super::GetUserInterestRequest>
                        for GetUserInterestSvc<T>
                    {
                        type Response = super::super::resources::UserInterest;
                        type Future = BoxFuture<tonic::Response<Self::Response>, tonic::Status>;
                        fn call(
                            &mut self,
                            request: tonic::Request<super::GetUserInterestRequest>,
                        ) -> Self::Future {
                            let inner = self.0.clone();
                            let fut = async move { inner.get_user_interest(request).await };
                            Box::pin(fut)
                        }
                    }
                    let inner = self.inner.clone();
                    let fut = async move {
                        let interceptor = inner.1.clone();
                        let inner = inner.0;
                        let method = GetUserInterestSvc(inner);
                        let codec = tonic::codec::ProstCodec::default();
                        let mut grpc = if let Some(interceptor) = interceptor {
                            tonic::server::Grpc::with_interceptor(codec, interceptor)
                        } else {
                            tonic::server::Grpc::new(codec)
                        };
                        let res = grpc.unary(method, req).await;
                        Ok(res)
                    };
                    Box::pin(fut)
                }
                _ => Box::pin(async move {
                    Ok(http::Response::builder()
                        .status(200)
                        .header("grpc-status", "12")
                        .body(tonic::body::BoxBody::empty())
                        .unwrap())
                }),
            }
        }
    }
    impl<T: UserInterestService> Clone for UserInterestServiceServer<T> {
        fn clone(&self) -> Self {
            let inner = self.inner.clone();
            Self { inner }
        }
    }
    impl<T: UserInterestService> Clone for _Inner<T> {
        fn clone(&self) -> Self {
            Self(self.0.clone(), self.1.clone())
        }
    }
    impl<T: std::fmt::Debug> std::fmt::Debug for _Inner<T> {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
            write!(f, "{:?}", self.0)
        }
    }
    impl<T: UserInterestService> tonic::transport::NamedService for UserInterestServiceServer<T> {
        const NAME: &'static str = "google.ads.googleads.v1.services.UserInterestService";
    }
}
/// Request message for [VideoService.GetVideo][google.ads.googleads.v1.services.VideoService.GetVideo].
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GetVideoRequest {
    /// Required. The resource name of the video to fetch.
    #[prost(string, tag = "1")]
    pub resource_name: std::string::String,
}
#[doc = r" Generated client implementations."]
pub mod video_service_client {
    #![allow(unused_variables, dead_code, missing_docs)]
    use tonic::codegen::*;
    #[doc = " Service to manage videos."]
    pub struct VideoServiceClient<T> {
        inner: tonic::client::Grpc<T>,
    }
    impl VideoServiceClient<tonic::transport::Channel> {
        #[doc = r" Attempt to create a new client by connecting to a given endpoint."]
        pub async fn connect<D>(dst: D) -> Result<Self, tonic::transport::Error>
        where
            D: std::convert::TryInto<tonic::transport::Endpoint>,
            D::Error: Into<StdError>,
        {
            let conn = tonic::transport::Endpoint::new(dst)?.connect().await?;
            Ok(Self::new(conn))
        }
    }
    impl<T> VideoServiceClient<T>
    where
        T: tonic::client::GrpcService<tonic::body::BoxBody>,
        T::ResponseBody: Body + HttpBody + Send + 'static,
        T::Error: Into<StdError>,
        <T::ResponseBody as HttpBody>::Error: Into<StdError> + Send,
    {
        pub fn new(inner: T) -> Self {
            let inner = tonic::client::Grpc::new(inner);
            Self { inner }
        }
        pub fn with_interceptor(inner: T, interceptor: impl Into<tonic::Interceptor>) -> Self {
            let inner = tonic::client::Grpc::with_interceptor(inner, interceptor);
            Self { inner }
        }
        #[doc = " Returns the requested video in full detail."]
        pub async fn get_video(
            &mut self,
            request: impl tonic::IntoRequest<super::GetVideoRequest>,
        ) -> Result<tonic::Response<super::super::resources::Video>, tonic::Status> {
            self.inner.ready().await.map_err(|e| {
                tonic::Status::new(
                    tonic::Code::Unknown,
                    format!("Service was not ready: {}", e.into()),
                )
            })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.ads.googleads.v1.services.VideoService/GetVideo",
            );
            self.inner.unary(request.into_request(), path, codec).await
        }
    }
    impl<T: Clone> Clone for VideoServiceClient<T> {
        fn clone(&self) -> Self {
            Self {
                inner: self.inner.clone(),
            }
        }
    }
    impl<T> std::fmt::Debug for VideoServiceClient<T> {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
            write!(f, "VideoServiceClient {{ ... }}")
        }
    }
}
#[doc = r" Generated server implementations."]
pub mod video_service_server {
    #![allow(unused_variables, dead_code, missing_docs)]
    use tonic::codegen::*;
    #[doc = "Generated trait containing gRPC methods that should be implemented for use with VideoServiceServer."]
    #[async_trait]
    pub trait VideoService: Send + Sync + 'static {
        #[doc = " Returns the requested video in full detail."]
        async fn get_video(
            &self,
            request: tonic::Request<super::GetVideoRequest>,
        ) -> Result<tonic::Response<super::super::resources::Video>, tonic::Status>;
    }
    #[doc = " Service to manage videos."]
    #[derive(Debug)]
    #[doc(hidden)]
    pub struct VideoServiceServer<T: VideoService> {
        inner: _Inner<T>,
    }
    struct _Inner<T>(Arc<T>, Option<tonic::Interceptor>);
    impl<T: VideoService> VideoServiceServer<T> {
        pub fn new(inner: T) -> Self {
            let inner = Arc::new(inner);
            let inner = _Inner(inner, None);
            Self { inner }
        }
        pub fn with_interceptor(inner: T, interceptor: impl Into<tonic::Interceptor>) -> Self {
            let inner = Arc::new(inner);
            let inner = _Inner(inner, Some(interceptor.into()));
            Self { inner }
        }
    }
    impl<T, B> Service<http::Request<B>> for VideoServiceServer<T>
    where
        T: VideoService,
        B: HttpBody + Send + Sync + 'static,
        B::Error: Into<StdError> + Send + 'static,
    {
        type Response = http::Response<tonic::body::BoxBody>;
        type Error = Never;
        type Future = BoxFuture<Self::Response, Self::Error>;
        fn poll_ready(&mut self, _cx: &mut Context<'_>) -> Poll<Result<(), Self::Error>> {
            Poll::Ready(Ok(()))
        }
        fn call(&mut self, req: http::Request<B>) -> Self::Future {
            let inner = self.inner.clone();
            match req.uri().path() {
                "/google.ads.googleads.v1.services.VideoService/GetVideo" => {
                    #[allow(non_camel_case_types)]
                    struct GetVideoSvc<T: VideoService>(pub Arc<T>);
                    impl<T: VideoService> tonic::server::UnaryService<super::GetVideoRequest> for GetVideoSvc<T> {
                        type Response = super::super::resources::Video;
                        type Future = BoxFuture<tonic::Response<Self::Response>, tonic::Status>;
                        fn call(
                            &mut self,
                            request: tonic::Request<super::GetVideoRequest>,
                        ) -> Self::Future {
                            let inner = self.0.clone();
                            let fut = async move { inner.get_video(request).await };
                            Box::pin(fut)
                        }
                    }
                    let inner = self.inner.clone();
                    let fut = async move {
                        let interceptor = inner.1.clone();
                        let inner = inner.0;
                        let method = GetVideoSvc(inner);
                        let codec = tonic::codec::ProstCodec::default();
                        let mut grpc = if let Some(interceptor) = interceptor {
                            tonic::server::Grpc::with_interceptor(codec, interceptor)
                        } else {
                            tonic::server::Grpc::new(codec)
                        };
                        let res = grpc.unary(method, req).await;
                        Ok(res)
                    };
                    Box::pin(fut)
                }
                _ => Box::pin(async move {
                    Ok(http::Response::builder()
                        .status(200)
                        .header("grpc-status", "12")
                        .body(tonic::body::BoxBody::empty())
                        .unwrap())
                }),
            }
        }
    }
    impl<T: VideoService> Clone for VideoServiceServer<T> {
        fn clone(&self) -> Self {
            let inner = self.inner.clone();
            Self { inner }
        }
    }
    impl<T: VideoService> Clone for _Inner<T> {
        fn clone(&self) -> Self {
            Self(self.0.clone(), self.1.clone())
        }
    }
    impl<T: std::fmt::Debug> std::fmt::Debug for _Inner<T> {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
            write!(f, "{:?}", self.0)
        }
    }
    impl<T: VideoService> tonic::transport::NamedService for VideoServiceServer<T> {
        const NAME: &'static str = "google.ads.googleads.v1.services.VideoService";
    }
}
