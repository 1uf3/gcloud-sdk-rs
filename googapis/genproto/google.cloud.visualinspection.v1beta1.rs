/// A vertex represents a 2D point in the image.
/// NOTE: the normalized vertex coordinates are relative to the original image
/// and range from 0 to 1.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct NormalizedVertex {
    /// X coordinate.
    #[prost(float, tag = "1")]
    pub x: f32,
    /// Y coordinate.
    #[prost(float, tag = "2")]
    pub y: f32,
}
/// Normalized Bounding Polygon.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct NormalizedBoundingPoly {
    /// The bounding polygon normalized vertices. Top left corner of the image will
    /// be [0, 0].
    #[prost(message, repeated, tag = "1")]
    pub normalized_vertices: ::std::vec::Vec<NormalizedVertex>,
}
/// Normalized Line, which represents a curve consisting of connected
/// straight-line segments.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct NormalizedPolyline {
    /// A sequence of vertices connected by straight lines.
    #[prost(message, repeated, tag = "1")]
    pub normalized_vertices: ::std::vec::Vec<NormalizedVertex>,
}
/// A piece of data in a Dataset.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct Image {
    /// Output only. Resource name of the Image generated by the system.
    #[prost(string, tag = "1")]
    pub name: std::string::String,
    /// Output only. Timestamp when this Image was created.
    #[prost(message, optional, tag = "2")]
    pub create_time: ::std::option::Option<::prost_types::Timestamp>,
    /// The labels with user-defined metadata to organize your Images.
    ///
    /// Label keys and values can be no longer than 64 characters
    /// (Unicode codepoints), can only contain lowercase letters, numeric
    /// characters, underscores and dashes. International characters are allowed.
    /// Label keys must start with a letter.
    ///
    /// See https://goo.gl/xmQnxf for more information on and examples of labels.
    #[prost(map = "string, string", tag = "3")]
    pub labels: ::std::collections::HashMap<std::string::String, std::string::String>,
    /// Output only. Source Google Cloud Storage uri for the Image.
    #[prost(string, tag = "4")]
    pub source_gcs_uri: std::string::String,
    /// Output only. Encoded image bytes. This field is only set when used to
    /// contain image predictions such as segmentation image masks by online
    /// prediction.
    #[prost(bytes, tag = "7")]
    pub image_bytes: std::vec::Vec<u8>,
}
/// Annotation is used to assign specific AnnotationSpec to a particular Image.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct Annotation {
    /// Output only. Resource name for Annotation generated by the system.
    #[prost(string, tag = "1")]
    pub name: std::string::String,
    /// Output only. Timestamp when this Annotation was created.
    #[prost(message, optional, tag = "2")]
    pub create_time: ::std::option::Option<::prost_types::Timestamp>,
    /// Output only. Timestamp when Annotation was last updated.
    #[prost(message, optional, tag = "3")]
    pub update_time: ::std::option::Option<::prost_types::Timestamp>,
    /// The resource ID of the AnnotationSpec that this Annotation pertains to.
    /// The AnnotationSpec must be in the same ancestor Dataset.
    /// The field could be empty for a MaskAnnotation.
    #[prost(string, tag = "4")]
    pub annotation_spec_id: std::string::String,
    /// Required. The resource ID of the AnnotationSet that this Annotation belongs
    /// to.
    #[prost(string, tag = "5")]
    pub annotation_set_id: std::string::String,
    /// The resource ID of the parent Annotation. Parent annotation represents a
    /// region in the original Image.
    #[prost(string, tag = "7")]
    pub parent_annotation_id: std::string::String,
    /// Output only. Source of the Annotation.
    #[prost(message, optional, tag = "12")]
    pub source: ::std::option::Option<annotation::Source>,
    /// The labels with user-defined metadata to organize your Annotations.
    ///
    /// Label keys and values can be no longer than 64 characters
    /// (Unicode codepoints), can only contain lowercase letters, numeric
    /// characters, underscores and dashes. International characters are allowed.
    /// Label keys must start with a letter.
    ///
    /// See https://goo.gl/xmQnxf for more information on and examples of labels.
    #[prost(map = "string, string", tag = "13")]
    pub labels: ::std::collections::HashMap<std::string::String, std::string::String>,
    /// Annotation type of the Annotation.
    #[prost(oneof = "annotation::AnnotationType", tags = "8, 9, 10, 11, 14")]
    pub annotation_type: ::std::option::Option<annotation::AnnotationType>,
}
pub mod annotation {
    /// Source of the Annotation.
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct Source {
        /// Source type.
        #[prost(enumeration = "source::SourceType", tag = "1")]
        pub r#type: i32,
        /// Resource name of the source model when the Annotation is
        /// MACHINE_PRODUCED.
        #[prost(string, tag = "2")]
        pub source_model: std::string::String,
    }
    pub mod source {
        /// Source type of the Annotation.
        #[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
        #[repr(i32)]
        pub enum SourceType {
            /// Unspecified source type.
            Unspecified = 0,
            /// The Annotation is generated by a human user.
            HumanProduced = 1,
            /// The Annotation is generated by a ML model.
            MachineProduced = 2,
            /// The Annotation is generated by machine, and it has
            /// child Annotation with HUMAN_PRODUCED.
            HumanLabeled = 3,
        }
    }
    /// Annotation type of the Annotation.
    #[derive(Clone, PartialEq, ::prost::Oneof)]
    pub enum AnnotationType {
        /// A BoundingBox Annotation.
        #[prost(message, tag = "8")]
        Box(super::BoundingBoxAnnotation),
        /// A BoundingPoly Annotation.
        #[prost(message, tag = "9")]
        Polygon(super::BoundingPolyAnnotation),
        /// A Classification Label Annotation.
        #[prost(message, tag = "10")]
        ClassificationLabel(super::ClassificationLabelAnnotation),
        /// A Mask Annotation.
        #[prost(message, tag = "11")]
        Mask(super::MaskAnnotation),
        /// A Polyline Annotation,
        #[prost(message, tag = "14")]
        Polyline(super::PolylineAnnotation),
    }
}
/// Detailed information for BoundingBox Annotation.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct BoundingBoxAnnotation {
    /// A box representing a rectangle region on the image.
    /// A box is supposed to have exactly four vertices in clockwise order.
    /// Vertices are represented in normalized format.
    #[prost(message, optional, tag = "1")]
    pub normalized_bounding_box: ::std::option::Option<NormalizedBoundingPoly>,
    /// Output only. A confidence score between 0.0 and 1.0. A higher value
    /// means greater confidence about the annotation.
    #[prost(float, tag = "2")]
    pub confidence_score: f32,
}
/// Detailed information for BoundingPoly Annotation.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct BoundingPolyAnnotation {
    /// A polygon region on the image.
    /// A polygon is supposed to have N vertices in clockwise order.
    /// Vertices are represented in normalized format.
    #[prost(message, optional, tag = "1")]
    pub normalized_bounding_poly: ::std::option::Option<NormalizedBoundingPoly>,
    /// Output only. A confidence score between 0.0 and 1.0. A higher value
    /// means greater confidence that the annotation is positive.
    #[prost(float, tag = "2")]
    pub confidence_score: f32,
}
/// Detailed information for ClassificationLabel Annotation.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ClassificationLabelAnnotation {
    /// Output only. A confidence score between 0.0 and 1.0. A higher value
    /// means greater confidence that the annotation is positive.
    #[prost(float, tag = "1")]
    pub confidence_score: f32,
}
/// Detailed information for Mask Annotation.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct MaskAnnotation {
    /// Output only. One channel image which is encoded as an 8bit lossless PNG.
    /// The size of the image will be the same as the original image. For a
    /// specific pixel, darker color means less confidence in correctness of the
    /// cateogry in the category_meask for the corresponding pixel. Black means no
    /// confidence and white means full confidence.
    #[prost(message, optional, tag = "1")]
    pub confidence_mask: ::std::option::Option<Image>,
    /// Three channel image which is encoded as an 8bit lossless PNG. Each pixel in
    /// the image mask represents the category which the pixel in the original
    /// image belong to. Each color is mapped to one AnnotationSpec based on
    /// annotation_spec_colors.
    #[prost(message, optional, tag = "2")]
    pub category_mask: ::std::option::Option<Image>,
}
/// Detailed information for Polyline Annotation.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct PolylineAnnotation {
    /// A polyline consisting of connected straight-line segments.
    #[prost(message, optional, tag = "1")]
    pub normalized_polyline: ::std::option::Option<NormalizedPolyline>,
    /// Output only. A confidence score between 0.0 and 1.0. A higher value
    /// means greater confidence that the annotation is positive.
    #[prost(float, tag = "2")]
    pub confidence_score: f32,
}
/// Resource of an AnnotationSpec.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct AnnotationSpec {
    /// Output only. Resource name for the AnnotationSpec generated by the system.
    #[prost(string, tag = "1")]
    pub name: std::string::String,
    /// Required. A user friendly display name for the AnnotationSpec.
    /// The name can be up to 128 characters long and can be consist of any UTF-8
    /// characters.
    #[prost(string, tag = "2")]
    pub display_name: std::string::String,
    /// Output only. Timestamp when this AnnotationSpec was created.
    #[prost(message, optional, tag = "3")]
    pub create_time: ::std::option::Option<::prost_types::Timestamp>,
    /// Output only. Timestamp when AnnotationSpec was last updated.
    #[prost(message, optional, tag = "4")]
    pub update_time: ::std::option::Option<::prost_types::Timestamp>,
}
/// Resource of an AnnotationSet.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct AnnotationSet {
    /// Output only. Resource name of the AnnotationSet generated by the system.
    #[prost(string, tag = "1")]
    pub name: std::string::String,
    /// Required. A user friendly display name for the annotationset.
    /// It can be up to 128 characters long and can be consist of any UTF-8
    /// characters.
    #[prost(string, tag = "2")]
    pub display_name: std::string::String,
    /// Output only. Timestamp when this AnnotationSet was created.
    #[prost(message, optional, tag = "7")]
    pub create_time: ::std::option::Option<::prost_types::Timestamp>,
    /// Output only. Timestamp when AnnotationSet was last updated.
    #[prost(message, optional, tag = "8")]
    pub update_time: ::std::option::Option<::prost_types::Timestamp>,
    /// Output only. The list of the AnnotationSpecs in the context of the
    /// AnnotationSet. All of the AnnotationSpecs that are imported or created into
    /// the AnnotationSet are automatically added to this list. User can manually
    /// add item to this list even though no annotation is associated with the
    /// corresponding AnnotationSpec.
    #[prost(message, repeated, tag = "9")]
    pub annotation_specs: ::std::vec::Vec<AnnotationSpec>,
    /// Type of the Annotations in this AnnotationSet. Annotations in this
    /// AnnotationSet must be of the same type.
    #[prost(oneof = "annotation_set::AnnotationSetType", tags = "3, 4, 5, 6, 11")]
    pub annotation_set_type: ::std::option::Option<annotation_set::AnnotationSetType>,
}
pub mod annotation_set {
    /// Type of the Annotations in this AnnotationSet. Annotations in this
    /// AnnotationSet must be of the same type.
    #[derive(Clone, PartialEq, ::prost::Oneof)]
    pub enum AnnotationSetType {
        /// Classification label.
        #[prost(message, tag = "3")]
        ClassificationLabel(super::ClassificationLabelAnnotationSet),
        /// Bounding box.
        #[prost(message, tag = "4")]
        Box(super::BoundingBoxAnnotationSet),
        /// Polygon.
        #[prost(message, tag = "5")]
        Polygon(super::PolygonAnnotationSet),
        /// Mask.
        #[prost(message, tag = "6")]
        Mask(super::MaskAnnotationSet),
        /// Polyline
        #[prost(message, tag = "11")]
        Polyline(super::PolylineAnnotationSet),
    }
}
/// ClassificationLabel Annotation type.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ClassificationLabelAnnotationSet {
    /// Whether or not the classification annotation is a multi-label
    /// classification.
    #[prost(bool, tag = "1")]
    pub multi_label: bool,
}
/// BoundingBox Annotation type.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct BoundingBoxAnnotationSet {}
/// Polygon Annotation type.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct PolygonAnnotationSet {}
/// Mask Annotation type.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct MaskAnnotationSet {
    /// Mapping of color to annotationspec.
    /// For example,
    /// annotation_spec_colors {
    ///  annotation_spec_id: 1
    ///  red: 0
    ///  green: 1
    ///  blue:0
    /// }
    /// it means green color maps to annotation_spec_id==1.
    #[prost(message, repeated, tag = "1")]
    pub annotation_spec_colors: ::std::vec::Vec<AnnotationSpecColor>,
}
/// Mapping of color to AnnotationSpec
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct AnnotationSpecColor {
    /// AnnotationSpec Id.
    #[prost(string, tag = "1")]
    pub annotation_spec_id: std::string::String,
    /// RGB value represents color in the category_mask image.
    /// Alpha value will always be empty.
    #[prost(message, optional, tag = "2")]
    pub color: ::std::option::Option<super::super::super::r#type::Color>,
}
/// Polyline Annotation type.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct PolylineAnnotationSet {}
/// Common operation metadata across Visual Inspection AI operations.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CommonOperationMetadata {
    /// Output only. Operation creation timestamp.
    #[prost(message, optional, tag = "1")]
    pub create_time: ::std::option::Option<::prost_types::Timestamp>,
    /// Output only. Operation last updated timestamp.
    #[prost(message, optional, tag = "2")]
    pub update_time: ::std::option::Option<::prost_types::Timestamp>,
    /// Output only. Resource name that this operation is directly associated with.
    /// For Create calls, this would be the parent resource.
    /// For others (Update, Delete, etc.) this would be the resource on which the
    /// method has been invoked.
    #[prost(string, tag = "3")]
    pub target: std::string::String,
}
/// The Google Cloud Storage location for the input content.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GcsSource {
    /// Required. Reference to a Google Cloud Storage path.
    #[prost(string, repeated, tag = "1")]
    pub uris: ::std::vec::Vec<std::string::String>,
}
/// The Google Cloud Storage location where the output is to be written to.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GcsDestination {
    /// Required. Google Cloud Storage URI to output directory. If the uri doesn't
    /// end with
    /// '/', a '/' will be automatically appended. The directory is created if it
    /// doesn't exist.
    #[prost(string, tag = "1")]
    pub output_uri_prefix: std::string::String,
}
/// A Dataset is a collection of Images and Annotations, which could be used to
/// solve a specifc visual inspection problem.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct Dataset {
    /// Output only. Resource name for the Dataset generated by the system.
    #[prost(string, tag = "1")]
    pub name: std::string::String,
    /// Required. A user friendly display name for the Dataset.
    #[prost(string, tag = "2")]
    pub display_name: std::string::String,
    /// Output only. Timestamp when this Dataset was created.
    #[prost(message, optional, tag = "3")]
    pub create_time: ::std::option::Option<::prost_types::Timestamp>,
    /// Output only. Timestamp when this Dataset was last updated.
    #[prost(message, optional, tag = "4")]
    pub update_time: ::std::option::Option<::prost_types::Timestamp>,
    /// Used to perform consistent read-modify-write updates. If not set, a blind
    /// "overwrite" update happens.
    #[prost(string, tag = "5")]
    pub etag: std::string::String,
    /// The labels with user-defined metadata to organize your dataset.
    ///
    /// Label keys and values can be no longer than 64 characters
    /// (Unicode codepoints), can only contain lowercase letters, numeric
    /// characters, underscores and dashes. International characters are allowed.
    /// Label keys must start with a letter.
    ///
    /// See https://goo.gl/xmQnxf for more information on and examples of labels.
    #[prost(map = "string, string", tag = "6")]
    pub labels: ::std::collections::HashMap<std::string::String, std::string::String>,
    /// Output only. The number of Images in the Dataset.
    #[prost(int64, tag = "7")]
    pub image_count: i64,
}
/// Describes the location from where we import data into a Dataset.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ImportDataConfig {
    /// The source of the input.
    #[prost(oneof = "import_data_config::Source", tags = "1, 2")]
    pub source: ::std::option::Option<import_data_config::Source>,
}
pub mod import_data_config {
    /// The source of the input.
    #[derive(Clone, PartialEq, ::prost::Oneof)]
    pub enum Source {
        /// The Google Cloud Storage location for the input content.
        /// Supported file extensions:
        /// 1. A JSON/CSV file.
        /// 2. Image file. Supported extension includes jpg,jpeg,png.
        #[prost(message, tag = "1")]
        GcsSource(super::GcsSource),
        /// Import data from another Dataset.
        #[prost(message, tag = "2")]
        DatasetResource(super::DatasetSource),
    }
}
/// Describes the source Dataset from where we import data.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct DatasetSource {
    /// Required. Dataset resource name. It needs to be in the same project and
    /// location.
    #[prost(string, tag = "1")]
    pub dataset: std::string::String,
    /// Filter on Images to import.
    #[prost(string, tag = "2")]
    pub image_filter: std::string::String,
    /// Filter on Annotations to import. Only Annotations on already filtered in
    /// Images are considered.
    #[prost(string, tag = "3")]
    pub annotation_filter: std::string::String,
}
/// Describes the location to where we export data from a Dataset.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ExportDataConfig {
    /// The Google Cloud Storage location where the output is to be written to.
    /// In the given directory a new directory will be created with name:
    /// export-data-<dataset-display-name>-<timestamp-of-export-call> where
    /// timestamp is in YYYYMMDDHHMMSS format. All export
    /// output will be written into that directory. Inside that directory,
    /// annotations with the same schema will be grouped into sub directories
    /// which are named with the corresponding annotations' schema title. Inside
    /// these sub directories, a schema.yaml will be created to describe the
    /// output format.
    #[prost(message, optional, tag = "1")]
    pub gcs_destination: ::std::option::Option<GcsDestination>,
}
/// Labeling job to trigger human labeling for adding annotations to images.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct LabelingJob {
    /// Output only. Resource name of the LabelingJob.
    #[prost(string, tag = "1")]
    pub name: std::string::String,
    /// Required. The user-defined name of the LabelingJob.
    /// The name can be up to 128 characters long and can be consist of any UTF-8
    /// characters.
    /// Display name of a LabelingJob.
    #[prost(string, tag = "2")]
    pub display_name: std::string::String,
    /// Required. The resource name of an existing AnnotationSet for all
    /// annotations created through this labeling job. The corresponding
    /// AnnotationSet needs to match the `labeling_config`, e.g.,
    /// AnomalyDetectionLabelingConfig needs AnnotationSet with
    /// `classification_label` specified. Format:
    ///
    /// projects/{project}/locations/{location}/datasets/{dataset}/annotationSets/{annotation_set}.
    #[prost(string, tag = "4")]
    pub output_annotation_set: std::string::String,
    /// Required. The Google Cloud Storage location of the instruction PDF. This
    /// pdf is shared with labelers, and provides detailed description on how to
    /// label.
    #[prost(string, tag = "5")]
    pub instruction_uri: std::string::String,
    /// Required. The full resource name of annotation specs that will be used for
    /// labeling. Format
    ///
    /// `projects/{project}/locations/{location}/datasets/{dataset}/annotationSpecs/{annotation_spec}`.
    #[prost(string, repeated, tag = "6")]
    pub annotation_specs: ::std::vec::Vec<std::string::String>,
    /// Optional. The SpecialistPools' resource names associated with this job.
    #[prost(string, repeated, tag = "7")]
    pub specialist_pools: ::std::vec::Vec<std::string::String>,
    /// Optional. The active learning config, e.g., maximum number of items to
    /// label.
    #[prost(message, optional, tag = "8")]
    pub active_learning_config: ::std::option::Option<ActiveLearningConfig>,
    /// Output only. The detailed state of the job.
    #[prost(enumeration = "labeling_job::JobState", tag = "9")]
    pub state: i32,
    /// Output only. Current labeling job progress percentage scaled in interval
    /// [0, 100], indicating the percentage of DataItems that has been finished.
    #[prost(int32, tag = "10")]
    pub labeling_progress: i32,
    /// Output only. Timestamp when this LabelingJob was created.
    #[prost(message, optional, tag = "11")]
    pub create_time: ::std::option::Option<::prost_types::Timestamp>,
    /// Output only. Timestamp when this LabelingJob was updated most recently.
    #[prost(message, optional, tag = "12")]
    pub update_time: ::std::option::Option<::prost_types::Timestamp>,
    /// Optional. The labels with user-defined metadata to organize your
    /// LabelingJob.
    ///
    /// Label keys and values can be no longer than 64 characters
    /// (Unicode codepoints), can only contain lowercase letters, numeric
    /// characters, underscores and dashes. International characters are allowed.
    /// Label keys must start with a letter.
    ///
    /// See https://goo.gl/xmQnxf for more information on and examples of labels.
    #[prost(map = "string, string", tag = "13")]
    pub labels: ::std::collections::HashMap<std::string::String, std::string::String>,
    #[prost(oneof = "labeling_job::LabelingConfig", tags = "3")]
    pub labeling_config: ::std::option::Option<labeling_job::LabelingConfig>,
}
pub mod labeling_job {
    /// Describes the state of a labeling job.
    #[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
    #[repr(i32)]
    pub enum JobState {
        /// The job state is unspecified.
        Unspecified = 0,
        /// The job has been just created or resumed and processing has not yet
        /// begun.
        Queued = 1,
        /// The service is preparing to run the job.
        Pending = 2,
        /// The job is in progress.
        Running = 3,
        /// The job completed successfully.
        Succeeded = 4,
        /// The job failed.
        Failed = 5,
        /// The job is being cancelled. From this state the job may only go to
        /// either JOB_STATE_SUCCEEDED, JOB_STATE_FAILED or JOB_STATE_CANCELLED.
        Cancelling = 6,
        /// The job has been cancelled.
        Cancelled = 7,
        /// The job has been stopped, and can be resumed.
        Paused = 8,
    }
    #[derive(Clone, PartialEq, ::prost::Oneof)]
    pub enum LabelingConfig {
        /// Optional. Labeling Config for `AnomalyDetection` module.
        #[prost(message, tag = "3")]
        AnomalyDetectionLabelingConfig(super::AnomalyDetectionLabelingConfig),
    }
}
/// Configuration of active learning.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ActiveLearningConfig {
    /// Max number of human labeled data items.
    #[prost(int64, tag = "1")]
    pub max_item_count: i64,
}
/// Labeling configuration of anomaly detection.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct AnomalyDetectionLabelingConfig {
    /// Required. The bounding box annotation set for anomaly detection module.
    /// Format:
    ///
    /// projects/{project}/locations/{location}/datasets/{dataset}/annotationSets/{annotation_set}.
    #[prost(string, repeated, tag = "1")]
    pub input_bounding_box_annotation_sets: ::std::vec::Vec<std::string::String>,
    /// A list of AnnotationSpecs to subselect Annotations in
    /// `input_bounding_box_annotation_sets`. If specified, only Annotations which
    /// have an AnnotationSpec in the list will be used for labeling. Format:
    ///
    /// `projects/{project}/locations/{location}/datasets/{dataset}/annotationSpecs/{annotation_spec}`.
    #[prost(string, repeated, tag = "2")]
    pub annotation_spec_allowlist: ::std::vec::Vec<std::string::String>,
}
/// SpecialistPool represents customers' own workforce to work on their data
/// labeling jobs. It includes a group of specialist managers who are responsible
/// for managing the labelers in this pool as well as customers' data labeling
/// jobs associated with this pool.
/// Customers create specialist pool as well as start data labeling jobs on
/// Cloud, managers and labelers work with the jobs using CrowdCompute console.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct SpecialistPool {
    /// Output only. Resource name for the SpecialistPool.
    #[prost(string, tag = "1")]
    pub name: std::string::String,
    /// Required. A user friendly display name for the Dataset.
    #[prost(string, tag = "2")]
    pub display_name: std::string::String,
    /// Output only. The number of Specialists in this SpecialistPool.
    #[prost(int32, tag = "3")]
    pub specialist_managers_count: i32,
    /// The email addresses of the specialists in the SpecialistPool.
    #[prost(string, repeated, tag = "4")]
    pub specialist_manager_emails: ::std::vec::Vec<std::string::String>,
}
/// All metrics for the solution.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct Metrics {
    /// Output only. Metrics for the solution at different slices.
    #[prost(map = "string, message", tag = "1")]
    pub metrics_slice: ::std::collections::HashMap<std::string::String, MetricsSlice>,
}
/// Metrics at a particular slice.
/// A slice can be "pixel" level, "image" level, "component" level, "unit" level,
/// and/or "product" level depending on the solution and the input data.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct MetricsSlice {
    /// Output only. The AnnotationSpec which this MetricSlice refers to. It is
    /// empty if this MetricSlice aggregates across AnnotationSpecs.
    #[prost(string, tag = "8")]
    pub annotation_spec: std::string::String,
    /// Output only. The AnnotationSpec display name which this MetricSlice refers
    /// to. It is empty if this MetricSlice aggregates across AnnotationSpecs.
    #[prost(string, tag = "9")]
    pub display_name: std::string::String,
    /// Output only. The number of examples used to create this evaluation metrics
    /// instance.
    #[prost(int32, tag = "10")]
    pub evaluated_example_count: i32,
    /// Output only. Model metrics across confidence thresholds.
    #[prost(message, repeated, tag = "5")]
    pub confidence_level_model_metrics: ::std::vec::Vec<metrics_slice::ConfidenceLevelModelMetrics>,
    /// Output only. Average model metrics.
    #[prost(message, optional, tag = "7")]
    pub average_model_metrics: ::std::option::Option<ModelMetrics>,
}
pub mod metrics_slice {
    /// Model metrics at a specific threshold.
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct ConfidenceLevelModelMetrics {
        /// Output only. Model metrics.
        #[prost(message, optional, tag = "1")]
        pub model_metrics: ::std::option::Option<super::ModelMetrics>,
        /// Output only. Confidence threshold in the range [0, 1].
        #[prost(float, tag = "2")]
        pub confidence_threshold: f32,
        /// Output only. Pixel level confidence threshold in the range [0, 1].
        #[prost(float, tag = "3")]
        pub pixel_confidence_threshold: f32,
        /// Output only. Cluster distance threshold in the range [0, 1] normalized by
        /// the diagonal length of the image.
        #[prost(float, tag = "4")]
        pub cluster_distance_threshold: f32,
    }
}
/// Model metrics which can vary depending on the model. These are not assumed to
/// refer to defect states in particular.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ModelMetrics {
    /// Output only. The false negative rate in the range [0, 1]. This is the rate
    /// with which the model incorrectly classifies examples as negative when they
    /// are positive. This is consistent with the following definition:
    ///
    /// https:
    /// //en.wikipedia.org/wiki/False_positives_
    /// // and_false_negatives#False_positive_and_false_negative_rates.
    #[prost(float, tag = "1")]
    pub false_negative_rate: f32,
    /// Output only. The false positive rate in the range [0, 1]. This is the rate
    /// with which the model  incorrectly classifies examples as positive when they
    /// are negative. This is consistent with the following definition:
    ///
    /// https:
    /// //en.wikipedia.org/wiki/False_positives_
    /// // and_false_negatives#False_positive_and_false_negative_rates.
    #[prost(float, tag = "2")]
    pub false_positive_rate: f32,
    /// Output only. The precision in the range [0, 1]. Precision measures the
    /// ratio of correctly classified examples by the model against all the
    /// predictions made by the model. Please see
    /// https://en.wikipedia.org/wiki/Precision_and_recall for its definition.
    #[prost(float, tag = "3")]
    pub precision: f32,
    /// Output only. The recall in the range [0, 1]. Recall measures the ratio of
    /// correctly predicted labels by the model against all true examples of that
    /// label. Please see https://en.wikipedia.org/wiki/Precision_and_recall for
    /// its definition.
    #[prost(float, tag = "4")]
    pub recall: f32,
    /// Output only. The Intersection over union (IOU) in the range [0, 1]. IOU
    /// measures the proportion of label regions that are common between ground
    /// truth and model predictions versus their union. Please see
    /// https://en.wikipedia.org/wiki/Jaccard_index for its definition.
    #[prost(float, tag = "5")]
    pub iou: f32,
    /// Output only. The Dice similarity coefficient in the range [0, 1]. Dice
    /// similarity coefficient is similar to IOU except that the common label
    /// region is weighted twice in the calculation. Please see its definition
    /// here: https://en.wikipedia.org/wiki/S%C3%B8rensen%E2%80%93Dice_coefficient
    #[prost(float, tag = "6")]
    pub dice_similarity_coefficient: f32,
    /// Output only. Confusion matrix for the classifications.
    /// Only present for aggregated metrics.
    #[prost(message, optional, tag = "7")]
    pub confusion_matrix: ::std::option::Option<ConfusionMatrix>,
    /// Output only. The average precision in the range [0, 1].
    #[prost(float, tag = "8")]
    pub average_precision: f32,
}
/// Confusion matrix across different class labels (if present).
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ConfusionMatrix {
    /// Output only. Counts of items across slices.
    /// For example, rows[i][j].count indicate the count for class_labels[i] as
    /// present in ground truth versus class_labels[j] as predicted by the model.
    /// The number of rows is the same as individual number of "counts" in a Row as
    /// well as the number of class_labels. So if the number of class_labels is n,
    /// then rows count is n as well as each rows.count has also count n.
    #[prost(message, repeated, tag = "1")]
    pub rows: ::std::vec::Vec<confusion_matrix::Row>,
    /// Output only. Class labels as the rows/columns of the confusion matrix.
    #[prost(string, repeated, tag = "2")]
    pub class_labels: ::std::vec::Vec<std::string::String>,
    /// Output only. Class AnnotationSpecs as the rows/columns of the confusion
    /// matrix.
    #[prost(string, repeated, tag = "3")]
    pub annotation_specs: ::std::vec::Vec<std::string::String>,
}
pub mod confusion_matrix {
    /// Individual row for the confusion matrix.
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct Row {
        /// Output only. Count of items in a "slice" classified at a particular
        /// class_label in the ground truth versus that classified by the solution.
        #[prost(int64, repeated, packed = "false", tag = "1")]
        pub count: ::std::vec::Vec<i64>,
    }
}
/// A Model is the trained artifact of a Module which makes predictions.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct Model {
    /// Output only. Resource name for Model generated by the system.
    #[prost(string, tag = "1")]
    pub name: std::string::String,
    /// Output only. Timestamp when the system started to create this Model.
    /// The difference between this field and create_time includes time spent on
    /// preprocessing, training, and evaluation.
    #[prost(message, optional, tag = "2")]
    pub create_request_time: ::std::option::Option<::prost_types::Timestamp>,
    /// Output only. Timestamp when this Model was trained and evaluated.
    #[prost(message, optional, tag = "3")]
    pub create_time: ::std::option::Option<::prost_types::Timestamp>,
    /// Output only. Timestamp when this Model was last updated.
    #[prost(message, optional, tag = "4")]
    pub update_time: ::std::option::Option<::prost_types::Timestamp>,
    /// Output only. Evaluations for this Model.
    #[prost(string, repeated, tag = "5")]
    pub evaluation_ids: ::std::vec::Vec<std::string::String>,
    /// Output only. A copy of the parent Module's configuration at the time of
    /// Model creation to provide a record of the training process configuration.
    #[prost(message, optional, tag = "6")]
    pub config: ::std::option::Option<::prost_types::Struct>,
    /// The labels with user-defined metadata to organize your Models.
    ///
    /// Label keys and values can be no longer than 64 characters
    /// (Unicode codepoints), can only contain lowercase letters, numeric
    /// characters, underscores and dashes. International characters are allowed.
    /// Label keys must start with a letter.
    ///
    /// See https://goo.gl/xmQnxf for more information on and examples of labels.
    #[prost(map = "string, string", tag = "7")]
    pub labels: ::std::collections::HashMap<std::string::String, std::string::String>,
}
/// ModelEvaluation for visual inspection solutions.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ModelEvaluation {
    /// Output only. Resource name for ModelEvaluation generated by the system.
    #[prost(string, tag = "1")]
    pub name: std::string::String,
    /// Deprecated, use metrics_map instead.
    /// Metrics for this evaluation.
    #[prost(message, optional, tag = "2")]
    pub metrics: ::std::option::Option<Metrics>,
    /// Output only. Deprecated, use eval_annotation_sets_map instead.
    /// The AnnotationSets containing output Annotations on the eval set. These
    /// will be readonly AnnotationSets belonging to the Solution's Dataset and
    /// have the same lifetime as the Model to which it belongs.
    #[prost(string, repeated, tag = "3")]
    pub eval_annotation_sets: ::std::vec::Vec<std::string::String>,
    /// Output only. Map of the Metrics for this model evaluation. The key is a
    /// name for the Metrics entry. Individual Modules define which Metrics they
    /// support and typically there will be a map entry for every output the Module
    /// produces.
    #[prost(map = "string, message", tag = "4")]
    pub metrics_map: ::std::collections::HashMap<std::string::String, Metrics>,
    /// Output only. Map of the evaluation annotation sets for this model. The keys
    /// are the name of module outputs annotation fields and the values are the
    /// annotation sets ids containing output Annotations on the eval set. These
    /// will be readonly AnnotationSets belonging to the Solution's Dataset and
    /// have the same lifetime as the Model to which it belongs.
    #[prost(map = "string, string", tag = "5")]
    pub eval_annotation_sets_map:
        ::std::collections::HashMap<std::string::String, std::string::String>,
}
/// A Module applies a computer vision algorithm to a subproblem of a visual
/// inspection task.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct Module {
    /// Output only. Resource name for Module generated by the system.
    #[prost(string, tag = "1")]
    pub name: std::string::String,
    /// Output only. Timestamp when this Module was created.
    #[prost(message, optional, tag = "2")]
    pub create_time: ::std::option::Option<::prost_types::Timestamp>,
    /// Output only. Timestamp when Module was last updated.
    #[prost(message, optional, tag = "3")]
    pub update_time: ::std::option::Option<::prost_types::Timestamp>,
    /// Required. A user friendly display name for the Module.
    /// The name can be up to 128 characters long and can consist of any UTF-8
    /// characters.
    #[prost(string, tag = "4")]
    pub display_name: std::string::String,
    /// A description for this Module.
    #[prost(string, tag = "5")]
    pub description: std::string::String,
    /// Configuration for this Module. Each Module may define its own
    /// configuration options.
    #[prost(message, optional, tag = "6")]
    pub config: ::std::option::Option<::prost_types::Struct>,
    /// The labels with user-defined metadata to organize your Modules.
    ///
    /// Label keys and values can be no longer than 64 characters
    /// (Unicode codepoints), can only contain lowercase letters, numeric
    /// characters, underscores and dashes. International characters are allowed.
    /// Label keys must start with a letter.
    ///
    /// See https://goo.gl/xmQnxf for more information on and examples of labels.
    #[prost(map = "string, string", tag = "7")]
    pub labels: ::std::collections::HashMap<std::string::String, std::string::String>,
    /// The type of the module.
    #[prost(oneof = "module::Type", tags = "8, 9, 10, 11, 12, 13")]
    pub r#type: ::std::option::Option<module::Type>,
}
pub mod module {
    /// The type of the module.
    #[derive(Clone, PartialEq, ::prost::Oneof)]
    pub enum Type {
        /// Anomaly detection.
        #[prost(message, tag = "8")]
        AnomalyDetection(super::AnomalyDetectionModule),
        /// Sparse alignment localization.
        #[prost(message, tag = "9")]
        SparseAlignmentLocalization(super::SparseAlignmentLocalizationModule),
        /// Localization refinement.
        #[prost(message, tag = "10")]
        LocalizationRefinement(super::LocalizationRefinementModule),
        /// Object detection.
        #[prost(message, tag = "11")]
        ObjectDetection(super::ObjectDetectionModule),
        /// Segmentation.
        #[prost(message, tag = "12")]
        Segmentation(super::SegmentationModule),
        /// Classification.
        #[prost(message, tag = "13")]
        Classification(super::ClassificationModule),
    }
}
/// Detailed input and output information of an anomaly detection Module.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct AnomalyDetectionModule {
    /// Input regions within which to detect anomalies. If not provided, the full
    /// image is used as input.
    #[prost(message, repeated, tag = "1")]
    pub query_regions: ::std::vec::Vec<AnnotationInput>,
    /// Required. Classification labels to train the model.
    #[prost(message, repeated, tag = "2")]
    pub classification_labels: ::std::vec::Vec<AnnotationInput>,
    /// Required. Classification predictions by the model.
    #[prost(message, repeated, tag = "3")]
    pub classification_predictions: ::std::vec::Vec<AnnotationOutput>,
}
/// Detailed input and output information of a sparse alignment localization
/// module.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct SparseAlignmentLocalizationModule {
    /// Regions within the query image to align. Multiple regions could be aligned
    /// per Image.
    #[prost(message, repeated, tag = "1")]
    pub query_regions: ::std::vec::Vec<AnnotationInput>,
    /// Regions within the template image to transfer to the query image.
    #[prost(message, repeated, tag = "2")]
    pub target_regions: ::std::vec::Vec<AnnotationInput>,
    /// Regions that define the portion of the template image from which to extract
    /// local features. These have both include/exclude Annotations, distinguished
    /// by labels on the AnnotationSpec.
    #[prost(message, repeated, tag = "3")]
    pub inspection_regions: ::std::vec::Vec<AnnotationInput>,
    /// The target regions transformed by the module.
    #[prost(message, repeated, tag = "4")]
    pub target_region_predictions: ::std::vec::Vec<AnnotationOutput>,
    /// The inspection regions transformed by the module.
    #[prost(message, repeated, tag = "5")]
    pub inspection_region_predictions: ::std::vec::Vec<AnnotationOutput>,
}
/// Detailed input and output information of a localization refinment module.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct LocalizationRefinementModule {
    /// Regions within the query image to align. Multiple regions could
    /// be aligned per Image.
    #[prost(message, repeated, tag = "1")]
    pub query_regions: ::std::vec::Vec<AnnotationInput>,
    /// Regions within the template image to transfer to the query image.
    #[prost(message, repeated, tag = "2")]
    pub target_regions: ::std::vec::Vec<AnnotationInput>,
    /// Regions which customize the search process for each target region.
    #[prost(message, repeated, tag = "3")]
    pub local_search_regions: ::std::vec::Vec<AnnotationInput>,
    /// The target regions transformed by the module.
    #[prost(message, repeated, tag = "4")]
    pub target_region_predictions: ::std::vec::Vec<AnnotationOutput>,
    /// The inspection regions transformed by the module.
    #[prost(message, repeated, tag = "5")]
    pub local_search_region_predictions: ::std::vec::Vec<AnnotationOutput>,
}
/// Detailed input and output information of an object detection module.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ObjectDetectionModule {
    /// Regions to search on for the query image, anything outside of these regions
    /// will not be considered from the module. These regions are defined in the
    /// template image and applied "as is" to each query image. If query_regions
    /// are not specified, the full image will be used as a single query region.
    #[prost(message, repeated, tag = "1")]
    pub query_regions: ::std::vec::Vec<AnnotationInput>,
    /// Regions within the template image to transfer to the query image.
    #[prost(message, repeated, tag = "2")]
    pub target_regions: ::std::vec::Vec<AnnotationInput>,
    /// Required. The regions for each object to learn the representation of.
    #[prost(message, repeated, tag = "3")]
    pub object_regions: ::std::vec::Vec<AnnotationInput>,
    /// The target regions transformed by the module.
    #[prost(message, repeated, tag = "4")]
    pub target_region_predictions: ::std::vec::Vec<AnnotationOutput>,
    /// Required. The objects regions detected by the module.
    #[prost(message, repeated, tag = "5")]
    pub object_region_predictions: ::std::vec::Vec<AnnotationOutput>,
}
/// Detailed input and output information of an image segmentation module.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct SegmentationModule {
    /// Regions to search on for the query image, anything outside of these regions
    /// will not be considered from the module. The query images can be defined in
    /// the template image or predicted per image from other modules.  If
    /// query_regions are not specified, the full image will be used as a single
    /// query region.
    #[prost(message, repeated, tag = "1")]
    pub query_regions: ::std::vec::Vec<AnnotationInput>,
    /// Regions within the template image to transfer to the query image.
    #[prost(message, repeated, tag = "2")]
    pub inspection_regions: ::std::vec::Vec<AnnotationInput>,
    /// Required. The segmentation regions to learn the representation of.
    #[prost(message, repeated, tag = "3")]
    pub segmentation_regions: ::std::vec::Vec<AnnotationInput>,
    /// The segmentation predictions in inspection regions by the module.
    #[prost(message, repeated, tag = "4")]
    pub inspection_region_predictions: ::std::vec::Vec<AnnotationOutput>,
    /// Required. The segmentation predictions by the module.
    #[prost(message, repeated, tag = "5")]
    pub segmentation_predictions: ::std::vec::Vec<AnnotationOutput>,
}
/// Detailed input and output information of an image classification module.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ClassificationModule {
    /// Regions to search on for the query image, anything outside of these regions
    /// will not be considered from the module. The query images can be defined in
    /// the template image or predicted per image from other modules.  If
    /// query_regions are not specified, the full image will be used as a single
    /// query region.
    #[prost(message, repeated, tag = "1")]
    pub query_regions: ::std::vec::Vec<AnnotationInput>,
    /// Regions within the template image to transfer to the query image.
    #[prost(message, repeated, tag = "2")]
    pub inspection_regions: ::std::vec::Vec<AnnotationInput>,
    /// Required. Classification labels to train the module.
    #[prost(message, repeated, tag = "3")]
    pub classification_labels: ::std::vec::Vec<AnnotationInput>,
    /// Classification predictions in inspection regions by the module.
    #[prost(message, repeated, tag = "4")]
    pub inspection_region_predictions: ::std::vec::Vec<AnnotationOutput>,
    /// Required. Classification predictions by the module.
    #[prost(message, repeated, tag = "5")]
    pub classification_predictions: ::std::vec::Vec<AnnotationOutput>,
}
/// Specifies the source of Annotations for a Module input.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct AnnotationInput {
    /// Required. The AnnotationSet ID containing input Annotations. The expected
    /// AnnotationType of this AnnotationSet will depend on the Module.
    #[prost(string, tag = "1")]
    pub annotation_set_id: std::string::String,
    /// Required. The AnnotationSet containing input Annotations. The expected
    /// AnnotationType of this AnnotationSet will depend on the Module.
    #[prost(string, tag = "3")]
    pub annotation_set: std::string::String,
    /// A list of AnnotationSpecs to subselect Annotations in this AnnotationSet.
    /// If specified, only Annotations which have an AnnotationSpec in the list are
    /// used as input to the Module.
    #[prost(string, repeated, tag = "2")]
    pub annotation_spec_allowlist: ::std::vec::Vec<std::string::String>,
}
/// Specifies the output for Annotations produced by a Module.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct AnnotationOutput {
    /// Required. The AnnotationSet ID containing output Annotations. The expected
    /// AnnotationType of this AnnotationSet will depend on the Module.
    #[prost(string, tag = "1")]
    pub annotation_set_id: std::string::String,
    /// Required. The AnnotationSet containing output Annotations. The expected
    /// AnnotationType of this AnnotationSet will depend on the Module.
    #[prost(string, tag = "2")]
    pub annotation_set: std::string::String,
}
/// A SolutionArtifact is a fixed set of Models which can be exported or
/// deployed.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct SolutionArtifact {
    /// Output only. Resource name for SolutionArtifact generated by the system.
    #[prost(string, tag = "1")]
    pub name: std::string::String,
    /// Output only. Timestamp when this Module was created.
    #[prost(message, optional, tag = "2")]
    pub create_time: ::std::option::Option<::prost_types::Timestamp>,
    /// Required. A user friendly display name for the SolutionArtifact.
    /// The name can be up to 128 characters long and can consist of any UTF-8
    /// characters.
    #[prost(string, tag = "4")]
    pub display_name: std::string::String,
    /// A description for this SolutionArtifact.
    #[prost(string, tag = "5")]
    pub description: std::string::String,
    /// The labels with user-defined metadata to organize your SolutionArtifacts.
    ///
    /// Label keys and values can be no longer than 64 characters
    /// (Unicode codepoints), can only contain lowercase letters, numeric
    /// characters, underscores and dashes. International characters are allowed.
    /// Label keys must start with a letter.
    ///
    /// See https://goo.gl/xmQnxf for more information on and examples of labels.
    #[prost(map = "string, string", tag = "6")]
    pub labels: ::std::collections::HashMap<std::string::String, std::string::String>,
    /// A list of Models to include in the exported solution. If this field is not
    /// provided in the CreateSolutionArtifactRequest, the latest Model for every
    /// Module will be exported. If provided, then only these Models are exported.
    /// The list of models must comprise a complete solution according to the
    /// expectations set by the Solution's SolutionType.
    #[prost(string, repeated, tag = "7")]
    pub models: ::std::vec::Vec<std::string::String>,
    /// Required. Export type.
    #[prost(enumeration = "solution_artifact::ExportType", tag = "8")]
    pub export_type: i32,
    #[prost(oneof = "solution_artifact::ExportLocation", tags = "9, 10")]
    pub export_location: ::std::option::Option<solution_artifact::ExportLocation>,
}
pub mod solution_artifact {
    /// Export format types.
    #[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
    #[repr(i32)]
    pub enum ExportType {
        /// Unspecified by the user.
        Unspecified = 0,
        /// A Docker-compatible container which runs on CPU only.
        CpuContainer = 1,
        /// A Docker-compatible container which runs on GPU.
        GpuContainer = 2,
        /// Packaged archive without the Docker container. It might include multiple
        /// models, images, and other configuration files in one package.
        PackagedArchive = 3,
    }
    #[derive(Clone, PartialEq, ::prost::Oneof)]
    pub enum ExportLocation {
        /// Export location for the container. This must be specified when export
        /// type is a CONTAINER type.
        #[prost(message, tag = "9")]
        ContainerExportLocation(super::GcrDestination),
        /// Export location for the packaged archive in the format like
        /// gs://<BUCKET_NAME>/<OBJECT_NAME>.tar.gz. This must be specified when
        /// export type is PACKAGED_ARCHIVE.
        #[prost(string, tag = "10")]
        PackagedArchiveGcsUri(std::string::String),
    }
}
/// The GCR location where the container will be pushed.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GcrDestination {
    /// Required. Google Container Registry URI of the new image, up to
    /// 2000 characters long. See
    ///
    /// https:
    /// //cloud.google.com/container-registry/do
    /// // cs/pushing-and-pulling#pushing_an_image_to_a_registry
    /// Accepted forms:
    /// * [HOSTNAME]/[PROJECT-ID]/[IMAGE]
    /// * [HOSTNAME]/[PROJECT-ID]/[IMAGE]:[TAG]
    ///
    /// The requesting user must have permission to push images the project.
    #[prost(string, tag = "1")]
    pub output_uri: std::string::String,
}
/// A solution is a set of models and algorithms combined together that will
/// solve a specific visual inspection problem.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct Solution {
    /// A unique name for the solution.
    /// This is an alphanumeric identifier generated by the system
    /// ([A-Z][A-Z0-9]+).
    #[prost(string, tag = "1")]
    pub name: std::string::String,
    /// A user friendly display name for the solution.
    #[prost(string, tag = "2")]
    pub display_name: std::string::String,
    /// Data input file specifies the input dataset for creating (training)
    /// the solution. This must be a GCS URI path i.e. of the form
    /// gs://<bucket_name>/<path to file>. The data file format is JSONL with each
    /// line following the format below (also see examples for Board Inspection
    /// and Cosmetic Inspection below).
    /// ```
    /// {
    ///   # Note: Only needed for Board inspection.
    ///   "golden_images": [
    ///     {
    ///        "template_image_gcs_uri": "GCS path to template image.",
    ///        "inspection_area_and_regions": [
    ///          {
    ///            "inspection_area": {
    ///              "inspection_area_id": "<unique id for inspection area.",
    ///              "bounding_poly": {
    ///                "normalized_vertices": [
    ///                  { "x": 0.1,  "y": 0.2 },
    ///                  { "x": 0.1,  "y": 0.2 },
    ///                  { "x": 0.1,  "y": 0.2 },
    ///                  { "x": 0.1,  "y": 0.2 },
    ///                ]
    ///              }
    ///            },
    ///            "regions": [
    ///              "bounding_poly": {
    ///                "normalized_vertices": [
    ///                  { "x": 0.1,  "y": 0.2 },
    ///                  { "x": 0.1,  "y": 0.2 },
    ///                  { "x": 0.1,  "y": 0.2 },
    ///                  { "x": 0.1,  "y": 0.2 },
    ///                ]
    ///              },
    ///              "region_metadata": {
    ///                "region_id": "<region id>",
    ///                "region_name": "<region name>",
    ///                "component_id": "<component id>",
    ///                "component_name": "<component name>"
    ///                "other_keywords": {
    ///                  "keyword1": "value1",
    ///                  "keyword2": "value2"
    ///                }
    ///              }
    ///            ]
    ///          }
    ///        ]
    ///      }
    ///   ]
    ///   # finetune_from_solution_id can be omitted.
    ///   "finetune_from_solution_id": "<id of existing solution>",
    ///
    ///
    ///   "image_and_annotations": [
    ///     {
    ///       "image_gcs_uri": "<path to the image.",
    ///       "image_properties": {
    ///         "image_property1": "value1",
    ///         "image_property2": "value2"
    ///       },
    ///       "inspection_state":
    ///
    /// "INSPECTION_STATE_UNLABELED|INSPECTION_STATE_NON_DEFECTIVE|INSPECTION_STATE_DEFECTIVE",
    ///
    ///       # Note: Only needed for Board inspection.
    ///       "region_id_and_defective_labels": [
    ///         {
    ///           "inspection_area_id": "<inspection area id>",
    ///           "region_id": "<region id>",
    ///           "inspection_state":
    ///
    /// "INSPECTION_STATE_UNLABELED|INSPECTION_STATE_NON_DEFECTIVE|INSPECTION_STATE_DEFECTIVE",
    ///           "defect_label_name": "defect label name."
    ///         }
    ///       ],
    ///       # Note: Only needed for Cosmetic Inspection.
    ///       "localized_region": [
    ///         {
    ///           "bounding_poly": {
    ///             "normalized_vertices": [
    ///               { "x": 0.1,  "y": 0.2 },
    ///               { "x": 0.1,  "y": 0.2 },
    ///               { "x": 0.1,  "y": 0.2 },
    ///               { "x": 0.1,  "y": 0.2 },
    ///             ]
    ///           },
    ///           "region_metadata": {
    ///             "region_id": "<region id>",
    ///             "region_name": "<region name>",
    ///             "component_id": "<component id>",
    ///             "component_name": "<component name>"
    ///             "other_keywords": {
    ///               "keyword1": "value1",
    ///               "keyword2": "value2"
    ///             }
    ///           }
    ///         }
    ///       ],
    ///       # Note: Only needed for Cosmetic Inspection.
    ///       "segmentation_annotation": {
    ///         "mask": {
    ///           "mask": {
    ///             "gcs_uri": "<gcs path to the image.>",
    ///             "class_map": {
    ///               1: "scratch",
    ///               2: "glue"
    ///             }
    ///           }
    ///         }
    ///       }
    ///     }
    ///   ]
    /// }
    ///
    /// ```
    /// Here's an example for Board Inspection.
    /// {
    ///   # Note: Only needed for Board inspection.
    ///   "golden_images": [
    ///     {
    ///        "template_image_gcs_uri": "GCS path to template image.",
    ///        "inspection_area_and_regions": [
    ///          {
    ///            "inspection_area": {
    ///              "inspection_area_id": "<unique id for inspection area.",
    ///              "bounding_poly": {
    ///                "normalized_vertices": [
    ///                  { "x": 0.1,  "y": 0.2 },
    ///                  { "x": 0.1,  "y": 0.2 },
    ///                  { "x": 0.1,  "y": 0.2 },
    ///                  { "x": 0.1,  "y": 0.2 },
    ///                ]
    ///              }
    ///            },
    ///            "regions": [
    ///              "bounding_poly": {
    ///                "normalized_vertices": [
    ///                  { "x": 0.1,  "y": 0.2 },
    ///                  { "x": 0.1,  "y": 0.2 },
    ///                  { "x": 0.1,  "y": 0.2 },
    ///                  { "x": 0.1,  "y": 0.2 },
    ///                ]
    ///              },
    ///              "region_metadata": {
    ///                "region_id": "<region id>",
    ///                "region_name": "<region name>",
    ///                "component_id": "<component id>",
    ///                "component_name": "<component name>"
    ///                "other_keywords": {
    ///                  "keyword1": "value1",
    ///                  "keyword2": "value2"
    ///                }
    ///              }
    ///            ]
    ///          }
    ///        ]
    ///      }
    ///   ]
    ///   # finetune_from_solution_id can be omitted.
    ///   "finetune_from_solution_id": "<id of existing solution>",
    ///
    ///
    ///   "image_and_annotations": [
    ///     {
    ///       "image_gcs_uri": "<path to the image.",
    ///       "image_properties": {
    ///         "image_property1": "value1",
    ///         "image_property2": "value2"
    ///       },
    ///       "inspection_state":
    ///
    /// "INSPECTION_STATE_UNLABELED|INSPECTION_STATE_NON_DEFECTIVE|INSPECTION_STATE_DEFECTIVE",
    ///
    ///       # Note: Only needed for Board inspection.
    ///       "region_id_and_defective_labels": [
    ///         {
    ///           "inspection_area_id": "<inspection area id>",
    ///           "region_id": "<region id>",
    ///           "inspection_state":
    ///
    /// "INSPECTION_STATE_UNLABELED|INSPECTION_STATE_NON_DEFECTIVE|INSPECTION_STATE_DEFECTIVE",
    ///           "defect_label_name": "defect label name."
    ///         }
    ///       ],
    ///     }
    ///   ]
    /// }
    ///
    /// ```
    /// Here's an example for Cosmetic Inspection.
    /// /```
    /// {
    ///   # finetune_from_solution_id can be omitted.
    ///   "finetune_from_solution_id": "<id of existing solution>",
    ///   "image_and_annotations": [
    ///     {
    ///       "image_gcs_uri": "<path to the image.",
    ///       "image_properties": {
    ///         "image_property1": "value1",
    ///         "image_property2": "value2"
    ///       },
    ///       "inspection_state":
    ///
    /// "INSPECTION_STATE_UNLABELED|INSPECTION_STATE_NON_DEFECTIVE|INSPECTION_STATE_DEFECTIVE",
    ///
    ///       # Note: Only needed for Cosmetic Inspection.
    ///       "localized_region": [
    ///         {
    ///           "bounding_poly": {
    ///             "normalized_vertices": [
    ///               { "x": 0.1,  "y": 0.2 },
    ///               { "x": 0.1,  "y": 0.2 },
    ///               { "x": 0.1,  "y": 0.2 },
    ///               { "x": 0.1,  "y": 0.2 },
    ///             ]
    ///           },
    ///           "region_metadata": {
    ///             "region_id": "<region id>",
    ///             "region_name": "<region name>",
    ///             "component_id": "<component id>",
    ///             "component_name": "<component name>"
    ///             "other_keywords": {
    ///               "keyword1": "value1",
    ///               "keyword2": "value2"
    ///             }
    ///           }
    ///         }
    ///       ],
    ///       # Note: Only needed for Cosmetic Inspection.
    ///       "segmentation_annotation": {
    ///         "mask": {
    ///           "mask": {
    ///             "gcs_uri": "<gcs path to the image.>",
    ///             "class_map": {
    ///               1: "scratch",
    ///               2: "glue"
    ///             }
    ///           }
    ///         }
    ///       }
    ///     }
    ///   ]
    /// }
    /// ```
    #[prost(string, tag = "3")]
    pub gcs_data_input_uri: std::string::String,
    /// Optional. Type of the solution. Valid values are:
    /// *    `assembly`: Solution for finding defects in PCB like components. This
    ///                  is the default value.
    /// *    `cosmetic`: Solution for finding cosmetic defects on a device.
    ///                  Examples include finding scratches or dust particles on
    ///                  a device.
    #[prost(string, tag = "7")]
    pub r#type: std::string::String,
    /// Optional. Solution creation train configuration.
    #[prost(message, optional, tag = "9")]
    pub training_config: ::std::option::Option<solution::TrainingConfig>,
    /// Output only. Timestamp when the all the models in the solution were trained
    /// and evaluated.
    #[prost(message, optional, tag = "5")]
    pub create_time: ::std::option::Option<::prost_types::Timestamp>,
    /// Output only. Timestamp when this solution was last updated.
    #[prost(message, optional, tag = "6")]
    pub update_time: ::std::option::Option<::prost_types::Timestamp>,
    /// Optional. A description for this Solution.
    #[prost(string, tag = "10")]
    pub description: std::string::String,
    /// Required. The Dataset of this Solution.
    #[prost(string, tag = "11")]
    pub dataset_id: std::string::String,
    /// Optional. The labels with user-defined metadata to organize your Solutions.
    ///
    /// Label keys and values can be no longer than 64 characters
    /// (Unicode codepoints), can only contain lowercase letters, numeric
    /// characters, underscores and dashes. International characters are allowed.
    /// Label keys must start with a letter.
    ///
    /// See https://goo.gl/xmQnxf for more information on and examples of labels.
    #[prost(map = "string, string", tag = "12")]
    pub labels: ::std::collections::HashMap<std::string::String, std::string::String>,
    /// Required. The SolutionType of this Solution. This restricts the allowable
    /// Modules and the linkage between them according to predefined solution
    /// schema.
    #[prost(message, optional, tag = "13")]
    pub solution_type: ::std::option::Option<solution::SolutionType>,
}
pub mod solution {
    /// Configuration specific to training parameters.
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct TrainingConfig {
        /// Optional. Training time for each individual artifacts.
        #[prost(message, optional, tag = "1")]
        pub training_duration: ::std::option::Option<::prost_types::Duration>,
        /// Optional. Structured object containing parameters to fine tune the
        /// training behavior.
        #[prost(message, optional, tag = "2")]
        pub parameters: ::std::option::Option<::prost_types::Struct>,
    }
    /// A predefined SolutionType.
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct SolutionType {
        /// The predefined type of this Solution.
        #[prost(oneof = "solution_type::Type", tags = "1, 2, 3")]
        pub r#type: ::std::option::Option<solution_type::Type>,
    }
    pub mod solution_type {
        /// Options for an assembly inspection Solution.
        #[derive(Clone, PartialEq, ::prost::Message)]
        pub struct AssemblyInspectionOptions {}
        /// Options for cosmetic inspection Solution.
        #[derive(Clone, PartialEq, ::prost::Message)]
        pub struct CosmeticInspectionOptions {}
        /// Options for a custom inspection Solution.
        #[derive(Clone, PartialEq, ::prost::Message)]
        pub struct CustomInspectionOptions {}
        /// The predefined type of this Solution.
        #[derive(Clone, PartialEq, ::prost::Oneof)]
        pub enum Type {
            /// Predefined solution for assembly inspection.
            #[prost(message, tag = "1")]
            AssemblyInspection(AssemblyInspectionOptions),
            /// Predefined solution for cosmetic inspection.
            #[prost(message, tag = "2")]
            CosmeticInspection(CosmeticInspectionOptions),
            /// Customized solution for inspection.
            #[prost(message, tag = "3")]
            CustomInspection(CustomInspectionOptions),
        }
    }
}
/// Solution operation metadata.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct SolutionOperationMetadata {
    /// Output only. Common operation metadata.
    #[prost(message, optional, tag = "1")]
    pub common_operation_metadata: ::std::option::Option<CommonOperationMetadata>,
}
/// Request for creating a solution.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CreateSolutionRequest {
    /// Required. Parent identifier.
    #[prost(string, tag = "1")]
    pub parent: std::string::String,
    /// Required. Solution to create.
    #[prost(message, optional, tag = "2")]
    pub solution: ::std::option::Option<Solution>,
}
/// Request method for listing solutions.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ListSolutionsRequest {
    /// Required. Parent identifier.
    #[prost(string, tag = "1")]
    pub parent: std::string::String,
    /// The maximum number of solutions to return. The service may return fewer
    /// than this value. If unspecified, at moast 50 solutions will be returned.
    /// The maximum value is 100; values above 100 will be coerced to 100.
    #[prost(int32, tag = "2")]
    pub page_size: i32,
    /// A page token, received from a previous `ListSolutions` call.
    /// Provide this to retrieve the subsequent page.
    ///
    /// When paginating, all other parameters provided to `ListSolutions` must
    /// match the call that provided the page token.
    #[prost(string, tag = "3")]
    pub page_token: std::string::String,
    /// The standard list filter.
    #[prost(string, tag = "4")]
    pub filter: std::string::String,
}
/// Response method for listing solutions.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ListSolutionsResponse {
    /// The solutions for this project.
    #[prost(message, repeated, tag = "1")]
    pub solutions: ::std::vec::Vec<Solution>,
    /// A token that can be sent as `page_token` to retrieve the next page.
    /// If this field is omitted, there are no subsequent pages.
    #[prost(string, tag = "2")]
    pub next_page_token: std::string::String,
}
/// For requesting details about a particular solution.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GetSolutionRequest {
    /// Required. Solution identifier.
    #[prost(string, tag = "1")]
    pub name: std::string::String,
}
/// Export solution metadata to distinguish that the operation is an export
/// solution operation.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ExportSolutionOperationMetadata {
    /// Output only. Common operation metadata.
    #[prost(message, optional, tag = "1")]
    pub common_operation_metadata: ::std::option::Option<CommonOperationMetadata>,
}
/// Deploy solution metadata to distinguish that the operation is an export
/// solution operation.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct DeploySolutionOperationMetadata {
    /// Output only. Common operation metadata.
    #[prost(message, optional, tag = "1")]
    pub common_operation_metadata: ::std::option::Option<CommonOperationMetadata>,
}
/// Undeploy solution metadata to distinguish that the operation is an export
/// solution operation.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct UndeploySolutionOperationMetadata {
    /// Output only. Common operation metadata.
    #[prost(message, optional, tag = "1")]
    pub common_operation_metadata: ::std::option::Option<CommonOperationMetadata>,
}
/// Request for creating a SolutionArtifact.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CreateSolutionArtifactRequest {
    /// Required. Parent identifier.
    #[prost(string, tag = "1")]
    pub parent: std::string::String,
    /// Required. SolutionArtifact to create.
    #[prost(message, optional, tag = "2")]
    pub solution_artifact: ::std::option::Option<SolutionArtifact>,
}
/// CreateSolutionArtifact operation metadata.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CreateSolutionArtifactOperationMetadata {
    /// Output only. Common operation metadata.
    #[prost(message, optional, tag = "1")]
    pub common_operation_metadata: ::std::option::Option<CommonOperationMetadata>,
}
/// Request for listing SolutionArtifacts.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ListSolutionArtifactsRequest {
    /// Required. Parent identifier.
    #[prost(string, tag = "1")]
    pub parent: std::string::String,
    /// The standard list filter.
    #[prost(string, tag = "2")]
    pub filter: std::string::String,
    /// The maximum number of SolutionArtifacts to return. The service may return
    /// fewer than this value. If unspecified, at most 20 Modules will be
    /// returned. The maximum value is 100; values above 100 will be coerced to
    /// 100.
    #[prost(int32, tag = "3")]
    pub page_size: i32,
    /// A page token, received from a previous `ListSolutionArtifacts` call.
    /// Provide this to retrieve the subsequent page.
    ///
    /// When paginating, all other parameters provided to `ListSolutionArtifacts`
    /// must match the call that provided the page token.
    #[prost(string, tag = "4")]
    pub page_token: std::string::String,
}
/// Response for ListSolutionArtifacts.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ListSolutionArtifactsResponse {
    /// The SolutionArtifact.
    #[prost(message, repeated, tag = "1")]
    pub solution_artifacts: ::std::vec::Vec<SolutionArtifact>,
    /// A token that can be sent as `page_token` to retrieve the next page.
    /// If this field is omitted, there are no subsequent pages.
    #[prost(string, tag = "2")]
    pub next_page_token: std::string::String,
}
/// Request for getting a SolutionArtifact.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GetSolutionArtifactRequest {
    /// Required. SolutionArtifact identifier.
    #[prost(string, tag = "1")]
    pub name: std::string::String,
}
/// Request for deleting a SolutionArtifact.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct DeleteSolutionArtifactRequest {
    /// Required. SolutionArtifact identifier.
    #[prost(string, tag = "1")]
    pub name: std::string::String,
}
/// Operation metadata for DeleteSolutionArtifact.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct DeleteSolutionArtifactOperationMetadata {
    /// Output only. Common operation metadata.
    #[prost(message, optional, tag = "1")]
    pub common_operation_metadata: ::std::option::Option<CommonOperationMetadata>,
}
/// Request for updating a SolutionArtifact.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct UpdateSolutionArtifactRequest {
    /// Required. The SolutionArtifact which replaces the resource on the server.
    #[prost(message, optional, tag = "1")]
    pub solution_artifact: ::std::option::Option<SolutionArtifact>,
    /// Required. The update mask applies to the resource.
    /// For the `FieldMask` definition, see
    ///
    /// [FieldMask](https:
    /// //developers.google.com/protocol-buffers
    /// // /docs/reference/google.protobuf#fieldmask).
    #[prost(message, optional, tag = "2")]
    pub update_mask: ::std::option::Option<::prost_types::FieldMask>,
}
/// CreateDataset operation metadata.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CreateDatasetOperationMetadata {
    /// Output only. Common operation metadata.
    #[prost(message, optional, tag = "1")]
    pub common_operation_metadata: ::std::option::Option<CommonOperationMetadata>,
}
/// Request for getting a Dataset.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GetDatasetRequest {
    /// Required. Dataset identifier.
    #[prost(string, tag = "1")]
    pub name: std::string::String,
}
/// Request for deleting a Dataset.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct DeleteDatasetRequest {
    /// Required. Dataset identifier.
    #[prost(string, tag = "1")]
    pub name: std::string::String,
}
/// Request for listing Datasets.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ListDatasetsRequest {
    /// Required. Parent identifier.
    #[prost(string, tag = "1")]
    pub parent: std::string::String,
    /// The standard list filter.
    #[prost(string, tag = "2")]
    pub filter: std::string::String,
    /// The maximum number of Dataset to return. The service may return fewer
    /// than this value. If unspecified, at most 20 Datasets will be returned.
    /// The maximum value is 100; values above 100 will be coerced to 100.
    #[prost(int32, tag = "3")]
    pub page_size: i32,
    /// A page token, received from a previous `ListDatasets` call.
    /// Provide this to retrieve the subsequent page.
    ///
    /// When paginating, all other parameters provided to `ListDatasets` must
    /// match the call that provided the page token.
    #[prost(string, tag = "4")]
    pub page_token: std::string::String,
}
/// Response for ListDatasets.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ListDatasetsResponse {
    /// The datasets for this project.
    #[prost(message, repeated, tag = "1")]
    pub datasets: ::std::vec::Vec<Dataset>,
    /// A token that can be sent as `page_token` to retrieve the next page.
    /// If this field is omitted, there are no subsequent pages.
    #[prost(string, tag = "2")]
    pub next_page_token: std::string::String,
}
/// Request for importing a Dataset.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ImportDataRequest {
    /// Required. Dataset identifier.
    #[prost(string, tag = "1")]
    pub name: std::string::String,
    /// Required. The desired input locations. The contents of all input locations
    /// will be imported in one batch.
    #[prost(message, repeated, tag = "2")]
    pub import_configs: ::std::vec::Vec<ImportDataConfig>,
}
/// ImportData operation metadata.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ImportDataOperationMetadata {
    /// Output only. Common operation metadata.
    #[prost(message, optional, tag = "1")]
    pub common_operation_metadata: ::std::option::Option<CommonOperationMetadata>,
}
/// Request for exporting a Dataset.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ExportDataRequest {
    /// Required. Dataset identifier.
    #[prost(string, tag = "1")]
    pub name: std::string::String,
    /// Required. The desired output location.
    #[prost(message, optional, tag = "2")]
    pub export_config: ::std::option::Option<ExportDataConfig>,
}
/// ExportData operation metadata.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ExportDataOperationMetadata {
    /// Output only. Common operation metadata.
    #[prost(message, optional, tag = "1")]
    pub common_operation_metadata: ::std::option::Option<CommonOperationMetadata>,
}
/// DeleteDataset operation metadata.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct DeleteDatasetOperationMetadata {
    /// Output only. Common operation metadata.
    #[prost(message, optional, tag = "1")]
    pub common_operation_metadata: ::std::option::Option<CommonOperationMetadata>,
}
/// Request for getting an Image.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GetImageRequest {
    /// Required. Image identifier.
    #[prost(string, tag = "1")]
    pub name: std::string::String,
}
/// Request for listing Images.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ListImagesRequest {
    /// Required. Parent identifier.
    #[prost(string, tag = "1")]
    pub parent: std::string::String,
    /// The standard list filter.
    #[prost(string, tag = "2")]
    pub filter: std::string::String,
    /// The maximum number of images to return. The service may return fewer
    /// than this value. If unspecified, at most 20 images will be returned.
    /// The maximum value is 200; values above 200 will be coerced to 100.
    #[prost(int32, tag = "3")]
    pub page_size: i32,
    /// A page token, received from a previous `ListImages` call.
    /// Provide this to retrieve the subsequent page.
    ///
    /// When paginating, all other parameters provided to `ListImages` must
    /// match the call that provided the page token.
    #[prost(string, tag = "4")]
    pub page_token: std::string::String,
}
/// Response for ListImages.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ListImagesResponse {
    /// The images for this dataset.
    #[prost(message, repeated, tag = "1")]
    pub images: ::std::vec::Vec<Image>,
    /// A token that can be sent as `page_token` to retrieve the next page.
    /// If this field is omitted, there are no subsequent pages.
    #[prost(string, tag = "2")]
    pub next_page_token: std::string::String,
}
/// Request for creating a AnnotationSet.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CreateAnnotationSetRequest {
    /// Required. Parent identifier.
    #[prost(string, tag = "1")]
    pub parent: std::string::String,
    /// Required. AnnotationSet to create.
    #[prost(message, optional, tag = "2")]
    pub annotation_set: ::std::option::Option<AnnotationSet>,
}
/// Request for listing AnnotationSets.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ListAnnotationSetsRequest {
    /// Required. Parent identifier.
    #[prost(string, tag = "1")]
    pub parent: std::string::String,
    /// The standard list filter.
    #[prost(string, tag = "2")]
    pub filter: std::string::String,
    /// The maximum number of AnnotationSets to return. The service may return
    /// fewer than this value. If unspecified, at most 20 AnnotationSets will be
    /// returned. The maximum value is 100; values above 100 will be coerced to
    /// 100.
    #[prost(int32, tag = "3")]
    pub page_size: i32,
    /// A page token, received from a previous `ListAnnotationSets` call.
    /// Provide this to retrieve the subsequent page.
    ///
    /// When paginating, all other parameters provided to `ListAnnotationSets` must
    /// match the call that provided the page token.
    #[prost(string, tag = "4")]
    pub page_token: std::string::String,
}
/// Response for ListAnnotationSets.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ListAnnotationSetsResponse {
    /// The annotationsets for this project.
    #[prost(message, repeated, tag = "1")]
    pub annotation_sets: ::std::vec::Vec<AnnotationSet>,
    /// A token that can be sent as `page_token` to retrieve the next page.
    /// If this field is omitted, there are no subsequent pages.
    #[prost(string, tag = "2")]
    pub next_page_token: std::string::String,
}
/// Operation metadata for DeleteAnnotationSet.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct DeleteAnnotationSetOperationMetadata {
    /// Output only. Common operation metadata.
    #[prost(message, optional, tag = "1")]
    pub common_operation_metadata: ::std::option::Option<CommonOperationMetadata>,
}
/// Request for creating a AnnotationSpec.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CreateAnnotationSpecRequest {
    /// Required. Parent identifier.
    #[prost(string, tag = "1")]
    pub parent: std::string::String,
    /// Required. AnnotationSpec to create.
    #[prost(message, optional, tag = "2")]
    pub annotation_spec: ::std::option::Option<AnnotationSpec>,
}
/// Request for listing AnnotationSpecs.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ListAnnotationSpecsRequest {
    /// Required. Parent identifier.
    #[prost(string, tag = "1")]
    pub parent: std::string::String,
    /// The standard list filter.
    #[prost(string, tag = "2")]
    pub filter: std::string::String,
    /// The maximum number of AnnotationSpecs to return. The service may return
    /// fewer than this value. If unspecified, at most 20 AnnotationSpecs will be
    /// returned. The maximum value is 100; values above 100 will be coerced to
    /// 100.
    #[prost(int32, tag = "3")]
    pub page_size: i32,
    /// A page token, received from a previous `ListAnnotationSpecs` call.
    /// Provide this to retrieve the subsequent page.
    ///
    /// When paginating, all other parameters provided to `ListAnnotationSpecs`
    /// must match the call that provided the page token.
    #[prost(string, tag = "4")]
    pub page_token: std::string::String,
}
/// Response for ListAnnotationSpecs.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ListAnnotationSpecsResponse {
    /// The annotationspecs for this project.
    #[prost(message, repeated, tag = "1")]
    pub annotation_specs: ::std::vec::Vec<AnnotationSpec>,
    /// A token that can be sent as `page_token` to retrieve the next page.
    /// If this field is omitted, there are no subsequent pages.
    #[prost(string, tag = "2")]
    pub next_page_token: std::string::String,
}
/// Operation Metadata for DeleteAnnotationSpec.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct DeleteAnnotationSpecOperationMetadata {
    /// Output only. Common operation metadata.
    #[prost(message, optional, tag = "1")]
    pub common_operation_metadata: ::std::option::Option<CommonOperationMetadata>,
}
/// Request for listing Annotations.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ListAnnotationsRequest {
    /// Required. Parent identifier.
    #[prost(string, tag = "1")]
    pub parent: std::string::String,
    /// The standard list filter.
    #[prost(string, tag = "2")]
    pub filter: std::string::String,
    /// The maximum number of annotations to return. The service may return
    /// fewer than this value. If unspecified, at most 20 annotations will be
    /// returned. The maximum value is 100; values above 100 will be coerced to
    /// 100.
    #[prost(int32, tag = "3")]
    pub page_size: i32,
    /// A page token, received from a previous `ListAnnotations` call.
    /// Provide this to retrieve the subsequent page.
    ///
    /// When paginating, all other parameters provided to `ListAnnotations`
    /// must match the call that provided the page token.
    #[prost(string, tag = "4")]
    pub page_token: std::string::String,
}
/// Response for ListAnnotations.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ListAnnotationsResponse {
    /// The annotations for this image.
    #[prost(message, repeated, tag = "1")]
    pub annotations: ::std::vec::Vec<Annotation>,
    /// A token that can be sent as `page_token` to retrieve the next page.
    /// If this field is omitted, there are no subsequent pages.
    #[prost(string, tag = "2")]
    pub next_page_token: std::string::String,
}
/// Operation metadata for DeleteAnnotation.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct DeleteAnnotationOperationMetadata {
    /// Output only. Common operation metadata.
    #[prost(message, optional, tag = "1")]
    pub common_operation_metadata: ::std::option::Option<CommonOperationMetadata>,
}
/// Request for creating a Module.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CreateModuleRequest {
    /// Required. Parent identifier.
    #[prost(string, tag = "1")]
    pub parent: std::string::String,
    /// Required. Module to create.
    #[prost(message, optional, tag = "2")]
    pub module: ::std::option::Option<Module>,
}
/// Request for listing Modules.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ListModulesRequest {
    /// Required. Parent identifier.
    #[prost(string, tag = "1")]
    pub parent: std::string::String,
    /// The standard list filter.
    #[prost(string, tag = "2")]
    pub filter: std::string::String,
    /// The maximum number of Modules to return. The service may return
    /// fewer than this value. If unspecified, at most 20 Modules will be
    /// returned. The maximum value is 100; values above 100 will be coerced to
    /// 100.
    #[prost(int32, tag = "3")]
    pub page_size: i32,
    /// A page token, received from a previous `ListModules` call.
    /// Provide this to retrieve the subsequent page.
    ///
    /// When paginating, all other parameters provided to `ListModules`
    /// must match the call that provided the page token.
    #[prost(string, tag = "4")]
    pub page_token: std::string::String,
}
/// Response for ListModules.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ListModulesResponse {
    /// The Modules.
    #[prost(message, repeated, tag = "1")]
    pub modules: ::std::vec::Vec<Module>,
    /// A token that can be sent as `page_token` to retrieve the next page.
    /// If this field is omitted, there are no subsequent pages.
    #[prost(string, tag = "2")]
    pub next_page_token: std::string::String,
}
/// Request for getting a Module.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GetModuleRequest {
    /// Required. Module identifier.
    #[prost(string, tag = "1")]
    pub name: std::string::String,
}
/// Request for deleting a Module.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct DeleteModuleRequest {
    /// Required. Module identifier.
    #[prost(string, tag = "1")]
    pub name: std::string::String,
}
/// Operation metadata for DeleteModule.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct DeleteModuleOperationMetadata {
    /// Output only. Common operation metadata.
    #[prost(message, optional, tag = "1")]
    pub common_operation_metadata: ::std::option::Option<CommonOperationMetadata>,
}
/// Request for updating a Module.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct UpdateModuleRequest {
    /// Required. The Module which replaces the resource on the server.
    #[prost(message, optional, tag = "1")]
    pub module: ::std::option::Option<Module>,
    /// Required. The update mask applies to the resource.
    /// For the `FieldMask` definition, see
    ///
    /// [FieldMask](https:
    /// //developers.google.com/protocol-buffers
    /// // /docs/reference/google.protobuf#fieldmask).
    #[prost(message, optional, tag = "2")]
    pub update_mask: ::std::option::Option<::prost_types::FieldMask>,
}
/// Request for creating a Model. This invokes the training process for
/// the parent Module.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CreateModelRequest {
    /// Required. Parent identifier.
    #[prost(string, tag = "1")]
    pub parent: std::string::String,
    /// Optional. Model to create.
    #[prost(message, optional, tag = "2")]
    pub model: ::std::option::Option<Model>,
}
/// Operation metadata for CreateModel.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CreateModelOperationMetadata {
    /// Output only. Common operation metadata.
    #[prost(message, optional, tag = "1")]
    pub common_operation_metadata: ::std::option::Option<CommonOperationMetadata>,
}
/// Request for listing Models.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ListModelsRequest {
    /// Required. Parent identifier.
    #[prost(string, tag = "1")]
    pub parent: std::string::String,
    /// The standard list filter.
    #[prost(string, tag = "2")]
    pub filter: std::string::String,
    /// The maximum number of Models to return. The service may return
    /// fewer than this value. If unspecified, at most 20 Models will be
    /// returned. The maximum value is 100; values above 100 will be coerced to
    /// 100.
    #[prost(int32, tag = "3")]
    pub page_size: i32,
    /// A page token, received from a previous `ListModels` call.
    /// Provide this to retrieve the subsequent page.
    ///
    /// When paginating, all other parameters provided to `ListModels`
    /// must match the call that provided the page token.
    #[prost(string, tag = "4")]
    pub page_token: std::string::String,
}
/// Response for ListModels.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ListModelsResponse {
    /// The Model.
    #[prost(message, repeated, tag = "1")]
    pub models: ::std::vec::Vec<Model>,
    /// A token that can be sent as `page_token` to retrieve the next page.
    /// If this field is omitted, there are no subsequent pages.
    #[prost(string, tag = "2")]
    pub next_page_token: std::string::String,
}
/// Request for getting a Model.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GetModelRequest {
    /// Required. Model identifier.
    #[prost(string, tag = "1")]
    pub name: std::string::String,
}
/// Request for deleting a Model.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct DeleteModelRequest {
    /// Required. Model identifier.
    #[prost(string, tag = "1")]
    pub name: std::string::String,
}
/// Operation metadata for DeleteModel.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct DeleteModelOperationMetadata {
    /// Output only. Common operation metadata.
    #[prost(message, optional, tag = "1")]
    pub common_operation_metadata: ::std::option::Option<CommonOperationMetadata>,
}
/// Request for updating a Model.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct UpdateModelRequest {
    /// Required. The Model which replaces the resource on the server.
    #[prost(message, optional, tag = "1")]
    pub model: ::std::option::Option<Model>,
    /// Required. The update mask applies to the resource.
    /// For the `FieldMask` definition, see
    ///
    /// [FieldMask](https:
    /// //developers.google.com/protocol-buffers
    /// // /docs/reference/google.protobuf#fieldmask).
    #[prost(message, optional, tag = "2")]
    pub update_mask: ::std::option::Option<::prost_types::FieldMask>,
}
/// Request for listing ModelEvaluations.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ListModelEvaluationsRequest {
    /// Required. Parent identifier.
    #[prost(string, tag = "1")]
    pub parent: std::string::String,
    /// The standard list filter.
    #[prost(string, tag = "2")]
    pub filter: std::string::String,
    /// The maximum number of ModelEvaluations to return. The service may return
    /// fewer than this value. If unspecified, at most 20 ModelEvaluations will be
    /// returned. The maximum value is 100; values above 100 will be coerced to
    /// 100.
    #[prost(int32, tag = "3")]
    pub page_size: i32,
    /// A page token, received from a previous `ModelEvaluations` call.
    /// Provide this to retrieve the subsequent page.
    ///
    /// When paginating, all other parameters provided to `ModelEvaluations`
    /// must match the call that provided the page token.
    #[prost(string, tag = "4")]
    pub page_token: std::string::String,
}
/// Response for ListModelEvaluations.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ListModelEvaluationsResponse {
    /// The ModelEvaluation.
    #[prost(message, repeated, tag = "1")]
    pub model_evaluations: ::std::vec::Vec<ModelEvaluation>,
    /// A token that can be sent as `page_token` to retrieve the next page.
    /// If this field is omitted, there are no subsequent pages.
    #[prost(string, tag = "2")]
    pub next_page_token: std::string::String,
}
/// Request for getting a ModelEvaluation.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GetModelEvaluationRequest {
    /// Required. ModelEvaluation identifier.
    #[prost(string, tag = "1")]
    pub name: std::string::String,
}
/// Request for enriching the Dataset with predicted Annotations from a
/// Model.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct WritePredictionsRequest {
    /// Required. Model identifier.
    #[prost(string, tag = "1")]
    pub model: std::string::String,
    /// A score threshold in the range [0, 1] to filter output Annotations. If set,
    /// only Annotations with at least this score will be saved in the output
    /// AnnotationSet. Otherwise a default value will be used based on the Module.
    #[prost(float, tag = "2")]
    pub output_score_threshold: f32,
    /// An IOU (intersection over union) threshold in the range [0, 1] to use for
    /// matching Annotations for some Module types. New Annotations must have at
    /// least this IOU in in relation to an old Anotation to be considered
    /// matching. If not provided, a default value will be used based on the
    /// Module.
    #[prost(float, tag = "3")]
    pub output_matching_iou_threshold: f32,
    /// By default WritePredictions copies all Annotation labels from old
    /// Annotations to new Annotations. These fields give finer control over which
    /// label keys to copy. If provided, only keys in this list will be copied.
    #[prost(string, repeated, tag = "4")]
    pub label_keys_copy_allowlist: ::std::vec::Vec<std::string::String>,
    /// If provided, no keys in this list will be copied, even if they appear
    /// in the allowlist.
    #[prost(string, repeated, tag = "5")]
    pub label_keys_copy_denylist: ::std::vec::Vec<std::string::String>,
}
/// Operation metadata for WritePredictions.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct WritePredictionsOperationMetadata {
    /// Output only. Common operation metadata.
    #[prost(message, optional, tag = "1")]
    pub common_operation_metadata: ::std::option::Option<CommonOperationMetadata>,
}
/// Request for creating a SpecialistPool.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CreateSpecialistPoolRequest {
    /// Required. The parent Project name for the new SpecialistPool.
    /// The form is `projects/{project}/locations/{location}`.
    #[prost(string, tag = "1")]
    pub parent: std::string::String,
    /// Required. The SpecialistPool to create.
    #[prost(message, optional, tag = "2")]
    pub specialist_pool: ::std::option::Option<SpecialistPool>,
}
/// Operation metadata for CreateSpecialistPool.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CreateSpecialistPoolOperationMetadata {
    /// Output only. Common operation metadata.
    #[prost(message, optional, tag = "1")]
    pub common_operation_metadata: ::std::option::Option<CommonOperationMetadata>,
}
/// Request for getting a SpecialistPool.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GetSpecialistPoolRequest {
    /// Required. The name of the SpecialistPool resource.
    /// The form is
    ///
    /// `projects/{project}/locations/{location}/specialistPools/{specialist_pool}`.
    #[prost(string, tag = "1")]
    pub name: std::string::String,
}
/// Request for updating a SpecialistPool.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct UpdateSpecialistPoolRequest {
    /// Required. The SpecialistPool which replaces the resource on the server.
    #[prost(message, optional, tag = "1")]
    pub specialist_pool: ::std::option::Option<SpecialistPool>,
    /// Required. The update mask applies to the resource.
    /// For the `FieldMask` definition, see
    ///
    /// [FieldMask](https:
    /// //developers.google.com/protocol-buffers
    /// // /docs/reference/google.protobuf#fieldmask).
    #[prost(message, optional, tag = "2")]
    pub update_mask: ::std::option::Option<::prost_types::FieldMask>,
}
/// Operation metadata for UpdateSpecialistPool.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct UpdateSpecialistPoolOperationMetadata {
    /// Output only. Common operation metadata.
    #[prost(message, optional, tag = "1")]
    pub common_operation_metadata: ::std::option::Option<CommonOperationMetadata>,
}
/// Request message for listing SpecialistPools.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ListSpecialistPoolsRequest {
    /// Required. The name of the SpecialistPool's parent resource.
    /// Format: `projects/{project}/locations/{location}`
    #[prost(string, tag = "1")]
    pub parent: std::string::String,
    /// The number of SpecialistPools to return.
    #[prost(int32, tag = "2")]
    pub page_size: i32,
    /// A page token, received from a previous `ListSpecialistPoolsRequest` call.
    /// Provide this to retrieve the subsequent page.
    ///
    /// When paginating, all other parameters provided to
    /// `ListSpecialistPoolsRequest` must match the call that provided the page
    /// token.
    #[prost(string, tag = "3")]
    pub page_token: std::string::String,
    /// The standard list filter.
    #[prost(string, tag = "4")]
    pub filter: std::string::String,
}
/// Response message for ListSpecialistPools.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ListSpecialistPoolsResponse {
    /// A list of SpecialistPools that matches the specified filter in the request.
    #[prost(message, repeated, tag = "1")]
    pub specialist_pools: ::std::vec::Vec<SpecialistPool>,
    /// A token that can be sent as `page_token` to retrieve the next page.
    /// If this field is omitted, there are no subsequent pages.
    #[prost(string, tag = "2")]
    pub next_page_token: std::string::String,
}
/// Request for deleting a specialist pool.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct DeleteSpecialistPoolRequest {
    /// Required. The resource name of the SpecialistPool to delete. Format:
    ///
    /// `projects/{project}/locations/{location}/specialistPools/{specialist_pool}`.
    #[prost(string, tag = "1")]
    pub name: std::string::String,
}
/// Operation metadata for DeleteSpecialistPool.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct DeleteSpecialistPoolOperationMetadata {
    /// Output only. Common operation metadata.
    #[prost(message, optional, tag = "1")]
    pub common_operation_metadata: ::std::option::Option<CommonOperationMetadata>,
}
/// Request for creating a labeling job.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CreateLabelingJobRequest {
    /// Required. The parent of the LabelingJob.
    /// Format: `projects/{project}/locations/{location}`
    #[prost(string, tag = "1")]
    pub parent: std::string::String,
    /// Required. The LabelingJob to create.
    #[prost(message, optional, tag = "2")]
    pub labeling_job: ::std::option::Option<LabelingJob>,
}
/// Request for getting a labeling job.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GetLabelingJobRequest {
    /// Required. The name of the LabelingJob.
    /// Format:
    /// `projects/{project}/locations/{location}/labelingJobs/{labeling_job}`
    #[prost(string, tag = "1")]
    pub name: std::string::String,
}
/// Request message for listing labeling jobs.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ListLabelingJobsRequest {
    /// Required. The name of the LabelingJob's parent resource.
    /// Format: `projects/{project}/locations/{location}`
    #[prost(string, tag = "1")]
    pub parent: std::string::String,
    /// The number of labeling jobs to return.
    #[prost(int32, tag = "2")]
    pub page_size: i32,
    /// A page token, received from a previous `ListLabelingJobsRequest` call.
    /// Provide this to retrieve the subsequent page.
    ///
    /// When paginating, all other parameters provided to
    /// `ListLabelingJobsRequest` must match the call that provided the page
    /// token.
    #[prost(string, tag = "3")]
    pub page_token: std::string::String,
    /// The standard list filter.
    #[prost(string, tag = "4")]
    pub filter: std::string::String,
}
/// Response message for listing labeling jobs.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ListLabelingJobsResponse {
    /// A list of SpecialistPools that matches the specified filter in the request.
    #[prost(message, repeated, tag = "1")]
    pub labeling_jobs: ::std::vec::Vec<LabelingJob>,
    /// A token that can be sent as `page_token` to retrieve the next page.
    /// If this field is omitted, there are no subsequent pages.
    #[prost(string, tag = "2")]
    pub next_page_token: std::string::String,
}
/// Request for deleting a labeling job.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct DeleteLabelingJobRequest {
    /// Required. The resource name of the labeling job to delete. Format:
    /// `projects/{project}/locations/{location}/labelingJobs/{labeling_job}`.
    #[prost(string, tag = "1")]
    pub name: std::string::String,
}
/// Operation metadata for deleting a labeling job.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct DeleteLabelingJobOperationMetadata {
    /// Output only. Common operation metadata.
    #[prost(message, optional, tag = "1")]
    pub common_operation_metadata: ::std::option::Option<CommonOperationMetadata>,
}
/// Request message for cancelling a labeling job.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CancelLabelingJobRequest {
    /// Required. The resource name of the labeling job to cancel. Format:
    /// `projects/{project}/locations/{location}/labelingJobs/{labeling_job}`.
    #[prost(string, tag = "1")]
    pub name: std::string::String,
}
/// Request message for BatchPredict.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct BatchPredictRequest {
    /// Required. SolutionArtifact identifier.
    #[prost(string, tag = "1")]
    pub solution_artifact: std::string::String,
    /// Required. The input configuration for batch prediction.
    /// The Cloud Storage path of input file. Accepted forms:
    /// * Full object path, e.g. gs://bucket/directory/object.csv in which each
    /// line is the full path to a image file.
    #[prost(string, tag = "2")]
    pub input_uri: std::string::String,
    /// Required. The Cloud Storage location of the directory where the output is
    /// to be written to. Output directory will contain:
    /// 1. output.jsonl
    /// # Each line is a JSON format of PredictionResult.
    ///
    /// 2. category_masks (for MaskAnnotation)
    /// # Directory of masks - referenced via annotation in output.jsonl.
    ///
    /// 3. confidence_masks (for MaskAnnotation)
    /// # Directory of masks - referenced via annotation in output.jsonl.
    #[prost(message, optional, tag = "3")]
    pub output_gcs_dir: ::std::option::Option<GcsDestination>,
}
/// Operation metadata for BatchPreidct.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct BatchPredictOperationMetadata {
    /// Output only. Common operation metadata.
    #[prost(message, optional, tag = "1")]
    pub common_operation_metadata: ::std::option::Option<CommonOperationMetadata>,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct BatchPredictResponse {}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ExportDataResponse {}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ImportDataResponse {}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct WritePredictionsResponse {}
#[doc = r" Generated client implementations."]
pub mod visual_inspection_client {
    #![allow(unused_variables, dead_code, missing_docs)]
    use tonic::codegen::*;
    #[doc = " Visual Inspection service enables users to train and manage solutions"]
    #[doc = " for visually inspecting parts."]
    pub struct VisualInspectionClient<T> {
        inner: tonic::client::Grpc<T>,
    }
    impl<T> VisualInspectionClient<T>
    where
        T: tonic::client::GrpcService<tonic::body::BoxBody>,
        T::ResponseBody: Body + HttpBody + Send + 'static,
        T::Error: Into<StdError>,
        <T::ResponseBody as HttpBody>::Error: Into<StdError> + Send,
    {
        pub fn new(inner: T) -> Self {
            let inner = tonic::client::Grpc::new(inner);
            Self { inner }
        }
        pub fn with_interceptor(inner: T, interceptor: impl Into<tonic::Interceptor>) -> Self {
            let inner = tonic::client::Grpc::with_interceptor(inner, interceptor);
            Self { inner }
        }
        #[doc = " Creates a solution."]
        pub async fn create_solution(
            &mut self,
            request: impl tonic::IntoRequest<super::CreateSolutionRequest>,
        ) -> Result<
            tonic::Response<super::super::super::super::longrunning::Operation>,
            tonic::Status,
        > {
            self.inner.ready().await.map_err(|e| {
                tonic::Status::new(
                    tonic::Code::Unknown,
                    format!("Service was not ready: {}", e.into()),
                )
            })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.visualinspection.v1beta1.VisualInspection/CreateSolution",
            );
            self.inner.unary(request.into_request(), path, codec).await
        }
        #[doc = " Lists solutions."]
        pub async fn list_solutions(
            &mut self,
            request: impl tonic::IntoRequest<super::ListSolutionsRequest>,
        ) -> Result<tonic::Response<super::ListSolutionsResponse>, tonic::Status> {
            self.inner.ready().await.map_err(|e| {
                tonic::Status::new(
                    tonic::Code::Unknown,
                    format!("Service was not ready: {}", e.into()),
                )
            })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.visualinspection.v1beta1.VisualInspection/ListSolutions",
            );
            self.inner.unary(request.into_request(), path, codec).await
        }
        #[doc = " Gets a solution."]
        pub async fn get_solution(
            &mut self,
            request: impl tonic::IntoRequest<super::GetSolutionRequest>,
        ) -> Result<tonic::Response<super::Solution>, tonic::Status> {
            self.inner.ready().await.map_err(|e| {
                tonic::Status::new(
                    tonic::Code::Unknown,
                    format!("Service was not ready: {}", e.into()),
                )
            })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.visualinspection.v1beta1.VisualInspection/GetSolution",
            );
            self.inner.unary(request.into_request(), path, codec).await
        }
        #[doc = " Creates a SolutionArtifact."]
        pub async fn create_solution_artifact(
            &mut self,
            request: impl tonic::IntoRequest<super::CreateSolutionArtifactRequest>,
        ) -> Result<
            tonic::Response<super::super::super::super::longrunning::Operation>,
            tonic::Status,
        > {
            self.inner.ready().await.map_err(|e| {
                tonic::Status::new(
                    tonic::Code::Unknown,
                    format!("Service was not ready: {}", e.into()),
                )
            })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.visualinspection.v1beta1.VisualInspection/CreateSolutionArtifact",
            );
            self.inner.unary(request.into_request(), path, codec).await
        }
        #[doc = " Lists SolutionArtifacts in a Solution."]
        pub async fn list_solution_artifacts(
            &mut self,
            request: impl tonic::IntoRequest<super::ListSolutionArtifactsRequest>,
        ) -> Result<tonic::Response<super::ListSolutionArtifactsResponse>, tonic::Status> {
            self.inner.ready().await.map_err(|e| {
                tonic::Status::new(
                    tonic::Code::Unknown,
                    format!("Service was not ready: {}", e.into()),
                )
            })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.visualinspection.v1beta1.VisualInspection/ListSolutionArtifacts",
            );
            self.inner.unary(request.into_request(), path, codec).await
        }
        #[doc = " Gets a SolutionArtifact."]
        pub async fn get_solution_artifact(
            &mut self,
            request: impl tonic::IntoRequest<super::GetSolutionArtifactRequest>,
        ) -> Result<tonic::Response<super::SolutionArtifact>, tonic::Status> {
            self.inner.ready().await.map_err(|e| {
                tonic::Status::new(
                    tonic::Code::Unknown,
                    format!("Service was not ready: {}", e.into()),
                )
            })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.visualinspection.v1beta1.VisualInspection/GetSolutionArtifact",
            );
            self.inner.unary(request.into_request(), path, codec).await
        }
        #[doc = " Deletes a SolutionArtifact. Only the subject SolutionArtifact is affected"]
        #[doc = " by this operation. The SolutionArtifact's Models remain unchanged."]
        pub async fn delete_solution_artifact(
            &mut self,
            request: impl tonic::IntoRequest<super::DeleteSolutionArtifactRequest>,
        ) -> Result<
            tonic::Response<super::super::super::super::longrunning::Operation>,
            tonic::Status,
        > {
            self.inner.ready().await.map_err(|e| {
                tonic::Status::new(
                    tonic::Code::Unknown,
                    format!("Service was not ready: {}", e.into()),
                )
            })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.visualinspection.v1beta1.VisualInspection/DeleteSolutionArtifact",
            );
            self.inner.unary(request.into_request(), path, codec).await
        }
        #[doc = " Updates a SolutionArtifact."]
        pub async fn update_solution_artifact(
            &mut self,
            request: impl tonic::IntoRequest<super::UpdateSolutionArtifactRequest>,
        ) -> Result<tonic::Response<super::SolutionArtifact>, tonic::Status> {
            self.inner.ready().await.map_err(|e| {
                tonic::Status::new(
                    tonic::Code::Unknown,
                    format!("Service was not ready: {}", e.into()),
                )
            })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.visualinspection.v1beta1.VisualInspection/UpdateSolutionArtifact",
            );
            self.inner.unary(request.into_request(), path, codec).await
        }
        #[doc = " Perform batch prediction on a given SolutionArtifact."]
        pub async fn batch_predict(
            &mut self,
            request: impl tonic::IntoRequest<super::BatchPredictRequest>,
        ) -> Result<
            tonic::Response<super::super::super::super::longrunning::Operation>,
            tonic::Status,
        > {
            self.inner.ready().await.map_err(|e| {
                tonic::Status::new(
                    tonic::Code::Unknown,
                    format!("Service was not ready: {}", e.into()),
                )
            })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.visualinspection.v1beta1.VisualInspection/BatchPredict",
            );
            self.inner.unary(request.into_request(), path, codec).await
        }
        #[doc = " Gets a Dataset."]
        pub async fn get_dataset(
            &mut self,
            request: impl tonic::IntoRequest<super::GetDatasetRequest>,
        ) -> Result<tonic::Response<super::Dataset>, tonic::Status> {
            self.inner.ready().await.map_err(|e| {
                tonic::Status::new(
                    tonic::Code::Unknown,
                    format!("Service was not ready: {}", e.into()),
                )
            })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.visualinspection.v1beta1.VisualInspection/GetDataset",
            );
            self.inner.unary(request.into_request(), path, codec).await
        }
        #[doc = " Lists Datasets in a Project."]
        pub async fn list_datasets(
            &mut self,
            request: impl tonic::IntoRequest<super::ListDatasetsRequest>,
        ) -> Result<tonic::Response<super::ListDatasetsResponse>, tonic::Status> {
            self.inner.ready().await.map_err(|e| {
                tonic::Status::new(
                    tonic::Code::Unknown,
                    format!("Service was not ready: {}", e.into()),
                )
            })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.visualinspection.v1beta1.VisualInspection/ListDatasets",
            );
            self.inner.unary(request.into_request(), path, codec).await
        }
        #[doc = " Deletes a Dataset."]
        pub async fn delete_dataset(
            &mut self,
            request: impl tonic::IntoRequest<super::DeleteDatasetRequest>,
        ) -> Result<
            tonic::Response<super::super::super::super::longrunning::Operation>,
            tonic::Status,
        > {
            self.inner.ready().await.map_err(|e| {
                tonic::Status::new(
                    tonic::Code::Unknown,
                    format!("Service was not ready: {}", e.into()),
                )
            })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.visualinspection.v1beta1.VisualInspection/DeleteDataset",
            );
            self.inner.unary(request.into_request(), path, codec).await
        }
        #[doc = " Imports data to a Dataset."]
        pub async fn import_data(
            &mut self,
            request: impl tonic::IntoRequest<super::ImportDataRequest>,
        ) -> Result<
            tonic::Response<super::super::super::super::longrunning::Operation>,
            tonic::Status,
        > {
            self.inner.ready().await.map_err(|e| {
                tonic::Status::new(
                    tonic::Code::Unknown,
                    format!("Service was not ready: {}", e.into()),
                )
            })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.visualinspection.v1beta1.VisualInspection/ImportData",
            );
            self.inner.unary(request.into_request(), path, codec).await
        }
        #[doc = " Exports data from a Dataset."]
        pub async fn export_data(
            &mut self,
            request: impl tonic::IntoRequest<super::ExportDataRequest>,
        ) -> Result<
            tonic::Response<super::super::super::super::longrunning::Operation>,
            tonic::Status,
        > {
            self.inner.ready().await.map_err(|e| {
                tonic::Status::new(
                    tonic::Code::Unknown,
                    format!("Service was not ready: {}", e.into()),
                )
            })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.visualinspection.v1beta1.VisualInspection/ExportData",
            );
            self.inner.unary(request.into_request(), path, codec).await
        }
        #[doc = " Gets an Image."]
        #[doc = " ImportData will create images. Therefore CreateImage is omitted."]
        pub async fn get_image(
            &mut self,
            request: impl tonic::IntoRequest<super::GetImageRequest>,
        ) -> Result<tonic::Response<super::Image>, tonic::Status> {
            self.inner.ready().await.map_err(|e| {
                tonic::Status::new(
                    tonic::Code::Unknown,
                    format!("Service was not ready: {}", e.into()),
                )
            })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.visualinspection.v1beta1.VisualInspection/GetImage",
            );
            self.inner.unary(request.into_request(), path, codec).await
        }
        #[doc = " Lists Images in a Dataset."]
        pub async fn list_images(
            &mut self,
            request: impl tonic::IntoRequest<super::ListImagesRequest>,
        ) -> Result<tonic::Response<super::ListImagesResponse>, tonic::Status> {
            self.inner.ready().await.map_err(|e| {
                tonic::Status::new(
                    tonic::Code::Unknown,
                    format!("Service was not ready: {}", e.into()),
                )
            })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.visualinspection.v1beta1.VisualInspection/ListImages",
            );
            self.inner.unary(request.into_request(), path, codec).await
        }
        #[doc = " Creates an AnnotationSet."]
        pub async fn create_annotation_set(
            &mut self,
            request: impl tonic::IntoRequest<super::CreateAnnotationSetRequest>,
        ) -> Result<tonic::Response<super::AnnotationSet>, tonic::Status> {
            self.inner.ready().await.map_err(|e| {
                tonic::Status::new(
                    tonic::Code::Unknown,
                    format!("Service was not ready: {}", e.into()),
                )
            })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.visualinspection.v1beta1.VisualInspection/CreateAnnotationSet",
            );
            self.inner.unary(request.into_request(), path, codec).await
        }
        #[doc = " Lists AnnotationSets in a Dataset."]
        pub async fn list_annotation_sets(
            &mut self,
            request: impl tonic::IntoRequest<super::ListAnnotationSetsRequest>,
        ) -> Result<tonic::Response<super::ListAnnotationSetsResponse>, tonic::Status> {
            self.inner.ready().await.map_err(|e| {
                tonic::Status::new(
                    tonic::Code::Unknown,
                    format!("Service was not ready: {}", e.into()),
                )
            })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.visualinspection.v1beta1.VisualInspection/ListAnnotationSets",
            );
            self.inner.unary(request.into_request(), path, codec).await
        }
        #[doc = " Creates an AnnotationSpec."]
        pub async fn create_annotation_spec(
            &mut self,
            request: impl tonic::IntoRequest<super::CreateAnnotationSpecRequest>,
        ) -> Result<tonic::Response<super::AnnotationSpec>, tonic::Status> {
            self.inner.ready().await.map_err(|e| {
                tonic::Status::new(
                    tonic::Code::Unknown,
                    format!("Service was not ready: {}", e.into()),
                )
            })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.visualinspection.v1beta1.VisualInspection/CreateAnnotationSpec",
            );
            self.inner.unary(request.into_request(), path, codec).await
        }
        #[doc = " Lists AnnotationSpecs in a dataset."]
        pub async fn list_annotation_specs(
            &mut self,
            request: impl tonic::IntoRequest<super::ListAnnotationSpecsRequest>,
        ) -> Result<tonic::Response<super::ListAnnotationSpecsResponse>, tonic::Status> {
            self.inner.ready().await.map_err(|e| {
                tonic::Status::new(
                    tonic::Code::Unknown,
                    format!("Service was not ready: {}", e.into()),
                )
            })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.visualinspection.v1beta1.VisualInspection/ListAnnotationSpecs",
            );
            self.inner.unary(request.into_request(), path, codec).await
        }
        #[doc = " Lists Annotations on an Image."]
        pub async fn list_annotations(
            &mut self,
            request: impl tonic::IntoRequest<super::ListAnnotationsRequest>,
        ) -> Result<tonic::Response<super::ListAnnotationsResponse>, tonic::Status> {
            self.inner.ready().await.map_err(|e| {
                tonic::Status::new(
                    tonic::Code::Unknown,
                    format!("Service was not ready: {}", e.into()),
                )
            })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.visualinspection.v1beta1.VisualInspection/ListAnnotations",
            );
            self.inner.unary(request.into_request(), path, codec).await
        }
        #[doc = " Creates a Module."]
        pub async fn create_module(
            &mut self,
            request: impl tonic::IntoRequest<super::CreateModuleRequest>,
        ) -> Result<tonic::Response<super::Module>, tonic::Status> {
            self.inner.ready().await.map_err(|e| {
                tonic::Status::new(
                    tonic::Code::Unknown,
                    format!("Service was not ready: {}", e.into()),
                )
            })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.visualinspection.v1beta1.VisualInspection/CreateModule",
            );
            self.inner.unary(request.into_request(), path, codec).await
        }
        #[doc = " Lists Modules in a Solution."]
        pub async fn list_modules(
            &mut self,
            request: impl tonic::IntoRequest<super::ListModulesRequest>,
        ) -> Result<tonic::Response<super::ListModulesResponse>, tonic::Status> {
            self.inner.ready().await.map_err(|e| {
                tonic::Status::new(
                    tonic::Code::Unknown,
                    format!("Service was not ready: {}", e.into()),
                )
            })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.visualinspection.v1beta1.VisualInspection/ListModules",
            );
            self.inner.unary(request.into_request(), path, codec).await
        }
        #[doc = " Gets a Module."]
        pub async fn get_module(
            &mut self,
            request: impl tonic::IntoRequest<super::GetModuleRequest>,
        ) -> Result<tonic::Response<super::Module>, tonic::Status> {
            self.inner.ready().await.map_err(|e| {
                tonic::Status::new(
                    tonic::Code::Unknown,
                    format!("Service was not ready: {}", e.into()),
                )
            })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.visualinspection.v1beta1.VisualInspection/GetModule",
            );
            self.inner.unary(request.into_request(), path, codec).await
        }
        #[doc = " Deletes a Module. Only the subject Module is affected by this operation."]
        #[doc = " The Module's input and output AnnotationSets and any connected Modules"]
        #[doc = " remain unchanged."]
        pub async fn delete_module(
            &mut self,
            request: impl tonic::IntoRequest<super::DeleteModuleRequest>,
        ) -> Result<
            tonic::Response<super::super::super::super::longrunning::Operation>,
            tonic::Status,
        > {
            self.inner.ready().await.map_err(|e| {
                tonic::Status::new(
                    tonic::Code::Unknown,
                    format!("Service was not ready: {}", e.into()),
                )
            })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.visualinspection.v1beta1.VisualInspection/DeleteModule",
            );
            self.inner.unary(request.into_request(), path, codec).await
        }
        #[doc = " Updates a Module."]
        pub async fn update_module(
            &mut self,
            request: impl tonic::IntoRequest<super::UpdateModuleRequest>,
        ) -> Result<tonic::Response<super::Module>, tonic::Status> {
            self.inner.ready().await.map_err(|e| {
                tonic::Status::new(
                    tonic::Code::Unknown,
                    format!("Service was not ready: {}", e.into()),
                )
            })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.visualinspection.v1beta1.VisualInspection/UpdateModule",
            );
            self.inner.unary(request.into_request(), path, codec).await
        }
        #[doc = " Creates a Model."]
        pub async fn create_model(
            &mut self,
            request: impl tonic::IntoRequest<super::CreateModelRequest>,
        ) -> Result<
            tonic::Response<super::super::super::super::longrunning::Operation>,
            tonic::Status,
        > {
            self.inner.ready().await.map_err(|e| {
                tonic::Status::new(
                    tonic::Code::Unknown,
                    format!("Service was not ready: {}", e.into()),
                )
            })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.visualinspection.v1beta1.VisualInspection/CreateModel",
            );
            self.inner.unary(request.into_request(), path, codec).await
        }
        #[doc = " Lists Models for a Module."]
        pub async fn list_models(
            &mut self,
            request: impl tonic::IntoRequest<super::ListModelsRequest>,
        ) -> Result<tonic::Response<super::ListModelsResponse>, tonic::Status> {
            self.inner.ready().await.map_err(|e| {
                tonic::Status::new(
                    tonic::Code::Unknown,
                    format!("Service was not ready: {}", e.into()),
                )
            })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.visualinspection.v1beta1.VisualInspection/ListModels",
            );
            self.inner.unary(request.into_request(), path, codec).await
        }
        #[doc = " Gets a Model."]
        pub async fn get_model(
            &mut self,
            request: impl tonic::IntoRequest<super::GetModelRequest>,
        ) -> Result<tonic::Response<super::Model>, tonic::Status> {
            self.inner.ready().await.map_err(|e| {
                tonic::Status::new(
                    tonic::Code::Unknown,
                    format!("Service was not ready: {}", e.into()),
                )
            })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.visualinspection.v1beta1.VisualInspection/GetModel",
            );
            self.inner.unary(request.into_request(), path, codec).await
        }
        #[doc = " Deletes a Model."]
        pub async fn delete_model(
            &mut self,
            request: impl tonic::IntoRequest<super::DeleteModelRequest>,
        ) -> Result<
            tonic::Response<super::super::super::super::longrunning::Operation>,
            tonic::Status,
        > {
            self.inner.ready().await.map_err(|e| {
                tonic::Status::new(
                    tonic::Code::Unknown,
                    format!("Service was not ready: {}", e.into()),
                )
            })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.visualinspection.v1beta1.VisualInspection/DeleteModel",
            );
            self.inner.unary(request.into_request(), path, codec).await
        }
        #[doc = " Updates a Model."]
        pub async fn update_model(
            &mut self,
            request: impl tonic::IntoRequest<super::UpdateModelRequest>,
        ) -> Result<tonic::Response<super::Model>, tonic::Status> {
            self.inner.ready().await.map_err(|e| {
                tonic::Status::new(
                    tonic::Code::Unknown,
                    format!("Service was not ready: {}", e.into()),
                )
            })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.visualinspection.v1beta1.VisualInspection/UpdateModel",
            );
            self.inner.unary(request.into_request(), path, codec).await
        }
        #[doc = " Lists ModelEvaluations for a Model. For Beta, we will have only one"]
        #[doc = " evaluation produced when the Model is created."]
        pub async fn list_model_evaluations(
            &mut self,
            request: impl tonic::IntoRequest<super::ListModelEvaluationsRequest>,
        ) -> Result<tonic::Response<super::ListModelEvaluationsResponse>, tonic::Status> {
            self.inner.ready().await.map_err(|e| {
                tonic::Status::new(
                    tonic::Code::Unknown,
                    format!("Service was not ready: {}", e.into()),
                )
            })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.visualinspection.v1beta1.VisualInspection/ListModelEvaluations",
            );
            self.inner.unary(request.into_request(), path, codec).await
        }
        #[doc = " Gets a ModelEvaluation."]
        pub async fn get_model_evaluation(
            &mut self,
            request: impl tonic::IntoRequest<super::GetModelEvaluationRequest>,
        ) -> Result<tonic::Response<super::ModelEvaluation>, tonic::Status> {
            self.inner.ready().await.map_err(|e| {
                tonic::Status::new(
                    tonic::Code::Unknown,
                    format!("Service was not ready: {}", e.into()),
                )
            })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.visualinspection.v1beta1.VisualInspection/GetModelEvaluation",
            );
            self.inner.unary(request.into_request(), path, codec).await
        }
        #[doc = " Writes a Model's predictions to the parent Module's output"]
        #[doc = " AnnotationSets."]
        pub async fn write_predictions(
            &mut self,
            request: impl tonic::IntoRequest<super::WritePredictionsRequest>,
        ) -> Result<
            tonic::Response<super::super::super::super::longrunning::Operation>,
            tonic::Status,
        > {
            self.inner.ready().await.map_err(|e| {
                tonic::Status::new(
                    tonic::Code::Unknown,
                    format!("Service was not ready: {}", e.into()),
                )
            })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.visualinspection.v1beta1.VisualInspection/WritePredictions",
            );
            self.inner.unary(request.into_request(), path, codec).await
        }
        #[doc = " Creates a SpecialistPool."]
        pub async fn create_specialist_pool(
            &mut self,
            request: impl tonic::IntoRequest<super::CreateSpecialistPoolRequest>,
        ) -> Result<
            tonic::Response<super::super::super::super::longrunning::Operation>,
            tonic::Status,
        > {
            self.inner.ready().await.map_err(|e| {
                tonic::Status::new(
                    tonic::Code::Unknown,
                    format!("Service was not ready: {}", e.into()),
                )
            })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.visualinspection.v1beta1.VisualInspection/CreateSpecialistPool",
            );
            self.inner.unary(request.into_request(), path, codec).await
        }
        #[doc = " Gets a SpecialistPool."]
        pub async fn get_specialist_pool(
            &mut self,
            request: impl tonic::IntoRequest<super::GetSpecialistPoolRequest>,
        ) -> Result<tonic::Response<super::SpecialistPool>, tonic::Status> {
            self.inner.ready().await.map_err(|e| {
                tonic::Status::new(
                    tonic::Code::Unknown,
                    format!("Service was not ready: {}", e.into()),
                )
            })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.visualinspection.v1beta1.VisualInspection/GetSpecialistPool",
            );
            self.inner.unary(request.into_request(), path, codec).await
        }
        #[doc = " Updates a SpecialistPool."]
        pub async fn update_specialist_pool(
            &mut self,
            request: impl tonic::IntoRequest<super::UpdateSpecialistPoolRequest>,
        ) -> Result<
            tonic::Response<super::super::super::super::longrunning::Operation>,
            tonic::Status,
        > {
            self.inner.ready().await.map_err(|e| {
                tonic::Status::new(
                    tonic::Code::Unknown,
                    format!("Service was not ready: {}", e.into()),
                )
            })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.visualinspection.v1beta1.VisualInspection/UpdateSpecialistPool",
            );
            self.inner.unary(request.into_request(), path, codec).await
        }
        #[doc = " Lists SpecialistPools."]
        pub async fn list_specialist_pools(
            &mut self,
            request: impl tonic::IntoRequest<super::ListSpecialistPoolsRequest>,
        ) -> Result<tonic::Response<super::ListSpecialistPoolsResponse>, tonic::Status> {
            self.inner.ready().await.map_err(|e| {
                tonic::Status::new(
                    tonic::Code::Unknown,
                    format!("Service was not ready: {}", e.into()),
                )
            })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.visualinspection.v1beta1.VisualInspection/ListSpecialistPools",
            );
            self.inner.unary(request.into_request(), path, codec).await
        }
        #[doc = " Deletes a SpecialistPool."]
        pub async fn delete_specialist_pool(
            &mut self,
            request: impl tonic::IntoRequest<super::DeleteSpecialistPoolRequest>,
        ) -> Result<
            tonic::Response<super::super::super::super::longrunning::Operation>,
            tonic::Status,
        > {
            self.inner.ready().await.map_err(|e| {
                tonic::Status::new(
                    tonic::Code::Unknown,
                    format!("Service was not ready: {}", e.into()),
                )
            })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.visualinspection.v1beta1.VisualInspection/DeleteSpecialistPool",
            );
            self.inner.unary(request.into_request(), path, codec).await
        }
        #[doc = " Creates a LabelingJob."]
        pub async fn create_labeling_job(
            &mut self,
            request: impl tonic::IntoRequest<super::CreateLabelingJobRequest>,
        ) -> Result<tonic::Response<super::LabelingJob>, tonic::Status> {
            self.inner.ready().await.map_err(|e| {
                tonic::Status::new(
                    tonic::Code::Unknown,
                    format!("Service was not ready: {}", e.into()),
                )
            })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.visualinspection.v1beta1.VisualInspection/CreateLabelingJob",
            );
            self.inner.unary(request.into_request(), path, codec).await
        }
        #[doc = " Gets a LabelingJob."]
        pub async fn get_labeling_job(
            &mut self,
            request: impl tonic::IntoRequest<super::GetLabelingJobRequest>,
        ) -> Result<tonic::Response<super::LabelingJob>, tonic::Status> {
            self.inner.ready().await.map_err(|e| {
                tonic::Status::new(
                    tonic::Code::Unknown,
                    format!("Service was not ready: {}", e.into()),
                )
            })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.visualinspection.v1beta1.VisualInspection/GetLabelingJob",
            );
            self.inner.unary(request.into_request(), path, codec).await
        }
        #[doc = " Lists LabelingJobs."]
        pub async fn list_labeling_jobs(
            &mut self,
            request: impl tonic::IntoRequest<super::ListLabelingJobsRequest>,
        ) -> Result<tonic::Response<super::ListLabelingJobsResponse>, tonic::Status> {
            self.inner.ready().await.map_err(|e| {
                tonic::Status::new(
                    tonic::Code::Unknown,
                    format!("Service was not ready: {}", e.into()),
                )
            })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.visualinspection.v1beta1.VisualInspection/ListLabelingJobs",
            );
            self.inner.unary(request.into_request(), path, codec).await
        }
        #[doc = " Deletes a LabelingJob."]
        pub async fn delete_labeling_job(
            &mut self,
            request: impl tonic::IntoRequest<super::DeleteLabelingJobRequest>,
        ) -> Result<
            tonic::Response<super::super::super::super::longrunning::Operation>,
            tonic::Status,
        > {
            self.inner.ready().await.map_err(|e| {
                tonic::Status::new(
                    tonic::Code::Unknown,
                    format!("Service was not ready: {}", e.into()),
                )
            })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.visualinspection.v1beta1.VisualInspection/DeleteLabelingJob",
            );
            self.inner.unary(request.into_request(), path, codec).await
        }
        #[doc = " Cancels a LabelingJob. Success of cancellation is not guaranteed."]
        pub async fn cancel_labeling_job(
            &mut self,
            request: impl tonic::IntoRequest<super::CancelLabelingJobRequest>,
        ) -> Result<tonic::Response<()>, tonic::Status> {
            self.inner.ready().await.map_err(|e| {
                tonic::Status::new(
                    tonic::Code::Unknown,
                    format!("Service was not ready: {}", e.into()),
                )
            })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.visualinspection.v1beta1.VisualInspection/CancelLabelingJob",
            );
            self.inner.unary(request.into_request(), path, codec).await
        }
    }
    impl<T: Clone> Clone for VisualInspectionClient<T> {
        fn clone(&self) -> Self {
            Self {
                inner: self.inner.clone(),
            }
        }
    }
    impl<T> std::fmt::Debug for VisualInspectionClient<T> {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
            write!(f, "VisualInspectionClient {{ ... }}")
        }
    }
}
