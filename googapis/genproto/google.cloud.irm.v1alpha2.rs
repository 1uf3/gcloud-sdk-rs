/// A user of the IRM app.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct User {
    /// One of several ways to uniquely identify a user.
    #[prost(oneof = "user::User", tags = "1, 2")]
    pub user: ::std::option::Option<user::User>,
}
pub mod user {
    /// One of several ways to uniquely identify a user.
    #[derive(Clone, PartialEq, ::prost::Oneof)]
    pub enum User {
        /// Output only. User id that will allow to get additional information from
        /// People API. This field will be populated implicitly if the caller creates
        /// or edits a resource (for example, posts an annotation).
        #[prost(string, tag = "1")]
        UserId(std::string::String),
        /// Email address of the user. This must be associated with a Google account.
        /// This field will be set if the user is explicitly identified (verbatim) by
        /// email address in an API request (potentially sometime in the past). It
        /// will not be populated based on the credentials of a caller of the API.
        #[prost(string, tag = "2")]
        Email(std::string::String),
    }
}
/// A signal is a message calling attention to a (potential) incident. An example
/// is a page based on a Stackdriver Alerting policy.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct Signal {
    /// Resource name of the signal, for example,
    /// "projects/{project_id_or_number}/signals/{signal_id}".
    #[prost(string, tag = "1")]
    pub name: std::string::String,
    /// Etag to validate the object is unchanged for a read-modify-write operation.
    /// An empty etag will overwrite other changes.
    #[prost(string, tag = "2")]
    pub etag: std::string::String,
    /// Resource name of the incident this signal is currently assigned to.
    /// May be empty if signal is unassigned.
    #[prost(string, tag = "3")]
    pub incident: std::string::String,
    /// Output only. Time this signal was created.
    #[prost(message, optional, tag = "4")]
    pub create_time: ::std::option::Option<::prost_types::Timestamp>,
    /// Output only. Time this signal was closed. This field is not populated
    /// while the signal is still firing.
    #[prost(message, optional, tag = "10")]
    pub close_time: ::std::option::Option<::prost_types::Timestamp>,
    /// The time this Signal was first detected. This is identical to create_time
    /// for Signals created by Stackdriver Alerting.
    #[prost(message, optional, tag = "15")]
    pub detect_time: ::std::option::Option<::prost_types::Timestamp>,
    /// Output only. The user that created this signal for manually created
    /// signals. Empty if this signal was generated by a system (for example,
    /// Stackdriver Alerting).
    #[prost(message, optional, tag = "5")]
    pub creator: ::std::option::Option<User>,
    /// One-line summary of the signal.
    /// Immutable.
    #[prost(string, tag = "6")]
    pub title: std::string::String,
    /// Content type string. 'text/plain' is currently the only supported content
    /// type for Signals created via the API. Signals created by Stackdriver
    /// Alerting support 'text/html' as well. Immutable for Signals created by
    /// Stackdriver Alerting.
    #[prost(string, tag = "7")]
    pub content_type: std::string::String,
    /// Full message of the signal.
    /// Immutable for Signals created by Stackdriver Alerting.
    #[prost(string, tag = "8")]
    pub content: std::string::String,
    /// The state of this signal.
    /// For Signals created by Stackdriver Alerting this field is output only.
    #[prost(enumeration = "signal::State", tag = "9")]
    pub signal_state: i32,
    /// A set of artifacts to additional resources for this Signal. For example, a
    /// link to Stackdriver logging for the Signal.
    /// Immutable for Signals created by Stackdriver Alerting.
    #[prost(message, repeated, tag = "16")]
    pub signal_artifacts: ::std::vec::Vec<signal::SignalArtifact>,
}
pub mod signal {
    /// An artifact associated with the Signal.
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct SignalArtifact {
        /// The URI for the artifact.
        #[prost(string, tag = "3")]
        pub uri: std::string::String,
        /// The type of resource linked to
        #[prost(oneof = "signal_artifact::ArtifactType", tags = "2")]
        pub artifact_type: ::std::option::Option<signal_artifact::ArtifactType>,
    }
    pub mod signal_artifact {
        /// The type of resource linked to
        #[derive(Clone, PartialEq, ::prost::Oneof)]
        pub enum ArtifactType {
            /// A custom user type
            #[prost(string, tag = "2")]
            UserType(std::string::String),
        }
    }
    /// Describes whether the alerting condition is still firing.
    #[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
    #[repr(i32)]
    pub enum State {
        /// Unspecified
        Unspecified = 0,
        /// Firing
        Open = 1,
        /// Non-firing
        Closed = 2,
    }
}
/// A text annotation by a user.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct Annotation {
    /// Resource name of the annotation, for example,
    /// "projects/{project_id_or_number}/incidents/{incident_id}/annotations/{annotation_id}".
    #[prost(string, tag = "1")]
    pub name: std::string::String,
    /// Output only. Author of the annotation.
    #[prost(message, optional, tag = "2")]
    pub author: ::std::option::Option<User>,
    /// Output only. Time the annotation was created.
    #[prost(message, optional, tag = "3")]
    pub create_time: ::std::option::Option<::prost_types::Timestamp>,
    /// Content of the annotation.
    #[prost(string, tag = "4")]
    pub content: std::string::String,
    /// Content type of the annotation, for example, 'text/plain'
    /// or 'text/markdown'.
    #[prost(string, tag = "5")]
    pub content_type: std::string::String,
}
/// A tag by a user.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct Tag {
    /// Resource name of a tag, for example,
    /// "projects/{project_id_or_number}/incidents/{incident_id}/tags/{tag_id}"
    #[prost(string, tag = "1")]
    pub name: std::string::String,
    /// Display name of the resource (for example, "cause:rollout"). Immutable.
    #[prost(string, tag = "2")]
    pub display_name: std::string::String,
}
/// Synopsis is a summary of an incident and it contains a textual content,
/// an author and a last updated timestamp.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct Synopsis {
    /// Content type string, for example, 'text/plain' or 'text/markdown'.
    #[prost(string, tag = "1")]
    pub content_type: std::string::String,
    /// Textual content of the synopsis. It can be plain text or markdown as
    /// indicated by the content_type.
    #[prost(string, tag = "2")]
    pub content: std::string::String,
    /// Last updated timestamp.
    #[prost(message, optional, tag = "3")]
    pub update_time: ::std::option::Option<::prost_types::Timestamp>,
    /// Author of the synopsis.
    #[prost(message, optional, tag = "4")]
    pub author: ::std::option::Option<User>,
}
/// Representation of an incident.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct Incident {
    /// Output only. Resource name of the incident, for example,
    /// "projects/{project_id_or_number}/incidents/{incident_id}".
    #[prost(string, tag = "1")]
    pub name: std::string::String,
    /// One-line summary of the incident.
    #[prost(string, tag = "2")]
    pub title: std::string::String,
    /// Escalation level of the incident.
    #[prost(enumeration = "incident::EscalationLevel", tag = "3")]
    pub escalation_level: i32,
    /// Etag to validate the object is unchanged for a read-modify-write operation.
    /// An empty etag will overwrite other changes.
    #[prost(string, tag = "4")]
    pub etag: std::string::String,
    /// Severity of the incident.
    #[prost(enumeration = "incident::Severity", tag = "5")]
    pub severity: i32,
    /// Stage of the incident.
    #[prost(enumeration = "incident::Stage", tag = "6")]
    pub stage: i32,
    /// Resource name of the incident this incident is a duplicate of. Empty if
    /// this incident is not a duplicate.
    /// An incident can only be a duplicate of an incident that is not marked as a
    /// duplicate already. Setting this to a non-empty value must also set the
    /// stage to `STAGE_DUPLICATE`. Unsetting this value value must also update
    /// `stage` to a value other than `STAGE_DUPLICATE`.
    #[prost(string, tag = "9")]
    pub duplicate_incident: std::string::String,
    /// Output only. Time this incident started. Used to measure the 'elapsed
    /// time'. Start time of an incident is the earliest creation time of any of
    /// its Signals or the create time of the incident if no Signals are assigned.
    #[prost(message, optional, tag = "7")]
    pub start_time: ::std::option::Option<::prost_types::Timestamp>,
    /// Output only. Synopsis of this incident.
    #[prost(message, optional, tag = "8")]
    pub synopsis: ::std::option::Option<Synopsis>,
    /// Location of communications for this incident. This is informational
    /// only; IRM does not use this to send messages.
    #[prost(message, optional, tag = "10")]
    pub communication_venue: ::std::option::Option<incident::CommunicationVenue>,
}
pub mod incident {
    /// CommunicationVenue is a record of where conversations about an incident
    /// are happening.
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct CommunicationVenue {
        /// A URI to the web interface of the channel.
        #[prost(string, tag = "1")]
        pub uri: std::string::String,
        /// A name representing the channel in IRM UI.
        #[prost(string, tag = "2")]
        pub display_name: std::string::String,
        /// The type of channel/venue for incident communications.
        #[prost(enumeration = "communication_venue::ChannelType", tag = "3")]
        pub channel_type: i32,
    }
    pub mod communication_venue {
        /// The type of channel/venue for incident communications.
        #[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
        #[repr(i32)]
        pub enum ChannelType {
            /// An unspecified communication channel.
            Unspecified = 0,
            /// A communication channel that is represented by a generic URI.
            Uri = 1,
            /// A communication channel that represents a Slack channel.
            Slack = 5,
        }
    }
    /// Specifies the escalation level of this incident, within the IRM protocol
    /// for handling incidents.
    #[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
    #[repr(i32)]
    pub enum EscalationLevel {
        /// The incident has not been escalated. This is the value used by all new
        /// and legacy incidents.
        Unspecified = 0,
        /// The incident has been escalated to the organizational level.
        Organization = 1,
    }
    /// Severity of an incident.
    #[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
    #[repr(i32)]
    pub enum Severity {
        /// Severity is not specified.
        Unspecified = 0,
        /// Huge incident.
        Huge = 1,
        /// Major incident.
        Major = 2,
        /// Medium incident.
        Medium = 3,
        /// Minor incident.
        Minor = 4,
        /// Negligible incident.
        Negligible = 5,
    }
    /// Stage of an incident.
    #[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
    #[repr(i32)]
    pub enum Stage {
        /// This is the default value if no stage has been specified.
        /// Note: The caller of the API should set the stage to DETECTED.
        Unspecified = 0,
        /// The incident has been detected. This is the initial stage of a new
        /// incident.
        /// Note: The caller still has to set the stage manually.
        Detected = 4,
        /// This incident has been formally characterized.
        Triaged = 1,
        /// This incident has been mitigated, i.e. does not affect the service level
        /// anymore.
        Mitigated = 2,
        /// This incident has been fully resolved, i.e. there are no immediate
        /// follow-up tasks.
        Resolved = 3,
        /// Postmortem for the incident was written.
        Documented = 5,
        /// Stage for an incident with `duplicate_incident`. This incident is not
        /// authoritative anymore and the `duplicate_incident` should be used to
        /// determine the stage.
        Duplicate = 6,
    }
}
/// Describes a role that can be assigned to an incident.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct IncidentRole {
    /// The type of role. The role type is immutable in role assignments. Each role
    /// type can only be used once per incident, except for TYPE_OTHER.
    #[prost(enumeration = "incident_role::Type", tag = "1")]
    pub r#type: i32,
    /// Output only and empty unless TYPE_OTHER is used. Title of the role. For
    /// TYPE_OTHER, must be unique within an incident.
    #[prost(string, tag = "2")]
    pub title: std::string::String,
    /// Output only and empty unless TYPE_OTHER is used. Description of the role.
    #[prost(string, tag = "3")]
    pub description: std::string::String,
}
pub mod incident_role {
    /// List of possible roles.
    #[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
    #[repr(i32)]
    pub enum Type {
        /// The role is unspecified.
        Unspecified = 0,
        /// Incident Commander: Manages response plan, near-term and long-term
        /// objectives, establishes priorities, and delegates tasks as needed.
        IncidentCommander = 1,
        /// Communications Lead: Keeps everybody outside and within the response team
        /// informed.
        CommunicationsLead = 2,
        /// Operations Lead: Figures out what to do, and gets it done.
        OperationsLead = 3,
        /// External Customer Communications Lead: Responsible for communicating
        /// incident details to customers/public.
        ExternalCustomerCommunicationsLead = 4,
        /// Primary Oncall: Responds to the initial page and handles all
        /// responsibilities for pre-escalated incidents.
        PrimaryOncall = 5,
        /// Secondary Oncall: Helps the primary oncall if necessary; mostly useful
        /// for pre-escalated incidents.
        SecondaryOncall = 6,
        /// User-specified roles. One example is a Planning Lead, who keeps track of
        /// the incident. Another is an assistant Incident Commander.
        Other = 7,
    }
}
/// Stores the assignee of a role as well as the proposed next assignee.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct IncidentRoleAssignment {
    /// Output only. Resource name such as
    /// "projects/{project_id_or_number}/incidents/{incident_id}/role_assignments/{role_id}".
    #[prost(string, tag = "1")]
    pub name: std::string::String,
    /// Output only. Etag for this version of the resource. Must be specified in
    /// update requests and match the current version in storage. Must not be
    /// modified by the client.
    #[prost(string, tag = "2")]
    pub etag: std::string::String,
    /// The role that is or will be assigned.
    #[prost(message, optional, tag = "3")]
    pub role: ::std::option::Option<IncidentRole>,
    /// The user this role is assigned to. This field can only be directly set
    /// during creation request. Subsequent updates are done via the
    /// IncidentRoleHandover methods.
    #[prost(message, optional, tag = "4")]
    pub assignee: ::std::option::Option<User>,
    /// The recipient of a requested role handoff. This field can only be directly
    /// set during creation request. Subsequent updates are done via the
    /// IncidentRoleHandover methods.
    ///
    /// `assignee` is always the current role-holder, and `proposed_assignee` is
    /// used to track unfinished assignments and handoffs. Let's say Bob assigns
    /// Alice to a role. Then the fields are:
    ///   `assignee`: nil, `proposed_assignee`: Alice
    /// If Alice accepts, then the fields are:
    ///   `assignee`: Alice, `proposed_assignee`: nil
    /// If she cancels, then the RoleAssignment is deleted.
    /// Let's say Alice has the role. Then the fields are:
    ///   `assignee`: Alice, `proposed_assignee`: nil
    /// If Alice becomes incapacitated and Bob requests Carol to take over, then
    /// the fields are:
    ///   `assignee`: Alice, `proposed_assignee`: Carol
    /// After Carol accepts the handover, the fields are:
    ///   `assignee`: Carol, `proposed_assignee`: nil
    /// Or if Carol refuses the handover, the fields are:
    ///   `assignee`: Alice, `proposed_assignee`: nil
    #[prost(message, optional, tag = "5")]
    pub proposed_assignee: ::std::option::Option<User>,
}
/// External artifact associated to an incident.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct Artifact {
    /// Output only. Resource name such as
    /// "projects/{project_id_or_number}/incidents/{incident_id}/artifacts/{artifact_id}".
    #[prost(string, tag = "1")]
    pub name: std::string::String,
    /// User provided name of an artifact.
    #[prost(string, tag = "2")]
    pub display_name: std::string::String,
    /// Output only. Etag for this version of the resource. Must be specified in
    /// update requests and match the current version in storage. Must not be
    /// modified by the client.
    #[prost(string, tag = "3")]
    pub etag: std::string::String,
    /// URL to access the artifact.
    #[prost(string, tag = "4")]
    pub url: std::string::String,
    /// Type of this artifact.
    #[prost(enumeration = "artifact::Type", tag = "5")]
    pub r#type: i32,
}
pub mod artifact {
    /// Possible types of an artifact.
    #[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
    #[repr(i32)]
    pub enum Type {
        /// External type is unspecified.
        Unspecified = 0,
        /// URL.
        Url = 1,
        /// A JIRA issue.
        JiraIssue = 4,
    }
}
/// Communication Channels are mechanisms used to receive notifications
/// about changes to incidents.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CommunicationChannel {
    /// An endpoint describes how messages will be delivered.
    #[prost(oneof = "communication_channel::Endpoint", tags = "1, 2")]
    pub endpoint: ::std::option::Option<communication_channel::Endpoint>,
}
pub mod communication_channel {
    /// A communication channel that delivers messages to an email address.
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct Email {
        /// The email address, for example, "user@example.com".
        #[prost(string, tag = "1")]
        pub address: std::string::String,
    }
    /// A communication channel that delivers messages to a Stackdriver
    /// notification channel.
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct NotificationChannel {
        /// Stackdriver notification channel name.
        #[prost(string, tag = "1")]
        pub name: std::string::String,
    }
    /// An endpoint describes how messages will be delivered.
    #[derive(Clone, PartialEq, ::prost::Oneof)]
    pub enum Endpoint {
        /// Messages will be delivered via email.
        #[prost(message, tag = "1")]
        Email(Email),
        /// Messages will be delivered via a Stackdriver notification channel.
        #[prost(message, tag = "2")]
        NotificationChannel(NotificationChannel),
    }
}
/// A subscription allows users to get notifications about changes to
/// an incident.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct Subscription {
    /// Output only. Resource name such as
    /// "projects/{project_id_or_number}/incidents/{incident_id}/subscriptions/{subscription_id}".
    #[prost(string, tag = "1")]
    pub name: std::string::String,
    /// Output only. Etag for this version of the resource. Must be specified in
    /// update requests and match the current version in storage. Must not be
    /// modified by the client.
    #[prost(string, tag = "2")]
    pub etag: std::string::String,
    /// A communications channel to send subscription messages to.
    #[prost(message, optional, tag = "3")]
    pub subscription_channel: ::std::option::Option<CommunicationChannel>,
    /// Types of events this subscription receives notifications for.
    #[prost(enumeration = "subscription::EventType", repeated, tag = "4")]
    pub event_types: ::std::vec::Vec<i32>,
}
pub mod subscription {
    /// Types of changes that users can subscribe to in an incident.
    #[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
    #[repr(i32)]
    pub enum EventType {
        /// An event_type that's not specified is an error.
        Unspecified = 0,
        /// The incident's title has changed.
        TitleChange = 1,
        /// The incident's synopsis has changed.
        SynopsisChange = 2,
        /// The incident's stage has changed.
        StageChange = 3,
        /// The incident's severity has changed.
        SeverityChange = 4,
        /// A new annotation has been added to the incident.
        AnnotationAdd = 5,
        /// An annotation has been modified.
        AnnotationChange = 6,
    }
}
/// Request for the CreateIncident method.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CreateIncidentRequest {
    /// Required. The incident to create.
    #[prost(message, optional, tag = "1")]
    pub incident: ::std::option::Option<Incident>,
    /// Required. The resource name of the hosting Stackdriver project which the incident
    /// belongs to.
    /// The name is of the form `projects/{project_id_or_number}`
    /// .
    #[prost(string, tag = "2")]
    pub parent: std::string::String,
}
/// Request for the GetIncident method.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GetIncidentRequest {
    /// Required. Resource name of the incident, for example,
    /// "projects/{project_id_or_number}/incidents/{incident_id}".
    #[prost(string, tag = "1")]
    pub name: std::string::String,
}
/// Request for the UpdateIncident method.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct UpdateIncidentRequest {
    /// Required. The incident to update with the new values.
    #[prost(message, optional, tag = "1")]
    pub incident: ::std::option::Option<Incident>,
    /// List of fields that should be updated.
    #[prost(message, optional, tag = "2")]
    pub update_mask: ::std::option::Option<::prost_types::FieldMask>,
}
/// Request for the SearchSimilarIncidents method.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct SearchSimilarIncidentsRequest {
    /// Required. Resource name of the incident or signal, for example,
    /// "projects/{project_id_or_number}/incidents/{incident_id}".
    #[prost(string, tag = "1")]
    pub name: std::string::String,
    /// Number of similar incidents to return.
    #[prost(int32, tag = "2")]
    pub page_size: i32,
    /// Page token from an earlier query, as returned in 'next_page_token'.
    #[prost(string, tag = "3")]
    pub page_token: std::string::String,
}
/// Response for the SearchSimilarIncidents method.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct SearchSimilarIncidentsResponse {
    /// The search results, ordered by descending relevance.
    #[prost(message, repeated, tag = "1")]
    pub results: ::std::vec::Vec<search_similar_incidents_response::Result>,
    /// Page token to fetch the next set of similar incidents.
    #[prost(string, tag = "2")]
    pub next_page_token: std::string::String,
}
pub mod search_similar_incidents_response {
    /// A single search result, i.e. an incident with (potentially) additional
    /// information.
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct Result {
        /// An incident that is "similar" to the incident or signal specified in the
        /// request.
        #[prost(message, optional, tag = "1")]
        pub incident: ::std::option::Option<super::Incident>,
    }
}
/// Request for the CreateAnnotation method.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CreateAnnotationRequest {
    /// Required. Resource name of the incident, for example,
    /// "projects/{project_id_or_number}/incidents/{incident_id}".
    #[prost(string, tag = "1")]
    pub parent: std::string::String,
    /// Required. Only annotation.content is an input argument.
    #[prost(message, optional, tag = "2")]
    pub annotation: ::std::option::Option<Annotation>,
}
/// Request for the ListAnnotations method.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ListAnnotationsRequest {
    /// Required. Resource name of the incident, for example,
    /// "projects/{project_id_or_number}/incidents/{incident_id}".
    #[prost(string, tag = "1")]
    pub parent: std::string::String,
    /// Number of annotations to return.
    #[prost(int32, tag = "2")]
    pub page_size: i32,
    /// Page token from an earlier query, as returned in `next_page_token`.
    #[prost(string, tag = "3")]
    pub page_token: std::string::String,
}
/// Response for the ListAnnotations method.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ListAnnotationsResponse {
    /// List of annotations.
    #[prost(message, repeated, tag = "1")]
    pub annotations: ::std::vec::Vec<Annotation>,
    /// Page token to fetch the next set of annotations.
    #[prost(string, tag = "2")]
    pub next_page_token: std::string::String,
}
/// Request for the CreateTag method.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CreateTagRequest {
    /// Required. Resource name of the incident, for example,
    /// "projects/{project_id_or_number}/incidents/{incident_id}".
    #[prost(string, tag = "1")]
    pub parent: std::string::String,
    /// Required. Tag to create. Only tag.display_name is an input argument.
    #[prost(message, optional, tag = "2")]
    pub tag: ::std::option::Option<Tag>,
}
/// Request for the DeleteTag method.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct DeleteTagRequest {
    /// Required. Resource name of the tag.
    #[prost(string, tag = "1")]
    pub name: std::string::String,
}
/// Request for the ListTagsForIncident method.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ListTagsRequest {
    /// Required. Resource name of the incident, for example,
    /// "projects/{project_id_or_number}/incidents/{incident_id}".
    #[prost(string, tag = "1")]
    pub parent: std::string::String,
    /// Number of tags to return.
    #[prost(int32, tag = "2")]
    pub page_size: i32,
    /// Page token from an earlier query, as returned in `next_page_token`.
    #[prost(string, tag = "3")]
    pub page_token: std::string::String,
}
/// Response for the ListTagsForIncident method.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ListTagsResponse {
    /// Tags.
    #[prost(message, repeated, tag = "1")]
    pub tags: ::std::vec::Vec<Tag>,
    /// Page token to fetch the next set of tags.
    #[prost(string, tag = "2")]
    pub next_page_token: std::string::String,
}
/// Request for the CreateSignal method.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CreateSignalRequest {
    /// Required. The resource name of the hosting Stackdriver project which requested
    /// signal belongs to.
    #[prost(string, tag = "1")]
    pub parent: std::string::String,
    /// Required. The signal to create.
    #[prost(message, optional, tag = "2")]
    pub signal: ::std::option::Option<Signal>,
}
/// Request for the SearchSignals method.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct SearchSignalsRequest {
    /// Required. The resource name of the hosting Stackdriver project which requested
    /// incidents belong to.
    #[prost(string, tag = "1")]
    pub parent: std::string::String,
    /// An expression that defines which signals to return.
    ///
    /// Search atoms can be used to match certain specific fields.  Otherwise,
    /// plain text will match text fields in the signal.
    ///
    /// Search atoms:
    ///
    /// * `start` - (timestamp) The time the signal was created.
    /// * `title` - The title of the signal.
    /// * `signal_state` - `open` or `closed`. State of the signal.
    ///   (e.g., `signal_state:open`)
    ///
    /// Timestamp formats:
    ///
    /// * yyyy-MM-dd - an absolute date, treated as a calendar-day-wide window.
    ///   In other words, the "<" operator will match dates before that date, the
    ///   ">" operator will match dates after that date, and the ":" operator will
    ///   match the entire day.
    /// * yyyy-MM-ddTHH:mm - Same as above, but with minute resolution.
    /// * yyyy-MM-ddTHH:mm:ss - Same as above, but with second resolution.
    /// * Nd (e.g. 7d) - a relative number of days ago, treated as a moment in time
    ///   (as opposed to a day-wide span) a multiple of 24 hours ago (as opposed to
    ///   calendar days).  In the case of daylight savings time, it will apply the
    ///   current timezone to both ends of the range.  Note that exact matching
    ///   (e.g. `start:7d`) is unlikely to be useful because that would only match
    ///   signals created precisely at a particular instant in time.
    ///
    /// The absolute timestamp formats (everything starting with a year) can
    /// optionally be followed with a UTC offset in +/-hh:mm format.  Also, the 'T'
    /// separating dates and times can optionally be replaced with a space. Note
    /// that any timestamp containing a space or colon will need to be quoted.
    ///
    /// Examples:
    ///
    /// * `foo` - matches signals containing the word "foo"
    /// * `"foo bar"` - matches signals containing the phrase "foo bar"
    /// * `foo bar` or `foo AND bar` - matches signals containing the words
    ///   "foo" and "bar"
    /// * `foo -bar` or `foo AND NOT bar` - matches signals containing the
    ///   word
    ///   "foo" but not the word "bar"
    /// * `foo OR bar` - matches signals containing the word "foo" or the
    ///   word "bar"
    /// * `start>2018-11-28` - matches signals which started after November
    ///   11, 2018.
    /// * `start<=2018-11-28` - matches signals which started on or before
    ///   November 11, 2018.
    /// * `start:2018-11-28` - matches signals which started on November 11,
    ///   2018.
    /// * `start>"2018-11-28 01:02:03+04:00"` - matches signals which started
    ///   after November 11, 2018 at 1:02:03 AM according to the UTC+04 time
    ///   zone.
    /// * `start>7d` - matches signals which started after the point in time
    ///   7*24 hours ago
    /// * `start>180d` - similar to 7d, but likely to cross the daylight savings
    ///   time boundary, so the end time will be 1 hour different from "now."
    /// * `foo AND start>90d AND stage<resolved` - unresolved signals from
    ///   the past 90 days containing the word "foo"
    #[prost(string, tag = "2")]
    pub query: std::string::String,
    /// Maximum number of `signals` to return in the response.
    #[prost(int32, tag = "3")]
    pub page_size: i32,
    /// Page token from an earlier query, as returned in `next_page_token`. All
    /// field values except for page_size and page_token should be the same as the
    /// original query (may return an error or unexpected data otherwise).
    #[prost(string, tag = "4")]
    pub page_token: std::string::String,
}
/// Response for the SearchSignals method.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct SearchSignalsResponse {
    /// Signals that matched the query in the request.
    #[prost(message, repeated, tag = "1")]
    pub signals: ::std::vec::Vec<Signal>,
    /// Page token to fetch the next set of signals.
    #[prost(string, tag = "2")]
    pub next_page_token: std::string::String,
}
/// Request for the GetSignal method.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GetSignalRequest {
    /// Required. Resource name of the Signal resource, for example,
    /// "projects/{project_id_or_number}/signals/{signal_id}".
    #[prost(string, tag = "1")]
    pub name: std::string::String,
}
/// Request for the LookupSignal method.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct LookupSignalRequest {
    /// The ID to use for lookup.
    #[prost(oneof = "lookup_signal_request::AlternateId", tags = "2, 3")]
    pub alternate_id: ::std::option::Option<lookup_signal_request::AlternateId>,
}
pub mod lookup_signal_request {
    /// The ID to use for lookup.
    #[derive(Clone, PartialEq, ::prost::Oneof)]
    pub enum AlternateId {
        /// Required. Full resource name of the CSCC finding id this signal refers to (e.g.
        /// "organizations/abc/sources/123/findings/xyz")
        #[prost(string, tag = "2")]
        CsccFinding(std::string::String),
        /// The ID from the Stackdriver Alerting notification.
        #[prost(string, tag = "3")]
        StackdriverNotificationId(std::string::String),
    }
}
/// Request for the UpdateSignal method.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct UpdateSignalRequest {
    /// Required. The signal to update with the new values.
    #[prost(message, optional, tag = "1")]
    pub signal: ::std::option::Option<Signal>,
    /// List of fields that should be updated.
    #[prost(message, optional, tag = "2")]
    pub update_mask: ::std::option::Option<::prost_types::FieldMask>,
}
/// Request for the SearchIncidents method.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct SearchIncidentsRequest {
    /// Required. The resource name of the hosting Stackdriver project which requested
    /// incidents belong to.
    #[prost(string, tag = "1")]
    pub parent: std::string::String,
    /// An expression that defines which incidents to return.
    ///
    /// Search atoms can be used to match certain specific fields.  Otherwise,
    /// plain text will match text fields in the incident.
    ///
    /// Search atoms:
    /// * `start` - (timestamp) The time the incident started.
    /// * `stage` - The stage of the incident, one of detected, triaged, mitigated,
    ///   resolved, documented, or duplicate (which correspond to values in the
    ///   Incident.Stage enum). These are ordered, so `stage<resolved` is
    ///   equivalent to `stage:detected OR stage:triaged OR stage:mitigated`.
    /// * `severity` - (Incident.Severity) The severity of the incident.
    ///    + Supports matching on a specific severity (for example,
    ///    `severity:major`) or on a range (for example, `severity>medium`,
    ///    `severity<=minor`, etc.).
    ///
    /// Timestamp formats:
    /// * yyyy-MM-dd - an absolute date, treated as a calendar-day-wide window.
    ///   In other words, the "<" operator will match dates before that date, the
    ///   ">" operator will match dates after that date, and the ":" or "="
    ///   operators will match the entire day.
    /// * Nd (for example, 7d) - a relative number of days ago, treated as a moment
    ///   in time (as opposed to a day-wide span). A multiple of 24 hours ago (as
    ///   opposed to calendar days).  In the case of daylight savings time, it will
    ///   apply the current timezone to both ends of the range.  Note that exact
    ///   matching (for example, `start:7d`) is unlikely to be useful because that
    ///   would only match incidents created precisely at a particular instant in
    ///   time.
    ///
    /// Examples:
    ///
    /// * `foo` - matches incidents containing the word "foo"
    /// * `"foo bar"` - matches incidents containing the phrase "foo bar"
    /// * `foo bar` or `foo AND bar` - matches incidents containing the words "foo"
    ///   and "bar"
    /// * `foo -bar` or `foo AND NOT bar` - matches incidents containing the word
    ///   "foo" but not the word "bar"
    /// * `foo OR bar` - matches incidents containing the word "foo" or the word
    ///   "bar"
    /// * `start>2018-11-28` - matches incidents which started after November 11,
    ///   2018.
    /// * `start<=2018-11-28` - matches incidents which started on or before
    ///   November 11, 2018.
    /// * `start:2018-11-28` - matches incidents which started on November 11,
    ///   2018.
    /// * `start>7d` - matches incidents which started after the point in time 7*24
    ///   hours ago
    /// * `start>180d` - similar to 7d, but likely to cross the daylight savings
    ///   time boundary, so the end time will be 1 hour different from "now."
    /// * `foo AND start>90d AND stage<resolved` - unresolved incidents from the
    ///   past 90 days containing the word "foo"
    #[prost(string, tag = "2")]
    pub query: std::string::String,
    /// Number of incidents to return.
    #[prost(int32, tag = "3")]
    pub page_size: i32,
    /// Page token from an earlier query, as returned in `next_page_token`.
    #[prost(string, tag = "4")]
    pub page_token: std::string::String,
    /// The time zone name. It should be an IANA TZ name, such as
    /// "America/Los_Angeles". For more information,
    /// see https://en.wikipedia.org/wiki/List_of_tz_database_time_zones.
    /// If no time zone is specified, the default is UTC.
    #[prost(string, tag = "5")]
    pub time_zone: std::string::String,
}
/// Response for the SearchIncidents method.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct SearchIncidentsResponse {
    /// Incidents.
    #[prost(message, repeated, tag = "1")]
    pub incidents: ::std::vec::Vec<Incident>,
    /// Page token to fetch the next set of incidents.
    #[prost(string, tag = "2")]
    pub next_page_token: std::string::String,
}
/// Request to escalate an incident.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct EscalateIncidentRequest {
    /// Required. The incident to escalate with the new values.
    #[prost(message, optional, tag = "1")]
    pub incident: ::std::option::Option<Incident>,
    /// List of fields that should be updated.
    #[prost(message, optional, tag = "2")]
    pub update_mask: ::std::option::Option<::prost_types::FieldMask>,
    /// Subscriptions to add or update. Existing subscriptions with the same
    /// channel and address as a subscription in the list will be updated.
    #[prost(message, repeated, tag = "3")]
    pub subscriptions: ::std::vec::Vec<Subscription>,
    /// Tags to add. Tags identical to existing tags will be ignored.
    #[prost(message, repeated, tag = "4")]
    pub tags: ::std::vec::Vec<Tag>,
    /// Roles to add or update. Existing roles with the same type (and title, for
    /// TYPE_OTHER roles) will be updated.
    #[prost(message, repeated, tag = "5")]
    pub roles: ::std::vec::Vec<IncidentRoleAssignment>,
    /// Artifacts to add. All artifacts are added without checking for duplicates.
    #[prost(message, repeated, tag = "6")]
    pub artifacts: ::std::vec::Vec<Artifact>,
}
/// Response for EscalateIncident.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct EscalateIncidentResponse {
    /// The escalated incident.
    #[prost(message, optional, tag = "1")]
    pub incident: ::std::option::Option<Incident>,
    /// New or modified subscriptions.
    #[prost(message, repeated, tag = "2")]
    pub subscriptions: ::std::vec::Vec<Subscription>,
    /// New or modified tags.
    #[prost(message, repeated, tag = "3")]
    pub tags: ::std::vec::Vec<Tag>,
    /// New or modified roles.
    #[prost(message, repeated, tag = "4")]
    pub roles: ::std::vec::Vec<IncidentRole>,
    /// New or modified artifacts.
    #[prost(message, repeated, tag = "5")]
    pub artifacts: ::std::vec::Vec<Artifact>,
}
/// Request for the CreateArtifact method.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CreateArtifactRequest {
    /// Required. Resource name of the incident, for example,
    /// "projects/{project_id_or_number}/incidents/{incident_id}".
    #[prost(string, tag = "1")]
    pub parent: std::string::String,
    /// Required. The artifact to create.
    #[prost(message, optional, tag = "2")]
    pub artifact: ::std::option::Option<Artifact>,
}
/// Request for the ListArtifacts method.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ListArtifactsRequest {
    /// Required. Resource name of the incident, for example,
    /// "projects/{project_id_or_number}/incidents/{incident_id}".
    #[prost(string, tag = "1")]
    pub parent: std::string::String,
    /// Number of artifacts to return.
    #[prost(int32, tag = "2")]
    pub page_size: i32,
    /// Page token from an earlier query, as returned in `next_page_token`.
    #[prost(string, tag = "3")]
    pub page_token: std::string::String,
}
/// Response for the ListArtifacts method.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ListArtifactsResponse {
    /// List of artifacts.
    #[prost(message, repeated, tag = "1")]
    pub artifacts: ::std::vec::Vec<Artifact>,
    /// Page token to fetch the next set of artifacts.
    #[prost(string, tag = "2")]
    pub next_page_token: std::string::String,
}
/// Request for the UpdateArtifact method.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct UpdateArtifactRequest {
    /// Required. The artifact to update with the new values.
    #[prost(message, optional, tag = "1")]
    pub artifact: ::std::option::Option<Artifact>,
    /// List of fields that should be updated.
    #[prost(message, optional, tag = "2")]
    pub update_mask: ::std::option::Option<::prost_types::FieldMask>,
}
/// Request for deleting an artifact.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct DeleteArtifactRequest {
    /// Required. Resource name of the artifact.
    #[prost(string, tag = "1")]
    pub name: std::string::String,
}
/// SendShiftHandoff and PreviewShiftHandoff RPC request.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct SendShiftHandoffRequest {
    /// Required. The resource name of the Stackdriver project that the handoff is being sent
    /// from. for example, `projects/{project_id_or_number}`
    #[prost(string, tag = "1")]
    pub parent: std::string::String,
    /// Required. Email addresses of the recipients of the handoff, for example,
    /// "user@example.com". Must contain at least one entry.
    #[prost(string, repeated, tag = "2")]
    pub recipients: ::std::vec::Vec<std::string::String>,
    /// Optional. Email addresses that should be CC'd on the handoff.
    #[prost(string, repeated, tag = "3")]
    pub cc: ::std::vec::Vec<std::string::String>,
    /// Required. The subject of the email.
    #[prost(string, tag = "4")]
    pub subject: std::string::String,
    /// Content type string, for example, 'text/plain' or 'text/html'.
    #[prost(string, tag = "5")]
    pub notes_content_type: std::string::String,
    /// Optional. Additional notes to be included in the handoff.
    #[prost(string, tag = "6")]
    pub notes_content: std::string::String,
    /// Optional. The set of incidents that should be included in the handoff.
    #[prost(message, repeated, tag = "7")]
    pub incidents: ::std::vec::Vec<send_shift_handoff_request::Incident>,
    /// If set to true a ShiftHandoffResponse will be returned but the handoff
    /// will not actually be sent.
    #[prost(bool, tag = "8")]
    pub preview_only: bool,
}
pub mod send_shift_handoff_request {
    /// Describes an incident for inclusion in the handoff.
    /// This is wrapped in a message to provide flexibility for potentially
    /// attaching additional data to each incident in the future.
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct Incident {
        /// Resource name of the incident, for example,
        /// "projects/{project_id_or_number}/incidents/{incident_id}".
        #[prost(string, tag = "1")]
        pub name: std::string::String,
    }
}
/// SendShiftHandoff and PreviewShiftHandoff RPC response.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct SendShiftHandoffResponse {
    /// Content type string, for example, 'text/plain' or 'text/html'.
    #[prost(string, tag = "1")]
    pub content_type: std::string::String,
    /// The contents of the handoff that was sent or would have been sent (if the
    /// request was preview_only).
    /// This will typically contain a full HTML document.
    #[prost(string, tag = "2")]
    pub content: std::string::String,
}
/// Request for the CreateSubscription method.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CreateSubscriptionRequest {
    /// Required. Resource name of the incident, for example,
    /// "projects/{project_id_or_number}/incidents/{incident_id}".
    #[prost(string, tag = "1")]
    pub parent: std::string::String,
    /// Required. The subscription to create.
    #[prost(message, optional, tag = "2")]
    pub subscription: ::std::option::Option<Subscription>,
}
/// Request for the UpdateSubscription method.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct UpdateSubscriptionRequest {
    /// Required. The subscription to update, with new values.
    #[prost(message, optional, tag = "1")]
    pub subscription: ::std::option::Option<Subscription>,
    /// List of fields that should be updated.
    #[prost(message, optional, tag = "2")]
    pub update_mask: ::std::option::Option<::prost_types::FieldMask>,
}
/// Request for the ListSubscriptions method.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ListSubscriptionsRequest {
    /// Required. Resource name of the incident, for example,
    /// "projects/{project_id_or_number}/incidents/{incident_id}".
    #[prost(string, tag = "1")]
    pub parent: std::string::String,
    /// Number of subscriptions to return.
    #[prost(int32, tag = "2")]
    pub page_size: i32,
    /// Page token from an earlier query, as returned in `next_page_token`.
    #[prost(string, tag = "3")]
    pub page_token: std::string::String,
}
/// Response for the ListSubscriptions method.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ListSubscriptionsResponse {
    /// List of subscriptions.
    #[prost(message, repeated, tag = "1")]
    pub subscriptions: ::std::vec::Vec<Subscription>,
    /// Page token to fetch the next set of subscriptions.
    #[prost(string, tag = "2")]
    pub next_page_token: std::string::String,
}
/// Request for deleting a subscription.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct DeleteSubscriptionRequest {
    /// Required. Resource name of the subscription.
    #[prost(string, tag = "1")]
    pub name: std::string::String,
}
/// Request for creating a role assignment.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CreateIncidentRoleAssignmentRequest {
    /// Required. Resource name of the incident, for example,
    /// "projects/{project_id_or_number}/incidents/{incident_id}".
    #[prost(string, tag = "1")]
    pub parent: std::string::String,
    /// Required. Role assignment to create.
    #[prost(message, optional, tag = "2")]
    pub incident_role_assignment: ::std::option::Option<IncidentRoleAssignment>,
}
/// Request for deleting a role assignment.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct DeleteIncidentRoleAssignmentRequest {
    /// Required. Resource name of the role assignment.
    #[prost(string, tag = "1")]
    pub name: std::string::String,
}
/// Request to list role assignments of an incident.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ListIncidentRoleAssignmentsRequest {
    /// Required. Resource name of the incident, for example,
    /// "projects/{project_id_or_number}/incidents/{incident_id}".
    #[prost(string, tag = "1")]
    pub parent: std::string::String,
    /// Number of assignments to return.
    #[prost(int32, tag = "2")]
    pub page_size: i32,
    /// Page token from an earlier query, as returned in `next_page_token`.
    #[prost(string, tag = "3")]
    pub page_token: std::string::String,
}
/// Response for the ListIncidentRoleAssignments method.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ListIncidentRoleAssignmentsResponse {
    /// List of assignments.
    #[prost(message, repeated, tag = "1")]
    pub incident_role_assignments: ::std::vec::Vec<IncidentRoleAssignment>,
    /// Page token to fetch the next set of assignments.
    #[prost(string, tag = "2")]
    pub next_page_token: std::string::String,
}
/// Request to start a role handover.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct RequestIncidentRoleHandoverRequest {
    /// Required. Resource name of the role assignment.
    #[prost(string, tag = "1")]
    pub name: std::string::String,
    /// Required. The proposed assignee.
    #[prost(message, optional, tag = "2")]
    pub new_assignee: ::std::option::Option<User>,
}
/// Request to confirm a role handover.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ConfirmIncidentRoleHandoverRequest {
    /// Required. Resource name of the role assignment.
    #[prost(string, tag = "1")]
    pub name: std::string::String,
    /// Required. The proposed assignee, who will now be the assignee. This should be the
    /// current user; otherwise ForceRoleHandover should be called.
    #[prost(message, optional, tag = "2")]
    pub new_assignee: ::std::option::Option<User>,
}
/// Request to force a role handover.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ForceIncidentRoleHandoverRequest {
    /// Required. Resource name of the role assignment.
    #[prost(string, tag = "1")]
    pub name: std::string::String,
    /// Required. The proposed assignee, who will now be the assignee. This should not be
    /// the current user; otherwise ConfirmRoleHandover should be called.
    #[prost(message, optional, tag = "2")]
    pub new_assignee: ::std::option::Option<User>,
}
/// Request to cancel a role handover.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CancelIncidentRoleHandoverRequest {
    /// Required. Resource name of the role assignment.
    #[prost(string, tag = "1")]
    pub name: std::string::String,
    /// Required. Person who was proposed as the next assignee (i.e.
    /// IncidentRoleAssignment.proposed_assignee) and whose proposal is being
    /// cancelled.
    #[prost(message, optional, tag = "2")]
    pub new_assignee: ::std::option::Option<User>,
}
#[doc = r" Generated client implementations."]
pub mod incident_service_client {
    #![allow(unused_variables, dead_code, missing_docs)]
    use tonic::codegen::*;
    #[doc = " The Incident API for Incident Response & Management."]
    pub struct IncidentServiceClient<T> {
        inner: tonic::client::Grpc<T>,
    }
    impl<T> IncidentServiceClient<T>
    where
        T: tonic::client::GrpcService<tonic::body::BoxBody>,
        T::ResponseBody: Body + HttpBody + Send + 'static,
        T::Error: Into<StdError>,
        <T::ResponseBody as HttpBody>::Error: Into<StdError> + Send,
    {
        pub fn new(inner: T) -> Self {
            let inner = tonic::client::Grpc::new(inner);
            Self { inner }
        }
        pub fn with_interceptor(inner: T, interceptor: impl Into<tonic::Interceptor>) -> Self {
            let inner = tonic::client::Grpc::with_interceptor(inner, interceptor);
            Self { inner }
        }
        #[doc = " Creates a new incident."]
        pub async fn create_incident(
            &mut self,
            request: impl tonic::IntoRequest<super::CreateIncidentRequest>,
        ) -> Result<tonic::Response<super::Incident>, tonic::Status> {
            self.inner.ready().await.map_err(|e| {
                tonic::Status::new(
                    tonic::Code::Unknown,
                    format!("Service was not ready: {}", e.into()),
                )
            })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.irm.v1alpha2.IncidentService/CreateIncident",
            );
            self.inner.unary(request.into_request(), path, codec).await
        }
        #[doc = " Returns an incident by name."]
        pub async fn get_incident(
            &mut self,
            request: impl tonic::IntoRequest<super::GetIncidentRequest>,
        ) -> Result<tonic::Response<super::Incident>, tonic::Status> {
            self.inner.ready().await.map_err(|e| {
                tonic::Status::new(
                    tonic::Code::Unknown,
                    format!("Service was not ready: {}", e.into()),
                )
            })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.irm.v1alpha2.IncidentService/GetIncident",
            );
            self.inner.unary(request.into_request(), path, codec).await
        }
        #[doc = " Returns a list of incidents."]
        #[doc = " Incidents are ordered by start time, with the most recent incidents first."]
        pub async fn search_incidents(
            &mut self,
            request: impl tonic::IntoRequest<super::SearchIncidentsRequest>,
        ) -> Result<tonic::Response<super::SearchIncidentsResponse>, tonic::Status> {
            self.inner.ready().await.map_err(|e| {
                tonic::Status::new(
                    tonic::Code::Unknown,
                    format!("Service was not ready: {}", e.into()),
                )
            })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.irm.v1alpha2.IncidentService/SearchIncidents",
            );
            self.inner.unary(request.into_request(), path, codec).await
        }
        #[doc = " Updates an existing incident."]
        pub async fn update_incident(
            &mut self,
            request: impl tonic::IntoRequest<super::UpdateIncidentRequest>,
        ) -> Result<tonic::Response<super::Incident>, tonic::Status> {
            self.inner.ready().await.map_err(|e| {
                tonic::Status::new(
                    tonic::Code::Unknown,
                    format!("Service was not ready: {}", e.into()),
                )
            })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.irm.v1alpha2.IncidentService/UpdateIncident",
            );
            self.inner.unary(request.into_request(), path, codec).await
        }
        #[doc = " Returns a list of incidents that are \"similar\" to the specified incident"]
        #[doc = " or signal. This functionality is provided on a best-effort basis and the"]
        #[doc = " definition of \"similar\" is subject to change."]
        pub async fn search_similar_incidents(
            &mut self,
            request: impl tonic::IntoRequest<super::SearchSimilarIncidentsRequest>,
        ) -> Result<tonic::Response<super::SearchSimilarIncidentsResponse>, tonic::Status> {
            self.inner.ready().await.map_err(|e| {
                tonic::Status::new(
                    tonic::Code::Unknown,
                    format!("Service was not ready: {}", e.into()),
                )
            })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.irm.v1alpha2.IncidentService/SearchSimilarIncidents",
            );
            self.inner.unary(request.into_request(), path, codec).await
        }
        #[doc = " Creates an annotation on an existing incident. Only 'text/plain' and"]
        #[doc = " 'text/markdown' annotations can be created via this method."]
        pub async fn create_annotation(
            &mut self,
            request: impl tonic::IntoRequest<super::CreateAnnotationRequest>,
        ) -> Result<tonic::Response<super::Annotation>, tonic::Status> {
            self.inner.ready().await.map_err(|e| {
                tonic::Status::new(
                    tonic::Code::Unknown,
                    format!("Service was not ready: {}", e.into()),
                )
            })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.irm.v1alpha2.IncidentService/CreateAnnotation",
            );
            self.inner.unary(request.into_request(), path, codec).await
        }
        #[doc = " Lists annotations that are part of an incident. No assumptions should be"]
        #[doc = " made on the content-type of the annotation returned."]
        pub async fn list_annotations(
            &mut self,
            request: impl tonic::IntoRequest<super::ListAnnotationsRequest>,
        ) -> Result<tonic::Response<super::ListAnnotationsResponse>, tonic::Status> {
            self.inner.ready().await.map_err(|e| {
                tonic::Status::new(
                    tonic::Code::Unknown,
                    format!("Service was not ready: {}", e.into()),
                )
            })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.irm.v1alpha2.IncidentService/ListAnnotations",
            );
            self.inner.unary(request.into_request(), path, codec).await
        }
        #[doc = " Creates a tag on an existing incident."]
        pub async fn create_tag(
            &mut self,
            request: impl tonic::IntoRequest<super::CreateTagRequest>,
        ) -> Result<tonic::Response<super::Tag>, tonic::Status> {
            self.inner.ready().await.map_err(|e| {
                tonic::Status::new(
                    tonic::Code::Unknown,
                    format!("Service was not ready: {}", e.into()),
                )
            })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.irm.v1alpha2.IncidentService/CreateTag",
            );
            self.inner.unary(request.into_request(), path, codec).await
        }
        #[doc = " Deletes an existing tag."]
        pub async fn delete_tag(
            &mut self,
            request: impl tonic::IntoRequest<super::DeleteTagRequest>,
        ) -> Result<tonic::Response<()>, tonic::Status> {
            self.inner.ready().await.map_err(|e| {
                tonic::Status::new(
                    tonic::Code::Unknown,
                    format!("Service was not ready: {}", e.into()),
                )
            })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.irm.v1alpha2.IncidentService/DeleteTag",
            );
            self.inner.unary(request.into_request(), path, codec).await
        }
        #[doc = " Lists tags that are part of an incident."]
        pub async fn list_tags(
            &mut self,
            request: impl tonic::IntoRequest<super::ListTagsRequest>,
        ) -> Result<tonic::Response<super::ListTagsResponse>, tonic::Status> {
            self.inner.ready().await.map_err(|e| {
                tonic::Status::new(
                    tonic::Code::Unknown,
                    format!("Service was not ready: {}", e.into()),
                )
            })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.irm.v1alpha2.IncidentService/ListTags",
            );
            self.inner.unary(request.into_request(), path, codec).await
        }
        #[doc = " Creates a new signal."]
        pub async fn create_signal(
            &mut self,
            request: impl tonic::IntoRequest<super::CreateSignalRequest>,
        ) -> Result<tonic::Response<super::Signal>, tonic::Status> {
            self.inner.ready().await.map_err(|e| {
                tonic::Status::new(
                    tonic::Code::Unknown,
                    format!("Service was not ready: {}", e.into()),
                )
            })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.irm.v1alpha2.IncidentService/CreateSignal",
            );
            self.inner.unary(request.into_request(), path, codec).await
        }
        #[doc = " Lists signals that are part of an incident."]
        #[doc = " Signals are returned in reverse chronological order."]
        #[doc = " Note that search should not be relied on for critical functionality.  It"]
        #[doc = " has lower availability guarantees and might fail to return valid results."]
        #[doc = " Returned results might include stale or extraneous entries."]
        pub async fn search_signals(
            &mut self,
            request: impl tonic::IntoRequest<super::SearchSignalsRequest>,
        ) -> Result<tonic::Response<super::SearchSignalsResponse>, tonic::Status> {
            self.inner.ready().await.map_err(|e| {
                tonic::Status::new(
                    tonic::Code::Unknown,
                    format!("Service was not ready: {}", e.into()),
                )
            })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.irm.v1alpha2.IncidentService/SearchSignals",
            );
            self.inner.unary(request.into_request(), path, codec).await
        }
        #[doc = " Finds a signal by other unique IDs."]
        pub async fn lookup_signal(
            &mut self,
            request: impl tonic::IntoRequest<super::LookupSignalRequest>,
        ) -> Result<tonic::Response<super::Signal>, tonic::Status> {
            self.inner.ready().await.map_err(|e| {
                tonic::Status::new(
                    tonic::Code::Unknown,
                    format!("Service was not ready: {}", e.into()),
                )
            })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.irm.v1alpha2.IncidentService/LookupSignal",
            );
            self.inner.unary(request.into_request(), path, codec).await
        }
        #[doc = " Returns a signal by name."]
        pub async fn get_signal(
            &mut self,
            request: impl tonic::IntoRequest<super::GetSignalRequest>,
        ) -> Result<tonic::Response<super::Signal>, tonic::Status> {
            self.inner.ready().await.map_err(|e| {
                tonic::Status::new(
                    tonic::Code::Unknown,
                    format!("Service was not ready: {}", e.into()),
                )
            })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.irm.v1alpha2.IncidentService/GetSignal",
            );
            self.inner.unary(request.into_request(), path, codec).await
        }
        #[doc = " Updates an existing signal (for example, to assign/unassign it to an"]
        #[doc = " incident)."]
        pub async fn update_signal(
            &mut self,
            request: impl tonic::IntoRequest<super::UpdateSignalRequest>,
        ) -> Result<tonic::Response<super::Signal>, tonic::Status> {
            self.inner.ready().await.map_err(|e| {
                tonic::Status::new(
                    tonic::Code::Unknown,
                    format!("Service was not ready: {}", e.into()),
                )
            })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.irm.v1alpha2.IncidentService/UpdateSignal",
            );
            self.inner.unary(request.into_request(), path, codec).await
        }
        #[doc = " Escalates an incident."]
        pub async fn escalate_incident(
            &mut self,
            request: impl tonic::IntoRequest<super::EscalateIncidentRequest>,
        ) -> Result<tonic::Response<super::EscalateIncidentResponse>, tonic::Status> {
            self.inner.ready().await.map_err(|e| {
                tonic::Status::new(
                    tonic::Code::Unknown,
                    format!("Service was not ready: {}", e.into()),
                )
            })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.irm.v1alpha2.IncidentService/EscalateIncident",
            );
            self.inner.unary(request.into_request(), path, codec).await
        }
        #[doc = " Creates a new artifact."]
        pub async fn create_artifact(
            &mut self,
            request: impl tonic::IntoRequest<super::CreateArtifactRequest>,
        ) -> Result<tonic::Response<super::Artifact>, tonic::Status> {
            self.inner.ready().await.map_err(|e| {
                tonic::Status::new(
                    tonic::Code::Unknown,
                    format!("Service was not ready: {}", e.into()),
                )
            })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.irm.v1alpha2.IncidentService/CreateArtifact",
            );
            self.inner.unary(request.into_request(), path, codec).await
        }
        #[doc = " Returns a list of artifacts for an incident."]
        pub async fn list_artifacts(
            &mut self,
            request: impl tonic::IntoRequest<super::ListArtifactsRequest>,
        ) -> Result<tonic::Response<super::ListArtifactsResponse>, tonic::Status> {
            self.inner.ready().await.map_err(|e| {
                tonic::Status::new(
                    tonic::Code::Unknown,
                    format!("Service was not ready: {}", e.into()),
                )
            })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.irm.v1alpha2.IncidentService/ListArtifacts",
            );
            self.inner.unary(request.into_request(), path, codec).await
        }
        #[doc = " Updates an existing artifact."]
        pub async fn update_artifact(
            &mut self,
            request: impl tonic::IntoRequest<super::UpdateArtifactRequest>,
        ) -> Result<tonic::Response<super::Artifact>, tonic::Status> {
            self.inner.ready().await.map_err(|e| {
                tonic::Status::new(
                    tonic::Code::Unknown,
                    format!("Service was not ready: {}", e.into()),
                )
            })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.irm.v1alpha2.IncidentService/UpdateArtifact",
            );
            self.inner.unary(request.into_request(), path, codec).await
        }
        #[doc = " Deletes an existing artifact."]
        pub async fn delete_artifact(
            &mut self,
            request: impl tonic::IntoRequest<super::DeleteArtifactRequest>,
        ) -> Result<tonic::Response<()>, tonic::Status> {
            self.inner.ready().await.map_err(|e| {
                tonic::Status::new(
                    tonic::Code::Unknown,
                    format!("Service was not ready: {}", e.into()),
                )
            })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.irm.v1alpha2.IncidentService/DeleteArtifact",
            );
            self.inner.unary(request.into_request(), path, codec).await
        }
        #[doc = " Sends a summary of the shift for oncall handoff."]
        pub async fn send_shift_handoff(
            &mut self,
            request: impl tonic::IntoRequest<super::SendShiftHandoffRequest>,
        ) -> Result<tonic::Response<super::SendShiftHandoffResponse>, tonic::Status> {
            self.inner.ready().await.map_err(|e| {
                tonic::Status::new(
                    tonic::Code::Unknown,
                    format!("Service was not ready: {}", e.into()),
                )
            })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.irm.v1alpha2.IncidentService/SendShiftHandoff",
            );
            self.inner.unary(request.into_request(), path, codec).await
        }
        #[doc = " Creates a new subscription."]
        #[doc = " This will fail if:"]
        #[doc = "    a. there are too many (50) subscriptions in the incident already"]
        #[doc = "    b. a subscription using the given channel already exists"]
        pub async fn create_subscription(
            &mut self,
            request: impl tonic::IntoRequest<super::CreateSubscriptionRequest>,
        ) -> Result<tonic::Response<super::Subscription>, tonic::Status> {
            self.inner.ready().await.map_err(|e| {
                tonic::Status::new(
                    tonic::Code::Unknown,
                    format!("Service was not ready: {}", e.into()),
                )
            })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.irm.v1alpha2.IncidentService/CreateSubscription",
            );
            self.inner.unary(request.into_request(), path, codec).await
        }
        #[doc = " Updates a subscription."]
        pub async fn update_subscription(
            &mut self,
            request: impl tonic::IntoRequest<super::UpdateSubscriptionRequest>,
        ) -> Result<tonic::Response<super::Subscription>, tonic::Status> {
            self.inner.ready().await.map_err(|e| {
                tonic::Status::new(
                    tonic::Code::Unknown,
                    format!("Service was not ready: {}", e.into()),
                )
            })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.irm.v1alpha2.IncidentService/UpdateSubscription",
            );
            self.inner.unary(request.into_request(), path, codec).await
        }
        #[doc = " Returns a list of subscriptions for an incident."]
        pub async fn list_subscriptions(
            &mut self,
            request: impl tonic::IntoRequest<super::ListSubscriptionsRequest>,
        ) -> Result<tonic::Response<super::ListSubscriptionsResponse>, tonic::Status> {
            self.inner.ready().await.map_err(|e| {
                tonic::Status::new(
                    tonic::Code::Unknown,
                    format!("Service was not ready: {}", e.into()),
                )
            })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.irm.v1alpha2.IncidentService/ListSubscriptions",
            );
            self.inner.unary(request.into_request(), path, codec).await
        }
        #[doc = " Deletes an existing subscription."]
        pub async fn delete_subscription(
            &mut self,
            request: impl tonic::IntoRequest<super::DeleteSubscriptionRequest>,
        ) -> Result<tonic::Response<()>, tonic::Status> {
            self.inner.ready().await.map_err(|e| {
                tonic::Status::new(
                    tonic::Code::Unknown,
                    format!("Service was not ready: {}", e.into()),
                )
            })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.irm.v1alpha2.IncidentService/DeleteSubscription",
            );
            self.inner.unary(request.into_request(), path, codec).await
        }
        #[doc = " Creates a role assignment on an existing incident. Normally, the user field"]
        #[doc = " will be set when assigning a role to oneself, and the next field will be"]
        #[doc = " set when proposing another user as the assignee. Setting the next field"]
        #[doc = " directly to a user other than oneself is equivalent to proposing and"]
        #[doc = " force-assigning the role to the user."]
        pub async fn create_incident_role_assignment(
            &mut self,
            request: impl tonic::IntoRequest<super::CreateIncidentRoleAssignmentRequest>,
        ) -> Result<tonic::Response<super::IncidentRoleAssignment>, tonic::Status> {
            self.inner.ready().await.map_err(|e| {
                tonic::Status::new(
                    tonic::Code::Unknown,
                    format!("Service was not ready: {}", e.into()),
                )
            })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.irm.v1alpha2.IncidentService/CreateIncidentRoleAssignment",
            );
            self.inner.unary(request.into_request(), path, codec).await
        }
        #[doc = " Deletes an existing role assignment."]
        pub async fn delete_incident_role_assignment(
            &mut self,
            request: impl tonic::IntoRequest<super::DeleteIncidentRoleAssignmentRequest>,
        ) -> Result<tonic::Response<()>, tonic::Status> {
            self.inner.ready().await.map_err(|e| {
                tonic::Status::new(
                    tonic::Code::Unknown,
                    format!("Service was not ready: {}", e.into()),
                )
            })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.irm.v1alpha2.IncidentService/DeleteIncidentRoleAssignment",
            );
            self.inner.unary(request.into_request(), path, codec).await
        }
        #[doc = " Lists role assignments that are part of an incident."]
        pub async fn list_incident_role_assignments(
            &mut self,
            request: impl tonic::IntoRequest<super::ListIncidentRoleAssignmentsRequest>,
        ) -> Result<tonic::Response<super::ListIncidentRoleAssignmentsResponse>, tonic::Status>
        {
            self.inner.ready().await.map_err(|e| {
                tonic::Status::new(
                    tonic::Code::Unknown,
                    format!("Service was not ready: {}", e.into()),
                )
            })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.irm.v1alpha2.IncidentService/ListIncidentRoleAssignments",
            );
            self.inner.unary(request.into_request(), path, codec).await
        }
        #[doc = " Starts a role handover. The proposed assignee will receive an email"]
        #[doc = " notifying them of the assignment. This will fail if a role handover is"]
        #[doc = " already pending."]
        #[doc = " Handover to an oncall ladder is not permitted. Use"]
        #[doc = " CreateIncidentRoleAssignment instead."]
        pub async fn request_incident_role_handover(
            &mut self,
            request: impl tonic::IntoRequest<super::RequestIncidentRoleHandoverRequest>,
        ) -> Result<tonic::Response<super::IncidentRoleAssignment>, tonic::Status> {
            self.inner.ready().await.map_err(|e| {
                tonic::Status::new(
                    tonic::Code::Unknown,
                    format!("Service was not ready: {}", e.into()),
                )
            })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.irm.v1alpha2.IncidentService/RequestIncidentRoleHandover",
            );
            self.inner.unary(request.into_request(), path, codec).await
        }
        #[doc = " Confirms a role handover. This will fail if the 'proposed_assignee' field"]
        #[doc = " of the IncidentRoleAssignment is not equal to the 'new_assignee' field of"]
        #[doc = " the request. If the caller is not the new_assignee,"]
        #[doc = " ForceIncidentRoleHandover should be used instead."]
        pub async fn confirm_incident_role_handover(
            &mut self,
            request: impl tonic::IntoRequest<super::ConfirmIncidentRoleHandoverRequest>,
        ) -> Result<tonic::Response<super::IncidentRoleAssignment>, tonic::Status> {
            self.inner.ready().await.map_err(|e| {
                tonic::Status::new(
                    tonic::Code::Unknown,
                    format!("Service was not ready: {}", e.into()),
                )
            })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.irm.v1alpha2.IncidentService/ConfirmIncidentRoleHandover",
            );
            self.inner.unary(request.into_request(), path, codec).await
        }
        #[doc = " Forces a role handover. This will fail if the 'proposed_assignee' field of"]
        #[doc = " the IncidentRoleAssignment is not equal to the 'new_assignee' field of the"]
        #[doc = " request. If the caller is the new_assignee, ConfirmIncidentRoleHandover"]
        #[doc = " should be used instead."]
        pub async fn force_incident_role_handover(
            &mut self,
            request: impl tonic::IntoRequest<super::ForceIncidentRoleHandoverRequest>,
        ) -> Result<tonic::Response<super::IncidentRoleAssignment>, tonic::Status> {
            self.inner.ready().await.map_err(|e| {
                tonic::Status::new(
                    tonic::Code::Unknown,
                    format!("Service was not ready: {}", e.into()),
                )
            })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.irm.v1alpha2.IncidentService/ForceIncidentRoleHandover",
            );
            self.inner.unary(request.into_request(), path, codec).await
        }
        #[doc = " Cancels a role handover. This will fail if the 'proposed_assignee' field of"]
        #[doc = " the IncidentRoleAssignment is not equal to the 'new_assignee' field of the"]
        #[doc = " request."]
        pub async fn cancel_incident_role_handover(
            &mut self,
            request: impl tonic::IntoRequest<super::CancelIncidentRoleHandoverRequest>,
        ) -> Result<tonic::Response<super::IncidentRoleAssignment>, tonic::Status> {
            self.inner.ready().await.map_err(|e| {
                tonic::Status::new(
                    tonic::Code::Unknown,
                    format!("Service was not ready: {}", e.into()),
                )
            })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.irm.v1alpha2.IncidentService/CancelIncidentRoleHandover",
            );
            self.inner.unary(request.into_request(), path, codec).await
        }
    }
    impl<T: Clone> Clone for IncidentServiceClient<T> {
        fn clone(&self) -> Self {
            Self {
                inner: self.inner.clone(),
            }
        }
    }
    impl<T> std::fmt::Debug for IncidentServiceClient<T> {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
            write!(f, "IncidentServiceClient {{ ... }}")
        }
    }
}
#[doc = r" Generated server implementations."]
pub mod incident_service_server {
    #![allow(unused_variables, dead_code, missing_docs)]
    use tonic::codegen::*;
    #[doc = "Generated trait containing gRPC methods that should be implemented for use with IncidentServiceServer."]
    #[async_trait]
    pub trait IncidentService: Send + Sync + 'static {
        #[doc = " Creates a new incident."]
        async fn create_incident(
            &self,
            request: tonic::Request<super::CreateIncidentRequest>,
        ) -> Result<tonic::Response<super::Incident>, tonic::Status>;
        #[doc = " Returns an incident by name."]
        async fn get_incident(
            &self,
            request: tonic::Request<super::GetIncidentRequest>,
        ) -> Result<tonic::Response<super::Incident>, tonic::Status>;
        #[doc = " Returns a list of incidents."]
        #[doc = " Incidents are ordered by start time, with the most recent incidents first."]
        async fn search_incidents(
            &self,
            request: tonic::Request<super::SearchIncidentsRequest>,
        ) -> Result<tonic::Response<super::SearchIncidentsResponse>, tonic::Status>;
        #[doc = " Updates an existing incident."]
        async fn update_incident(
            &self,
            request: tonic::Request<super::UpdateIncidentRequest>,
        ) -> Result<tonic::Response<super::Incident>, tonic::Status>;
        #[doc = " Returns a list of incidents that are \"similar\" to the specified incident"]
        #[doc = " or signal. This functionality is provided on a best-effort basis and the"]
        #[doc = " definition of \"similar\" is subject to change."]
        async fn search_similar_incidents(
            &self,
            request: tonic::Request<super::SearchSimilarIncidentsRequest>,
        ) -> Result<tonic::Response<super::SearchSimilarIncidentsResponse>, tonic::Status>;
        #[doc = " Creates an annotation on an existing incident. Only 'text/plain' and"]
        #[doc = " 'text/markdown' annotations can be created via this method."]
        async fn create_annotation(
            &self,
            request: tonic::Request<super::CreateAnnotationRequest>,
        ) -> Result<tonic::Response<super::Annotation>, tonic::Status>;
        #[doc = " Lists annotations that are part of an incident. No assumptions should be"]
        #[doc = " made on the content-type of the annotation returned."]
        async fn list_annotations(
            &self,
            request: tonic::Request<super::ListAnnotationsRequest>,
        ) -> Result<tonic::Response<super::ListAnnotationsResponse>, tonic::Status>;
        #[doc = " Creates a tag on an existing incident."]
        async fn create_tag(
            &self,
            request: tonic::Request<super::CreateTagRequest>,
        ) -> Result<tonic::Response<super::Tag>, tonic::Status>;
        #[doc = " Deletes an existing tag."]
        async fn delete_tag(
            &self,
            request: tonic::Request<super::DeleteTagRequest>,
        ) -> Result<tonic::Response<()>, tonic::Status>;
        #[doc = " Lists tags that are part of an incident."]
        async fn list_tags(
            &self,
            request: tonic::Request<super::ListTagsRequest>,
        ) -> Result<tonic::Response<super::ListTagsResponse>, tonic::Status>;
        #[doc = " Creates a new signal."]
        async fn create_signal(
            &self,
            request: tonic::Request<super::CreateSignalRequest>,
        ) -> Result<tonic::Response<super::Signal>, tonic::Status>;
        #[doc = " Lists signals that are part of an incident."]
        #[doc = " Signals are returned in reverse chronological order."]
        #[doc = " Note that search should not be relied on for critical functionality.  It"]
        #[doc = " has lower availability guarantees and might fail to return valid results."]
        #[doc = " Returned results might include stale or extraneous entries."]
        async fn search_signals(
            &self,
            request: tonic::Request<super::SearchSignalsRequest>,
        ) -> Result<tonic::Response<super::SearchSignalsResponse>, tonic::Status>;
        #[doc = " Finds a signal by other unique IDs."]
        async fn lookup_signal(
            &self,
            request: tonic::Request<super::LookupSignalRequest>,
        ) -> Result<tonic::Response<super::Signal>, tonic::Status>;
        #[doc = " Returns a signal by name."]
        async fn get_signal(
            &self,
            request: tonic::Request<super::GetSignalRequest>,
        ) -> Result<tonic::Response<super::Signal>, tonic::Status>;
        #[doc = " Updates an existing signal (for example, to assign/unassign it to an"]
        #[doc = " incident)."]
        async fn update_signal(
            &self,
            request: tonic::Request<super::UpdateSignalRequest>,
        ) -> Result<tonic::Response<super::Signal>, tonic::Status>;
        #[doc = " Escalates an incident."]
        async fn escalate_incident(
            &self,
            request: tonic::Request<super::EscalateIncidentRequest>,
        ) -> Result<tonic::Response<super::EscalateIncidentResponse>, tonic::Status>;
        #[doc = " Creates a new artifact."]
        async fn create_artifact(
            &self,
            request: tonic::Request<super::CreateArtifactRequest>,
        ) -> Result<tonic::Response<super::Artifact>, tonic::Status>;
        #[doc = " Returns a list of artifacts for an incident."]
        async fn list_artifacts(
            &self,
            request: tonic::Request<super::ListArtifactsRequest>,
        ) -> Result<tonic::Response<super::ListArtifactsResponse>, tonic::Status>;
        #[doc = " Updates an existing artifact."]
        async fn update_artifact(
            &self,
            request: tonic::Request<super::UpdateArtifactRequest>,
        ) -> Result<tonic::Response<super::Artifact>, tonic::Status>;
        #[doc = " Deletes an existing artifact."]
        async fn delete_artifact(
            &self,
            request: tonic::Request<super::DeleteArtifactRequest>,
        ) -> Result<tonic::Response<()>, tonic::Status>;
        #[doc = " Sends a summary of the shift for oncall handoff."]
        async fn send_shift_handoff(
            &self,
            request: tonic::Request<super::SendShiftHandoffRequest>,
        ) -> Result<tonic::Response<super::SendShiftHandoffResponse>, tonic::Status>;
        #[doc = " Creates a new subscription."]
        #[doc = " This will fail if:"]
        #[doc = "    a. there are too many (50) subscriptions in the incident already"]
        #[doc = "    b. a subscription using the given channel already exists"]
        async fn create_subscription(
            &self,
            request: tonic::Request<super::CreateSubscriptionRequest>,
        ) -> Result<tonic::Response<super::Subscription>, tonic::Status>;
        #[doc = " Updates a subscription."]
        async fn update_subscription(
            &self,
            request: tonic::Request<super::UpdateSubscriptionRequest>,
        ) -> Result<tonic::Response<super::Subscription>, tonic::Status>;
        #[doc = " Returns a list of subscriptions for an incident."]
        async fn list_subscriptions(
            &self,
            request: tonic::Request<super::ListSubscriptionsRequest>,
        ) -> Result<tonic::Response<super::ListSubscriptionsResponse>, tonic::Status>;
        #[doc = " Deletes an existing subscription."]
        async fn delete_subscription(
            &self,
            request: tonic::Request<super::DeleteSubscriptionRequest>,
        ) -> Result<tonic::Response<()>, tonic::Status>;
        #[doc = " Creates a role assignment on an existing incident. Normally, the user field"]
        #[doc = " will be set when assigning a role to oneself, and the next field will be"]
        #[doc = " set when proposing another user as the assignee. Setting the next field"]
        #[doc = " directly to a user other than oneself is equivalent to proposing and"]
        #[doc = " force-assigning the role to the user."]
        async fn create_incident_role_assignment(
            &self,
            request: tonic::Request<super::CreateIncidentRoleAssignmentRequest>,
        ) -> Result<tonic::Response<super::IncidentRoleAssignment>, tonic::Status>;
        #[doc = " Deletes an existing role assignment."]
        async fn delete_incident_role_assignment(
            &self,
            request: tonic::Request<super::DeleteIncidentRoleAssignmentRequest>,
        ) -> Result<tonic::Response<()>, tonic::Status>;
        #[doc = " Lists role assignments that are part of an incident."]
        async fn list_incident_role_assignments(
            &self,
            request: tonic::Request<super::ListIncidentRoleAssignmentsRequest>,
        ) -> Result<tonic::Response<super::ListIncidentRoleAssignmentsResponse>, tonic::Status>;
        #[doc = " Starts a role handover. The proposed assignee will receive an email"]
        #[doc = " notifying them of the assignment. This will fail if a role handover is"]
        #[doc = " already pending."]
        #[doc = " Handover to an oncall ladder is not permitted. Use"]
        #[doc = " CreateIncidentRoleAssignment instead."]
        async fn request_incident_role_handover(
            &self,
            request: tonic::Request<super::RequestIncidentRoleHandoverRequest>,
        ) -> Result<tonic::Response<super::IncidentRoleAssignment>, tonic::Status>;
        #[doc = " Confirms a role handover. This will fail if the 'proposed_assignee' field"]
        #[doc = " of the IncidentRoleAssignment is not equal to the 'new_assignee' field of"]
        #[doc = " the request. If the caller is not the new_assignee,"]
        #[doc = " ForceIncidentRoleHandover should be used instead."]
        async fn confirm_incident_role_handover(
            &self,
            request: tonic::Request<super::ConfirmIncidentRoleHandoverRequest>,
        ) -> Result<tonic::Response<super::IncidentRoleAssignment>, tonic::Status>;
        #[doc = " Forces a role handover. This will fail if the 'proposed_assignee' field of"]
        #[doc = " the IncidentRoleAssignment is not equal to the 'new_assignee' field of the"]
        #[doc = " request. If the caller is the new_assignee, ConfirmIncidentRoleHandover"]
        #[doc = " should be used instead."]
        async fn force_incident_role_handover(
            &self,
            request: tonic::Request<super::ForceIncidentRoleHandoverRequest>,
        ) -> Result<tonic::Response<super::IncidentRoleAssignment>, tonic::Status>;
        #[doc = " Cancels a role handover. This will fail if the 'proposed_assignee' field of"]
        #[doc = " the IncidentRoleAssignment is not equal to the 'new_assignee' field of the"]
        #[doc = " request."]
        async fn cancel_incident_role_handover(
            &self,
            request: tonic::Request<super::CancelIncidentRoleHandoverRequest>,
        ) -> Result<tonic::Response<super::IncidentRoleAssignment>, tonic::Status>;
    }
    #[doc = " The Incident API for Incident Response & Management."]
    #[derive(Debug)]
    #[doc(hidden)]
    pub struct IncidentServiceServer<T: IncidentService> {
        inner: _Inner<T>,
    }
    struct _Inner<T>(Arc<T>, Option<tonic::Interceptor>);
    impl<T: IncidentService> IncidentServiceServer<T> {
        pub fn new(inner: T) -> Self {
            let inner = Arc::new(inner);
            let inner = _Inner(inner, None);
            Self { inner }
        }
        pub fn with_interceptor(inner: T, interceptor: impl Into<tonic::Interceptor>) -> Self {
            let inner = Arc::new(inner);
            let inner = _Inner(inner, Some(interceptor.into()));
            Self { inner }
        }
    }
    impl<T, B> Service<http::Request<B>> for IncidentServiceServer<T>
    where
        T: IncidentService,
        B: HttpBody + Send + Sync + 'static,
        B::Error: Into<StdError> + Send + 'static,
    {
        type Response = http::Response<tonic::body::BoxBody>;
        type Error = Never;
        type Future = BoxFuture<Self::Response, Self::Error>;
        fn poll_ready(&mut self, _cx: &mut Context<'_>) -> Poll<Result<(), Self::Error>> {
            Poll::Ready(Ok(()))
        }
        fn call(&mut self, req: http::Request<B>) -> Self::Future {
            let inner = self.inner.clone();
            match req.uri().path() {
                "/google.cloud.irm.v1alpha2.IncidentService/CreateIncident" => {
                    #[allow(non_camel_case_types)]
                    struct CreateIncidentSvc<T: IncidentService>(pub Arc<T>);
                    impl<T: IncidentService>
                        tonic::server::UnaryService<super::CreateIncidentRequest>
                        for CreateIncidentSvc<T>
                    {
                        type Response = super::Incident;
                        type Future = BoxFuture<tonic::Response<Self::Response>, tonic::Status>;
                        fn call(
                            &mut self,
                            request: tonic::Request<super::CreateIncidentRequest>,
                        ) -> Self::Future {
                            let inner = self.0.clone();
                            let fut = async move { inner.create_incident(request).await };
                            Box::pin(fut)
                        }
                    }
                    let inner = self.inner.clone();
                    let fut = async move {
                        let interceptor = inner.1.clone();
                        let inner = inner.0;
                        let method = CreateIncidentSvc(inner);
                        let codec = tonic::codec::ProstCodec::default();
                        let mut grpc = if let Some(interceptor) = interceptor {
                            tonic::server::Grpc::with_interceptor(codec, interceptor)
                        } else {
                            tonic::server::Grpc::new(codec)
                        };
                        let res = grpc.unary(method, req).await;
                        Ok(res)
                    };
                    Box::pin(fut)
                }
                "/google.cloud.irm.v1alpha2.IncidentService/GetIncident" => {
                    #[allow(non_camel_case_types)]
                    struct GetIncidentSvc<T: IncidentService>(pub Arc<T>);
                    impl<T: IncidentService> tonic::server::UnaryService<super::GetIncidentRequest>
                        for GetIncidentSvc<T>
                    {
                        type Response = super::Incident;
                        type Future = BoxFuture<tonic::Response<Self::Response>, tonic::Status>;
                        fn call(
                            &mut self,
                            request: tonic::Request<super::GetIncidentRequest>,
                        ) -> Self::Future {
                            let inner = self.0.clone();
                            let fut = async move { inner.get_incident(request).await };
                            Box::pin(fut)
                        }
                    }
                    let inner = self.inner.clone();
                    let fut = async move {
                        let interceptor = inner.1.clone();
                        let inner = inner.0;
                        let method = GetIncidentSvc(inner);
                        let codec = tonic::codec::ProstCodec::default();
                        let mut grpc = if let Some(interceptor) = interceptor {
                            tonic::server::Grpc::with_interceptor(codec, interceptor)
                        } else {
                            tonic::server::Grpc::new(codec)
                        };
                        let res = grpc.unary(method, req).await;
                        Ok(res)
                    };
                    Box::pin(fut)
                }
                "/google.cloud.irm.v1alpha2.IncidentService/SearchIncidents" => {
                    #[allow(non_camel_case_types)]
                    struct SearchIncidentsSvc<T: IncidentService>(pub Arc<T>);
                    impl<T: IncidentService>
                        tonic::server::UnaryService<super::SearchIncidentsRequest>
                        for SearchIncidentsSvc<T>
                    {
                        type Response = super::SearchIncidentsResponse;
                        type Future = BoxFuture<tonic::Response<Self::Response>, tonic::Status>;
                        fn call(
                            &mut self,
                            request: tonic::Request<super::SearchIncidentsRequest>,
                        ) -> Self::Future {
                            let inner = self.0.clone();
                            let fut = async move { inner.search_incidents(request).await };
                            Box::pin(fut)
                        }
                    }
                    let inner = self.inner.clone();
                    let fut = async move {
                        let interceptor = inner.1.clone();
                        let inner = inner.0;
                        let method = SearchIncidentsSvc(inner);
                        let codec = tonic::codec::ProstCodec::default();
                        let mut grpc = if let Some(interceptor) = interceptor {
                            tonic::server::Grpc::with_interceptor(codec, interceptor)
                        } else {
                            tonic::server::Grpc::new(codec)
                        };
                        let res = grpc.unary(method, req).await;
                        Ok(res)
                    };
                    Box::pin(fut)
                }
                "/google.cloud.irm.v1alpha2.IncidentService/UpdateIncident" => {
                    #[allow(non_camel_case_types)]
                    struct UpdateIncidentSvc<T: IncidentService>(pub Arc<T>);
                    impl<T: IncidentService>
                        tonic::server::UnaryService<super::UpdateIncidentRequest>
                        for UpdateIncidentSvc<T>
                    {
                        type Response = super::Incident;
                        type Future = BoxFuture<tonic::Response<Self::Response>, tonic::Status>;
                        fn call(
                            &mut self,
                            request: tonic::Request<super::UpdateIncidentRequest>,
                        ) -> Self::Future {
                            let inner = self.0.clone();
                            let fut = async move { inner.update_incident(request).await };
                            Box::pin(fut)
                        }
                    }
                    let inner = self.inner.clone();
                    let fut = async move {
                        let interceptor = inner.1.clone();
                        let inner = inner.0;
                        let method = UpdateIncidentSvc(inner);
                        let codec = tonic::codec::ProstCodec::default();
                        let mut grpc = if let Some(interceptor) = interceptor {
                            tonic::server::Grpc::with_interceptor(codec, interceptor)
                        } else {
                            tonic::server::Grpc::new(codec)
                        };
                        let res = grpc.unary(method, req).await;
                        Ok(res)
                    };
                    Box::pin(fut)
                }
                "/google.cloud.irm.v1alpha2.IncidentService/SearchSimilarIncidents" => {
                    #[allow(non_camel_case_types)]
                    struct SearchSimilarIncidentsSvc<T: IncidentService>(pub Arc<T>);
                    impl<T: IncidentService>
                        tonic::server::UnaryService<super::SearchSimilarIncidentsRequest>
                        for SearchSimilarIncidentsSvc<T>
                    {
                        type Response = super::SearchSimilarIncidentsResponse;
                        type Future = BoxFuture<tonic::Response<Self::Response>, tonic::Status>;
                        fn call(
                            &mut self,
                            request: tonic::Request<super::SearchSimilarIncidentsRequest>,
                        ) -> Self::Future {
                            let inner = self.0.clone();
                            let fut = async move { inner.search_similar_incidents(request).await };
                            Box::pin(fut)
                        }
                    }
                    let inner = self.inner.clone();
                    let fut = async move {
                        let interceptor = inner.1.clone();
                        let inner = inner.0;
                        let method = SearchSimilarIncidentsSvc(inner);
                        let codec = tonic::codec::ProstCodec::default();
                        let mut grpc = if let Some(interceptor) = interceptor {
                            tonic::server::Grpc::with_interceptor(codec, interceptor)
                        } else {
                            tonic::server::Grpc::new(codec)
                        };
                        let res = grpc.unary(method, req).await;
                        Ok(res)
                    };
                    Box::pin(fut)
                }
                "/google.cloud.irm.v1alpha2.IncidentService/CreateAnnotation" => {
                    #[allow(non_camel_case_types)]
                    struct CreateAnnotationSvc<T: IncidentService>(pub Arc<T>);
                    impl<T: IncidentService>
                        tonic::server::UnaryService<super::CreateAnnotationRequest>
                        for CreateAnnotationSvc<T>
                    {
                        type Response = super::Annotation;
                        type Future = BoxFuture<tonic::Response<Self::Response>, tonic::Status>;
                        fn call(
                            &mut self,
                            request: tonic::Request<super::CreateAnnotationRequest>,
                        ) -> Self::Future {
                            let inner = self.0.clone();
                            let fut = async move { inner.create_annotation(request).await };
                            Box::pin(fut)
                        }
                    }
                    let inner = self.inner.clone();
                    let fut = async move {
                        let interceptor = inner.1.clone();
                        let inner = inner.0;
                        let method = CreateAnnotationSvc(inner);
                        let codec = tonic::codec::ProstCodec::default();
                        let mut grpc = if let Some(interceptor) = interceptor {
                            tonic::server::Grpc::with_interceptor(codec, interceptor)
                        } else {
                            tonic::server::Grpc::new(codec)
                        };
                        let res = grpc.unary(method, req).await;
                        Ok(res)
                    };
                    Box::pin(fut)
                }
                "/google.cloud.irm.v1alpha2.IncidentService/ListAnnotations" => {
                    #[allow(non_camel_case_types)]
                    struct ListAnnotationsSvc<T: IncidentService>(pub Arc<T>);
                    impl<T: IncidentService>
                        tonic::server::UnaryService<super::ListAnnotationsRequest>
                        for ListAnnotationsSvc<T>
                    {
                        type Response = super::ListAnnotationsResponse;
                        type Future = BoxFuture<tonic::Response<Self::Response>, tonic::Status>;
                        fn call(
                            &mut self,
                            request: tonic::Request<super::ListAnnotationsRequest>,
                        ) -> Self::Future {
                            let inner = self.0.clone();
                            let fut = async move { inner.list_annotations(request).await };
                            Box::pin(fut)
                        }
                    }
                    let inner = self.inner.clone();
                    let fut = async move {
                        let interceptor = inner.1.clone();
                        let inner = inner.0;
                        let method = ListAnnotationsSvc(inner);
                        let codec = tonic::codec::ProstCodec::default();
                        let mut grpc = if let Some(interceptor) = interceptor {
                            tonic::server::Grpc::with_interceptor(codec, interceptor)
                        } else {
                            tonic::server::Grpc::new(codec)
                        };
                        let res = grpc.unary(method, req).await;
                        Ok(res)
                    };
                    Box::pin(fut)
                }
                "/google.cloud.irm.v1alpha2.IncidentService/CreateTag" => {
                    #[allow(non_camel_case_types)]
                    struct CreateTagSvc<T: IncidentService>(pub Arc<T>);
                    impl<T: IncidentService> tonic::server::UnaryService<super::CreateTagRequest> for CreateTagSvc<T> {
                        type Response = super::Tag;
                        type Future = BoxFuture<tonic::Response<Self::Response>, tonic::Status>;
                        fn call(
                            &mut self,
                            request: tonic::Request<super::CreateTagRequest>,
                        ) -> Self::Future {
                            let inner = self.0.clone();
                            let fut = async move { inner.create_tag(request).await };
                            Box::pin(fut)
                        }
                    }
                    let inner = self.inner.clone();
                    let fut = async move {
                        let interceptor = inner.1.clone();
                        let inner = inner.0;
                        let method = CreateTagSvc(inner);
                        let codec = tonic::codec::ProstCodec::default();
                        let mut grpc = if let Some(interceptor) = interceptor {
                            tonic::server::Grpc::with_interceptor(codec, interceptor)
                        } else {
                            tonic::server::Grpc::new(codec)
                        };
                        let res = grpc.unary(method, req).await;
                        Ok(res)
                    };
                    Box::pin(fut)
                }
                "/google.cloud.irm.v1alpha2.IncidentService/DeleteTag" => {
                    #[allow(non_camel_case_types)]
                    struct DeleteTagSvc<T: IncidentService>(pub Arc<T>);
                    impl<T: IncidentService> tonic::server::UnaryService<super::DeleteTagRequest> for DeleteTagSvc<T> {
                        type Response = ();
                        type Future = BoxFuture<tonic::Response<Self::Response>, tonic::Status>;
                        fn call(
                            &mut self,
                            request: tonic::Request<super::DeleteTagRequest>,
                        ) -> Self::Future {
                            let inner = self.0.clone();
                            let fut = async move { inner.delete_tag(request).await };
                            Box::pin(fut)
                        }
                    }
                    let inner = self.inner.clone();
                    let fut = async move {
                        let interceptor = inner.1.clone();
                        let inner = inner.0;
                        let method = DeleteTagSvc(inner);
                        let codec = tonic::codec::ProstCodec::default();
                        let mut grpc = if let Some(interceptor) = interceptor {
                            tonic::server::Grpc::with_interceptor(codec, interceptor)
                        } else {
                            tonic::server::Grpc::new(codec)
                        };
                        let res = grpc.unary(method, req).await;
                        Ok(res)
                    };
                    Box::pin(fut)
                }
                "/google.cloud.irm.v1alpha2.IncidentService/ListTags" => {
                    #[allow(non_camel_case_types)]
                    struct ListTagsSvc<T: IncidentService>(pub Arc<T>);
                    impl<T: IncidentService> tonic::server::UnaryService<super::ListTagsRequest> for ListTagsSvc<T> {
                        type Response = super::ListTagsResponse;
                        type Future = BoxFuture<tonic::Response<Self::Response>, tonic::Status>;
                        fn call(
                            &mut self,
                            request: tonic::Request<super::ListTagsRequest>,
                        ) -> Self::Future {
                            let inner = self.0.clone();
                            let fut = async move { inner.list_tags(request).await };
                            Box::pin(fut)
                        }
                    }
                    let inner = self.inner.clone();
                    let fut = async move {
                        let interceptor = inner.1.clone();
                        let inner = inner.0;
                        let method = ListTagsSvc(inner);
                        let codec = tonic::codec::ProstCodec::default();
                        let mut grpc = if let Some(interceptor) = interceptor {
                            tonic::server::Grpc::with_interceptor(codec, interceptor)
                        } else {
                            tonic::server::Grpc::new(codec)
                        };
                        let res = grpc.unary(method, req).await;
                        Ok(res)
                    };
                    Box::pin(fut)
                }
                "/google.cloud.irm.v1alpha2.IncidentService/CreateSignal" => {
                    #[allow(non_camel_case_types)]
                    struct CreateSignalSvc<T: IncidentService>(pub Arc<T>);
                    impl<T: IncidentService> tonic::server::UnaryService<super::CreateSignalRequest>
                        for CreateSignalSvc<T>
                    {
                        type Response = super::Signal;
                        type Future = BoxFuture<tonic::Response<Self::Response>, tonic::Status>;
                        fn call(
                            &mut self,
                            request: tonic::Request<super::CreateSignalRequest>,
                        ) -> Self::Future {
                            let inner = self.0.clone();
                            let fut = async move { inner.create_signal(request).await };
                            Box::pin(fut)
                        }
                    }
                    let inner = self.inner.clone();
                    let fut = async move {
                        let interceptor = inner.1.clone();
                        let inner = inner.0;
                        let method = CreateSignalSvc(inner);
                        let codec = tonic::codec::ProstCodec::default();
                        let mut grpc = if let Some(interceptor) = interceptor {
                            tonic::server::Grpc::with_interceptor(codec, interceptor)
                        } else {
                            tonic::server::Grpc::new(codec)
                        };
                        let res = grpc.unary(method, req).await;
                        Ok(res)
                    };
                    Box::pin(fut)
                }
                "/google.cloud.irm.v1alpha2.IncidentService/SearchSignals" => {
                    #[allow(non_camel_case_types)]
                    struct SearchSignalsSvc<T: IncidentService>(pub Arc<T>);
                    impl<T: IncidentService>
                        tonic::server::UnaryService<super::SearchSignalsRequest>
                        for SearchSignalsSvc<T>
                    {
                        type Response = super::SearchSignalsResponse;
                        type Future = BoxFuture<tonic::Response<Self::Response>, tonic::Status>;
                        fn call(
                            &mut self,
                            request: tonic::Request<super::SearchSignalsRequest>,
                        ) -> Self::Future {
                            let inner = self.0.clone();
                            let fut = async move { inner.search_signals(request).await };
                            Box::pin(fut)
                        }
                    }
                    let inner = self.inner.clone();
                    let fut = async move {
                        let interceptor = inner.1.clone();
                        let inner = inner.0;
                        let method = SearchSignalsSvc(inner);
                        let codec = tonic::codec::ProstCodec::default();
                        let mut grpc = if let Some(interceptor) = interceptor {
                            tonic::server::Grpc::with_interceptor(codec, interceptor)
                        } else {
                            tonic::server::Grpc::new(codec)
                        };
                        let res = grpc.unary(method, req).await;
                        Ok(res)
                    };
                    Box::pin(fut)
                }
                "/google.cloud.irm.v1alpha2.IncidentService/LookupSignal" => {
                    #[allow(non_camel_case_types)]
                    struct LookupSignalSvc<T: IncidentService>(pub Arc<T>);
                    impl<T: IncidentService> tonic::server::UnaryService<super::LookupSignalRequest>
                        for LookupSignalSvc<T>
                    {
                        type Response = super::Signal;
                        type Future = BoxFuture<tonic::Response<Self::Response>, tonic::Status>;
                        fn call(
                            &mut self,
                            request: tonic::Request<super::LookupSignalRequest>,
                        ) -> Self::Future {
                            let inner = self.0.clone();
                            let fut = async move { inner.lookup_signal(request).await };
                            Box::pin(fut)
                        }
                    }
                    let inner = self.inner.clone();
                    let fut = async move {
                        let interceptor = inner.1.clone();
                        let inner = inner.0;
                        let method = LookupSignalSvc(inner);
                        let codec = tonic::codec::ProstCodec::default();
                        let mut grpc = if let Some(interceptor) = interceptor {
                            tonic::server::Grpc::with_interceptor(codec, interceptor)
                        } else {
                            tonic::server::Grpc::new(codec)
                        };
                        let res = grpc.unary(method, req).await;
                        Ok(res)
                    };
                    Box::pin(fut)
                }
                "/google.cloud.irm.v1alpha2.IncidentService/GetSignal" => {
                    #[allow(non_camel_case_types)]
                    struct GetSignalSvc<T: IncidentService>(pub Arc<T>);
                    impl<T: IncidentService> tonic::server::UnaryService<super::GetSignalRequest> for GetSignalSvc<T> {
                        type Response = super::Signal;
                        type Future = BoxFuture<tonic::Response<Self::Response>, tonic::Status>;
                        fn call(
                            &mut self,
                            request: tonic::Request<super::GetSignalRequest>,
                        ) -> Self::Future {
                            let inner = self.0.clone();
                            let fut = async move { inner.get_signal(request).await };
                            Box::pin(fut)
                        }
                    }
                    let inner = self.inner.clone();
                    let fut = async move {
                        let interceptor = inner.1.clone();
                        let inner = inner.0;
                        let method = GetSignalSvc(inner);
                        let codec = tonic::codec::ProstCodec::default();
                        let mut grpc = if let Some(interceptor) = interceptor {
                            tonic::server::Grpc::with_interceptor(codec, interceptor)
                        } else {
                            tonic::server::Grpc::new(codec)
                        };
                        let res = grpc.unary(method, req).await;
                        Ok(res)
                    };
                    Box::pin(fut)
                }
                "/google.cloud.irm.v1alpha2.IncidentService/UpdateSignal" => {
                    #[allow(non_camel_case_types)]
                    struct UpdateSignalSvc<T: IncidentService>(pub Arc<T>);
                    impl<T: IncidentService> tonic::server::UnaryService<super::UpdateSignalRequest>
                        for UpdateSignalSvc<T>
                    {
                        type Response = super::Signal;
                        type Future = BoxFuture<tonic::Response<Self::Response>, tonic::Status>;
                        fn call(
                            &mut self,
                            request: tonic::Request<super::UpdateSignalRequest>,
                        ) -> Self::Future {
                            let inner = self.0.clone();
                            let fut = async move { inner.update_signal(request).await };
                            Box::pin(fut)
                        }
                    }
                    let inner = self.inner.clone();
                    let fut = async move {
                        let interceptor = inner.1.clone();
                        let inner = inner.0;
                        let method = UpdateSignalSvc(inner);
                        let codec = tonic::codec::ProstCodec::default();
                        let mut grpc = if let Some(interceptor) = interceptor {
                            tonic::server::Grpc::with_interceptor(codec, interceptor)
                        } else {
                            tonic::server::Grpc::new(codec)
                        };
                        let res = grpc.unary(method, req).await;
                        Ok(res)
                    };
                    Box::pin(fut)
                }
                "/google.cloud.irm.v1alpha2.IncidentService/EscalateIncident" => {
                    #[allow(non_camel_case_types)]
                    struct EscalateIncidentSvc<T: IncidentService>(pub Arc<T>);
                    impl<T: IncidentService>
                        tonic::server::UnaryService<super::EscalateIncidentRequest>
                        for EscalateIncidentSvc<T>
                    {
                        type Response = super::EscalateIncidentResponse;
                        type Future = BoxFuture<tonic::Response<Self::Response>, tonic::Status>;
                        fn call(
                            &mut self,
                            request: tonic::Request<super::EscalateIncidentRequest>,
                        ) -> Self::Future {
                            let inner = self.0.clone();
                            let fut = async move { inner.escalate_incident(request).await };
                            Box::pin(fut)
                        }
                    }
                    let inner = self.inner.clone();
                    let fut = async move {
                        let interceptor = inner.1.clone();
                        let inner = inner.0;
                        let method = EscalateIncidentSvc(inner);
                        let codec = tonic::codec::ProstCodec::default();
                        let mut grpc = if let Some(interceptor) = interceptor {
                            tonic::server::Grpc::with_interceptor(codec, interceptor)
                        } else {
                            tonic::server::Grpc::new(codec)
                        };
                        let res = grpc.unary(method, req).await;
                        Ok(res)
                    };
                    Box::pin(fut)
                }
                "/google.cloud.irm.v1alpha2.IncidentService/CreateArtifact" => {
                    #[allow(non_camel_case_types)]
                    struct CreateArtifactSvc<T: IncidentService>(pub Arc<T>);
                    impl<T: IncidentService>
                        tonic::server::UnaryService<super::CreateArtifactRequest>
                        for CreateArtifactSvc<T>
                    {
                        type Response = super::Artifact;
                        type Future = BoxFuture<tonic::Response<Self::Response>, tonic::Status>;
                        fn call(
                            &mut self,
                            request: tonic::Request<super::CreateArtifactRequest>,
                        ) -> Self::Future {
                            let inner = self.0.clone();
                            let fut = async move { inner.create_artifact(request).await };
                            Box::pin(fut)
                        }
                    }
                    let inner = self.inner.clone();
                    let fut = async move {
                        let interceptor = inner.1.clone();
                        let inner = inner.0;
                        let method = CreateArtifactSvc(inner);
                        let codec = tonic::codec::ProstCodec::default();
                        let mut grpc = if let Some(interceptor) = interceptor {
                            tonic::server::Grpc::with_interceptor(codec, interceptor)
                        } else {
                            tonic::server::Grpc::new(codec)
                        };
                        let res = grpc.unary(method, req).await;
                        Ok(res)
                    };
                    Box::pin(fut)
                }
                "/google.cloud.irm.v1alpha2.IncidentService/ListArtifacts" => {
                    #[allow(non_camel_case_types)]
                    struct ListArtifactsSvc<T: IncidentService>(pub Arc<T>);
                    impl<T: IncidentService>
                        tonic::server::UnaryService<super::ListArtifactsRequest>
                        for ListArtifactsSvc<T>
                    {
                        type Response = super::ListArtifactsResponse;
                        type Future = BoxFuture<tonic::Response<Self::Response>, tonic::Status>;
                        fn call(
                            &mut self,
                            request: tonic::Request<super::ListArtifactsRequest>,
                        ) -> Self::Future {
                            let inner = self.0.clone();
                            let fut = async move { inner.list_artifacts(request).await };
                            Box::pin(fut)
                        }
                    }
                    let inner = self.inner.clone();
                    let fut = async move {
                        let interceptor = inner.1.clone();
                        let inner = inner.0;
                        let method = ListArtifactsSvc(inner);
                        let codec = tonic::codec::ProstCodec::default();
                        let mut grpc = if let Some(interceptor) = interceptor {
                            tonic::server::Grpc::with_interceptor(codec, interceptor)
                        } else {
                            tonic::server::Grpc::new(codec)
                        };
                        let res = grpc.unary(method, req).await;
                        Ok(res)
                    };
                    Box::pin(fut)
                }
                "/google.cloud.irm.v1alpha2.IncidentService/UpdateArtifact" => {
                    #[allow(non_camel_case_types)]
                    struct UpdateArtifactSvc<T: IncidentService>(pub Arc<T>);
                    impl<T: IncidentService>
                        tonic::server::UnaryService<super::UpdateArtifactRequest>
                        for UpdateArtifactSvc<T>
                    {
                        type Response = super::Artifact;
                        type Future = BoxFuture<tonic::Response<Self::Response>, tonic::Status>;
                        fn call(
                            &mut self,
                            request: tonic::Request<super::UpdateArtifactRequest>,
                        ) -> Self::Future {
                            let inner = self.0.clone();
                            let fut = async move { inner.update_artifact(request).await };
                            Box::pin(fut)
                        }
                    }
                    let inner = self.inner.clone();
                    let fut = async move {
                        let interceptor = inner.1.clone();
                        let inner = inner.0;
                        let method = UpdateArtifactSvc(inner);
                        let codec = tonic::codec::ProstCodec::default();
                        let mut grpc = if let Some(interceptor) = interceptor {
                            tonic::server::Grpc::with_interceptor(codec, interceptor)
                        } else {
                            tonic::server::Grpc::new(codec)
                        };
                        let res = grpc.unary(method, req).await;
                        Ok(res)
                    };
                    Box::pin(fut)
                }
                "/google.cloud.irm.v1alpha2.IncidentService/DeleteArtifact" => {
                    #[allow(non_camel_case_types)]
                    struct DeleteArtifactSvc<T: IncidentService>(pub Arc<T>);
                    impl<T: IncidentService>
                        tonic::server::UnaryService<super::DeleteArtifactRequest>
                        for DeleteArtifactSvc<T>
                    {
                        type Response = ();
                        type Future = BoxFuture<tonic::Response<Self::Response>, tonic::Status>;
                        fn call(
                            &mut self,
                            request: tonic::Request<super::DeleteArtifactRequest>,
                        ) -> Self::Future {
                            let inner = self.0.clone();
                            let fut = async move { inner.delete_artifact(request).await };
                            Box::pin(fut)
                        }
                    }
                    let inner = self.inner.clone();
                    let fut = async move {
                        let interceptor = inner.1.clone();
                        let inner = inner.0;
                        let method = DeleteArtifactSvc(inner);
                        let codec = tonic::codec::ProstCodec::default();
                        let mut grpc = if let Some(interceptor) = interceptor {
                            tonic::server::Grpc::with_interceptor(codec, interceptor)
                        } else {
                            tonic::server::Grpc::new(codec)
                        };
                        let res = grpc.unary(method, req).await;
                        Ok(res)
                    };
                    Box::pin(fut)
                }
                "/google.cloud.irm.v1alpha2.IncidentService/SendShiftHandoff" => {
                    #[allow(non_camel_case_types)]
                    struct SendShiftHandoffSvc<T: IncidentService>(pub Arc<T>);
                    impl<T: IncidentService>
                        tonic::server::UnaryService<super::SendShiftHandoffRequest>
                        for SendShiftHandoffSvc<T>
                    {
                        type Response = super::SendShiftHandoffResponse;
                        type Future = BoxFuture<tonic::Response<Self::Response>, tonic::Status>;
                        fn call(
                            &mut self,
                            request: tonic::Request<super::SendShiftHandoffRequest>,
                        ) -> Self::Future {
                            let inner = self.0.clone();
                            let fut = async move { inner.send_shift_handoff(request).await };
                            Box::pin(fut)
                        }
                    }
                    let inner = self.inner.clone();
                    let fut = async move {
                        let interceptor = inner.1.clone();
                        let inner = inner.0;
                        let method = SendShiftHandoffSvc(inner);
                        let codec = tonic::codec::ProstCodec::default();
                        let mut grpc = if let Some(interceptor) = interceptor {
                            tonic::server::Grpc::with_interceptor(codec, interceptor)
                        } else {
                            tonic::server::Grpc::new(codec)
                        };
                        let res = grpc.unary(method, req).await;
                        Ok(res)
                    };
                    Box::pin(fut)
                }
                "/google.cloud.irm.v1alpha2.IncidentService/CreateSubscription" => {
                    #[allow(non_camel_case_types)]
                    struct CreateSubscriptionSvc<T: IncidentService>(pub Arc<T>);
                    impl<T: IncidentService>
                        tonic::server::UnaryService<super::CreateSubscriptionRequest>
                        for CreateSubscriptionSvc<T>
                    {
                        type Response = super::Subscription;
                        type Future = BoxFuture<tonic::Response<Self::Response>, tonic::Status>;
                        fn call(
                            &mut self,
                            request: tonic::Request<super::CreateSubscriptionRequest>,
                        ) -> Self::Future {
                            let inner = self.0.clone();
                            let fut = async move { inner.create_subscription(request).await };
                            Box::pin(fut)
                        }
                    }
                    let inner = self.inner.clone();
                    let fut = async move {
                        let interceptor = inner.1.clone();
                        let inner = inner.0;
                        let method = CreateSubscriptionSvc(inner);
                        let codec = tonic::codec::ProstCodec::default();
                        let mut grpc = if let Some(interceptor) = interceptor {
                            tonic::server::Grpc::with_interceptor(codec, interceptor)
                        } else {
                            tonic::server::Grpc::new(codec)
                        };
                        let res = grpc.unary(method, req).await;
                        Ok(res)
                    };
                    Box::pin(fut)
                }
                "/google.cloud.irm.v1alpha2.IncidentService/UpdateSubscription" => {
                    #[allow(non_camel_case_types)]
                    struct UpdateSubscriptionSvc<T: IncidentService>(pub Arc<T>);
                    impl<T: IncidentService>
                        tonic::server::UnaryService<super::UpdateSubscriptionRequest>
                        for UpdateSubscriptionSvc<T>
                    {
                        type Response = super::Subscription;
                        type Future = BoxFuture<tonic::Response<Self::Response>, tonic::Status>;
                        fn call(
                            &mut self,
                            request: tonic::Request<super::UpdateSubscriptionRequest>,
                        ) -> Self::Future {
                            let inner = self.0.clone();
                            let fut = async move { inner.update_subscription(request).await };
                            Box::pin(fut)
                        }
                    }
                    let inner = self.inner.clone();
                    let fut = async move {
                        let interceptor = inner.1.clone();
                        let inner = inner.0;
                        let method = UpdateSubscriptionSvc(inner);
                        let codec = tonic::codec::ProstCodec::default();
                        let mut grpc = if let Some(interceptor) = interceptor {
                            tonic::server::Grpc::with_interceptor(codec, interceptor)
                        } else {
                            tonic::server::Grpc::new(codec)
                        };
                        let res = grpc.unary(method, req).await;
                        Ok(res)
                    };
                    Box::pin(fut)
                }
                "/google.cloud.irm.v1alpha2.IncidentService/ListSubscriptions" => {
                    #[allow(non_camel_case_types)]
                    struct ListSubscriptionsSvc<T: IncidentService>(pub Arc<T>);
                    impl<T: IncidentService>
                        tonic::server::UnaryService<super::ListSubscriptionsRequest>
                        for ListSubscriptionsSvc<T>
                    {
                        type Response = super::ListSubscriptionsResponse;
                        type Future = BoxFuture<tonic::Response<Self::Response>, tonic::Status>;
                        fn call(
                            &mut self,
                            request: tonic::Request<super::ListSubscriptionsRequest>,
                        ) -> Self::Future {
                            let inner = self.0.clone();
                            let fut = async move { inner.list_subscriptions(request).await };
                            Box::pin(fut)
                        }
                    }
                    let inner = self.inner.clone();
                    let fut = async move {
                        let interceptor = inner.1.clone();
                        let inner = inner.0;
                        let method = ListSubscriptionsSvc(inner);
                        let codec = tonic::codec::ProstCodec::default();
                        let mut grpc = if let Some(interceptor) = interceptor {
                            tonic::server::Grpc::with_interceptor(codec, interceptor)
                        } else {
                            tonic::server::Grpc::new(codec)
                        };
                        let res = grpc.unary(method, req).await;
                        Ok(res)
                    };
                    Box::pin(fut)
                }
                "/google.cloud.irm.v1alpha2.IncidentService/DeleteSubscription" => {
                    #[allow(non_camel_case_types)]
                    struct DeleteSubscriptionSvc<T: IncidentService>(pub Arc<T>);
                    impl<T: IncidentService>
                        tonic::server::UnaryService<super::DeleteSubscriptionRequest>
                        for DeleteSubscriptionSvc<T>
                    {
                        type Response = ();
                        type Future = BoxFuture<tonic::Response<Self::Response>, tonic::Status>;
                        fn call(
                            &mut self,
                            request: tonic::Request<super::DeleteSubscriptionRequest>,
                        ) -> Self::Future {
                            let inner = self.0.clone();
                            let fut = async move { inner.delete_subscription(request).await };
                            Box::pin(fut)
                        }
                    }
                    let inner = self.inner.clone();
                    let fut = async move {
                        let interceptor = inner.1.clone();
                        let inner = inner.0;
                        let method = DeleteSubscriptionSvc(inner);
                        let codec = tonic::codec::ProstCodec::default();
                        let mut grpc = if let Some(interceptor) = interceptor {
                            tonic::server::Grpc::with_interceptor(codec, interceptor)
                        } else {
                            tonic::server::Grpc::new(codec)
                        };
                        let res = grpc.unary(method, req).await;
                        Ok(res)
                    };
                    Box::pin(fut)
                }
                "/google.cloud.irm.v1alpha2.IncidentService/CreateIncidentRoleAssignment" => {
                    #[allow(non_camel_case_types)]
                    struct CreateIncidentRoleAssignmentSvc<T: IncidentService>(pub Arc<T>);
                    impl<T: IncidentService>
                        tonic::server::UnaryService<super::CreateIncidentRoleAssignmentRequest>
                        for CreateIncidentRoleAssignmentSvc<T>
                    {
                        type Response = super::IncidentRoleAssignment;
                        type Future = BoxFuture<tonic::Response<Self::Response>, tonic::Status>;
                        fn call(
                            &mut self,
                            request: tonic::Request<super::CreateIncidentRoleAssignmentRequest>,
                        ) -> Self::Future {
                            let inner = self.0.clone();
                            let fut =
                                async move { inner.create_incident_role_assignment(request).await };
                            Box::pin(fut)
                        }
                    }
                    let inner = self.inner.clone();
                    let fut = async move {
                        let interceptor = inner.1.clone();
                        let inner = inner.0;
                        let method = CreateIncidentRoleAssignmentSvc(inner);
                        let codec = tonic::codec::ProstCodec::default();
                        let mut grpc = if let Some(interceptor) = interceptor {
                            tonic::server::Grpc::with_interceptor(codec, interceptor)
                        } else {
                            tonic::server::Grpc::new(codec)
                        };
                        let res = grpc.unary(method, req).await;
                        Ok(res)
                    };
                    Box::pin(fut)
                }
                "/google.cloud.irm.v1alpha2.IncidentService/DeleteIncidentRoleAssignment" => {
                    #[allow(non_camel_case_types)]
                    struct DeleteIncidentRoleAssignmentSvc<T: IncidentService>(pub Arc<T>);
                    impl<T: IncidentService>
                        tonic::server::UnaryService<super::DeleteIncidentRoleAssignmentRequest>
                        for DeleteIncidentRoleAssignmentSvc<T>
                    {
                        type Response = ();
                        type Future = BoxFuture<tonic::Response<Self::Response>, tonic::Status>;
                        fn call(
                            &mut self,
                            request: tonic::Request<super::DeleteIncidentRoleAssignmentRequest>,
                        ) -> Self::Future {
                            let inner = self.0.clone();
                            let fut =
                                async move { inner.delete_incident_role_assignment(request).await };
                            Box::pin(fut)
                        }
                    }
                    let inner = self.inner.clone();
                    let fut = async move {
                        let interceptor = inner.1.clone();
                        let inner = inner.0;
                        let method = DeleteIncidentRoleAssignmentSvc(inner);
                        let codec = tonic::codec::ProstCodec::default();
                        let mut grpc = if let Some(interceptor) = interceptor {
                            tonic::server::Grpc::with_interceptor(codec, interceptor)
                        } else {
                            tonic::server::Grpc::new(codec)
                        };
                        let res = grpc.unary(method, req).await;
                        Ok(res)
                    };
                    Box::pin(fut)
                }
                "/google.cloud.irm.v1alpha2.IncidentService/ListIncidentRoleAssignments" => {
                    #[allow(non_camel_case_types)]
                    struct ListIncidentRoleAssignmentsSvc<T: IncidentService>(pub Arc<T>);
                    impl<T: IncidentService>
                        tonic::server::UnaryService<super::ListIncidentRoleAssignmentsRequest>
                        for ListIncidentRoleAssignmentsSvc<T>
                    {
                        type Response = super::ListIncidentRoleAssignmentsResponse;
                        type Future = BoxFuture<tonic::Response<Self::Response>, tonic::Status>;
                        fn call(
                            &mut self,
                            request: tonic::Request<super::ListIncidentRoleAssignmentsRequest>,
                        ) -> Self::Future {
                            let inner = self.0.clone();
                            let fut =
                                async move { inner.list_incident_role_assignments(request).await };
                            Box::pin(fut)
                        }
                    }
                    let inner = self.inner.clone();
                    let fut = async move {
                        let interceptor = inner.1.clone();
                        let inner = inner.0;
                        let method = ListIncidentRoleAssignmentsSvc(inner);
                        let codec = tonic::codec::ProstCodec::default();
                        let mut grpc = if let Some(interceptor) = interceptor {
                            tonic::server::Grpc::with_interceptor(codec, interceptor)
                        } else {
                            tonic::server::Grpc::new(codec)
                        };
                        let res = grpc.unary(method, req).await;
                        Ok(res)
                    };
                    Box::pin(fut)
                }
                "/google.cloud.irm.v1alpha2.IncidentService/RequestIncidentRoleHandover" => {
                    #[allow(non_camel_case_types)]
                    struct RequestIncidentRoleHandoverSvc<T: IncidentService>(pub Arc<T>);
                    impl<T: IncidentService>
                        tonic::server::UnaryService<super::RequestIncidentRoleHandoverRequest>
                        for RequestIncidentRoleHandoverSvc<T>
                    {
                        type Response = super::IncidentRoleAssignment;
                        type Future = BoxFuture<tonic::Response<Self::Response>, tonic::Status>;
                        fn call(
                            &mut self,
                            request: tonic::Request<super::RequestIncidentRoleHandoverRequest>,
                        ) -> Self::Future {
                            let inner = self.0.clone();
                            let fut =
                                async move { inner.request_incident_role_handover(request).await };
                            Box::pin(fut)
                        }
                    }
                    let inner = self.inner.clone();
                    let fut = async move {
                        let interceptor = inner.1.clone();
                        let inner = inner.0;
                        let method = RequestIncidentRoleHandoverSvc(inner);
                        let codec = tonic::codec::ProstCodec::default();
                        let mut grpc = if let Some(interceptor) = interceptor {
                            tonic::server::Grpc::with_interceptor(codec, interceptor)
                        } else {
                            tonic::server::Grpc::new(codec)
                        };
                        let res = grpc.unary(method, req).await;
                        Ok(res)
                    };
                    Box::pin(fut)
                }
                "/google.cloud.irm.v1alpha2.IncidentService/ConfirmIncidentRoleHandover" => {
                    #[allow(non_camel_case_types)]
                    struct ConfirmIncidentRoleHandoverSvc<T: IncidentService>(pub Arc<T>);
                    impl<T: IncidentService>
                        tonic::server::UnaryService<super::ConfirmIncidentRoleHandoverRequest>
                        for ConfirmIncidentRoleHandoverSvc<T>
                    {
                        type Response = super::IncidentRoleAssignment;
                        type Future = BoxFuture<tonic::Response<Self::Response>, tonic::Status>;
                        fn call(
                            &mut self,
                            request: tonic::Request<super::ConfirmIncidentRoleHandoverRequest>,
                        ) -> Self::Future {
                            let inner = self.0.clone();
                            let fut =
                                async move { inner.confirm_incident_role_handover(request).await };
                            Box::pin(fut)
                        }
                    }
                    let inner = self.inner.clone();
                    let fut = async move {
                        let interceptor = inner.1.clone();
                        let inner = inner.0;
                        let method = ConfirmIncidentRoleHandoverSvc(inner);
                        let codec = tonic::codec::ProstCodec::default();
                        let mut grpc = if let Some(interceptor) = interceptor {
                            tonic::server::Grpc::with_interceptor(codec, interceptor)
                        } else {
                            tonic::server::Grpc::new(codec)
                        };
                        let res = grpc.unary(method, req).await;
                        Ok(res)
                    };
                    Box::pin(fut)
                }
                "/google.cloud.irm.v1alpha2.IncidentService/ForceIncidentRoleHandover" => {
                    #[allow(non_camel_case_types)]
                    struct ForceIncidentRoleHandoverSvc<T: IncidentService>(pub Arc<T>);
                    impl<T: IncidentService>
                        tonic::server::UnaryService<super::ForceIncidentRoleHandoverRequest>
                        for ForceIncidentRoleHandoverSvc<T>
                    {
                        type Response = super::IncidentRoleAssignment;
                        type Future = BoxFuture<tonic::Response<Self::Response>, tonic::Status>;
                        fn call(
                            &mut self,
                            request: tonic::Request<super::ForceIncidentRoleHandoverRequest>,
                        ) -> Self::Future {
                            let inner = self.0.clone();
                            let fut =
                                async move { inner.force_incident_role_handover(request).await };
                            Box::pin(fut)
                        }
                    }
                    let inner = self.inner.clone();
                    let fut = async move {
                        let interceptor = inner.1.clone();
                        let inner = inner.0;
                        let method = ForceIncidentRoleHandoverSvc(inner);
                        let codec = tonic::codec::ProstCodec::default();
                        let mut grpc = if let Some(interceptor) = interceptor {
                            tonic::server::Grpc::with_interceptor(codec, interceptor)
                        } else {
                            tonic::server::Grpc::new(codec)
                        };
                        let res = grpc.unary(method, req).await;
                        Ok(res)
                    };
                    Box::pin(fut)
                }
                "/google.cloud.irm.v1alpha2.IncidentService/CancelIncidentRoleHandover" => {
                    #[allow(non_camel_case_types)]
                    struct CancelIncidentRoleHandoverSvc<T: IncidentService>(pub Arc<T>);
                    impl<T: IncidentService>
                        tonic::server::UnaryService<super::CancelIncidentRoleHandoverRequest>
                        for CancelIncidentRoleHandoverSvc<T>
                    {
                        type Response = super::IncidentRoleAssignment;
                        type Future = BoxFuture<tonic::Response<Self::Response>, tonic::Status>;
                        fn call(
                            &mut self,
                            request: tonic::Request<super::CancelIncidentRoleHandoverRequest>,
                        ) -> Self::Future {
                            let inner = self.0.clone();
                            let fut =
                                async move { inner.cancel_incident_role_handover(request).await };
                            Box::pin(fut)
                        }
                    }
                    let inner = self.inner.clone();
                    let fut = async move {
                        let interceptor = inner.1.clone();
                        let inner = inner.0;
                        let method = CancelIncidentRoleHandoverSvc(inner);
                        let codec = tonic::codec::ProstCodec::default();
                        let mut grpc = if let Some(interceptor) = interceptor {
                            tonic::server::Grpc::with_interceptor(codec, interceptor)
                        } else {
                            tonic::server::Grpc::new(codec)
                        };
                        let res = grpc.unary(method, req).await;
                        Ok(res)
                    };
                    Box::pin(fut)
                }
                _ => Box::pin(async move {
                    Ok(http::Response::builder()
                        .status(200)
                        .header("grpc-status", "12")
                        .body(tonic::body::BoxBody::empty())
                        .unwrap())
                }),
            }
        }
    }
    impl<T: IncidentService> Clone for IncidentServiceServer<T> {
        fn clone(&self) -> Self {
            let inner = self.inner.clone();
            Self { inner }
        }
    }
    impl<T: IncidentService> Clone for _Inner<T> {
        fn clone(&self) -> Self {
            Self(self.0.clone(), self.1.clone())
        }
    }
    impl<T: std::fmt::Debug> std::fmt::Debug for _Inner<T> {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
            write!(f, "{:?}", self.0)
        }
    }
}
